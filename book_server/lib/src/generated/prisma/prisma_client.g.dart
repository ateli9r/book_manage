// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'prisma_client.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

ALLCODETBLWhereInput _$ALLCODETBLWhereInputFromJson(
        Map<String, dynamic> json) =>
    ALLCODETBLWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map(
          (e) => ALLCODETBLWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map(
          (e) => ALLCODETBLWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map(
          (e) => ALLCODETBLWhereInput.fromJson(e as Map<String, dynamic>)),
      codeType: json['CODE_TYPE'] == null
          ? null
          : StringFilter.fromJson(json['CODE_TYPE'] as Map<String, dynamic>),
      codeName: json['CODE_NAME'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['CODE_NAME'] as Map<String, dynamic>),
      unitType: json['UNIT_TYPE'] == null
          ? null
          : StringFilter.fromJson(json['UNIT_TYPE'] as Map<String, dynamic>),
      unitName: json['UNIT_NAME'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['UNIT_NAME'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : IntNullableFilter.fromJson(json['SORT'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(json['UPD_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$ALLCODETBLWhereInputToJson(
    ALLCODETBLWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('CODE_TYPE', instance.codeType?.toJson());
  writeNotNull('CODE_NAME', instance.codeName?.toJson());
  writeNotNull('UNIT_TYPE', instance.unitType?.toJson());
  writeNotNull('UNIT_NAME', instance.unitName?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

ALLCODETBLOrderByWithRelationInput _$ALLCODETBLOrderByWithRelationInputFromJson(
        Map<String, dynamic> json) =>
    ALLCODETBLOrderByWithRelationInput(
      codeType: $enumDecodeNullable(_$SortOrderEnumMap, json['CODE_TYPE']),
      codeName: $enumDecodeNullable(_$SortOrderEnumMap, json['CODE_NAME']),
      unitType: $enumDecodeNullable(_$SortOrderEnumMap, json['UNIT_TYPE']),
      unitName: $enumDecodeNullable(_$SortOrderEnumMap, json['UNIT_NAME']),
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
      useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
      delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
    );

Map<String, dynamic> _$ALLCODETBLOrderByWithRelationInputToJson(
    ALLCODETBLOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CODE_TYPE', _$SortOrderEnumMap[instance.codeType]);
  writeNotNull('CODE_NAME', _$SortOrderEnumMap[instance.codeName]);
  writeNotNull('UNIT_TYPE', _$SortOrderEnumMap[instance.unitType]);
  writeNotNull('UNIT_NAME', _$SortOrderEnumMap[instance.unitName]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  return val;
}

const _$SortOrderEnumMap = {
  SortOrder.asc: 'asc',
  SortOrder.desc: 'desc',
};

ALLCODETBLWhereUniqueInput _$ALLCODETBLWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    ALLCODETBLWhereUniqueInput(
      codeTypeUnitType: json['CODE_TYPE_UNIT_TYPE'] == null
          ? null
          : ALLCODETBLCODETYPEUNITTYPECompoundUniqueInput.fromJson(
              json['CODE_TYPE_UNIT_TYPE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$ALLCODETBLWhereUniqueInputToJson(
    ALLCODETBLWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CODE_TYPE_UNIT_TYPE', instance.codeTypeUnitType?.toJson());
  return val;
}

ALLCODETBLOrderByWithAggregationInput
    _$ALLCODETBLOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        ALLCODETBLOrderByWithAggregationInput(
          codeType: $enumDecodeNullable(_$SortOrderEnumMap, json['CODE_TYPE']),
          codeName: $enumDecodeNullable(_$SortOrderEnumMap, json['CODE_NAME']),
          unitType: $enumDecodeNullable(_$SortOrderEnumMap, json['UNIT_TYPE']),
          unitName: $enumDecodeNullable(_$SortOrderEnumMap, json['UNIT_NAME']),
          sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          $count: json['_count'] == null
              ? null
              : ALLCODETBLCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : ALLCODETBLAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : ALLCODETBLMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : ALLCODETBLMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : ALLCODETBLSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$ALLCODETBLOrderByWithAggregationInputToJson(
    ALLCODETBLOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CODE_TYPE', _$SortOrderEnumMap[instance.codeType]);
  writeNotNull('CODE_NAME', _$SortOrderEnumMap[instance.codeName]);
  writeNotNull('UNIT_TYPE', _$SortOrderEnumMap[instance.unitType]);
  writeNotNull('UNIT_NAME', _$SortOrderEnumMap[instance.unitName]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

ALLCODETBLScalarWhereWithAggregatesInput
    _$ALLCODETBLScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        ALLCODETBLScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              ALLCODETBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              ALLCODETBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              ALLCODETBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          codeType: json['CODE_TYPE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['CODE_TYPE'] as Map<String, dynamic>),
          codeName: json['CODE_NAME'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['CODE_NAME'] as Map<String, dynamic>),
          unitType: json['UNIT_TYPE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['UNIT_TYPE'] as Map<String, dynamic>),
          unitName: json['UNIT_NAME'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['UNIT_NAME'] as Map<String, dynamic>),
          sort: json['SORT'] == null
              ? null
              : IntNullableWithAggregatesFilter.fromJson(
                  json['SORT'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$ALLCODETBLScalarWhereWithAggregatesInputToJson(
    ALLCODETBLScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('CODE_TYPE', instance.codeType?.toJson());
  writeNotNull('CODE_NAME', instance.codeName?.toJson());
  writeNotNull('UNIT_TYPE', instance.unitType?.toJson());
  writeNotNull('UNIT_NAME', instance.unitName?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

APPROVALATTACHFILETBLWhereInput _$APPROVALATTACHFILETBLWhereInputFromJson(
        Map<String, dynamic> json) =>
    APPROVALATTACHFILETBLWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map((e) =>
          APPROVALATTACHFILETBLWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map((e) =>
          APPROVALATTACHFILETBLWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
          APPROVALATTACHFILETBLWhereInput.fromJson(e as Map<String, dynamic>)),
      approvalId: json['APPROVAL_ID'] == null
          ? null
          : StringFilter.fromJson(json['APPROVAL_ID'] as Map<String, dynamic>),
      seq: json['SEQ'] == null
          ? null
          : DecimalFilter.fromJson(json['SEQ'] as Map<String, dynamic>),
      oriFileNm: json['ORI_FILE_NM'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['ORI_FILE_NM'] as Map<String, dynamic>),
      saveFileNm: json['SAVE_FILE_NM'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['SAVE_FILE_NM'] as Map<String, dynamic>),
      fileSize: json['FILE_SIZE'] == null
          ? null
          : IntNullableFilter.fromJson(
              json['FILE_SIZE'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$APPROVALATTACHFILETBLWhereInputToJson(
    APPROVALATTACHFILETBLWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('APPROVAL_ID', instance.approvalId?.toJson());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ORI_FILE_NM', instance.oriFileNm?.toJson());
  writeNotNull('SAVE_FILE_NM', instance.saveFileNm?.toJson());
  writeNotNull('FILE_SIZE', instance.fileSize?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

APPROVALATTACHFILETBLOrderByWithRelationInput
    _$APPROVALATTACHFILETBLOrderByWithRelationInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALATTACHFILETBLOrderByWithRelationInput(
          approvalId:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_ID']),
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          oriFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ORI_FILE_NM']),
          saveFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['SAVE_FILE_NM']),
          fileSize: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_SIZE']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
        );

Map<String, dynamic> _$APPROVALATTACHFILETBLOrderByWithRelationInputToJson(
    APPROVALATTACHFILETBLOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_ID', _$SortOrderEnumMap[instance.approvalId]);
  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ORI_FILE_NM', _$SortOrderEnumMap[instance.oriFileNm]);
  writeNotNull('SAVE_FILE_NM', _$SortOrderEnumMap[instance.saveFileNm]);
  writeNotNull('FILE_SIZE', _$SortOrderEnumMap[instance.fileSize]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  return val;
}

APPROVALATTACHFILETBLWhereUniqueInput
    _$APPROVALATTACHFILETBLWhereUniqueInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALATTACHFILETBLWhereUniqueInput(
          approvalIdSeq: json['APPROVAL_ID_SEQ'] == null
              ? null
              : APPROVALATTACHFILETBLAPPROVALIDSEQCompoundUniqueInput.fromJson(
                  json['APPROVAL_ID_SEQ'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALATTACHFILETBLWhereUniqueInputToJson(
    APPROVALATTACHFILETBLWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_ID_SEQ', instance.approvalIdSeq?.toJson());
  return val;
}

APPROVALATTACHFILETBLOrderByWithAggregationInput
    _$APPROVALATTACHFILETBLOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALATTACHFILETBLOrderByWithAggregationInput(
          approvalId:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_ID']),
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          oriFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ORI_FILE_NM']),
          saveFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['SAVE_FILE_NM']),
          fileSize: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_SIZE']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          $count: json['_count'] == null
              ? null
              : APPROVALATTACHFILETBLCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : APPROVALATTACHFILETBLAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : APPROVALATTACHFILETBLMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : APPROVALATTACHFILETBLMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : APPROVALATTACHFILETBLSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALATTACHFILETBLOrderByWithAggregationInputToJson(
    APPROVALATTACHFILETBLOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_ID', _$SortOrderEnumMap[instance.approvalId]);
  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ORI_FILE_NM', _$SortOrderEnumMap[instance.oriFileNm]);
  writeNotNull('SAVE_FILE_NM', _$SortOrderEnumMap[instance.saveFileNm]);
  writeNotNull('FILE_SIZE', _$SortOrderEnumMap[instance.fileSize]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

APPROVALATTACHFILETBLScalarWhereWithAggregatesInput
    _$APPROVALATTACHFILETBLScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALATTACHFILETBLScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              APPROVALATTACHFILETBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              APPROVALATTACHFILETBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              APPROVALATTACHFILETBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          approvalId: json['APPROVAL_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['APPROVAL_ID'] as Map<String, dynamic>),
          seq: json['SEQ'] == null
              ? null
              : DecimalWithAggregatesFilter.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          oriFileNm: json['ORI_FILE_NM'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['ORI_FILE_NM'] as Map<String, dynamic>),
          saveFileNm: json['SAVE_FILE_NM'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['SAVE_FILE_NM'] as Map<String, dynamic>),
          fileSize: json['FILE_SIZE'] == null
              ? null
              : IntNullableWithAggregatesFilter.fromJson(
                  json['FILE_SIZE'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic>
    _$APPROVALATTACHFILETBLScalarWhereWithAggregatesInputToJson(
        APPROVALATTACHFILETBLScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('APPROVAL_ID', instance.approvalId?.toJson());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ORI_FILE_NM', instance.oriFileNm?.toJson());
  writeNotNull('SAVE_FILE_NM', instance.saveFileNm?.toJson());
  writeNotNull('FILE_SIZE', instance.fileSize?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

APPROVALDOCINFOTBLWhereInput _$APPROVALDOCINFOTBLWhereInputFromJson(
        Map<String, dynamic> json) =>
    APPROVALDOCINFOTBLWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map((e) =>
          APPROVALDOCINFOTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map((e) =>
          APPROVALDOCINFOTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
          APPROVALDOCINFOTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      seq: json['SEQ'] == null
          ? null
          : BigIntFilter.fromJson(json['SEQ'] as Map<String, dynamic>),
      docType: json['DOC_TYPE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DOC_TYPE'] as Map<String, dynamic>),
      docNm: json['DOC_NM'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DOC_NM'] as Map<String, dynamic>),
      title: json['TITLE'] == null
          ? null
          : StringFilter.fromJson(json['TITLE'] as Map<String, dynamic>),
      approvalLineType: json['APPROVAL_LINE_TYPE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['APPROVAL_LINE_TYPE'] as Map<String, dynamic>),
      approvalLineContent: json['APPROVAL_LINE_CONTENT'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['APPROVAL_LINE_CONTENT'] as Map<String, dynamic>),
      approvalLineContentBak: json['APPROVAL_LINE_CONTENT_BAK'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['APPROVAL_LINE_CONTENT_BAK'] as Map<String, dynamic>),
      content: json['CONTENT'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['CONTENT'] as Map<String, dynamic>),
      writerId: json['WRITER_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['WRITER_ID'] as Map<String, dynamic>),
      userNm: json['USER_NM'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['USER_NM'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : DateTimeNullableFilter.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$APPROVALDOCINFOTBLWhereInputToJson(
    APPROVALDOCINFOTBLWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('DOC_TYPE', instance.docType?.toJson());
  writeNotNull('DOC_NM', instance.docNm?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('APPROVAL_LINE_TYPE', instance.approvalLineType?.toJson());
  writeNotNull('APPROVAL_LINE_CONTENT', instance.approvalLineContent?.toJson());
  writeNotNull(
      'APPROVAL_LINE_CONTENT_BAK', instance.approvalLineContentBak?.toJson());
  writeNotNull('CONTENT', instance.content?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('USER_NM', instance.userNm?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALDOCINFOTBLOrderByWithRelationInput
    _$APPROVALDOCINFOTBLOrderByWithRelationInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALDOCINFOTBLOrderByWithRelationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          docType: $enumDecodeNullable(_$SortOrderEnumMap, json['DOC_TYPE']),
          docNm: $enumDecodeNullable(_$SortOrderEnumMap, json['DOC_NM']),
          title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
          approvalLineType: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_LINE_TYPE']),
          approvalLineContent: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_LINE_CONTENT']),
          approvalLineContentBak: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_LINE_CONTENT_BAK']),
          content: $enumDecodeNullable(_$SortOrderEnumMap, json['CONTENT']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          userNm: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_NM']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$APPROVALDOCINFOTBLOrderByWithRelationInputToJson(
    APPROVALDOCINFOTBLOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('DOC_TYPE', _$SortOrderEnumMap[instance.docType]);
  writeNotNull('DOC_NM', _$SortOrderEnumMap[instance.docNm]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull(
      'APPROVAL_LINE_TYPE', _$SortOrderEnumMap[instance.approvalLineType]);
  writeNotNull('APPROVAL_LINE_CONTENT',
      _$SortOrderEnumMap[instance.approvalLineContent]);
  writeNotNull('APPROVAL_LINE_CONTENT_BAK',
      _$SortOrderEnumMap[instance.approvalLineContentBak]);
  writeNotNull('CONTENT', _$SortOrderEnumMap[instance.content]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('USER_NM', _$SortOrderEnumMap[instance.userNm]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

APPROVALDOCINFOTBLWhereUniqueInput _$APPROVALDOCINFOTBLWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    APPROVALDOCINFOTBLWhereUniqueInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
    );

Map<String, dynamic> _$APPROVALDOCINFOTBLWhereUniqueInputToJson(
    APPROVALDOCINFOTBLWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  return val;
}

APPROVALDOCINFOTBLOrderByWithAggregationInput
    _$APPROVALDOCINFOTBLOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALDOCINFOTBLOrderByWithAggregationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          docType: $enumDecodeNullable(_$SortOrderEnumMap, json['DOC_TYPE']),
          docNm: $enumDecodeNullable(_$SortOrderEnumMap, json['DOC_NM']),
          title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
          approvalLineType: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_LINE_TYPE']),
          approvalLineContent: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_LINE_CONTENT']),
          approvalLineContentBak: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_LINE_CONTENT_BAK']),
          content: $enumDecodeNullable(_$SortOrderEnumMap, json['CONTENT']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          userNm: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_NM']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          $count: json['_count'] == null
              ? null
              : APPROVALDOCINFOTBLCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : APPROVALDOCINFOTBLAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : APPROVALDOCINFOTBLMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : APPROVALDOCINFOTBLMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : APPROVALDOCINFOTBLSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALDOCINFOTBLOrderByWithAggregationInputToJson(
    APPROVALDOCINFOTBLOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('DOC_TYPE', _$SortOrderEnumMap[instance.docType]);
  writeNotNull('DOC_NM', _$SortOrderEnumMap[instance.docNm]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull(
      'APPROVAL_LINE_TYPE', _$SortOrderEnumMap[instance.approvalLineType]);
  writeNotNull('APPROVAL_LINE_CONTENT',
      _$SortOrderEnumMap[instance.approvalLineContent]);
  writeNotNull('APPROVAL_LINE_CONTENT_BAK',
      _$SortOrderEnumMap[instance.approvalLineContentBak]);
  writeNotNull('CONTENT', _$SortOrderEnumMap[instance.content]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('USER_NM', _$SortOrderEnumMap[instance.userNm]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

APPROVALDOCINFOTBLScalarWhereWithAggregatesInput
    _$APPROVALDOCINFOTBLScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALDOCINFOTBLScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              APPROVALDOCINFOTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              APPROVALDOCINFOTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              APPROVALDOCINFOTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          seq: json['SEQ'] == null
              ? null
              : BigIntWithAggregatesFilter.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          docType: json['DOC_TYPE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DOC_TYPE'] as Map<String, dynamic>),
          docNm: json['DOC_NM'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DOC_NM'] as Map<String, dynamic>),
          title: json['TITLE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['TITLE'] as Map<String, dynamic>),
          approvalLineType: json['APPROVAL_LINE_TYPE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['APPROVAL_LINE_TYPE'] as Map<String, dynamic>),
          approvalLineContent: json['APPROVAL_LINE_CONTENT'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['APPROVAL_LINE_CONTENT'] as Map<String, dynamic>),
          approvalLineContentBak: json['APPROVAL_LINE_CONTENT_BAK'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['APPROVAL_LINE_CONTENT_BAK'] as Map<String, dynamic>),
          content: json['CONTENT'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['CONTENT'] as Map<String, dynamic>),
          writerId: json['WRITER_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['WRITER_ID'] as Map<String, dynamic>),
          userNm: json['USER_NM'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['USER_NM'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : DateTimeNullableWithAggregatesFilter.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALDOCINFOTBLScalarWhereWithAggregatesInputToJson(
    APPROVALDOCINFOTBLScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('DOC_TYPE', instance.docType?.toJson());
  writeNotNull('DOC_NM', instance.docNm?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('APPROVAL_LINE_TYPE', instance.approvalLineType?.toJson());
  writeNotNull('APPROVAL_LINE_CONTENT', instance.approvalLineContent?.toJson());
  writeNotNull(
      'APPROVAL_LINE_CONTENT_BAK', instance.approvalLineContentBak?.toJson());
  writeNotNull('CONTENT', instance.content?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('USER_NM', instance.userNm?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALHISTORYTBLWhereInput _$APPROVALHISTORYTBLWhereInputFromJson(
        Map<String, dynamic> json) =>
    APPROVALHISTORYTBLWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map((e) =>
          APPROVALHISTORYTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map((e) =>
          APPROVALHISTORYTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
          APPROVALHISTORYTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      seq: json['SEQ'] == null
          ? null
          : BigIntFilter.fromJson(json['SEQ'] as Map<String, dynamic>),
      approvalId: json['APPROVAL_ID'] == null
          ? null
          : StringFilter.fromJson(json['APPROVAL_ID'] as Map<String, dynamic>),
      writerId: json['WRITER_ID'] == null
          ? null
          : StringFilter.fromJson(json['WRITER_ID'] as Map<String, dynamic>),
      writerNm: json['WRITER_NM'] == null
          ? null
          : StringFilter.fromJson(json['WRITER_NM'] as Map<String, dynamic>),
      docType: json['DOC_TYPE'] == null
          ? null
          : StringFilter.fromJson(json['DOC_TYPE'] as Map<String, dynamic>),
      keepPriod: json['KEEP_PRIOD'] == null
          ? null
          : IntFilter.fromJson(json['KEEP_PRIOD'] as Map<String, dynamic>),
      keepDate: json['KEEP_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(json['KEEP_DATE'] as Map<String, dynamic>),
      grade: json['GRADE'] == null
          ? null
          : StringFilter.fromJson(json['GRADE'] as Map<String, dynamic>),
      status: json['STATUS'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['STATUS'] as Map<String, dynamic>),
      content: json['CONTENT'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['CONTENT'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : DateTimeNullableFilter.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$APPROVALHISTORYTBLWhereInputToJson(
    APPROVALHISTORYTBLWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('APPROVAL_ID', instance.approvalId?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('WRITER_NM', instance.writerNm?.toJson());
  writeNotNull('DOC_TYPE', instance.docType?.toJson());
  writeNotNull('KEEP_PRIOD', instance.keepPriod?.toJson());
  writeNotNull('KEEP_DATE', instance.keepDate?.toJson());
  writeNotNull('GRADE', instance.grade?.toJson());
  writeNotNull('STATUS', instance.status?.toJson());
  writeNotNull('CONTENT', instance.content?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALHISTORYTBLOrderByWithRelationInput
    _$APPROVALHISTORYTBLOrderByWithRelationInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALHISTORYTBLOrderByWithRelationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          approvalId:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_ID']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          writerNm: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_NM']),
          docType: $enumDecodeNullable(_$SortOrderEnumMap, json['DOC_TYPE']),
          keepPriod:
              $enumDecodeNullable(_$SortOrderEnumMap, json['KEEP_PRIOD']),
          keepDate: $enumDecodeNullable(_$SortOrderEnumMap, json['KEEP_DATE']),
          grade: $enumDecodeNullable(_$SortOrderEnumMap, json['GRADE']),
          status: $enumDecodeNullable(_$SortOrderEnumMap, json['STATUS']),
          content: $enumDecodeNullable(_$SortOrderEnumMap, json['CONTENT']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$APPROVALHISTORYTBLOrderByWithRelationInputToJson(
    APPROVALHISTORYTBLOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('APPROVAL_ID', _$SortOrderEnumMap[instance.approvalId]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('WRITER_NM', _$SortOrderEnumMap[instance.writerNm]);
  writeNotNull('DOC_TYPE', _$SortOrderEnumMap[instance.docType]);
  writeNotNull('KEEP_PRIOD', _$SortOrderEnumMap[instance.keepPriod]);
  writeNotNull('KEEP_DATE', _$SortOrderEnumMap[instance.keepDate]);
  writeNotNull('GRADE', _$SortOrderEnumMap[instance.grade]);
  writeNotNull('STATUS', _$SortOrderEnumMap[instance.status]);
  writeNotNull('CONTENT', _$SortOrderEnumMap[instance.content]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

APPROVALHISTORYTBLWhereUniqueInput _$APPROVALHISTORYTBLWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    APPROVALHISTORYTBLWhereUniqueInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
    );

Map<String, dynamic> _$APPROVALHISTORYTBLWhereUniqueInputToJson(
    APPROVALHISTORYTBLWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  return val;
}

APPROVALHISTORYTBLOrderByWithAggregationInput
    _$APPROVALHISTORYTBLOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALHISTORYTBLOrderByWithAggregationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          approvalId:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_ID']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          writerNm: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_NM']),
          docType: $enumDecodeNullable(_$SortOrderEnumMap, json['DOC_TYPE']),
          keepPriod:
              $enumDecodeNullable(_$SortOrderEnumMap, json['KEEP_PRIOD']),
          keepDate: $enumDecodeNullable(_$SortOrderEnumMap, json['KEEP_DATE']),
          grade: $enumDecodeNullable(_$SortOrderEnumMap, json['GRADE']),
          status: $enumDecodeNullable(_$SortOrderEnumMap, json['STATUS']),
          content: $enumDecodeNullable(_$SortOrderEnumMap, json['CONTENT']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          $count: json['_count'] == null
              ? null
              : APPROVALHISTORYTBLCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : APPROVALHISTORYTBLAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : APPROVALHISTORYTBLMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : APPROVALHISTORYTBLMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : APPROVALHISTORYTBLSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALHISTORYTBLOrderByWithAggregationInputToJson(
    APPROVALHISTORYTBLOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('APPROVAL_ID', _$SortOrderEnumMap[instance.approvalId]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('WRITER_NM', _$SortOrderEnumMap[instance.writerNm]);
  writeNotNull('DOC_TYPE', _$SortOrderEnumMap[instance.docType]);
  writeNotNull('KEEP_PRIOD', _$SortOrderEnumMap[instance.keepPriod]);
  writeNotNull('KEEP_DATE', _$SortOrderEnumMap[instance.keepDate]);
  writeNotNull('GRADE', _$SortOrderEnumMap[instance.grade]);
  writeNotNull('STATUS', _$SortOrderEnumMap[instance.status]);
  writeNotNull('CONTENT', _$SortOrderEnumMap[instance.content]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

APPROVALHISTORYTBLScalarWhereWithAggregatesInput
    _$APPROVALHISTORYTBLScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALHISTORYTBLScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              APPROVALHISTORYTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              APPROVALHISTORYTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              APPROVALHISTORYTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          seq: json['SEQ'] == null
              ? null
              : BigIntWithAggregatesFilter.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          approvalId: json['APPROVAL_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['APPROVAL_ID'] as Map<String, dynamic>),
          writerId: json['WRITER_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['WRITER_ID'] as Map<String, dynamic>),
          writerNm: json['WRITER_NM'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['WRITER_NM'] as Map<String, dynamic>),
          docType: json['DOC_TYPE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['DOC_TYPE'] as Map<String, dynamic>),
          keepPriod: json['KEEP_PRIOD'] == null
              ? null
              : IntWithAggregatesFilter.fromJson(
                  json['KEEP_PRIOD'] as Map<String, dynamic>),
          keepDate: json['KEEP_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['KEEP_DATE'] as Map<String, dynamic>),
          grade: json['GRADE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['GRADE'] as Map<String, dynamic>),
          status: json['STATUS'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['STATUS'] as Map<String, dynamic>),
          content: json['CONTENT'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['CONTENT'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : DateTimeNullableWithAggregatesFilter.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALHISTORYTBLScalarWhereWithAggregatesInputToJson(
    APPROVALHISTORYTBLScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('APPROVAL_ID', instance.approvalId?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('WRITER_NM', instance.writerNm?.toJson());
  writeNotNull('DOC_TYPE', instance.docType?.toJson());
  writeNotNull('KEEP_PRIOD', instance.keepPriod?.toJson());
  writeNotNull('KEEP_DATE', instance.keepDate?.toJson());
  writeNotNull('GRADE', instance.grade?.toJson());
  writeNotNull('STATUS', instance.status?.toJson());
  writeNotNull('CONTENT', instance.content?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALMASTERTBLWhereInput _$APPROVALMASTERTBLWhereInputFromJson(
        Map<String, dynamic> json) =>
    APPROVALMASTERTBLWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map((e) =>
          APPROVALMASTERTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map((e) =>
          APPROVALMASTERTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
          APPROVALMASTERTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      approvalId: json['APPROVAL_ID'] == null
          ? null
          : StringFilter.fromJson(json['APPROVAL_ID'] as Map<String, dynamic>),
      writerId: json['WRITER_ID'] == null
          ? null
          : StringFilter.fromJson(json['WRITER_ID'] as Map<String, dynamic>),
      writerNm: json['WRITER_NM'] == null
          ? null
          : StringFilter.fromJson(json['WRITER_NM'] as Map<String, dynamic>),
      docType: json['DOC_TYPE'] == null
          ? null
          : StringFilter.fromJson(json['DOC_TYPE'] as Map<String, dynamic>),
      keepPriod: json['KEEP_PRIOD'] == null
          ? null
          : IntFilter.fromJson(json['KEEP_PRIOD'] as Map<String, dynamic>),
      keepDate: json['KEEP_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(json['KEEP_DATE'] as Map<String, dynamic>),
      grade: json['GRADE'] == null
          ? null
          : StringFilter.fromJson(json['GRADE'] as Map<String, dynamic>),
      status: json['STATUS'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['STATUS'] as Map<String, dynamic>),
      title: json['TITLE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['TITLE'] as Map<String, dynamic>),
      header: json['HEADER'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['HEADER'] as Map<String, dynamic>),
      content: json['CONTENT'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['CONTENT'] as Map<String, dynamic>),
      m1: json['M1'] == null
          ? null
          : DecimalNullableFilter.fromJson(json['M1'] as Map<String, dynamic>),
      m2: json['M2'] == null
          ? null
          : DecimalNullableFilter.fromJson(json['M2'] as Map<String, dynamic>),
      m3: json['M3'] == null
          ? null
          : DecimalNullableFilter.fromJson(json['M3'] as Map<String, dynamic>),
      m4: json['M4'] == null
          ? null
          : DecimalNullableFilter.fromJson(json['M4'] as Map<String, dynamic>),
      m5: json['M5'] == null
          ? null
          : DecimalNullableFilter.fromJson(json['M5'] as Map<String, dynamic>),
      m6: json['M6'] == null
          ? null
          : DecimalNullableFilter.fromJson(json['M6'] as Map<String, dynamic>),
      m7: json['M7'] == null
          ? null
          : DecimalNullableFilter.fromJson(json['M7'] as Map<String, dynamic>),
      m8: json['M8'] == null
          ? null
          : DecimalNullableFilter.fromJson(json['M8'] as Map<String, dynamic>),
      m9: json['M9'] == null
          ? null
          : DecimalNullableFilter.fromJson(json['M9'] as Map<String, dynamic>),
      m10: json['M10'] == null
          ? null
          : DecimalNullableFilter.fromJson(json['M10'] as Map<String, dynamic>),
      m11: json['M11'] == null
          ? null
          : DecimalNullableFilter.fromJson(json['M11'] as Map<String, dynamic>),
      m12: json['M12'] == null
          ? null
          : DecimalNullableFilter.fromJson(json['M12'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      completeDate: json['COMPLETE_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(
              json['COMPLETE_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : DateTimeNullableFilter.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$APPROVALMASTERTBLWhereInputToJson(
    APPROVALMASTERTBLWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('APPROVAL_ID', instance.approvalId?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('WRITER_NM', instance.writerNm?.toJson());
  writeNotNull('DOC_TYPE', instance.docType?.toJson());
  writeNotNull('KEEP_PRIOD', instance.keepPriod?.toJson());
  writeNotNull('KEEP_DATE', instance.keepDate?.toJson());
  writeNotNull('GRADE', instance.grade?.toJson());
  writeNotNull('STATUS', instance.status?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('HEADER', instance.header?.toJson());
  writeNotNull('CONTENT', instance.content?.toJson());
  writeNotNull('M1', instance.m1?.toJson());
  writeNotNull('M2', instance.m2?.toJson());
  writeNotNull('M3', instance.m3?.toJson());
  writeNotNull('M4', instance.m4?.toJson());
  writeNotNull('M5', instance.m5?.toJson());
  writeNotNull('M6', instance.m6?.toJson());
  writeNotNull('M7', instance.m7?.toJson());
  writeNotNull('M8', instance.m8?.toJson());
  writeNotNull('M9', instance.m9?.toJson());
  writeNotNull('M10', instance.m10?.toJson());
  writeNotNull('M11', instance.m11?.toJson());
  writeNotNull('M12', instance.m12?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('COMPLETE_DATE', instance.completeDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALMASTERTBLOrderByWithRelationInput
    _$APPROVALMASTERTBLOrderByWithRelationInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALMASTERTBLOrderByWithRelationInput(
          approvalId:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_ID']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          writerNm: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_NM']),
          docType: $enumDecodeNullable(_$SortOrderEnumMap, json['DOC_TYPE']),
          keepPriod:
              $enumDecodeNullable(_$SortOrderEnumMap, json['KEEP_PRIOD']),
          keepDate: $enumDecodeNullable(_$SortOrderEnumMap, json['KEEP_DATE']),
          grade: $enumDecodeNullable(_$SortOrderEnumMap, json['GRADE']),
          status: $enumDecodeNullable(_$SortOrderEnumMap, json['STATUS']),
          title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
          header: $enumDecodeNullable(_$SortOrderEnumMap, json['HEADER']),
          content: $enumDecodeNullable(_$SortOrderEnumMap, json['CONTENT']),
          m1: $enumDecodeNullable(_$SortOrderEnumMap, json['M1']),
          m2: $enumDecodeNullable(_$SortOrderEnumMap, json['M2']),
          m3: $enumDecodeNullable(_$SortOrderEnumMap, json['M3']),
          m4: $enumDecodeNullable(_$SortOrderEnumMap, json['M4']),
          m5: $enumDecodeNullable(_$SortOrderEnumMap, json['M5']),
          m6: $enumDecodeNullable(_$SortOrderEnumMap, json['M6']),
          m7: $enumDecodeNullable(_$SortOrderEnumMap, json['M7']),
          m8: $enumDecodeNullable(_$SortOrderEnumMap, json['M8']),
          m9: $enumDecodeNullable(_$SortOrderEnumMap, json['M9']),
          m10: $enumDecodeNullable(_$SortOrderEnumMap, json['M10']),
          m11: $enumDecodeNullable(_$SortOrderEnumMap, json['M11']),
          m12: $enumDecodeNullable(_$SortOrderEnumMap, json['M12']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          completeDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['COMPLETE_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$APPROVALMASTERTBLOrderByWithRelationInputToJson(
    APPROVALMASTERTBLOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_ID', _$SortOrderEnumMap[instance.approvalId]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('WRITER_NM', _$SortOrderEnumMap[instance.writerNm]);
  writeNotNull('DOC_TYPE', _$SortOrderEnumMap[instance.docType]);
  writeNotNull('KEEP_PRIOD', _$SortOrderEnumMap[instance.keepPriod]);
  writeNotNull('KEEP_DATE', _$SortOrderEnumMap[instance.keepDate]);
  writeNotNull('GRADE', _$SortOrderEnumMap[instance.grade]);
  writeNotNull('STATUS', _$SortOrderEnumMap[instance.status]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull('HEADER', _$SortOrderEnumMap[instance.header]);
  writeNotNull('CONTENT', _$SortOrderEnumMap[instance.content]);
  writeNotNull('M1', _$SortOrderEnumMap[instance.m1]);
  writeNotNull('M2', _$SortOrderEnumMap[instance.m2]);
  writeNotNull('M3', _$SortOrderEnumMap[instance.m3]);
  writeNotNull('M4', _$SortOrderEnumMap[instance.m4]);
  writeNotNull('M5', _$SortOrderEnumMap[instance.m5]);
  writeNotNull('M6', _$SortOrderEnumMap[instance.m6]);
  writeNotNull('M7', _$SortOrderEnumMap[instance.m7]);
  writeNotNull('M8', _$SortOrderEnumMap[instance.m8]);
  writeNotNull('M9', _$SortOrderEnumMap[instance.m9]);
  writeNotNull('M10', _$SortOrderEnumMap[instance.m10]);
  writeNotNull('M11', _$SortOrderEnumMap[instance.m11]);
  writeNotNull('M12', _$SortOrderEnumMap[instance.m12]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('COMPLETE_DATE', _$SortOrderEnumMap[instance.completeDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

APPROVALMASTERTBLWhereUniqueInput _$APPROVALMASTERTBLWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    APPROVALMASTERTBLWhereUniqueInput(
      approvalId: json['APPROVAL_ID'] as String?,
    );

Map<String, dynamic> _$APPROVALMASTERTBLWhereUniqueInputToJson(
    APPROVALMASTERTBLWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_ID', instance.approvalId);
  return val;
}

APPROVALMASTERTBLOrderByWithAggregationInput
    _$APPROVALMASTERTBLOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALMASTERTBLOrderByWithAggregationInput(
          approvalId:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_ID']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          writerNm: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_NM']),
          docType: $enumDecodeNullable(_$SortOrderEnumMap, json['DOC_TYPE']),
          keepPriod:
              $enumDecodeNullable(_$SortOrderEnumMap, json['KEEP_PRIOD']),
          keepDate: $enumDecodeNullable(_$SortOrderEnumMap, json['KEEP_DATE']),
          grade: $enumDecodeNullable(_$SortOrderEnumMap, json['GRADE']),
          status: $enumDecodeNullable(_$SortOrderEnumMap, json['STATUS']),
          title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
          header: $enumDecodeNullable(_$SortOrderEnumMap, json['HEADER']),
          content: $enumDecodeNullable(_$SortOrderEnumMap, json['CONTENT']),
          m1: $enumDecodeNullable(_$SortOrderEnumMap, json['M1']),
          m2: $enumDecodeNullable(_$SortOrderEnumMap, json['M2']),
          m3: $enumDecodeNullable(_$SortOrderEnumMap, json['M3']),
          m4: $enumDecodeNullable(_$SortOrderEnumMap, json['M4']),
          m5: $enumDecodeNullable(_$SortOrderEnumMap, json['M5']),
          m6: $enumDecodeNullable(_$SortOrderEnumMap, json['M6']),
          m7: $enumDecodeNullable(_$SortOrderEnumMap, json['M7']),
          m8: $enumDecodeNullable(_$SortOrderEnumMap, json['M8']),
          m9: $enumDecodeNullable(_$SortOrderEnumMap, json['M9']),
          m10: $enumDecodeNullable(_$SortOrderEnumMap, json['M10']),
          m11: $enumDecodeNullable(_$SortOrderEnumMap, json['M11']),
          m12: $enumDecodeNullable(_$SortOrderEnumMap, json['M12']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          completeDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['COMPLETE_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          $count: json['_count'] == null
              ? null
              : APPROVALMASTERTBLCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : APPROVALMASTERTBLAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : APPROVALMASTERTBLMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : APPROVALMASTERTBLMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : APPROVALMASTERTBLSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALMASTERTBLOrderByWithAggregationInputToJson(
    APPROVALMASTERTBLOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_ID', _$SortOrderEnumMap[instance.approvalId]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('WRITER_NM', _$SortOrderEnumMap[instance.writerNm]);
  writeNotNull('DOC_TYPE', _$SortOrderEnumMap[instance.docType]);
  writeNotNull('KEEP_PRIOD', _$SortOrderEnumMap[instance.keepPriod]);
  writeNotNull('KEEP_DATE', _$SortOrderEnumMap[instance.keepDate]);
  writeNotNull('GRADE', _$SortOrderEnumMap[instance.grade]);
  writeNotNull('STATUS', _$SortOrderEnumMap[instance.status]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull('HEADER', _$SortOrderEnumMap[instance.header]);
  writeNotNull('CONTENT', _$SortOrderEnumMap[instance.content]);
  writeNotNull('M1', _$SortOrderEnumMap[instance.m1]);
  writeNotNull('M2', _$SortOrderEnumMap[instance.m2]);
  writeNotNull('M3', _$SortOrderEnumMap[instance.m3]);
  writeNotNull('M4', _$SortOrderEnumMap[instance.m4]);
  writeNotNull('M5', _$SortOrderEnumMap[instance.m5]);
  writeNotNull('M6', _$SortOrderEnumMap[instance.m6]);
  writeNotNull('M7', _$SortOrderEnumMap[instance.m7]);
  writeNotNull('M8', _$SortOrderEnumMap[instance.m8]);
  writeNotNull('M9', _$SortOrderEnumMap[instance.m9]);
  writeNotNull('M10', _$SortOrderEnumMap[instance.m10]);
  writeNotNull('M11', _$SortOrderEnumMap[instance.m11]);
  writeNotNull('M12', _$SortOrderEnumMap[instance.m12]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('COMPLETE_DATE', _$SortOrderEnumMap[instance.completeDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

APPROVALMASTERTBLScalarWhereWithAggregatesInput
    _$APPROVALMASTERTBLScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALMASTERTBLScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              APPROVALMASTERTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              APPROVALMASTERTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              APPROVALMASTERTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          approvalId: json['APPROVAL_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['APPROVAL_ID'] as Map<String, dynamic>),
          writerId: json['WRITER_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['WRITER_ID'] as Map<String, dynamic>),
          writerNm: json['WRITER_NM'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['WRITER_NM'] as Map<String, dynamic>),
          docType: json['DOC_TYPE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['DOC_TYPE'] as Map<String, dynamic>),
          keepPriod: json['KEEP_PRIOD'] == null
              ? null
              : IntWithAggregatesFilter.fromJson(
                  json['KEEP_PRIOD'] as Map<String, dynamic>),
          keepDate: json['KEEP_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['KEEP_DATE'] as Map<String, dynamic>),
          grade: json['GRADE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['GRADE'] as Map<String, dynamic>),
          status: json['STATUS'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['STATUS'] as Map<String, dynamic>),
          title: json['TITLE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['TITLE'] as Map<String, dynamic>),
          header: json['HEADER'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['HEADER'] as Map<String, dynamic>),
          content: json['CONTENT'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['CONTENT'] as Map<String, dynamic>),
          m1: json['M1'] == null
              ? null
              : DecimalNullableWithAggregatesFilter.fromJson(
                  json['M1'] as Map<String, dynamic>),
          m2: json['M2'] == null
              ? null
              : DecimalNullableWithAggregatesFilter.fromJson(
                  json['M2'] as Map<String, dynamic>),
          m3: json['M3'] == null
              ? null
              : DecimalNullableWithAggregatesFilter.fromJson(
                  json['M3'] as Map<String, dynamic>),
          m4: json['M4'] == null
              ? null
              : DecimalNullableWithAggregatesFilter.fromJson(
                  json['M4'] as Map<String, dynamic>),
          m5: json['M5'] == null
              ? null
              : DecimalNullableWithAggregatesFilter.fromJson(
                  json['M5'] as Map<String, dynamic>),
          m6: json['M6'] == null
              ? null
              : DecimalNullableWithAggregatesFilter.fromJson(
                  json['M6'] as Map<String, dynamic>),
          m7: json['M7'] == null
              ? null
              : DecimalNullableWithAggregatesFilter.fromJson(
                  json['M7'] as Map<String, dynamic>),
          m8: json['M8'] == null
              ? null
              : DecimalNullableWithAggregatesFilter.fromJson(
                  json['M8'] as Map<String, dynamic>),
          m9: json['M9'] == null
              ? null
              : DecimalNullableWithAggregatesFilter.fromJson(
                  json['M9'] as Map<String, dynamic>),
          m10: json['M10'] == null
              ? null
              : DecimalNullableWithAggregatesFilter.fromJson(
                  json['M10'] as Map<String, dynamic>),
          m11: json['M11'] == null
              ? null
              : DecimalNullableWithAggregatesFilter.fromJson(
                  json['M11'] as Map<String, dynamic>),
          m12: json['M12'] == null
              ? null
              : DecimalNullableWithAggregatesFilter.fromJson(
                  json['M12'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          completeDate: json['COMPLETE_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['COMPLETE_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : DateTimeNullableWithAggregatesFilter.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALMASTERTBLScalarWhereWithAggregatesInputToJson(
    APPROVALMASTERTBLScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('APPROVAL_ID', instance.approvalId?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('WRITER_NM', instance.writerNm?.toJson());
  writeNotNull('DOC_TYPE', instance.docType?.toJson());
  writeNotNull('KEEP_PRIOD', instance.keepPriod?.toJson());
  writeNotNull('KEEP_DATE', instance.keepDate?.toJson());
  writeNotNull('GRADE', instance.grade?.toJson());
  writeNotNull('STATUS', instance.status?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('HEADER', instance.header?.toJson());
  writeNotNull('CONTENT', instance.content?.toJson());
  writeNotNull('M1', instance.m1?.toJson());
  writeNotNull('M2', instance.m2?.toJson());
  writeNotNull('M3', instance.m3?.toJson());
  writeNotNull('M4', instance.m4?.toJson());
  writeNotNull('M5', instance.m5?.toJson());
  writeNotNull('M6', instance.m6?.toJson());
  writeNotNull('M7', instance.m7?.toJson());
  writeNotNull('M8', instance.m8?.toJson());
  writeNotNull('M9', instance.m9?.toJson());
  writeNotNull('M10', instance.m10?.toJson());
  writeNotNull('M11', instance.m11?.toJson());
  writeNotNull('M12', instance.m12?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('COMPLETE_DATE', instance.completeDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALMEMOTBLWhereInput _$APPROVALMEMOTBLWhereInputFromJson(
        Map<String, dynamic> json) =>
    APPROVALMEMOTBLWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map(
          (e) => APPROVALMEMOTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map(
          (e) => APPROVALMEMOTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map(
          (e) => APPROVALMEMOTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      seq: json['SEQ'] == null
          ? null
          : BigIntFilter.fromJson(json['SEQ'] as Map<String, dynamic>),
      approvalId: json['APPROVAL_ID'] == null
          ? null
          : StringFilter.fromJson(json['APPROVAL_ID'] as Map<String, dynamic>),
      writerId: json['WRITER_ID'] == null
          ? null
          : StringFilter.fromJson(json['WRITER_ID'] as Map<String, dynamic>),
      writerNm: json['WRITER_NM'] == null
          ? null
          : StringFilter.fromJson(json['WRITER_NM'] as Map<String, dynamic>),
      content: json['CONTENT'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['CONTENT'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : DateTimeNullableFilter.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$APPROVALMEMOTBLWhereInputToJson(
    APPROVALMEMOTBLWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('APPROVAL_ID', instance.approvalId?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('WRITER_NM', instance.writerNm?.toJson());
  writeNotNull('CONTENT', instance.content?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALMEMOTBLOrderByWithRelationInput
    _$APPROVALMEMOTBLOrderByWithRelationInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALMEMOTBLOrderByWithRelationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          approvalId:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_ID']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          writerNm: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_NM']),
          content: $enumDecodeNullable(_$SortOrderEnumMap, json['CONTENT']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$APPROVALMEMOTBLOrderByWithRelationInputToJson(
    APPROVALMEMOTBLOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('APPROVAL_ID', _$SortOrderEnumMap[instance.approvalId]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('WRITER_NM', _$SortOrderEnumMap[instance.writerNm]);
  writeNotNull('CONTENT', _$SortOrderEnumMap[instance.content]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

APPROVALMEMOTBLWhereUniqueInput _$APPROVALMEMOTBLWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    APPROVALMEMOTBLWhereUniqueInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
    );

Map<String, dynamic> _$APPROVALMEMOTBLWhereUniqueInputToJson(
    APPROVALMEMOTBLWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  return val;
}

APPROVALMEMOTBLOrderByWithAggregationInput
    _$APPROVALMEMOTBLOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALMEMOTBLOrderByWithAggregationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          approvalId:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_ID']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          writerNm: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_NM']),
          content: $enumDecodeNullable(_$SortOrderEnumMap, json['CONTENT']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          $count: json['_count'] == null
              ? null
              : APPROVALMEMOTBLCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : APPROVALMEMOTBLAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : APPROVALMEMOTBLMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : APPROVALMEMOTBLMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : APPROVALMEMOTBLSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALMEMOTBLOrderByWithAggregationInputToJson(
    APPROVALMEMOTBLOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('APPROVAL_ID', _$SortOrderEnumMap[instance.approvalId]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('WRITER_NM', _$SortOrderEnumMap[instance.writerNm]);
  writeNotNull('CONTENT', _$SortOrderEnumMap[instance.content]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

APPROVALMEMOTBLScalarWhereWithAggregatesInput
    _$APPROVALMEMOTBLScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALMEMOTBLScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              APPROVALMEMOTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              APPROVALMEMOTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              APPROVALMEMOTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          seq: json['SEQ'] == null
              ? null
              : BigIntWithAggregatesFilter.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          approvalId: json['APPROVAL_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['APPROVAL_ID'] as Map<String, dynamic>),
          writerId: json['WRITER_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['WRITER_ID'] as Map<String, dynamic>),
          writerNm: json['WRITER_NM'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['WRITER_NM'] as Map<String, dynamic>),
          content: json['CONTENT'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['CONTENT'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : DateTimeNullableWithAggregatesFilter.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALMEMOTBLScalarWhereWithAggregatesInputToJson(
    APPROVALMEMOTBLScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('APPROVAL_ID', instance.approvalId?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('WRITER_NM', instance.writerNm?.toJson());
  writeNotNull('CONTENT', instance.content?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALTYPETBLWhereInput _$APPROVALTYPETBLWhereInputFromJson(
        Map<String, dynamic> json) =>
    APPROVALTYPETBLWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map(
          (e) => APPROVALTYPETBLWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map(
          (e) => APPROVALTYPETBLWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map(
          (e) => APPROVALTYPETBLWhereInput.fromJson(e as Map<String, dynamic>)),
      type: json['TYPE'] == null
          ? null
          : StringFilter.fromJson(json['TYPE'] as Map<String, dynamic>),
      content: json['CONTENT'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['CONTENT'] as Map<String, dynamic>),
      contentBak: json['CONTENT_BAK'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['CONTENT_BAK'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$APPROVALTYPETBLWhereInputToJson(
    APPROVALTYPETBLWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('TYPE', instance.type?.toJson());
  writeNotNull('CONTENT', instance.content?.toJson());
  writeNotNull('CONTENT_BAK', instance.contentBak?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALTYPETBLOrderByWithRelationInput
    _$APPROVALTYPETBLOrderByWithRelationInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALTYPETBLOrderByWithRelationInput(
          type: $enumDecodeNullable(_$SortOrderEnumMap, json['TYPE']),
          content: $enumDecodeNullable(_$SortOrderEnumMap, json['CONTENT']),
          contentBak:
              $enumDecodeNullable(_$SortOrderEnumMap, json['CONTENT_BAK']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$APPROVALTYPETBLOrderByWithRelationInputToJson(
    APPROVALTYPETBLOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('TYPE', _$SortOrderEnumMap[instance.type]);
  writeNotNull('CONTENT', _$SortOrderEnumMap[instance.content]);
  writeNotNull('CONTENT_BAK', _$SortOrderEnumMap[instance.contentBak]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

APPROVALTYPETBLWhereUniqueInput _$APPROVALTYPETBLWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    APPROVALTYPETBLWhereUniqueInput(
      type: json['TYPE'] as String?,
    );

Map<String, dynamic> _$APPROVALTYPETBLWhereUniqueInputToJson(
    APPROVALTYPETBLWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('TYPE', instance.type);
  return val;
}

APPROVALTYPETBLOrderByWithAggregationInput
    _$APPROVALTYPETBLOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALTYPETBLOrderByWithAggregationInput(
          type: $enumDecodeNullable(_$SortOrderEnumMap, json['TYPE']),
          content: $enumDecodeNullable(_$SortOrderEnumMap, json['CONTENT']),
          contentBak:
              $enumDecodeNullable(_$SortOrderEnumMap, json['CONTENT_BAK']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          $count: json['_count'] == null
              ? null
              : APPROVALTYPETBLCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : APPROVALTYPETBLMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : APPROVALTYPETBLMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALTYPETBLOrderByWithAggregationInputToJson(
    APPROVALTYPETBLOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('TYPE', _$SortOrderEnumMap[instance.type]);
  writeNotNull('CONTENT', _$SortOrderEnumMap[instance.content]);
  writeNotNull('CONTENT_BAK', _$SortOrderEnumMap[instance.contentBak]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  return val;
}

APPROVALTYPETBLScalarWhereWithAggregatesInput
    _$APPROVALTYPETBLScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALTYPETBLScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              APPROVALTYPETBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              APPROVALTYPETBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              APPROVALTYPETBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          type: json['TYPE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['TYPE'] as Map<String, dynamic>),
          content: json['CONTENT'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['CONTENT'] as Map<String, dynamic>),
          contentBak: json['CONTENT_BAK'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['CONTENT_BAK'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALTYPETBLScalarWhereWithAggregatesInputToJson(
    APPROVALTYPETBLScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('TYPE', instance.type?.toJson());
  writeNotNull('CONTENT', instance.content?.toJson());
  writeNotNull('CONTENT_BAK', instance.contentBak?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALUSERTBLWhereInput _$APPROVALUSERTBLWhereInputFromJson(
        Map<String, dynamic> json) =>
    APPROVALUSERTBLWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map(
          (e) => APPROVALUSERTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map(
          (e) => APPROVALUSERTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map(
          (e) => APPROVALUSERTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      approvalId: json['APPROVAL_ID'] == null
          ? null
          : StringFilter.fromJson(json['APPROVAL_ID'] as Map<String, dynamic>),
      approvalUsrId: json['APPROVAL_USR_ID'] == null
          ? null
          : StringFilter.fromJson(
              json['APPROVAL_USR_ID'] as Map<String, dynamic>),
      approvalUsrGradeCd: json['APPROVAL_USR_GRADE_CD'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['APPROVAL_USR_GRADE_CD'] as Map<String, dynamic>),
      approvalUsrType: json['APPROVAL_USR_TYPE'] == null
          ? null
          : StringFilter.fromJson(
              json['APPROVAL_USR_TYPE'] as Map<String, dynamic>),
      approvalUsrSort: json['APPROVAL_USR_SORT'] == null
          ? null
          : IntFilter.fromJson(
              json['APPROVAL_USR_SORT'] as Map<String, dynamic>),
      approvalProcUserYn: json['APPROVAL_PROC_USER_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['APPROVAL_PROC_USER_YN'] as Map<String, dynamic>),
      approvalProcYn: json['APPROVAL_PROC_YN'] == null
          ? null
          : StringFilter.fromJson(
              json['APPROVAL_PROC_YN'] as Map<String, dynamic>),
      approvalProcDate: json['APPROVAL_PROC_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(
              json['APPROVAL_PROC_DATE'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : DateTimeNullableFilter.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$APPROVALUSERTBLWhereInputToJson(
    APPROVALUSERTBLWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('APPROVAL_ID', instance.approvalId?.toJson());
  writeNotNull('APPROVAL_USR_ID', instance.approvalUsrId?.toJson());
  writeNotNull('APPROVAL_USR_GRADE_CD', instance.approvalUsrGradeCd?.toJson());
  writeNotNull('APPROVAL_USR_TYPE', instance.approvalUsrType?.toJson());
  writeNotNull('APPROVAL_USR_SORT', instance.approvalUsrSort?.toJson());
  writeNotNull('APPROVAL_PROC_USER_YN', instance.approvalProcUserYn?.toJson());
  writeNotNull('APPROVAL_PROC_YN', instance.approvalProcYn?.toJson());
  writeNotNull('APPROVAL_PROC_DATE', instance.approvalProcDate?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALUSERTBLOrderByWithRelationInput
    _$APPROVALUSERTBLOrderByWithRelationInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALUSERTBLOrderByWithRelationInput(
          approvalId:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_ID']),
          approvalUsrId:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_USR_ID']),
          approvalUsrGradeCd: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_USR_GRADE_CD']),
          approvalUsrType: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_USR_TYPE']),
          approvalUsrSort: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_USR_SORT']),
          approvalProcUserYn: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_PROC_USER_YN']),
          approvalProcYn:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_PROC_YN']),
          approvalProcDate: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_PROC_DATE']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$APPROVALUSERTBLOrderByWithRelationInputToJson(
    APPROVALUSERTBLOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_ID', _$SortOrderEnumMap[instance.approvalId]);
  writeNotNull('APPROVAL_USR_ID', _$SortOrderEnumMap[instance.approvalUsrId]);
  writeNotNull(
      'APPROVAL_USR_GRADE_CD', _$SortOrderEnumMap[instance.approvalUsrGradeCd]);
  writeNotNull(
      'APPROVAL_USR_TYPE', _$SortOrderEnumMap[instance.approvalUsrType]);
  writeNotNull(
      'APPROVAL_USR_SORT', _$SortOrderEnumMap[instance.approvalUsrSort]);
  writeNotNull(
      'APPROVAL_PROC_USER_YN', _$SortOrderEnumMap[instance.approvalProcUserYn]);
  writeNotNull('APPROVAL_PROC_YN', _$SortOrderEnumMap[instance.approvalProcYn]);
  writeNotNull(
      'APPROVAL_PROC_DATE', _$SortOrderEnumMap[instance.approvalProcDate]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

APPROVALUSERTBLWhereUniqueInput _$APPROVALUSERTBLWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    APPROVALUSERTBLWhereUniqueInput(
      approvalIdApprovalUsrIdApprovalUsrType: json[
                  'APPROVAL_ID_APPROVAL_USR_ID_APPROVAL_USR_TYPE'] ==
              null
          ? null
          : APPROVALUSERTBLAPPROVALIDAPPROVALUSRIDAPPROVALUSRTYPECompoundUniqueInput
              .fromJson(json['APPROVAL_ID_APPROVAL_USR_ID_APPROVAL_USR_TYPE']
                  as Map<String, dynamic>),
    );

Map<String, dynamic> _$APPROVALUSERTBLWhereUniqueInputToJson(
    APPROVALUSERTBLWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_ID_APPROVAL_USR_ID_APPROVAL_USR_TYPE',
      instance.approvalIdApprovalUsrIdApprovalUsrType?.toJson());
  return val;
}

APPROVALUSERTBLOrderByWithAggregationInput
    _$APPROVALUSERTBLOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALUSERTBLOrderByWithAggregationInput(
          approvalId:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_ID']),
          approvalUsrId:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_USR_ID']),
          approvalUsrGradeCd: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_USR_GRADE_CD']),
          approvalUsrType: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_USR_TYPE']),
          approvalUsrSort: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_USR_SORT']),
          approvalProcUserYn: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_PROC_USER_YN']),
          approvalProcYn:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_PROC_YN']),
          approvalProcDate: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_PROC_DATE']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          $count: json['_count'] == null
              ? null
              : APPROVALUSERTBLCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : APPROVALUSERTBLAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : APPROVALUSERTBLMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : APPROVALUSERTBLMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : APPROVALUSERTBLSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALUSERTBLOrderByWithAggregationInputToJson(
    APPROVALUSERTBLOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_ID', _$SortOrderEnumMap[instance.approvalId]);
  writeNotNull('APPROVAL_USR_ID', _$SortOrderEnumMap[instance.approvalUsrId]);
  writeNotNull(
      'APPROVAL_USR_GRADE_CD', _$SortOrderEnumMap[instance.approvalUsrGradeCd]);
  writeNotNull(
      'APPROVAL_USR_TYPE', _$SortOrderEnumMap[instance.approvalUsrType]);
  writeNotNull(
      'APPROVAL_USR_SORT', _$SortOrderEnumMap[instance.approvalUsrSort]);
  writeNotNull(
      'APPROVAL_PROC_USER_YN', _$SortOrderEnumMap[instance.approvalProcUserYn]);
  writeNotNull('APPROVAL_PROC_YN', _$SortOrderEnumMap[instance.approvalProcYn]);
  writeNotNull(
      'APPROVAL_PROC_DATE', _$SortOrderEnumMap[instance.approvalProcDate]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

APPROVALUSERTBLScalarWhereWithAggregatesInput
    _$APPROVALUSERTBLScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALUSERTBLScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              APPROVALUSERTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              APPROVALUSERTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              APPROVALUSERTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          approvalId: json['APPROVAL_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['APPROVAL_ID'] as Map<String, dynamic>),
          approvalUsrId: json['APPROVAL_USR_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['APPROVAL_USR_ID'] as Map<String, dynamic>),
          approvalUsrGradeCd: json['APPROVAL_USR_GRADE_CD'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['APPROVAL_USR_GRADE_CD'] as Map<String, dynamic>),
          approvalUsrType: json['APPROVAL_USR_TYPE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['APPROVAL_USR_TYPE'] as Map<String, dynamic>),
          approvalUsrSort: json['APPROVAL_USR_SORT'] == null
              ? null
              : IntWithAggregatesFilter.fromJson(
                  json['APPROVAL_USR_SORT'] as Map<String, dynamic>),
          approvalProcUserYn: json['APPROVAL_PROC_USER_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['APPROVAL_PROC_USER_YN'] as Map<String, dynamic>),
          approvalProcYn: json['APPROVAL_PROC_YN'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['APPROVAL_PROC_YN'] as Map<String, dynamic>),
          approvalProcDate: json['APPROVAL_PROC_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['APPROVAL_PROC_DATE'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : DateTimeNullableWithAggregatesFilter.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALUSERTBLScalarWhereWithAggregatesInputToJson(
    APPROVALUSERTBLScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('APPROVAL_ID', instance.approvalId?.toJson());
  writeNotNull('APPROVAL_USR_ID', instance.approvalUsrId?.toJson());
  writeNotNull('APPROVAL_USR_GRADE_CD', instance.approvalUsrGradeCd?.toJson());
  writeNotNull('APPROVAL_USR_TYPE', instance.approvalUsrType?.toJson());
  writeNotNull('APPROVAL_USR_SORT', instance.approvalUsrSort?.toJson());
  writeNotNull('APPROVAL_PROC_USER_YN', instance.approvalProcUserYn?.toJson());
  writeNotNull('APPROVAL_PROC_YN', instance.approvalProcYn?.toJson());
  writeNotNull('APPROVAL_PROC_DATE', instance.approvalProcDate?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

BOOKASSETTBLWhereInput _$BOOKASSETTBLWhereInputFromJson(
        Map<String, dynamic> json) =>
    BOOKASSETTBLWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map(
          (e) => BOOKASSETTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map(
          (e) => BOOKASSETTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map(
          (e) => BOOKASSETTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      seq: json['SEQ'] == null
          ? null
          : BigIntFilter.fromJson(json['SEQ'] as Map<String, dynamic>),
      assetNo: json['ASSET_NO'] == null
          ? null
          : StringFilter.fromJson(json['ASSET_NO'] as Map<String, dynamic>),
      bookNm: json['BOOK_NM'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['BOOK_NM'] as Map<String, dynamic>),
      cnt: json['CNT'] == null
          ? null
          : IntNullableFilter.fromJson(json['CNT'] as Map<String, dynamic>),
      publisher: json['PUBLISHER'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['PUBLISHER'] as Map<String, dynamic>),
      amount: json['AMOUNT'] == null
          ? null
          : IntNullableFilter.fromJson(json['AMOUNT'] as Map<String, dynamic>),
      buyDate: json['BUY_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['BUY_DATE'] as Map<String, dynamic>),
      mngDept: json['MNG_DEPT'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['MNG_DEPT'] as Map<String, dynamic>),
      rentYn: json['RENT_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['RENT_YN'] as Map<String, dynamic>),
      rentUser: json['RENT_USER'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['RENT_USER'] as Map<String, dynamic>),
      remarks: json['REMARKS'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['REMARKS'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : StringFilter.fromJson(json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringFilter.fromJson(json['DEL_YN'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : DateTimeNullableFilter.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$BOOKASSETTBLWhereInputToJson(
    BOOKASSETTBLWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('BOOK_NM', instance.bookNm?.toJson());
  writeNotNull('CNT', instance.cnt?.toJson());
  writeNotNull('PUBLISHER', instance.publisher?.toJson());
  writeNotNull('AMOUNT', instance.amount?.toJson());
  writeNotNull('BUY_DATE', instance.buyDate?.toJson());
  writeNotNull('MNG_DEPT', instance.mngDept?.toJson());
  writeNotNull('RENT_YN', instance.rentYn?.toJson());
  writeNotNull('RENT_USER', instance.rentUser?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

BOOKASSETTBLOrderByWithRelationInput
    _$BOOKASSETTBLOrderByWithRelationInputFromJson(Map<String, dynamic> json) =>
        BOOKASSETTBLOrderByWithRelationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          assetNo: $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_NO']),
          bookNm: $enumDecodeNullable(_$SortOrderEnumMap, json['BOOK_NM']),
          cnt: $enumDecodeNullable(_$SortOrderEnumMap, json['CNT']),
          publisher: $enumDecodeNullable(_$SortOrderEnumMap, json['PUBLISHER']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
          buyDate: $enumDecodeNullable(_$SortOrderEnumMap, json['BUY_DATE']),
          mngDept: $enumDecodeNullable(_$SortOrderEnumMap, json['MNG_DEPT']),
          rentYn: $enumDecodeNullable(_$SortOrderEnumMap, json['RENT_YN']),
          rentUser: $enumDecodeNullable(_$SortOrderEnumMap, json['RENT_USER']),
          remarks: $enumDecodeNullable(_$SortOrderEnumMap, json['REMARKS']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
        );

Map<String, dynamic> _$BOOKASSETTBLOrderByWithRelationInputToJson(
    BOOKASSETTBLOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ASSET_NO', _$SortOrderEnumMap[instance.assetNo]);
  writeNotNull('BOOK_NM', _$SortOrderEnumMap[instance.bookNm]);
  writeNotNull('CNT', _$SortOrderEnumMap[instance.cnt]);
  writeNotNull('PUBLISHER', _$SortOrderEnumMap[instance.publisher]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  writeNotNull('BUY_DATE', _$SortOrderEnumMap[instance.buyDate]);
  writeNotNull('MNG_DEPT', _$SortOrderEnumMap[instance.mngDept]);
  writeNotNull('RENT_YN', _$SortOrderEnumMap[instance.rentYn]);
  writeNotNull('RENT_USER', _$SortOrderEnumMap[instance.rentUser]);
  writeNotNull('REMARKS', _$SortOrderEnumMap[instance.remarks]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  return val;
}

BOOKASSETTBLWhereUniqueInput _$BOOKASSETTBLWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    BOOKASSETTBLWhereUniqueInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
    );

Map<String, dynamic> _$BOOKASSETTBLWhereUniqueInputToJson(
    BOOKASSETTBLWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  return val;
}

BOOKASSETTBLOrderByWithAggregationInput
    _$BOOKASSETTBLOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        BOOKASSETTBLOrderByWithAggregationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          assetNo: $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_NO']),
          bookNm: $enumDecodeNullable(_$SortOrderEnumMap, json['BOOK_NM']),
          cnt: $enumDecodeNullable(_$SortOrderEnumMap, json['CNT']),
          publisher: $enumDecodeNullable(_$SortOrderEnumMap, json['PUBLISHER']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
          buyDate: $enumDecodeNullable(_$SortOrderEnumMap, json['BUY_DATE']),
          mngDept: $enumDecodeNullable(_$SortOrderEnumMap, json['MNG_DEPT']),
          rentYn: $enumDecodeNullable(_$SortOrderEnumMap, json['RENT_YN']),
          rentUser: $enumDecodeNullable(_$SortOrderEnumMap, json['RENT_USER']),
          remarks: $enumDecodeNullable(_$SortOrderEnumMap, json['REMARKS']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          $count: json['_count'] == null
              ? null
              : BOOKASSETTBLCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : BOOKASSETTBLAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : BOOKASSETTBLMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : BOOKASSETTBLMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : BOOKASSETTBLSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$BOOKASSETTBLOrderByWithAggregationInputToJson(
    BOOKASSETTBLOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ASSET_NO', _$SortOrderEnumMap[instance.assetNo]);
  writeNotNull('BOOK_NM', _$SortOrderEnumMap[instance.bookNm]);
  writeNotNull('CNT', _$SortOrderEnumMap[instance.cnt]);
  writeNotNull('PUBLISHER', _$SortOrderEnumMap[instance.publisher]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  writeNotNull('BUY_DATE', _$SortOrderEnumMap[instance.buyDate]);
  writeNotNull('MNG_DEPT', _$SortOrderEnumMap[instance.mngDept]);
  writeNotNull('RENT_YN', _$SortOrderEnumMap[instance.rentYn]);
  writeNotNull('RENT_USER', _$SortOrderEnumMap[instance.rentUser]);
  writeNotNull('REMARKS', _$SortOrderEnumMap[instance.remarks]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

BOOKASSETTBLScalarWhereWithAggregatesInput
    _$BOOKASSETTBLScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        BOOKASSETTBLScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              BOOKASSETTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              BOOKASSETTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              BOOKASSETTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          seq: json['SEQ'] == null
              ? null
              : BigIntWithAggregatesFilter.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          assetNo: json['ASSET_NO'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['ASSET_NO'] as Map<String, dynamic>),
          bookNm: json['BOOK_NM'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['BOOK_NM'] as Map<String, dynamic>),
          cnt: json['CNT'] == null
              ? null
              : IntNullableWithAggregatesFilter.fromJson(
                  json['CNT'] as Map<String, dynamic>),
          publisher: json['PUBLISHER'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['PUBLISHER'] as Map<String, dynamic>),
          amount: json['AMOUNT'] == null
              ? null
              : IntNullableWithAggregatesFilter.fromJson(
                  json['AMOUNT'] as Map<String, dynamic>),
          buyDate: json['BUY_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['BUY_DATE'] as Map<String, dynamic>),
          mngDept: json['MNG_DEPT'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['MNG_DEPT'] as Map<String, dynamic>),
          rentYn: json['RENT_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['RENT_YN'] as Map<String, dynamic>),
          rentUser: json['RENT_USER'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['RENT_USER'] as Map<String, dynamic>),
          remarks: json['REMARKS'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['REMARKS'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : DateTimeNullableWithAggregatesFilter.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$BOOKASSETTBLScalarWhereWithAggregatesInputToJson(
    BOOKASSETTBLScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('BOOK_NM', instance.bookNm?.toJson());
  writeNotNull('CNT', instance.cnt?.toJson());
  writeNotNull('PUBLISHER', instance.publisher?.toJson());
  writeNotNull('AMOUNT', instance.amount?.toJson());
  writeNotNull('BUY_DATE', instance.buyDate?.toJson());
  writeNotNull('MNG_DEPT', instance.mngDept?.toJson());
  writeNotNull('RENT_YN', instance.rentYn?.toJson());
  writeNotNull('RENT_USER', instance.rentUser?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

CARASSETINSURTBLWhereInput _$CARASSETINSURTBLWhereInputFromJson(
        Map<String, dynamic> json) =>
    CARASSETINSURTBLWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map((e) =>
          CARASSETINSURTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map((e) =>
          CARASSETINSURTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
          CARASSETINSURTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      seq: json['SEQ'] == null
          ? null
          : BigIntFilter.fromJson(json['SEQ'] as Map<String, dynamic>),
      mseq: json['MSEQ'] == null
          ? null
          : BigIntFilter.fromJson(json['MSEQ'] as Map<String, dynamic>),
      guarantee: json['GUARANTEE'] == null
          ? null
          : StringFilter.fromJson(json['GUARANTEE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$CARASSETINSURTBLWhereInputToJson(
    CARASSETINSURTBLWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('GUARANTEE', instance.guarantee?.toJson());
  return val;
}

CARASSETINSURTBLOrderByWithRelationInput
    _$CARASSETINSURTBLOrderByWithRelationInputFromJson(
            Map<String, dynamic> json) =>
        CARASSETINSURTBLOrderByWithRelationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          guarantee: $enumDecodeNullable(_$SortOrderEnumMap, json['GUARANTEE']),
        );

Map<String, dynamic> _$CARASSETINSURTBLOrderByWithRelationInputToJson(
    CARASSETINSURTBLOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('GUARANTEE', _$SortOrderEnumMap[instance.guarantee]);
  return val;
}

CARASSETINSURTBLWhereUniqueInput _$CARASSETINSURTBLWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    CARASSETINSURTBLWhereUniqueInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
    );

Map<String, dynamic> _$CARASSETINSURTBLWhereUniqueInputToJson(
    CARASSETINSURTBLWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  return val;
}

CARASSETINSURTBLOrderByWithAggregationInput
    _$CARASSETINSURTBLOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        CARASSETINSURTBLOrderByWithAggregationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          guarantee: $enumDecodeNullable(_$SortOrderEnumMap, json['GUARANTEE']),
          $count: json['_count'] == null
              ? null
              : CARASSETINSURTBLCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : CARASSETINSURTBLAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : CARASSETINSURTBLMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : CARASSETINSURTBLMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : CARASSETINSURTBLSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$CARASSETINSURTBLOrderByWithAggregationInputToJson(
    CARASSETINSURTBLOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('GUARANTEE', _$SortOrderEnumMap[instance.guarantee]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

CARASSETINSURTBLScalarWhereWithAggregatesInput
    _$CARASSETINSURTBLScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        CARASSETINSURTBLScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              CARASSETINSURTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              CARASSETINSURTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              CARASSETINSURTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          seq: json['SEQ'] == null
              ? null
              : BigIntWithAggregatesFilter.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          mseq: json['MSEQ'] == null
              ? null
              : BigIntWithAggregatesFilter.fromJson(
                  json['MSEQ'] as Map<String, dynamic>),
          guarantee: json['GUARANTEE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['GUARANTEE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$CARASSETINSURTBLScalarWhereWithAggregatesInputToJson(
    CARASSETINSURTBLScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('GUARANTEE', instance.guarantee?.toJson());
  return val;
}

CARASSETTBLWhereInput _$CARASSETTBLWhereInputFromJson(
        Map<String, dynamic> json) =>
    CARASSETTBLWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map(
          (e) => CARASSETTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map(
          (e) => CARASSETTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map(
          (e) => CARASSETTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      seq: json['SEQ'] == null
          ? null
          : BigIntFilter.fromJson(json['SEQ'] as Map<String, dynamic>),
      assetNo: json['ASSET_NO'] == null
          ? null
          : StringFilter.fromJson(json['ASSET_NO'] as Map<String, dynamic>),
      modelNo: json['MODEL_NO'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['MODEL_NO'] as Map<String, dynamic>),
      carNo: json['CAR_NO'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['CAR_NO'] as Map<String, dynamic>),
      owner: json['OWNER'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['OWNER'] as Map<String, dynamic>),
      ownerType: json['OWNER_TYPE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['OWNER_TYPE'] as Map<String, dynamic>),
      amount: json['AMOUNT'] == null
          ? null
          : IntNullableFilter.fromJson(json['AMOUNT'] as Map<String, dynamic>),
      buyDate: json['BUY_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['BUY_DATE'] as Map<String, dynamic>),
      seller: json['SELLER'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['SELLER'] as Map<String, dynamic>),
      remarks: json['REMARKS'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['REMARKS'] as Map<String, dynamic>),
      mngrNm: json['MNGR_NM'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['MNGR_NM'] as Map<String, dynamic>),
      fuel: json['FUEL'] == null
          ? null
          : StringNullableFilter.fromJson(json['FUEL'] as Map<String, dynamic>),
      manuDt: json['MANU_DT'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['MANU_DT'] as Map<String, dynamic>),
      effic: json['EFFIC'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EFFIC'] as Map<String, dynamic>),
      insur: json['INSUR'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['INSUR'] as Map<String, dynamic>),
      insurMngr: json['INSUR_MNGR'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['INSUR_MNGR'] as Map<String, dynamic>),
      emgTel: json['EMG_TEL'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EMG_TEL'] as Map<String, dynamic>),
      storeNm: json['STORE_NM'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['STORE_NM'] as Map<String, dynamic>),
      storeTel: json['STORE_TEL'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['STORE_TEL'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : StringFilter.fromJson(json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringFilter.fromJson(json['DEL_YN'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : DateTimeNullableFilter.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$CARASSETTBLWhereInputToJson(
    CARASSETTBLWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('MODEL_NO', instance.modelNo?.toJson());
  writeNotNull('CAR_NO', instance.carNo?.toJson());
  writeNotNull('OWNER', instance.owner?.toJson());
  writeNotNull('OWNER_TYPE', instance.ownerType?.toJson());
  writeNotNull('AMOUNT', instance.amount?.toJson());
  writeNotNull('BUY_DATE', instance.buyDate?.toJson());
  writeNotNull('SELLER', instance.seller?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('MNGR_NM', instance.mngrNm?.toJson());
  writeNotNull('FUEL', instance.fuel?.toJson());
  writeNotNull('MANU_DT', instance.manuDt?.toJson());
  writeNotNull('EFFIC', instance.effic?.toJson());
  writeNotNull('INSUR', instance.insur?.toJson());
  writeNotNull('INSUR_MNGR', instance.insurMngr?.toJson());
  writeNotNull('EMG_TEL', instance.emgTel?.toJson());
  writeNotNull('STORE_NM', instance.storeNm?.toJson());
  writeNotNull('STORE_TEL', instance.storeTel?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

CARASSETTBLOrderByWithRelationInput
    _$CARASSETTBLOrderByWithRelationInputFromJson(Map<String, dynamic> json) =>
        CARASSETTBLOrderByWithRelationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          assetNo: $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_NO']),
          modelNo: $enumDecodeNullable(_$SortOrderEnumMap, json['MODEL_NO']),
          carNo: $enumDecodeNullable(_$SortOrderEnumMap, json['CAR_NO']),
          owner: $enumDecodeNullable(_$SortOrderEnumMap, json['OWNER']),
          ownerType:
              $enumDecodeNullable(_$SortOrderEnumMap, json['OWNER_TYPE']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
          buyDate: $enumDecodeNullable(_$SortOrderEnumMap, json['BUY_DATE']),
          seller: $enumDecodeNullable(_$SortOrderEnumMap, json['SELLER']),
          remarks: $enumDecodeNullable(_$SortOrderEnumMap, json['REMARKS']),
          mngrNm: $enumDecodeNullable(_$SortOrderEnumMap, json['MNGR_NM']),
          fuel: $enumDecodeNullable(_$SortOrderEnumMap, json['FUEL']),
          manuDt: $enumDecodeNullable(_$SortOrderEnumMap, json['MANU_DT']),
          effic: $enumDecodeNullable(_$SortOrderEnumMap, json['EFFIC']),
          insur: $enumDecodeNullable(_$SortOrderEnumMap, json['INSUR']),
          insurMngr:
              $enumDecodeNullable(_$SortOrderEnumMap, json['INSUR_MNGR']),
          emgTel: $enumDecodeNullable(_$SortOrderEnumMap, json['EMG_TEL']),
          storeNm: $enumDecodeNullable(_$SortOrderEnumMap, json['STORE_NM']),
          storeTel: $enumDecodeNullable(_$SortOrderEnumMap, json['STORE_TEL']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
        );

Map<String, dynamic> _$CARASSETTBLOrderByWithRelationInputToJson(
    CARASSETTBLOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ASSET_NO', _$SortOrderEnumMap[instance.assetNo]);
  writeNotNull('MODEL_NO', _$SortOrderEnumMap[instance.modelNo]);
  writeNotNull('CAR_NO', _$SortOrderEnumMap[instance.carNo]);
  writeNotNull('OWNER', _$SortOrderEnumMap[instance.owner]);
  writeNotNull('OWNER_TYPE', _$SortOrderEnumMap[instance.ownerType]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  writeNotNull('BUY_DATE', _$SortOrderEnumMap[instance.buyDate]);
  writeNotNull('SELLER', _$SortOrderEnumMap[instance.seller]);
  writeNotNull('REMARKS', _$SortOrderEnumMap[instance.remarks]);
  writeNotNull('MNGR_NM', _$SortOrderEnumMap[instance.mngrNm]);
  writeNotNull('FUEL', _$SortOrderEnumMap[instance.fuel]);
  writeNotNull('MANU_DT', _$SortOrderEnumMap[instance.manuDt]);
  writeNotNull('EFFIC', _$SortOrderEnumMap[instance.effic]);
  writeNotNull('INSUR', _$SortOrderEnumMap[instance.insur]);
  writeNotNull('INSUR_MNGR', _$SortOrderEnumMap[instance.insurMngr]);
  writeNotNull('EMG_TEL', _$SortOrderEnumMap[instance.emgTel]);
  writeNotNull('STORE_NM', _$SortOrderEnumMap[instance.storeNm]);
  writeNotNull('STORE_TEL', _$SortOrderEnumMap[instance.storeTel]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  return val;
}

CARASSETTBLWhereUniqueInput _$CARASSETTBLWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    CARASSETTBLWhereUniqueInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
    );

Map<String, dynamic> _$CARASSETTBLWhereUniqueInputToJson(
    CARASSETTBLWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  return val;
}

CARASSETTBLOrderByWithAggregationInput
    _$CARASSETTBLOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        CARASSETTBLOrderByWithAggregationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          assetNo: $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_NO']),
          modelNo: $enumDecodeNullable(_$SortOrderEnumMap, json['MODEL_NO']),
          carNo: $enumDecodeNullable(_$SortOrderEnumMap, json['CAR_NO']),
          owner: $enumDecodeNullable(_$SortOrderEnumMap, json['OWNER']),
          ownerType:
              $enumDecodeNullable(_$SortOrderEnumMap, json['OWNER_TYPE']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
          buyDate: $enumDecodeNullable(_$SortOrderEnumMap, json['BUY_DATE']),
          seller: $enumDecodeNullable(_$SortOrderEnumMap, json['SELLER']),
          remarks: $enumDecodeNullable(_$SortOrderEnumMap, json['REMARKS']),
          mngrNm: $enumDecodeNullable(_$SortOrderEnumMap, json['MNGR_NM']),
          fuel: $enumDecodeNullable(_$SortOrderEnumMap, json['FUEL']),
          manuDt: $enumDecodeNullable(_$SortOrderEnumMap, json['MANU_DT']),
          effic: $enumDecodeNullable(_$SortOrderEnumMap, json['EFFIC']),
          insur: $enumDecodeNullable(_$SortOrderEnumMap, json['INSUR']),
          insurMngr:
              $enumDecodeNullable(_$SortOrderEnumMap, json['INSUR_MNGR']),
          emgTel: $enumDecodeNullable(_$SortOrderEnumMap, json['EMG_TEL']),
          storeNm: $enumDecodeNullable(_$SortOrderEnumMap, json['STORE_NM']),
          storeTel: $enumDecodeNullable(_$SortOrderEnumMap, json['STORE_TEL']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          $count: json['_count'] == null
              ? null
              : CARASSETTBLCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : CARASSETTBLAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : CARASSETTBLMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : CARASSETTBLMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : CARASSETTBLSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$CARASSETTBLOrderByWithAggregationInputToJson(
    CARASSETTBLOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ASSET_NO', _$SortOrderEnumMap[instance.assetNo]);
  writeNotNull('MODEL_NO', _$SortOrderEnumMap[instance.modelNo]);
  writeNotNull('CAR_NO', _$SortOrderEnumMap[instance.carNo]);
  writeNotNull('OWNER', _$SortOrderEnumMap[instance.owner]);
  writeNotNull('OWNER_TYPE', _$SortOrderEnumMap[instance.ownerType]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  writeNotNull('BUY_DATE', _$SortOrderEnumMap[instance.buyDate]);
  writeNotNull('SELLER', _$SortOrderEnumMap[instance.seller]);
  writeNotNull('REMARKS', _$SortOrderEnumMap[instance.remarks]);
  writeNotNull('MNGR_NM', _$SortOrderEnumMap[instance.mngrNm]);
  writeNotNull('FUEL', _$SortOrderEnumMap[instance.fuel]);
  writeNotNull('MANU_DT', _$SortOrderEnumMap[instance.manuDt]);
  writeNotNull('EFFIC', _$SortOrderEnumMap[instance.effic]);
  writeNotNull('INSUR', _$SortOrderEnumMap[instance.insur]);
  writeNotNull('INSUR_MNGR', _$SortOrderEnumMap[instance.insurMngr]);
  writeNotNull('EMG_TEL', _$SortOrderEnumMap[instance.emgTel]);
  writeNotNull('STORE_NM', _$SortOrderEnumMap[instance.storeNm]);
  writeNotNull('STORE_TEL', _$SortOrderEnumMap[instance.storeTel]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

CARASSETTBLScalarWhereWithAggregatesInput
    _$CARASSETTBLScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        CARASSETTBLScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              CARASSETTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              CARASSETTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              CARASSETTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          seq: json['SEQ'] == null
              ? null
              : BigIntWithAggregatesFilter.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          assetNo: json['ASSET_NO'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['ASSET_NO'] as Map<String, dynamic>),
          modelNo: json['MODEL_NO'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['MODEL_NO'] as Map<String, dynamic>),
          carNo: json['CAR_NO'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['CAR_NO'] as Map<String, dynamic>),
          owner: json['OWNER'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['OWNER'] as Map<String, dynamic>),
          ownerType: json['OWNER_TYPE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['OWNER_TYPE'] as Map<String, dynamic>),
          amount: json['AMOUNT'] == null
              ? null
              : IntNullableWithAggregatesFilter.fromJson(
                  json['AMOUNT'] as Map<String, dynamic>),
          buyDate: json['BUY_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['BUY_DATE'] as Map<String, dynamic>),
          seller: json['SELLER'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['SELLER'] as Map<String, dynamic>),
          remarks: json['REMARKS'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['REMARKS'] as Map<String, dynamic>),
          mngrNm: json['MNGR_NM'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['MNGR_NM'] as Map<String, dynamic>),
          fuel: json['FUEL'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['FUEL'] as Map<String, dynamic>),
          manuDt: json['MANU_DT'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['MANU_DT'] as Map<String, dynamic>),
          effic: json['EFFIC'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EFFIC'] as Map<String, dynamic>),
          insur: json['INSUR'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['INSUR'] as Map<String, dynamic>),
          insurMngr: json['INSUR_MNGR'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['INSUR_MNGR'] as Map<String, dynamic>),
          emgTel: json['EMG_TEL'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EMG_TEL'] as Map<String, dynamic>),
          storeNm: json['STORE_NM'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['STORE_NM'] as Map<String, dynamic>),
          storeTel: json['STORE_TEL'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['STORE_TEL'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : DateTimeNullableWithAggregatesFilter.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$CARASSETTBLScalarWhereWithAggregatesInputToJson(
    CARASSETTBLScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('MODEL_NO', instance.modelNo?.toJson());
  writeNotNull('CAR_NO', instance.carNo?.toJson());
  writeNotNull('OWNER', instance.owner?.toJson());
  writeNotNull('OWNER_TYPE', instance.ownerType?.toJson());
  writeNotNull('AMOUNT', instance.amount?.toJson());
  writeNotNull('BUY_DATE', instance.buyDate?.toJson());
  writeNotNull('SELLER', instance.seller?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('MNGR_NM', instance.mngrNm?.toJson());
  writeNotNull('FUEL', instance.fuel?.toJson());
  writeNotNull('MANU_DT', instance.manuDt?.toJson());
  writeNotNull('EFFIC', instance.effic?.toJson());
  writeNotNull('INSUR', instance.insur?.toJson());
  writeNotNull('INSUR_MNGR', instance.insurMngr?.toJson());
  writeNotNull('EMG_TEL', instance.emgTel?.toJson());
  writeNotNull('STORE_NM', instance.storeNm?.toJson());
  writeNotNull('STORE_TEL', instance.storeTel?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

CARCHARGETBLWhereInput _$CARCHARGETBLWhereInputFromJson(
        Map<String, dynamic> json) =>
    CARCHARGETBLWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map(
          (e) => CARCHARGETBLWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map(
          (e) => CARCHARGETBLWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map(
          (e) => CARCHARGETBLWhereInput.fromJson(e as Map<String, dynamic>)),
      seq: json['SEQ'] == null
          ? null
          : BigIntFilter.fromJson(json['SEQ'] as Map<String, dynamic>),
      item: json['ITEM'] == null
          ? null
          : StringFilter.fromJson(json['ITEM'] as Map<String, dynamic>),
      charge: json['CHARGE'] == null
          ? null
          : BigIntFilter.fromJson(json['CHARGE'] as Map<String, dynamic>),
      writerId: json['WRITER_ID'] == null
          ? null
          : StringFilter.fromJson(json['WRITER_ID'] as Map<String, dynamic>),
      memo: json['MEMO'] == null
          ? null
          : StringFilter.fromJson(json['MEMO'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$CARCHARGETBLWhereInputToJson(
    CARCHARGETBLWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ITEM', instance.item?.toJson());
  writeNotNull('CHARGE', instance.charge?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('MEMO', instance.memo?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

CARCHARGETBLOrderByWithRelationInput
    _$CARCHARGETBLOrderByWithRelationInputFromJson(Map<String, dynamic> json) =>
        CARCHARGETBLOrderByWithRelationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          item: $enumDecodeNullable(_$SortOrderEnumMap, json['ITEM']),
          charge: $enumDecodeNullable(_$SortOrderEnumMap, json['CHARGE']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          memo: $enumDecodeNullable(_$SortOrderEnumMap, json['MEMO']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
        );

Map<String, dynamic> _$CARCHARGETBLOrderByWithRelationInputToJson(
    CARCHARGETBLOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ITEM', _$SortOrderEnumMap[instance.item]);
  writeNotNull('CHARGE', _$SortOrderEnumMap[instance.charge]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('MEMO', _$SortOrderEnumMap[instance.memo]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  return val;
}

CARCHARGETBLWhereUniqueInput _$CARCHARGETBLWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    CARCHARGETBLWhereUniqueInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
    );

Map<String, dynamic> _$CARCHARGETBLWhereUniqueInputToJson(
    CARCHARGETBLWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  return val;
}

CARCHARGETBLOrderByWithAggregationInput
    _$CARCHARGETBLOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        CARCHARGETBLOrderByWithAggregationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          item: $enumDecodeNullable(_$SortOrderEnumMap, json['ITEM']),
          charge: $enumDecodeNullable(_$SortOrderEnumMap, json['CHARGE']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          memo: $enumDecodeNullable(_$SortOrderEnumMap, json['MEMO']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          $count: json['_count'] == null
              ? null
              : CARCHARGETBLCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : CARCHARGETBLAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : CARCHARGETBLMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : CARCHARGETBLMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : CARCHARGETBLSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$CARCHARGETBLOrderByWithAggregationInputToJson(
    CARCHARGETBLOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ITEM', _$SortOrderEnumMap[instance.item]);
  writeNotNull('CHARGE', _$SortOrderEnumMap[instance.charge]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('MEMO', _$SortOrderEnumMap[instance.memo]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

CARCHARGETBLScalarWhereWithAggregatesInput
    _$CARCHARGETBLScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        CARCHARGETBLScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              CARCHARGETBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              CARCHARGETBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              CARCHARGETBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          seq: json['SEQ'] == null
              ? null
              : BigIntWithAggregatesFilter.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          item: json['ITEM'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['ITEM'] as Map<String, dynamic>),
          charge: json['CHARGE'] == null
              ? null
              : BigIntWithAggregatesFilter.fromJson(
                  json['CHARGE'] as Map<String, dynamic>),
          writerId: json['WRITER_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['WRITER_ID'] as Map<String, dynamic>),
          memo: json['MEMO'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['MEMO'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$CARCHARGETBLScalarWhereWithAggregatesInputToJson(
    CARCHARGETBLScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ITEM', instance.item?.toJson());
  writeNotNull('CHARGE', instance.charge?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('MEMO', instance.memo?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

CARINFOTBLWhereInput _$CARINFOTBLWhereInputFromJson(
        Map<String, dynamic> json) =>
    CARINFOTBLWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map(
          (e) => CARINFOTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map(
          (e) => CARINFOTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map(
          (e) => CARINFOTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      sort: json['SORT'] == null
          ? null
          : BigIntFilter.fromJson(json['SORT'] as Map<String, dynamic>),
      carManageNo: json['CAR_MANAGE_NO'] == null
          ? null
          : StringFilter.fromJson(
              json['CAR_MANAGE_NO'] as Map<String, dynamic>),
      model: json['MODEL'] == null
          ? null
          : StringFilter.fromJson(json['MODEL'] as Map<String, dynamic>),
      userId: json['USER_ID'] == null
          ? null
          : StringFilter.fromJson(json['USER_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      disusedYn: json['DISUSED_YN'] == null
          ? null
          : StringFilter.fromJson(json['DISUSED_YN'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$CARINFOTBLWhereInputToJson(
    CARINFOTBLWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('CAR_MANAGE_NO', instance.carManageNo?.toJson());
  writeNotNull('MODEL', instance.model?.toJson());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('DISUSED_YN', instance.disusedYn?.toJson());
  return val;
}

CARINFOTBLOrderByWithRelationInput _$CARINFOTBLOrderByWithRelationInputFromJson(
        Map<String, dynamic> json) =>
    CARINFOTBLOrderByWithRelationInput(
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
      carManageNo:
          $enumDecodeNullable(_$SortOrderEnumMap, json['CAR_MANAGE_NO']),
      model: $enumDecodeNullable(_$SortOrderEnumMap, json['MODEL']),
      userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      disusedYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DISUSED_YN']),
    );

Map<String, dynamic> _$CARINFOTBLOrderByWithRelationInputToJson(
    CARINFOTBLOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('CAR_MANAGE_NO', _$SortOrderEnumMap[instance.carManageNo]);
  writeNotNull('MODEL', _$SortOrderEnumMap[instance.model]);
  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('DISUSED_YN', _$SortOrderEnumMap[instance.disusedYn]);
  return val;
}

CARINFOTBLWhereUniqueInput _$CARINFOTBLWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    CARINFOTBLWhereUniqueInput(
      sort: json['SORT'] == null ? null : BigInt.parse(json['SORT'] as String),
    );

Map<String, dynamic> _$CARINFOTBLWhereUniqueInputToJson(
    CARINFOTBLWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SORT', instance.sort?.toString());
  return val;
}

CARINFOTBLOrderByWithAggregationInput
    _$CARINFOTBLOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        CARINFOTBLOrderByWithAggregationInput(
          sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
          carManageNo:
              $enumDecodeNullable(_$SortOrderEnumMap, json['CAR_MANAGE_NO']),
          model: $enumDecodeNullable(_$SortOrderEnumMap, json['MODEL']),
          userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          disusedYn:
              $enumDecodeNullable(_$SortOrderEnumMap, json['DISUSED_YN']),
          $count: json['_count'] == null
              ? null
              : CARINFOTBLCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : CARINFOTBLAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : CARINFOTBLMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : CARINFOTBLMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : CARINFOTBLSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$CARINFOTBLOrderByWithAggregationInputToJson(
    CARINFOTBLOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('CAR_MANAGE_NO', _$SortOrderEnumMap[instance.carManageNo]);
  writeNotNull('MODEL', _$SortOrderEnumMap[instance.model]);
  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('DISUSED_YN', _$SortOrderEnumMap[instance.disusedYn]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

CARINFOTBLScalarWhereWithAggregatesInput
    _$CARINFOTBLScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        CARINFOTBLScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              CARINFOTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              CARINFOTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              CARINFOTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          sort: json['SORT'] == null
              ? null
              : BigIntWithAggregatesFilter.fromJson(
                  json['SORT'] as Map<String, dynamic>),
          carManageNo: json['CAR_MANAGE_NO'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['CAR_MANAGE_NO'] as Map<String, dynamic>),
          model: json['MODEL'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['MODEL'] as Map<String, dynamic>),
          userId: json['USER_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['USER_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          disusedYn: json['DISUSED_YN'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['DISUSED_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$CARINFOTBLScalarWhereWithAggregatesInputToJson(
    CARINFOTBLScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('CAR_MANAGE_NO', instance.carManageNo?.toJson());
  writeNotNull('MODEL', instance.model?.toJson());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('DISUSED_YN', instance.disusedYn?.toJson());
  return val;
}

CARMILEAGETBLWhereInput _$CARMILEAGETBLWhereInputFromJson(
        Map<String, dynamic> json) =>
    CARMILEAGETBLWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map(
          (e) => CARMILEAGETBLWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map(
          (e) => CARMILEAGETBLWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map(
          (e) => CARMILEAGETBLWhereInput.fromJson(e as Map<String, dynamic>)),
      seq: json['SEQ'] == null
          ? null
          : BigIntFilter.fromJson(json['SEQ'] as Map<String, dynamic>),
      carManageNo: json['CAR_MANAGE_NO'] == null
          ? null
          : StringFilter.fromJson(
              json['CAR_MANAGE_NO'] as Map<String, dynamic>),
      forUse: json['FOR_USE'] == null
          ? null
          : StringFilter.fromJson(json['FOR_USE'] as Map<String, dynamic>),
      stPoint: json['ST_POINT'] == null
          ? null
          : StringFilter.fromJson(json['ST_POINT'] as Map<String, dynamic>),
      destination: json['DESTINATION'] == null
          ? null
          : StringFilter.fromJson(json['DESTINATION'] as Map<String, dynamic>),
      mileage: json['MILEAGE'] == null
          ? null
          : BigIntFilter.fromJson(json['MILEAGE'] as Map<String, dynamic>),
      totalMileage: json['TOTAL_MILEAGE'] == null
          ? null
          : BigIntFilter.fromJson(
              json['TOTAL_MILEAGE'] as Map<String, dynamic>),
      recordDate: json['RECORD_DATE'] == null
          ? null
          : StringFilter.fromJson(json['RECORD_DATE'] as Map<String, dynamic>),
      writerId: json['WRITER_ID'] == null
          ? null
          : StringFilter.fromJson(json['WRITER_ID'] as Map<String, dynamic>),
      editorId: json['EDITOR_ID'] == null
          ? null
          : StringFilter.fromJson(json['EDITOR_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      apprYn: json['APPR_YN'] == null
          ? null
          : StringFilter.fromJson(json['APPR_YN'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$CARMILEAGETBLWhereInputToJson(
    CARMILEAGETBLWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('CAR_MANAGE_NO', instance.carManageNo?.toJson());
  writeNotNull('FOR_USE', instance.forUse?.toJson());
  writeNotNull('ST_POINT', instance.stPoint?.toJson());
  writeNotNull('DESTINATION', instance.destination?.toJson());
  writeNotNull('MILEAGE', instance.mileage?.toJson());
  writeNotNull('TOTAL_MILEAGE', instance.totalMileage?.toJson());
  writeNotNull('RECORD_DATE', instance.recordDate?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('EDITOR_ID', instance.editorId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('APPR_YN', instance.apprYn?.toJson());
  return val;
}

CARMILEAGETBLOrderByWithRelationInput
    _$CARMILEAGETBLOrderByWithRelationInputFromJson(
            Map<String, dynamic> json) =>
        CARMILEAGETBLOrderByWithRelationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          carManageNo:
              $enumDecodeNullable(_$SortOrderEnumMap, json['CAR_MANAGE_NO']),
          forUse: $enumDecodeNullable(_$SortOrderEnumMap, json['FOR_USE']),
          stPoint: $enumDecodeNullable(_$SortOrderEnumMap, json['ST_POINT']),
          destination:
              $enumDecodeNullable(_$SortOrderEnumMap, json['DESTINATION']),
          mileage: $enumDecodeNullable(_$SortOrderEnumMap, json['MILEAGE']),
          totalMileage:
              $enumDecodeNullable(_$SortOrderEnumMap, json['TOTAL_MILEAGE']),
          recordDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['RECORD_DATE']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          editorId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDITOR_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          apprYn: $enumDecodeNullable(_$SortOrderEnumMap, json['APPR_YN']),
        );

Map<String, dynamic> _$CARMILEAGETBLOrderByWithRelationInputToJson(
    CARMILEAGETBLOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('CAR_MANAGE_NO', _$SortOrderEnumMap[instance.carManageNo]);
  writeNotNull('FOR_USE', _$SortOrderEnumMap[instance.forUse]);
  writeNotNull('ST_POINT', _$SortOrderEnumMap[instance.stPoint]);
  writeNotNull('DESTINATION', _$SortOrderEnumMap[instance.destination]);
  writeNotNull('MILEAGE', _$SortOrderEnumMap[instance.mileage]);
  writeNotNull('TOTAL_MILEAGE', _$SortOrderEnumMap[instance.totalMileage]);
  writeNotNull('RECORD_DATE', _$SortOrderEnumMap[instance.recordDate]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('EDITOR_ID', _$SortOrderEnumMap[instance.editorId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('APPR_YN', _$SortOrderEnumMap[instance.apprYn]);
  return val;
}

CARMILEAGETBLWhereUniqueInput _$CARMILEAGETBLWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    CARMILEAGETBLWhereUniqueInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
    );

Map<String, dynamic> _$CARMILEAGETBLWhereUniqueInputToJson(
    CARMILEAGETBLWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  return val;
}

CARMILEAGETBLOrderByWithAggregationInput
    _$CARMILEAGETBLOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        CARMILEAGETBLOrderByWithAggregationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          carManageNo:
              $enumDecodeNullable(_$SortOrderEnumMap, json['CAR_MANAGE_NO']),
          forUse: $enumDecodeNullable(_$SortOrderEnumMap, json['FOR_USE']),
          stPoint: $enumDecodeNullable(_$SortOrderEnumMap, json['ST_POINT']),
          destination:
              $enumDecodeNullable(_$SortOrderEnumMap, json['DESTINATION']),
          mileage: $enumDecodeNullable(_$SortOrderEnumMap, json['MILEAGE']),
          totalMileage:
              $enumDecodeNullable(_$SortOrderEnumMap, json['TOTAL_MILEAGE']),
          recordDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['RECORD_DATE']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          editorId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDITOR_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          apprYn: $enumDecodeNullable(_$SortOrderEnumMap, json['APPR_YN']),
          $count: json['_count'] == null
              ? null
              : CARMILEAGETBLCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : CARMILEAGETBLAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : CARMILEAGETBLMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : CARMILEAGETBLMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : CARMILEAGETBLSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$CARMILEAGETBLOrderByWithAggregationInputToJson(
    CARMILEAGETBLOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('CAR_MANAGE_NO', _$SortOrderEnumMap[instance.carManageNo]);
  writeNotNull('FOR_USE', _$SortOrderEnumMap[instance.forUse]);
  writeNotNull('ST_POINT', _$SortOrderEnumMap[instance.stPoint]);
  writeNotNull('DESTINATION', _$SortOrderEnumMap[instance.destination]);
  writeNotNull('MILEAGE', _$SortOrderEnumMap[instance.mileage]);
  writeNotNull('TOTAL_MILEAGE', _$SortOrderEnumMap[instance.totalMileage]);
  writeNotNull('RECORD_DATE', _$SortOrderEnumMap[instance.recordDate]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('EDITOR_ID', _$SortOrderEnumMap[instance.editorId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('APPR_YN', _$SortOrderEnumMap[instance.apprYn]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

CARMILEAGETBLScalarWhereWithAggregatesInput
    _$CARMILEAGETBLScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        CARMILEAGETBLScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              CARMILEAGETBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              CARMILEAGETBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              CARMILEAGETBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          seq: json['SEQ'] == null
              ? null
              : BigIntWithAggregatesFilter.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          carManageNo: json['CAR_MANAGE_NO'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['CAR_MANAGE_NO'] as Map<String, dynamic>),
          forUse: json['FOR_USE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['FOR_USE'] as Map<String, dynamic>),
          stPoint: json['ST_POINT'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['ST_POINT'] as Map<String, dynamic>),
          destination: json['DESTINATION'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['DESTINATION'] as Map<String, dynamic>),
          mileage: json['MILEAGE'] == null
              ? null
              : BigIntWithAggregatesFilter.fromJson(
                  json['MILEAGE'] as Map<String, dynamic>),
          totalMileage: json['TOTAL_MILEAGE'] == null
              ? null
              : BigIntWithAggregatesFilter.fromJson(
                  json['TOTAL_MILEAGE'] as Map<String, dynamic>),
          recordDate: json['RECORD_DATE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['RECORD_DATE'] as Map<String, dynamic>),
          writerId: json['WRITER_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['WRITER_ID'] as Map<String, dynamic>),
          editorId: json['EDITOR_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['EDITOR_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          apprYn: json['APPR_YN'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['APPR_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$CARMILEAGETBLScalarWhereWithAggregatesInputToJson(
    CARMILEAGETBLScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('CAR_MANAGE_NO', instance.carManageNo?.toJson());
  writeNotNull('FOR_USE', instance.forUse?.toJson());
  writeNotNull('ST_POINT', instance.stPoint?.toJson());
  writeNotNull('DESTINATION', instance.destination?.toJson());
  writeNotNull('MILEAGE', instance.mileage?.toJson());
  writeNotNull('TOTAL_MILEAGE', instance.totalMileage?.toJson());
  writeNotNull('RECORD_DATE', instance.recordDate?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('EDITOR_ID', instance.editorId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('APPR_YN', instance.apprYn?.toJson());
  return val;
}

CARPARTREPLACETBLWhereInput _$CARPARTREPLACETBLWhereInputFromJson(
        Map<String, dynamic> json) =>
    CARPARTREPLACETBLWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map((e) =>
          CARPARTREPLACETBLWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map((e) =>
          CARPARTREPLACETBLWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
          CARPARTREPLACETBLWhereInput.fromJson(e as Map<String, dynamic>)),
      seq: json['SEQ'] == null
          ? null
          : BigIntFilter.fromJson(json['SEQ'] as Map<String, dynamic>),
      partNm: json['PART_NM'] == null
          ? null
          : StringFilter.fromJson(json['PART_NM'] as Map<String, dynamic>),
      replacePeriod: json['REPLACE_PERIOD'] == null
          ? null
          : BigIntFilter.fromJson(
              json['REPLACE_PERIOD'] as Map<String, dynamic>),
      reTotalMileage: json['RE_TOTAL_MILEAGE'] == null
          ? null
          : BigIntFilter.fromJson(
              json['RE_TOTAL_MILEAGE'] as Map<String, dynamic>),
      nowTotalMileage: json['NOW_TOTAL_MILEAGE'] == null
          ? null
          : BigIntFilter.fromJson(
              json['NOW_TOTAL_MILEAGE'] as Map<String, dynamic>),
      remainMileage: json['REMAIN_MILEAGE'] == null
          ? null
          : BigIntFilter.fromJson(
              json['REMAIN_MILEAGE'] as Map<String, dynamic>),
      replaceCount: json['REPLACE_COUNT'] == null
          ? null
          : BigIntFilter.fromJson(
              json['REPLACE_COUNT'] as Map<String, dynamic>),
      partReDate: json['PART_RE_DATE'] == null
          ? null
          : StringFilter.fromJson(json['PART_RE_DATE'] as Map<String, dynamic>),
      writerId: json['WRITER_ID'] == null
          ? null
          : StringFilter.fromJson(json['WRITER_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$CARPARTREPLACETBLWhereInputToJson(
    CARPARTREPLACETBLWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('PART_NM', instance.partNm?.toJson());
  writeNotNull('REPLACE_PERIOD', instance.replacePeriod?.toJson());
  writeNotNull('RE_TOTAL_MILEAGE', instance.reTotalMileage?.toJson());
  writeNotNull('NOW_TOTAL_MILEAGE', instance.nowTotalMileage?.toJson());
  writeNotNull('REMAIN_MILEAGE', instance.remainMileage?.toJson());
  writeNotNull('REPLACE_COUNT', instance.replaceCount?.toJson());
  writeNotNull('PART_RE_DATE', instance.partReDate?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

CARPARTREPLACETBLOrderByWithRelationInput
    _$CARPARTREPLACETBLOrderByWithRelationInputFromJson(
            Map<String, dynamic> json) =>
        CARPARTREPLACETBLOrderByWithRelationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          partNm: $enumDecodeNullable(_$SortOrderEnumMap, json['PART_NM']),
          replacePeriod:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPLACE_PERIOD']),
          reTotalMileage:
              $enumDecodeNullable(_$SortOrderEnumMap, json['RE_TOTAL_MILEAGE']),
          nowTotalMileage: $enumDecodeNullable(
              _$SortOrderEnumMap, json['NOW_TOTAL_MILEAGE']),
          remainMileage:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REMAIN_MILEAGE']),
          replaceCount:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPLACE_COUNT']),
          partReDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PART_RE_DATE']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
        );

Map<String, dynamic> _$CARPARTREPLACETBLOrderByWithRelationInputToJson(
    CARPARTREPLACETBLOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('PART_NM', _$SortOrderEnumMap[instance.partNm]);
  writeNotNull('REPLACE_PERIOD', _$SortOrderEnumMap[instance.replacePeriod]);
  writeNotNull('RE_TOTAL_MILEAGE', _$SortOrderEnumMap[instance.reTotalMileage]);
  writeNotNull(
      'NOW_TOTAL_MILEAGE', _$SortOrderEnumMap[instance.nowTotalMileage]);
  writeNotNull('REMAIN_MILEAGE', _$SortOrderEnumMap[instance.remainMileage]);
  writeNotNull('REPLACE_COUNT', _$SortOrderEnumMap[instance.replaceCount]);
  writeNotNull('PART_RE_DATE', _$SortOrderEnumMap[instance.partReDate]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  return val;
}

CARPARTREPLACETBLWhereUniqueInput _$CARPARTREPLACETBLWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    CARPARTREPLACETBLWhereUniqueInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
    );

Map<String, dynamic> _$CARPARTREPLACETBLWhereUniqueInputToJson(
    CARPARTREPLACETBLWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  return val;
}

CARPARTREPLACETBLOrderByWithAggregationInput
    _$CARPARTREPLACETBLOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        CARPARTREPLACETBLOrderByWithAggregationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          partNm: $enumDecodeNullable(_$SortOrderEnumMap, json['PART_NM']),
          replacePeriod:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPLACE_PERIOD']),
          reTotalMileage:
              $enumDecodeNullable(_$SortOrderEnumMap, json['RE_TOTAL_MILEAGE']),
          nowTotalMileage: $enumDecodeNullable(
              _$SortOrderEnumMap, json['NOW_TOTAL_MILEAGE']),
          remainMileage:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REMAIN_MILEAGE']),
          replaceCount:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPLACE_COUNT']),
          partReDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PART_RE_DATE']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          $count: json['_count'] == null
              ? null
              : CARPARTREPLACETBLCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : CARPARTREPLACETBLAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : CARPARTREPLACETBLMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : CARPARTREPLACETBLMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : CARPARTREPLACETBLSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$CARPARTREPLACETBLOrderByWithAggregationInputToJson(
    CARPARTREPLACETBLOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('PART_NM', _$SortOrderEnumMap[instance.partNm]);
  writeNotNull('REPLACE_PERIOD', _$SortOrderEnumMap[instance.replacePeriod]);
  writeNotNull('RE_TOTAL_MILEAGE', _$SortOrderEnumMap[instance.reTotalMileage]);
  writeNotNull(
      'NOW_TOTAL_MILEAGE', _$SortOrderEnumMap[instance.nowTotalMileage]);
  writeNotNull('REMAIN_MILEAGE', _$SortOrderEnumMap[instance.remainMileage]);
  writeNotNull('REPLACE_COUNT', _$SortOrderEnumMap[instance.replaceCount]);
  writeNotNull('PART_RE_DATE', _$SortOrderEnumMap[instance.partReDate]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

CARPARTREPLACETBLScalarWhereWithAggregatesInput
    _$CARPARTREPLACETBLScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        CARPARTREPLACETBLScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              CARPARTREPLACETBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              CARPARTREPLACETBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              CARPARTREPLACETBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          seq: json['SEQ'] == null
              ? null
              : BigIntWithAggregatesFilter.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          partNm: json['PART_NM'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['PART_NM'] as Map<String, dynamic>),
          replacePeriod: json['REPLACE_PERIOD'] == null
              ? null
              : BigIntWithAggregatesFilter.fromJson(
                  json['REPLACE_PERIOD'] as Map<String, dynamic>),
          reTotalMileage: json['RE_TOTAL_MILEAGE'] == null
              ? null
              : BigIntWithAggregatesFilter.fromJson(
                  json['RE_TOTAL_MILEAGE'] as Map<String, dynamic>),
          nowTotalMileage: json['NOW_TOTAL_MILEAGE'] == null
              ? null
              : BigIntWithAggregatesFilter.fromJson(
                  json['NOW_TOTAL_MILEAGE'] as Map<String, dynamic>),
          remainMileage: json['REMAIN_MILEAGE'] == null
              ? null
              : BigIntWithAggregatesFilter.fromJson(
                  json['REMAIN_MILEAGE'] as Map<String, dynamic>),
          replaceCount: json['REPLACE_COUNT'] == null
              ? null
              : BigIntWithAggregatesFilter.fromJson(
                  json['REPLACE_COUNT'] as Map<String, dynamic>),
          partReDate: json['PART_RE_DATE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['PART_RE_DATE'] as Map<String, dynamic>),
          writerId: json['WRITER_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['WRITER_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$CARPARTREPLACETBLScalarWhereWithAggregatesInputToJson(
    CARPARTREPLACETBLScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('PART_NM', instance.partNm?.toJson());
  writeNotNull('REPLACE_PERIOD', instance.replacePeriod?.toJson());
  writeNotNull('RE_TOTAL_MILEAGE', instance.reTotalMileage?.toJson());
  writeNotNull('NOW_TOTAL_MILEAGE', instance.nowTotalMileage?.toJson());
  writeNotNull('REMAIN_MILEAGE', instance.remainMileage?.toJson());
  writeNotNull('REPLACE_COUNT', instance.replaceCount?.toJson());
  writeNotNull('PART_RE_DATE', instance.partReDate?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

CARREPAIRLOGWhereInput _$CARREPAIRLOGWhereInputFromJson(
        Map<String, dynamic> json) =>
    CARREPAIRLOGWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map(
          (e) => CARREPAIRLOGWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map(
          (e) => CARREPAIRLOGWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map(
          (e) => CARREPAIRLOGWhereInput.fromJson(e as Map<String, dynamic>)),
      seq: json['SEQ'] == null
          ? null
          : BigIntFilter.fromJson(json['SEQ'] as Map<String, dynamic>),
      mseq: json['MSEQ'] == null
          ? null
          : BigIntNullableFilter.fromJson(json['MSEQ'] as Map<String, dynamic>),
      assetNo: json['ASSET_NO'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['ASSET_NO'] as Map<String, dynamic>),
      repairDe: json['REPAIR_DE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['REPAIR_DE'] as Map<String, dynamic>),
      repairAmount: json['REPAIR_AMOUNT'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['REPAIR_AMOUNT'] as Map<String, dynamic>),
      repairStore: json['REPAIR_STORE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['REPAIR_STORE'] as Map<String, dynamic>),
      repairLog: json['REPAIR_LOG'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['REPAIR_LOG'] as Map<String, dynamic>),
      repairOwner: json['REPAIR_OWNER'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['REPAIR_OWNER'] as Map<String, dynamic>),
      fileTp: json['FILE_TP'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['FILE_TP'] as Map<String, dynamic>),
      flpth: json['FLPTH'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['FLPTH'] as Map<String, dynamic>),
      orginalFileNm: json['ORGINAL_FILE_NM'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['ORGINAL_FILE_NM'] as Map<String, dynamic>),
      streFileNm: json['STRE_FILE_NM'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['STRE_FILE_NM'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$CARREPAIRLOGWhereInputToJson(
    CARREPAIRLOGWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('REPAIR_DE', instance.repairDe?.toJson());
  writeNotNull('REPAIR_AMOUNT', instance.repairAmount?.toJson());
  writeNotNull('REPAIR_STORE', instance.repairStore?.toJson());
  writeNotNull('REPAIR_LOG', instance.repairLog?.toJson());
  writeNotNull('REPAIR_OWNER', instance.repairOwner?.toJson());
  writeNotNull('FILE_TP', instance.fileTp?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm?.toJson());
  writeNotNull('STRE_FILE_NM', instance.streFileNm?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

CARREPAIRLOGOrderByWithRelationInput
    _$CARREPAIRLOGOrderByWithRelationInputFromJson(Map<String, dynamic> json) =>
        CARREPAIRLOGOrderByWithRelationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          assetNo: $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_NO']),
          repairDe: $enumDecodeNullable(_$SortOrderEnumMap, json['REPAIR_DE']),
          repairAmount:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPAIR_AMOUNT']),
          repairStore:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPAIR_STORE']),
          repairLog:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPAIR_LOG']),
          repairOwner:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPAIR_OWNER']),
          fileTp: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_TP']),
          flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
          orginalFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ORGINAL_FILE_NM']),
          streFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['STRE_FILE_NM']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$CARREPAIRLOGOrderByWithRelationInputToJson(
    CARREPAIRLOGOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('ASSET_NO', _$SortOrderEnumMap[instance.assetNo]);
  writeNotNull('REPAIR_DE', _$SortOrderEnumMap[instance.repairDe]);
  writeNotNull('REPAIR_AMOUNT', _$SortOrderEnumMap[instance.repairAmount]);
  writeNotNull('REPAIR_STORE', _$SortOrderEnumMap[instance.repairStore]);
  writeNotNull('REPAIR_LOG', _$SortOrderEnumMap[instance.repairLog]);
  writeNotNull('REPAIR_OWNER', _$SortOrderEnumMap[instance.repairOwner]);
  writeNotNull('FILE_TP', _$SortOrderEnumMap[instance.fileTp]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('ORGINAL_FILE_NM', _$SortOrderEnumMap[instance.orginalFileNm]);
  writeNotNull('STRE_FILE_NM', _$SortOrderEnumMap[instance.streFileNm]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

CARREPAIRLOGWhereUniqueInput _$CARREPAIRLOGWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    CARREPAIRLOGWhereUniqueInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
    );

Map<String, dynamic> _$CARREPAIRLOGWhereUniqueInputToJson(
    CARREPAIRLOGWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  return val;
}

CARREPAIRLOGOrderByWithAggregationInput
    _$CARREPAIRLOGOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        CARREPAIRLOGOrderByWithAggregationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          assetNo: $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_NO']),
          repairDe: $enumDecodeNullable(_$SortOrderEnumMap, json['REPAIR_DE']),
          repairAmount:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPAIR_AMOUNT']),
          repairStore:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPAIR_STORE']),
          repairLog:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPAIR_LOG']),
          repairOwner:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPAIR_OWNER']),
          fileTp: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_TP']),
          flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
          orginalFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ORGINAL_FILE_NM']),
          streFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['STRE_FILE_NM']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
          $count: json['_count'] == null
              ? null
              : CARREPAIRLOGCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : CARREPAIRLOGAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : CARREPAIRLOGMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : CARREPAIRLOGMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : CARREPAIRLOGSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$CARREPAIRLOGOrderByWithAggregationInputToJson(
    CARREPAIRLOGOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('ASSET_NO', _$SortOrderEnumMap[instance.assetNo]);
  writeNotNull('REPAIR_DE', _$SortOrderEnumMap[instance.repairDe]);
  writeNotNull('REPAIR_AMOUNT', _$SortOrderEnumMap[instance.repairAmount]);
  writeNotNull('REPAIR_STORE', _$SortOrderEnumMap[instance.repairStore]);
  writeNotNull('REPAIR_LOG', _$SortOrderEnumMap[instance.repairLog]);
  writeNotNull('REPAIR_OWNER', _$SortOrderEnumMap[instance.repairOwner]);
  writeNotNull('FILE_TP', _$SortOrderEnumMap[instance.fileTp]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('ORGINAL_FILE_NM', _$SortOrderEnumMap[instance.orginalFileNm]);
  writeNotNull('STRE_FILE_NM', _$SortOrderEnumMap[instance.streFileNm]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

CARREPAIRLOGScalarWhereWithAggregatesInput
    _$CARREPAIRLOGScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        CARREPAIRLOGScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              CARREPAIRLOGScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              CARREPAIRLOGScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              CARREPAIRLOGScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          seq: json['SEQ'] == null
              ? null
              : BigIntWithAggregatesFilter.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          mseq: json['MSEQ'] == null
              ? null
              : BigIntNullableWithAggregatesFilter.fromJson(
                  json['MSEQ'] as Map<String, dynamic>),
          assetNo: json['ASSET_NO'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['ASSET_NO'] as Map<String, dynamic>),
          repairDe: json['REPAIR_DE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['REPAIR_DE'] as Map<String, dynamic>),
          repairAmount: json['REPAIR_AMOUNT'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['REPAIR_AMOUNT'] as Map<String, dynamic>),
          repairStore: json['REPAIR_STORE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['REPAIR_STORE'] as Map<String, dynamic>),
          repairLog: json['REPAIR_LOG'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['REPAIR_LOG'] as Map<String, dynamic>),
          repairOwner: json['REPAIR_OWNER'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['REPAIR_OWNER'] as Map<String, dynamic>),
          fileTp: json['FILE_TP'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['FILE_TP'] as Map<String, dynamic>),
          flpth: json['FLPTH'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['FLPTH'] as Map<String, dynamic>),
          orginalFileNm: json['ORGINAL_FILE_NM'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['ORGINAL_FILE_NM'] as Map<String, dynamic>),
          streFileNm: json['STRE_FILE_NM'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['STRE_FILE_NM'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delId: json['DEL_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_ID'] as Map<String, dynamic>),
          delDate: json['DEL_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$CARREPAIRLOGScalarWhereWithAggregatesInputToJson(
    CARREPAIRLOGScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('REPAIR_DE', instance.repairDe?.toJson());
  writeNotNull('REPAIR_AMOUNT', instance.repairAmount?.toJson());
  writeNotNull('REPAIR_STORE', instance.repairStore?.toJson());
  writeNotNull('REPAIR_LOG', instance.repairLog?.toJson());
  writeNotNull('REPAIR_OWNER', instance.repairOwner?.toJson());
  writeNotNull('FILE_TP', instance.fileTp?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm?.toJson());
  writeNotNull('STRE_FILE_NM', instance.streFileNm?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

CARUSEMANAGETBLWhereInput _$CARUSEMANAGETBLWhereInputFromJson(
        Map<String, dynamic> json) =>
    CARUSEMANAGETBLWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map(
          (e) => CARUSEMANAGETBLWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map(
          (e) => CARUSEMANAGETBLWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map(
          (e) => CARUSEMANAGETBLWhereInput.fromJson(e as Map<String, dynamic>)),
      seq: json['SEQ'] == null
          ? null
          : BigIntFilter.fromJson(json['SEQ'] as Map<String, dynamic>),
      carNo: json['CAR_NO'] == null
          ? null
          : StringFilter.fromJson(json['CAR_NO'] as Map<String, dynamic>),
      carType: json['CAR_TYPE'] == null
          ? null
          : StringFilter.fromJson(json['CAR_TYPE'] as Map<String, dynamic>),
      destination: json['DESTINATION'] == null
          ? null
          : StringFilter.fromJson(json['DESTINATION'] as Map<String, dynamic>),
      purpose: json['PURPOSE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['PURPOSE'] as Map<String, dynamic>),
      users: json['USERS'] == null
          ? null
          : StringFilter.fromJson(json['USERS'] as Map<String, dynamic>),
      useStartDate: json['USE_START_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(
              json['USE_START_DATE'] as Map<String, dynamic>),
      useEndDate: json['USE_END_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(
              json['USE_END_DATE'] as Map<String, dynamic>),
      useBeforeDistance: json['USE_BEFORE_DISTANCE'] == null
          ? null
          : DecimalNullableFilter.fromJson(
              json['USE_BEFORE_DISTANCE'] as Map<String, dynamic>),
      useAfterDistance: json['USE_AFTER_DISTANCE'] == null
          ? null
          : DecimalNullableFilter.fromJson(
              json['USE_AFTER_DISTANCE'] as Map<String, dynamic>),
      remarks: json['REMARKS'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['REMARKS'] as Map<String, dynamic>),
      acceptYn: json['ACCEPT_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['ACCEPT_YN'] as Map<String, dynamic>),
      regUser: json['REG_USER'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['REG_USER'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      useStartHour: json['USE_START_HOUR'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['USE_START_HOUR'] as Map<String, dynamic>),
      useEndHour: json['USE_END_HOUR'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['USE_END_HOUR'] as Map<String, dynamic>),
      cardApply: json['CARD_APPLY'] == null
          ? null
          : StringFilter.fromJson(json['CARD_APPLY'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$CARUSEMANAGETBLWhereInputToJson(
    CARUSEMANAGETBLWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('CAR_NO', instance.carNo?.toJson());
  writeNotNull('CAR_TYPE', instance.carType?.toJson());
  writeNotNull('DESTINATION', instance.destination?.toJson());
  writeNotNull('PURPOSE', instance.purpose?.toJson());
  writeNotNull('USERS', instance.users?.toJson());
  writeNotNull('USE_START_DATE', instance.useStartDate?.toJson());
  writeNotNull('USE_END_DATE', instance.useEndDate?.toJson());
  writeNotNull('USE_BEFORE_DISTANCE', instance.useBeforeDistance?.toJson());
  writeNotNull('USE_AFTER_DISTANCE', instance.useAfterDistance?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('ACCEPT_YN', instance.acceptYn?.toJson());
  writeNotNull('REG_USER', instance.regUser?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('USE_START_HOUR', instance.useStartHour?.toJson());
  writeNotNull('USE_END_HOUR', instance.useEndHour?.toJson());
  writeNotNull('CARD_APPLY', instance.cardApply?.toJson());
  return val;
}

CARUSEMANAGETBLOrderByWithRelationInput
    _$CARUSEMANAGETBLOrderByWithRelationInputFromJson(
            Map<String, dynamic> json) =>
        CARUSEMANAGETBLOrderByWithRelationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          carNo: $enumDecodeNullable(_$SortOrderEnumMap, json['CAR_NO']),
          carType: $enumDecodeNullable(_$SortOrderEnumMap, json['CAR_TYPE']),
          destination:
              $enumDecodeNullable(_$SortOrderEnumMap, json['DESTINATION']),
          purpose: $enumDecodeNullable(_$SortOrderEnumMap, json['PURPOSE']),
          users: $enumDecodeNullable(_$SortOrderEnumMap, json['USERS']),
          useStartDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['USE_START_DATE']),
          useEndDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['USE_END_DATE']),
          useBeforeDistance: $enumDecodeNullable(
              _$SortOrderEnumMap, json['USE_BEFORE_DISTANCE']),
          useAfterDistance: $enumDecodeNullable(
              _$SortOrderEnumMap, json['USE_AFTER_DISTANCE']),
          remarks: $enumDecodeNullable(_$SortOrderEnumMap, json['REMARKS']),
          acceptYn: $enumDecodeNullable(_$SortOrderEnumMap, json['ACCEPT_YN']),
          regUser: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_USER']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          useStartHour:
              $enumDecodeNullable(_$SortOrderEnumMap, json['USE_START_HOUR']),
          useEndHour:
              $enumDecodeNullable(_$SortOrderEnumMap, json['USE_END_HOUR']),
          cardApply:
              $enumDecodeNullable(_$SortOrderEnumMap, json['CARD_APPLY']),
        );

Map<String, dynamic> _$CARUSEMANAGETBLOrderByWithRelationInputToJson(
    CARUSEMANAGETBLOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('CAR_NO', _$SortOrderEnumMap[instance.carNo]);
  writeNotNull('CAR_TYPE', _$SortOrderEnumMap[instance.carType]);
  writeNotNull('DESTINATION', _$SortOrderEnumMap[instance.destination]);
  writeNotNull('PURPOSE', _$SortOrderEnumMap[instance.purpose]);
  writeNotNull('USERS', _$SortOrderEnumMap[instance.users]);
  writeNotNull('USE_START_DATE', _$SortOrderEnumMap[instance.useStartDate]);
  writeNotNull('USE_END_DATE', _$SortOrderEnumMap[instance.useEndDate]);
  writeNotNull(
      'USE_BEFORE_DISTANCE', _$SortOrderEnumMap[instance.useBeforeDistance]);
  writeNotNull(
      'USE_AFTER_DISTANCE', _$SortOrderEnumMap[instance.useAfterDistance]);
  writeNotNull('REMARKS', _$SortOrderEnumMap[instance.remarks]);
  writeNotNull('ACCEPT_YN', _$SortOrderEnumMap[instance.acceptYn]);
  writeNotNull('REG_USER', _$SortOrderEnumMap[instance.regUser]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('USE_START_HOUR', _$SortOrderEnumMap[instance.useStartHour]);
  writeNotNull('USE_END_HOUR', _$SortOrderEnumMap[instance.useEndHour]);
  writeNotNull('CARD_APPLY', _$SortOrderEnumMap[instance.cardApply]);
  return val;
}

CARUSEMANAGETBLWhereUniqueInput _$CARUSEMANAGETBLWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    CARUSEMANAGETBLWhereUniqueInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
    );

Map<String, dynamic> _$CARUSEMANAGETBLWhereUniqueInputToJson(
    CARUSEMANAGETBLWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  return val;
}

CARUSEMANAGETBLOrderByWithAggregationInput
    _$CARUSEMANAGETBLOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        CARUSEMANAGETBLOrderByWithAggregationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          carNo: $enumDecodeNullable(_$SortOrderEnumMap, json['CAR_NO']),
          carType: $enumDecodeNullable(_$SortOrderEnumMap, json['CAR_TYPE']),
          destination:
              $enumDecodeNullable(_$SortOrderEnumMap, json['DESTINATION']),
          purpose: $enumDecodeNullable(_$SortOrderEnumMap, json['PURPOSE']),
          users: $enumDecodeNullable(_$SortOrderEnumMap, json['USERS']),
          useStartDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['USE_START_DATE']),
          useEndDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['USE_END_DATE']),
          useBeforeDistance: $enumDecodeNullable(
              _$SortOrderEnumMap, json['USE_BEFORE_DISTANCE']),
          useAfterDistance: $enumDecodeNullable(
              _$SortOrderEnumMap, json['USE_AFTER_DISTANCE']),
          remarks: $enumDecodeNullable(_$SortOrderEnumMap, json['REMARKS']),
          acceptYn: $enumDecodeNullable(_$SortOrderEnumMap, json['ACCEPT_YN']),
          regUser: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_USER']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          useStartHour:
              $enumDecodeNullable(_$SortOrderEnumMap, json['USE_START_HOUR']),
          useEndHour:
              $enumDecodeNullable(_$SortOrderEnumMap, json['USE_END_HOUR']),
          cardApply:
              $enumDecodeNullable(_$SortOrderEnumMap, json['CARD_APPLY']),
          $count: json['_count'] == null
              ? null
              : CARUSEMANAGETBLCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : CARUSEMANAGETBLAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : CARUSEMANAGETBLMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : CARUSEMANAGETBLMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : CARUSEMANAGETBLSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$CARUSEMANAGETBLOrderByWithAggregationInputToJson(
    CARUSEMANAGETBLOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('CAR_NO', _$SortOrderEnumMap[instance.carNo]);
  writeNotNull('CAR_TYPE', _$SortOrderEnumMap[instance.carType]);
  writeNotNull('DESTINATION', _$SortOrderEnumMap[instance.destination]);
  writeNotNull('PURPOSE', _$SortOrderEnumMap[instance.purpose]);
  writeNotNull('USERS', _$SortOrderEnumMap[instance.users]);
  writeNotNull('USE_START_DATE', _$SortOrderEnumMap[instance.useStartDate]);
  writeNotNull('USE_END_DATE', _$SortOrderEnumMap[instance.useEndDate]);
  writeNotNull(
      'USE_BEFORE_DISTANCE', _$SortOrderEnumMap[instance.useBeforeDistance]);
  writeNotNull(
      'USE_AFTER_DISTANCE', _$SortOrderEnumMap[instance.useAfterDistance]);
  writeNotNull('REMARKS', _$SortOrderEnumMap[instance.remarks]);
  writeNotNull('ACCEPT_YN', _$SortOrderEnumMap[instance.acceptYn]);
  writeNotNull('REG_USER', _$SortOrderEnumMap[instance.regUser]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('USE_START_HOUR', _$SortOrderEnumMap[instance.useStartHour]);
  writeNotNull('USE_END_HOUR', _$SortOrderEnumMap[instance.useEndHour]);
  writeNotNull('CARD_APPLY', _$SortOrderEnumMap[instance.cardApply]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

CARUSEMANAGETBLScalarWhereWithAggregatesInput
    _$CARUSEMANAGETBLScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        CARUSEMANAGETBLScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              CARUSEMANAGETBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              CARUSEMANAGETBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              CARUSEMANAGETBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          seq: json['SEQ'] == null
              ? null
              : BigIntWithAggregatesFilter.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          carNo: json['CAR_NO'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['CAR_NO'] as Map<String, dynamic>),
          carType: json['CAR_TYPE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['CAR_TYPE'] as Map<String, dynamic>),
          destination: json['DESTINATION'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['DESTINATION'] as Map<String, dynamic>),
          purpose: json['PURPOSE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['PURPOSE'] as Map<String, dynamic>),
          users: json['USERS'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['USERS'] as Map<String, dynamic>),
          useStartDate: json['USE_START_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['USE_START_DATE'] as Map<String, dynamic>),
          useEndDate: json['USE_END_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['USE_END_DATE'] as Map<String, dynamic>),
          useBeforeDistance: json['USE_BEFORE_DISTANCE'] == null
              ? null
              : DecimalNullableWithAggregatesFilter.fromJson(
                  json['USE_BEFORE_DISTANCE'] as Map<String, dynamic>),
          useAfterDistance: json['USE_AFTER_DISTANCE'] == null
              ? null
              : DecimalNullableWithAggregatesFilter.fromJson(
                  json['USE_AFTER_DISTANCE'] as Map<String, dynamic>),
          remarks: json['REMARKS'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['REMARKS'] as Map<String, dynamic>),
          acceptYn: json['ACCEPT_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['ACCEPT_YN'] as Map<String, dynamic>),
          regUser: json['REG_USER'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['REG_USER'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          useStartHour: json['USE_START_HOUR'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['USE_START_HOUR'] as Map<String, dynamic>),
          useEndHour: json['USE_END_HOUR'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['USE_END_HOUR'] as Map<String, dynamic>),
          cardApply: json['CARD_APPLY'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['CARD_APPLY'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$CARUSEMANAGETBLScalarWhereWithAggregatesInputToJson(
    CARUSEMANAGETBLScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('CAR_NO', instance.carNo?.toJson());
  writeNotNull('CAR_TYPE', instance.carType?.toJson());
  writeNotNull('DESTINATION', instance.destination?.toJson());
  writeNotNull('PURPOSE', instance.purpose?.toJson());
  writeNotNull('USERS', instance.users?.toJson());
  writeNotNull('USE_START_DATE', instance.useStartDate?.toJson());
  writeNotNull('USE_END_DATE', instance.useEndDate?.toJson());
  writeNotNull('USE_BEFORE_DISTANCE', instance.useBeforeDistance?.toJson());
  writeNotNull('USE_AFTER_DISTANCE', instance.useAfterDistance?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('ACCEPT_YN', instance.acceptYn?.toJson());
  writeNotNull('REG_USER', instance.regUser?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('USE_START_HOUR', instance.useStartHour?.toJson());
  writeNotNull('USE_END_HOUR', instance.useEndHour?.toJson());
  writeNotNull('CARD_APPLY', instance.cardApply?.toJson());
  return val;
}

HOLIDAYTBLWhereInput _$HOLIDAYTBLWhereInputFromJson(
        Map<String, dynamic> json) =>
    HOLIDAYTBLWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map(
          (e) => HOLIDAYTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map(
          (e) => HOLIDAYTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map(
          (e) => HOLIDAYTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      userId: json['USER_ID'] == null
          ? null
          : StringFilter.fromJson(json['USER_ID'] as Map<String, dynamic>),
      stdYear: json['STD_YEAR'] == null
          ? null
          : StringFilter.fromJson(json['STD_YEAR'] as Map<String, dynamic>),
      m1: json['M1'] == null
          ? null
          : DecimalNullableFilter.fromJson(json['M1'] as Map<String, dynamic>),
      m2: json['M2'] == null
          ? null
          : DecimalNullableFilter.fromJson(json['M2'] as Map<String, dynamic>),
      m3: json['M3'] == null
          ? null
          : DecimalNullableFilter.fromJson(json['M3'] as Map<String, dynamic>),
      m4: json['M4'] == null
          ? null
          : DecimalNullableFilter.fromJson(json['M4'] as Map<String, dynamic>),
      m5: json['M5'] == null
          ? null
          : DecimalNullableFilter.fromJson(json['M5'] as Map<String, dynamic>),
      m6: json['M6'] == null
          ? null
          : DecimalNullableFilter.fromJson(json['M6'] as Map<String, dynamic>),
      m7: json['M7'] == null
          ? null
          : DecimalNullableFilter.fromJson(json['M7'] as Map<String, dynamic>),
      m8: json['M8'] == null
          ? null
          : DecimalNullableFilter.fromJson(json['M8'] as Map<String, dynamic>),
      m9: json['M9'] == null
          ? null
          : DecimalNullableFilter.fromJson(json['M9'] as Map<String, dynamic>),
      m10: json['M10'] == null
          ? null
          : DecimalNullableFilter.fromJson(json['M10'] as Map<String, dynamic>),
      m11: json['M11'] == null
          ? null
          : DecimalNullableFilter.fromJson(json['M11'] as Map<String, dynamic>),
      m12: json['M12'] == null
          ? null
          : DecimalNullableFilter.fromJson(json['M12'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : StringFilter.fromJson(json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringFilter.fromJson(json['DEL_YN'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : DateTimeNullableFilter.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$HOLIDAYTBLWhereInputToJson(
    HOLIDAYTBLWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('STD_YEAR', instance.stdYear?.toJson());
  writeNotNull('M1', instance.m1?.toJson());
  writeNotNull('M2', instance.m2?.toJson());
  writeNotNull('M3', instance.m3?.toJson());
  writeNotNull('M4', instance.m4?.toJson());
  writeNotNull('M5', instance.m5?.toJson());
  writeNotNull('M6', instance.m6?.toJson());
  writeNotNull('M7', instance.m7?.toJson());
  writeNotNull('M8', instance.m8?.toJson());
  writeNotNull('M9', instance.m9?.toJson());
  writeNotNull('M10', instance.m10?.toJson());
  writeNotNull('M11', instance.m11?.toJson());
  writeNotNull('M12', instance.m12?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

HOLIDAYTBLOrderByWithRelationInput _$HOLIDAYTBLOrderByWithRelationInputFromJson(
        Map<String, dynamic> json) =>
    HOLIDAYTBLOrderByWithRelationInput(
      userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
      stdYear: $enumDecodeNullable(_$SortOrderEnumMap, json['STD_YEAR']),
      m1: $enumDecodeNullable(_$SortOrderEnumMap, json['M1']),
      m2: $enumDecodeNullable(_$SortOrderEnumMap, json['M2']),
      m3: $enumDecodeNullable(_$SortOrderEnumMap, json['M3']),
      m4: $enumDecodeNullable(_$SortOrderEnumMap, json['M4']),
      m5: $enumDecodeNullable(_$SortOrderEnumMap, json['M5']),
      m6: $enumDecodeNullable(_$SortOrderEnumMap, json['M6']),
      m7: $enumDecodeNullable(_$SortOrderEnumMap, json['M7']),
      m8: $enumDecodeNullable(_$SortOrderEnumMap, json['M8']),
      m9: $enumDecodeNullable(_$SortOrderEnumMap, json['M9']),
      m10: $enumDecodeNullable(_$SortOrderEnumMap, json['M10']),
      m11: $enumDecodeNullable(_$SortOrderEnumMap, json['M11']),
      m12: $enumDecodeNullable(_$SortOrderEnumMap, json['M12']),
      useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
      delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
    );

Map<String, dynamic> _$HOLIDAYTBLOrderByWithRelationInputToJson(
    HOLIDAYTBLOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('STD_YEAR', _$SortOrderEnumMap[instance.stdYear]);
  writeNotNull('M1', _$SortOrderEnumMap[instance.m1]);
  writeNotNull('M2', _$SortOrderEnumMap[instance.m2]);
  writeNotNull('M3', _$SortOrderEnumMap[instance.m3]);
  writeNotNull('M4', _$SortOrderEnumMap[instance.m4]);
  writeNotNull('M5', _$SortOrderEnumMap[instance.m5]);
  writeNotNull('M6', _$SortOrderEnumMap[instance.m6]);
  writeNotNull('M7', _$SortOrderEnumMap[instance.m7]);
  writeNotNull('M8', _$SortOrderEnumMap[instance.m8]);
  writeNotNull('M9', _$SortOrderEnumMap[instance.m9]);
  writeNotNull('M10', _$SortOrderEnumMap[instance.m10]);
  writeNotNull('M11', _$SortOrderEnumMap[instance.m11]);
  writeNotNull('M12', _$SortOrderEnumMap[instance.m12]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  return val;
}

HOLIDAYTBLWhereUniqueInput _$HOLIDAYTBLWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    HOLIDAYTBLWhereUniqueInput(
      userIdStdYear: json['USER_ID_STD_YEAR'] == null
          ? null
          : HOLIDAYTBLUSERIDSTDYEARCompoundUniqueInput.fromJson(
              json['USER_ID_STD_YEAR'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$HOLIDAYTBLWhereUniqueInputToJson(
    HOLIDAYTBLWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID_STD_YEAR', instance.userIdStdYear?.toJson());
  return val;
}

HOLIDAYTBLOrderByWithAggregationInput
    _$HOLIDAYTBLOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        HOLIDAYTBLOrderByWithAggregationInput(
          userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
          stdYear: $enumDecodeNullable(_$SortOrderEnumMap, json['STD_YEAR']),
          m1: $enumDecodeNullable(_$SortOrderEnumMap, json['M1']),
          m2: $enumDecodeNullable(_$SortOrderEnumMap, json['M2']),
          m3: $enumDecodeNullable(_$SortOrderEnumMap, json['M3']),
          m4: $enumDecodeNullable(_$SortOrderEnumMap, json['M4']),
          m5: $enumDecodeNullable(_$SortOrderEnumMap, json['M5']),
          m6: $enumDecodeNullable(_$SortOrderEnumMap, json['M6']),
          m7: $enumDecodeNullable(_$SortOrderEnumMap, json['M7']),
          m8: $enumDecodeNullable(_$SortOrderEnumMap, json['M8']),
          m9: $enumDecodeNullable(_$SortOrderEnumMap, json['M9']),
          m10: $enumDecodeNullable(_$SortOrderEnumMap, json['M10']),
          m11: $enumDecodeNullable(_$SortOrderEnumMap, json['M11']),
          m12: $enumDecodeNullable(_$SortOrderEnumMap, json['M12']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          $count: json['_count'] == null
              ? null
              : HOLIDAYTBLCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : HOLIDAYTBLAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : HOLIDAYTBLMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : HOLIDAYTBLMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : HOLIDAYTBLSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$HOLIDAYTBLOrderByWithAggregationInputToJson(
    HOLIDAYTBLOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('STD_YEAR', _$SortOrderEnumMap[instance.stdYear]);
  writeNotNull('M1', _$SortOrderEnumMap[instance.m1]);
  writeNotNull('M2', _$SortOrderEnumMap[instance.m2]);
  writeNotNull('M3', _$SortOrderEnumMap[instance.m3]);
  writeNotNull('M4', _$SortOrderEnumMap[instance.m4]);
  writeNotNull('M5', _$SortOrderEnumMap[instance.m5]);
  writeNotNull('M6', _$SortOrderEnumMap[instance.m6]);
  writeNotNull('M7', _$SortOrderEnumMap[instance.m7]);
  writeNotNull('M8', _$SortOrderEnumMap[instance.m8]);
  writeNotNull('M9', _$SortOrderEnumMap[instance.m9]);
  writeNotNull('M10', _$SortOrderEnumMap[instance.m10]);
  writeNotNull('M11', _$SortOrderEnumMap[instance.m11]);
  writeNotNull('M12', _$SortOrderEnumMap[instance.m12]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

HOLIDAYTBLScalarWhereWithAggregatesInput
    _$HOLIDAYTBLScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        HOLIDAYTBLScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              HOLIDAYTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              HOLIDAYTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              HOLIDAYTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          userId: json['USER_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['USER_ID'] as Map<String, dynamic>),
          stdYear: json['STD_YEAR'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['STD_YEAR'] as Map<String, dynamic>),
          m1: json['M1'] == null
              ? null
              : DecimalNullableWithAggregatesFilter.fromJson(
                  json['M1'] as Map<String, dynamic>),
          m2: json['M2'] == null
              ? null
              : DecimalNullableWithAggregatesFilter.fromJson(
                  json['M2'] as Map<String, dynamic>),
          m3: json['M3'] == null
              ? null
              : DecimalNullableWithAggregatesFilter.fromJson(
                  json['M3'] as Map<String, dynamic>),
          m4: json['M4'] == null
              ? null
              : DecimalNullableWithAggregatesFilter.fromJson(
                  json['M4'] as Map<String, dynamic>),
          m5: json['M5'] == null
              ? null
              : DecimalNullableWithAggregatesFilter.fromJson(
                  json['M5'] as Map<String, dynamic>),
          m6: json['M6'] == null
              ? null
              : DecimalNullableWithAggregatesFilter.fromJson(
                  json['M6'] as Map<String, dynamic>),
          m7: json['M7'] == null
              ? null
              : DecimalNullableWithAggregatesFilter.fromJson(
                  json['M7'] as Map<String, dynamic>),
          m8: json['M8'] == null
              ? null
              : DecimalNullableWithAggregatesFilter.fromJson(
                  json['M8'] as Map<String, dynamic>),
          m9: json['M9'] == null
              ? null
              : DecimalNullableWithAggregatesFilter.fromJson(
                  json['M9'] as Map<String, dynamic>),
          m10: json['M10'] == null
              ? null
              : DecimalNullableWithAggregatesFilter.fromJson(
                  json['M10'] as Map<String, dynamic>),
          m11: json['M11'] == null
              ? null
              : DecimalNullableWithAggregatesFilter.fromJson(
                  json['M11'] as Map<String, dynamic>),
          m12: json['M12'] == null
              ? null
              : DecimalNullableWithAggregatesFilter.fromJson(
                  json['M12'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : DateTimeNullableWithAggregatesFilter.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$HOLIDAYTBLScalarWhereWithAggregatesInputToJson(
    HOLIDAYTBLScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('STD_YEAR', instance.stdYear?.toJson());
  writeNotNull('M1', instance.m1?.toJson());
  writeNotNull('M2', instance.m2?.toJson());
  writeNotNull('M3', instance.m3?.toJson());
  writeNotNull('M4', instance.m4?.toJson());
  writeNotNull('M5', instance.m5?.toJson());
  writeNotNull('M6', instance.m6?.toJson());
  writeNotNull('M7', instance.m7?.toJson());
  writeNotNull('M8', instance.m8?.toJson());
  writeNotNull('M9', instance.m9?.toJson());
  writeNotNull('M10', instance.m10?.toJson());
  writeNotNull('M11', instance.m11?.toJson());
  writeNotNull('M12', instance.m12?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

MEMBERTBLWhereInput _$MEMBERTBLWhereInputFromJson(Map<String, dynamic> json) =>
    MEMBERTBLWhereInput(
      AND: (json['AND'] as List<dynamic>?)
          ?.map((e) => MEMBERTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)
          ?.map((e) => MEMBERTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)
          ?.map((e) => MEMBERTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      userId: json['USER_ID'] == null
          ? null
          : StringFilter.fromJson(json['USER_ID'] as Map<String, dynamic>),
      passwd: json['PASSWD'] == null
          ? null
          : StringFilter.fromJson(json['PASSWD'] as Map<String, dynamic>),
      userNm: json['USER_NM'] == null
          ? null
          : StringFilter.fromJson(json['USER_NM'] as Map<String, dynamic>),
      dept: json['DEPT'] == null
          ? null
          : StringNullableFilter.fromJson(json['DEPT'] as Map<String, dynamic>),
      grade: json['GRADE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['GRADE'] as Map<String, dynamic>),
      joinDate: json['JOIN_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(json['JOIN_DATE'] as Map<String, dynamic>),
      retireDate: json['RETIRE_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(
              json['RETIRE_DATE'] as Map<String, dynamic>),
      pwdChgDate: json['PWD_CHG_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(
              json['PWD_CHG_DATE'] as Map<String, dynamic>),
      pwdWrongCnt: json['PWD_WRONG_CNT'] == null
          ? null
          : IntNullableFilter.fromJson(
              json['PWD_WRONG_CNT'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : DateTimeNullableFilter.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
      lastLoginDate: json['LAST_LOGIN_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(
              json['LAST_LOGIN_DATE'] as Map<String, dynamic>),
      memo: json['MEMO'] == null
          ? null
          : StringNullableFilter.fromJson(json['MEMO'] as Map<String, dynamic>),
      menuTbl: json['MENU_TBL'] == null
          ? null
          : MENUTBLListRelationFilter.fromJson(
              json['MENU_TBL'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$MEMBERTBLWhereInputToJson(MEMBERTBLWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('PASSWD', instance.passwd?.toJson());
  writeNotNull('USER_NM', instance.userNm?.toJson());
  writeNotNull('DEPT', instance.dept?.toJson());
  writeNotNull('GRADE', instance.grade?.toJson());
  writeNotNull('JOIN_DATE', instance.joinDate?.toJson());
  writeNotNull('RETIRE_DATE', instance.retireDate?.toJson());
  writeNotNull('PWD_CHG_DATE', instance.pwdChgDate?.toJson());
  writeNotNull('PWD_WRONG_CNT', instance.pwdWrongCnt?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('LAST_LOGIN_DATE', instance.lastLoginDate?.toJson());
  writeNotNull('MEMO', instance.memo?.toJson());
  writeNotNull('MENU_TBL', instance.menuTbl?.toJson());
  return val;
}

MEMBERTBLOrderByWithRelationInput _$MEMBERTBLOrderByWithRelationInputFromJson(
        Map<String, dynamic> json) =>
    MEMBERTBLOrderByWithRelationInput(
      userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
      passwd: $enumDecodeNullable(_$SortOrderEnumMap, json['PASSWD']),
      userNm: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_NM']),
      dept: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT']),
      grade: $enumDecodeNullable(_$SortOrderEnumMap, json['GRADE']),
      joinDate: $enumDecodeNullable(_$SortOrderEnumMap, json['JOIN_DATE']),
      retireDate: $enumDecodeNullable(_$SortOrderEnumMap, json['RETIRE_DATE']),
      pwdChgDate: $enumDecodeNullable(_$SortOrderEnumMap, json['PWD_CHG_DATE']),
      pwdWrongCnt:
          $enumDecodeNullable(_$SortOrderEnumMap, json['PWD_WRONG_CNT']),
      useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
      delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
      lastLoginDate:
          $enumDecodeNullable(_$SortOrderEnumMap, json['LAST_LOGIN_DATE']),
      memo: $enumDecodeNullable(_$SortOrderEnumMap, json['MEMO']),
      menuTbl: json['MENU_TBL'] == null
          ? null
          : MENUTBLOrderByRelationAggregateInput.fromJson(
              json['MENU_TBL'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$MEMBERTBLOrderByWithRelationInputToJson(
    MEMBERTBLOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('PASSWD', _$SortOrderEnumMap[instance.passwd]);
  writeNotNull('USER_NM', _$SortOrderEnumMap[instance.userNm]);
  writeNotNull('DEPT', _$SortOrderEnumMap[instance.dept]);
  writeNotNull('GRADE', _$SortOrderEnumMap[instance.grade]);
  writeNotNull('JOIN_DATE', _$SortOrderEnumMap[instance.joinDate]);
  writeNotNull('RETIRE_DATE', _$SortOrderEnumMap[instance.retireDate]);
  writeNotNull('PWD_CHG_DATE', _$SortOrderEnumMap[instance.pwdChgDate]);
  writeNotNull('PWD_WRONG_CNT', _$SortOrderEnumMap[instance.pwdWrongCnt]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('LAST_LOGIN_DATE', _$SortOrderEnumMap[instance.lastLoginDate]);
  writeNotNull('MEMO', _$SortOrderEnumMap[instance.memo]);
  writeNotNull('MENU_TBL', instance.menuTbl?.toJson());
  return val;
}

MEMBERTBLWhereUniqueInput _$MEMBERTBLWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    MEMBERTBLWhereUniqueInput(
      userId: json['USER_ID'] as String?,
    );

Map<String, dynamic> _$MEMBERTBLWhereUniqueInputToJson(
    MEMBERTBLWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', instance.userId);
  return val;
}

MEMBERTBLOrderByWithAggregationInput
    _$MEMBERTBLOrderByWithAggregationInputFromJson(Map<String, dynamic> json) =>
        MEMBERTBLOrderByWithAggregationInput(
          userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
          passwd: $enumDecodeNullable(_$SortOrderEnumMap, json['PASSWD']),
          userNm: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_NM']),
          dept: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT']),
          grade: $enumDecodeNullable(_$SortOrderEnumMap, json['GRADE']),
          joinDate: $enumDecodeNullable(_$SortOrderEnumMap, json['JOIN_DATE']),
          retireDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['RETIRE_DATE']),
          pwdChgDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PWD_CHG_DATE']),
          pwdWrongCnt:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PWD_WRONG_CNT']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          lastLoginDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['LAST_LOGIN_DATE']),
          memo: $enumDecodeNullable(_$SortOrderEnumMap, json['MEMO']),
          $count: json['_count'] == null
              ? null
              : MEMBERTBLCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : MEMBERTBLAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : MEMBERTBLMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : MEMBERTBLMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : MEMBERTBLSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$MEMBERTBLOrderByWithAggregationInputToJson(
    MEMBERTBLOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('PASSWD', _$SortOrderEnumMap[instance.passwd]);
  writeNotNull('USER_NM', _$SortOrderEnumMap[instance.userNm]);
  writeNotNull('DEPT', _$SortOrderEnumMap[instance.dept]);
  writeNotNull('GRADE', _$SortOrderEnumMap[instance.grade]);
  writeNotNull('JOIN_DATE', _$SortOrderEnumMap[instance.joinDate]);
  writeNotNull('RETIRE_DATE', _$SortOrderEnumMap[instance.retireDate]);
  writeNotNull('PWD_CHG_DATE', _$SortOrderEnumMap[instance.pwdChgDate]);
  writeNotNull('PWD_WRONG_CNT', _$SortOrderEnumMap[instance.pwdWrongCnt]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('LAST_LOGIN_DATE', _$SortOrderEnumMap[instance.lastLoginDate]);
  writeNotNull('MEMO', _$SortOrderEnumMap[instance.memo]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

MEMBERTBLScalarWhereWithAggregatesInput
    _$MEMBERTBLScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        MEMBERTBLScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              MEMBERTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              MEMBERTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              MEMBERTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          userId: json['USER_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['USER_ID'] as Map<String, dynamic>),
          passwd: json['PASSWD'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['PASSWD'] as Map<String, dynamic>),
          userNm: json['USER_NM'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['USER_NM'] as Map<String, dynamic>),
          dept: json['DEPT'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEPT'] as Map<String, dynamic>),
          grade: json['GRADE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['GRADE'] as Map<String, dynamic>),
          joinDate: json['JOIN_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['JOIN_DATE'] as Map<String, dynamic>),
          retireDate: json['RETIRE_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['RETIRE_DATE'] as Map<String, dynamic>),
          pwdChgDate: json['PWD_CHG_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['PWD_CHG_DATE'] as Map<String, dynamic>),
          pwdWrongCnt: json['PWD_WRONG_CNT'] == null
              ? null
              : IntNullableWithAggregatesFilter.fromJson(
                  json['PWD_WRONG_CNT'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : DateTimeNullableWithAggregatesFilter.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
          lastLoginDate: json['LAST_LOGIN_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['LAST_LOGIN_DATE'] as Map<String, dynamic>),
          memo: json['MEMO'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['MEMO'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$MEMBERTBLScalarWhereWithAggregatesInputToJson(
    MEMBERTBLScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('PASSWD', instance.passwd?.toJson());
  writeNotNull('USER_NM', instance.userNm?.toJson());
  writeNotNull('DEPT', instance.dept?.toJson());
  writeNotNull('GRADE', instance.grade?.toJson());
  writeNotNull('JOIN_DATE', instance.joinDate?.toJson());
  writeNotNull('RETIRE_DATE', instance.retireDate?.toJson());
  writeNotNull('PWD_CHG_DATE', instance.pwdChgDate?.toJson());
  writeNotNull('PWD_WRONG_CNT', instance.pwdWrongCnt?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('LAST_LOGIN_DATE', instance.lastLoginDate?.toJson());
  writeNotNull('MEMO', instance.memo?.toJson());
  return val;
}

MENUAUTHTBLWhereInput _$MENUAUTHTBLWhereInputFromJson(
        Map<String, dynamic> json) =>
    MENUAUTHTBLWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map(
          (e) => MENUAUTHTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map(
          (e) => MENUAUTHTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map(
          (e) => MENUAUTHTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      userId: json['USER_ID'] == null
          ? null
          : StringFilter.fromJson(json['USER_ID'] as Map<String, dynamic>),
      menuId: json['MENU_ID'] == null
          ? null
          : StringFilter.fromJson(json['MENU_ID'] as Map<String, dynamic>),
      readYn: json['READ_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['READ_YN'] as Map<String, dynamic>),
      writeYn: json['WRITE_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['WRITE_YN'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      updId: json['UPD_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['UPD_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : DateTimeNullableFilter.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$MENUAUTHTBLWhereInputToJson(
    MENUAUTHTBLWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('MENU_ID', instance.menuId?.toJson());
  writeNotNull('READ_YN', instance.readYn?.toJson());
  writeNotNull('WRITE_YN', instance.writeYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('UPD_ID', instance.updId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

MENUAUTHTBLOrderByWithRelationInput
    _$MENUAUTHTBLOrderByWithRelationInputFromJson(Map<String, dynamic> json) =>
        MENUAUTHTBLOrderByWithRelationInput(
          userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
          menuId: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_ID']),
          readYn: $enumDecodeNullable(_$SortOrderEnumMap, json['READ_YN']),
          writeYn: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITE_YN']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          updId: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
        );

Map<String, dynamic> _$MENUAUTHTBLOrderByWithRelationInputToJson(
    MENUAUTHTBLOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('MENU_ID', _$SortOrderEnumMap[instance.menuId]);
  writeNotNull('READ_YN', _$SortOrderEnumMap[instance.readYn]);
  writeNotNull('WRITE_YN', _$SortOrderEnumMap[instance.writeYn]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('UPD_ID', _$SortOrderEnumMap[instance.updId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  return val;
}

MENUAUTHTBLWhereUniqueInput _$MENUAUTHTBLWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    MENUAUTHTBLWhereUniqueInput(
      userIdMenuId: json['USER_ID_MENU_ID'] == null
          ? null
          : MENUAUTHTBLUSERIDMENUIDCompoundUniqueInput.fromJson(
              json['USER_ID_MENU_ID'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$MENUAUTHTBLWhereUniqueInputToJson(
    MENUAUTHTBLWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID_MENU_ID', instance.userIdMenuId?.toJson());
  return val;
}

MENUAUTHTBLOrderByWithAggregationInput
    _$MENUAUTHTBLOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        MENUAUTHTBLOrderByWithAggregationInput(
          userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
          menuId: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_ID']),
          readYn: $enumDecodeNullable(_$SortOrderEnumMap, json['READ_YN']),
          writeYn: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITE_YN']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          updId: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          $count: json['_count'] == null
              ? null
              : MENUAUTHTBLCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : MENUAUTHTBLMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : MENUAUTHTBLMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$MENUAUTHTBLOrderByWithAggregationInputToJson(
    MENUAUTHTBLOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('MENU_ID', _$SortOrderEnumMap[instance.menuId]);
  writeNotNull('READ_YN', _$SortOrderEnumMap[instance.readYn]);
  writeNotNull('WRITE_YN', _$SortOrderEnumMap[instance.writeYn]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('UPD_ID', _$SortOrderEnumMap[instance.updId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  return val;
}

MENUAUTHTBLScalarWhereWithAggregatesInput
    _$MENUAUTHTBLScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        MENUAUTHTBLScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              MENUAUTHTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              MENUAUTHTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              MENUAUTHTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          userId: json['USER_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['USER_ID'] as Map<String, dynamic>),
          menuId: json['MENU_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['MENU_ID'] as Map<String, dynamic>),
          readYn: json['READ_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['READ_YN'] as Map<String, dynamic>),
          writeYn: json['WRITE_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['WRITE_YN'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          updId: json['UPD_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['UPD_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : DateTimeNullableWithAggregatesFilter.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$MENUAUTHTBLScalarWhereWithAggregatesInputToJson(
    MENUAUTHTBLScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('MENU_ID', instance.menuId?.toJson());
  writeNotNull('READ_YN', instance.readYn?.toJson());
  writeNotNull('WRITE_YN', instance.writeYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('UPD_ID', instance.updId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

MENUTBLWhereInput _$MENUTBLWhereInputFromJson(Map<String, dynamic> json) =>
    MENUTBLWhereInput(
      AND: (json['AND'] as List<dynamic>?)
          ?.map((e) => MENUTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)
          ?.map((e) => MENUTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)
          ?.map((e) => MENUTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      menuId: json['MENU_ID'] == null
          ? null
          : StringFilter.fromJson(json['MENU_ID'] as Map<String, dynamic>),
      menuNm: json['MENU_NM'] == null
          ? null
          : StringFilter.fromJson(json['MENU_NM'] as Map<String, dynamic>),
      depth: json['DEPTH'] == null
          ? null
          : IntFilter.fromJson(json['DEPTH'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : IntFilter.fromJson(json['SORT'] as Map<String, dynamic>),
      ownerId: json['OWNER_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['OWNER_ID'] as Map<String, dynamic>),
      url: json['URL'] == null
          ? null
          : StringNullableFilter.fromJson(json['URL'] as Map<String, dynamic>),
      writerId: json['WRITER_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['WRITER_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : DateTimeNullableFilter.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      dispYn: json['DISP_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DISP_YN'] as Map<String, dynamic>),
      menuIcon: json['MENU_ICON'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['MENU_ICON'] as Map<String, dynamic>),
      memberTbl: json['MEMBER_TBL'] == null
          ? null
          : MEMBERTBLRelationFilter.fromJson(
              json['MEMBER_TBL'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$MENUTBLWhereInputToJson(MENUTBLWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('MENU_ID', instance.menuId?.toJson());
  writeNotNull('MENU_NM', instance.menuNm?.toJson());
  writeNotNull('DEPTH', instance.depth?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('OWNER_ID', instance.ownerId?.toJson());
  writeNotNull('URL', instance.url?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('DISP_YN', instance.dispYn?.toJson());
  writeNotNull('MENU_ICON', instance.menuIcon?.toJson());
  writeNotNull('MEMBER_TBL', instance.memberTbl?.toJson());
  return val;
}

MENUTBLOrderByWithRelationInput _$MENUTBLOrderByWithRelationInputFromJson(
        Map<String, dynamic> json) =>
    MENUTBLOrderByWithRelationInput(
      menuId: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_ID']),
      menuNm: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_NM']),
      depth: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPTH']),
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
      ownerId: $enumDecodeNullable(_$SortOrderEnumMap, json['OWNER_ID']),
      url: $enumDecodeNullable(_$SortOrderEnumMap, json['URL']),
      writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
      useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
      delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
      dispYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DISP_YN']),
      menuIcon: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_ICON']),
      memberTbl: json['MEMBER_TBL'] == null
          ? null
          : MEMBERTBLOrderByWithRelationInput.fromJson(
              json['MEMBER_TBL'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$MENUTBLOrderByWithRelationInputToJson(
    MENUTBLOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_ID', _$SortOrderEnumMap[instance.menuId]);
  writeNotNull('MENU_NM', _$SortOrderEnumMap[instance.menuNm]);
  writeNotNull('DEPTH', _$SortOrderEnumMap[instance.depth]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('OWNER_ID', _$SortOrderEnumMap[instance.ownerId]);
  writeNotNull('URL', _$SortOrderEnumMap[instance.url]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('DISP_YN', _$SortOrderEnumMap[instance.dispYn]);
  writeNotNull('MENU_ICON', _$SortOrderEnumMap[instance.menuIcon]);
  writeNotNull('MEMBER_TBL', instance.memberTbl?.toJson());
  return val;
}

MENUTBLWhereUniqueInput _$MENUTBLWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    MENUTBLWhereUniqueInput(
      menuId: json['MENU_ID'] as String?,
    );

Map<String, dynamic> _$MENUTBLWhereUniqueInputToJson(
    MENUTBLWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_ID', instance.menuId);
  return val;
}

MENUTBLOrderByWithAggregationInput _$MENUTBLOrderByWithAggregationInputFromJson(
        Map<String, dynamic> json) =>
    MENUTBLOrderByWithAggregationInput(
      menuId: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_ID']),
      menuNm: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_NM']),
      depth: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPTH']),
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
      ownerId: $enumDecodeNullable(_$SortOrderEnumMap, json['OWNER_ID']),
      url: $enumDecodeNullable(_$SortOrderEnumMap, json['URL']),
      writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
      useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
      delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
      dispYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DISP_YN']),
      menuIcon: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_ICON']),
      $count: json['_count'] == null
          ? null
          : MENUTBLCountOrderByAggregateInput.fromJson(
              json['_count'] as Map<String, dynamic>),
      $avg: json['_avg'] == null
          ? null
          : MENUTBLAvgOrderByAggregateInput.fromJson(
              json['_avg'] as Map<String, dynamic>),
      $max: json['_max'] == null
          ? null
          : MENUTBLMaxOrderByAggregateInput.fromJson(
              json['_max'] as Map<String, dynamic>),
      $min: json['_min'] == null
          ? null
          : MENUTBLMinOrderByAggregateInput.fromJson(
              json['_min'] as Map<String, dynamic>),
      $sum: json['_sum'] == null
          ? null
          : MENUTBLSumOrderByAggregateInput.fromJson(
              json['_sum'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$MENUTBLOrderByWithAggregationInputToJson(
    MENUTBLOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_ID', _$SortOrderEnumMap[instance.menuId]);
  writeNotNull('MENU_NM', _$SortOrderEnumMap[instance.menuNm]);
  writeNotNull('DEPTH', _$SortOrderEnumMap[instance.depth]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('OWNER_ID', _$SortOrderEnumMap[instance.ownerId]);
  writeNotNull('URL', _$SortOrderEnumMap[instance.url]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('DISP_YN', _$SortOrderEnumMap[instance.dispYn]);
  writeNotNull('MENU_ICON', _$SortOrderEnumMap[instance.menuIcon]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

MENUTBLScalarWhereWithAggregatesInput
    _$MENUTBLScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        MENUTBLScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              MENUTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              MENUTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              MENUTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          menuId: json['MENU_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['MENU_ID'] as Map<String, dynamic>),
          menuNm: json['MENU_NM'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['MENU_NM'] as Map<String, dynamic>),
          depth: json['DEPTH'] == null
              ? null
              : IntWithAggregatesFilter.fromJson(
                  json['DEPTH'] as Map<String, dynamic>),
          sort: json['SORT'] == null
              ? null
              : IntWithAggregatesFilter.fromJson(
                  json['SORT'] as Map<String, dynamic>),
          ownerId: json['OWNER_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['OWNER_ID'] as Map<String, dynamic>),
          url: json['URL'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['URL'] as Map<String, dynamic>),
          writerId: json['WRITER_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['WRITER_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : DateTimeNullableWithAggregatesFilter.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
          dispYn: json['DISP_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DISP_YN'] as Map<String, dynamic>),
          menuIcon: json['MENU_ICON'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['MENU_ICON'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$MENUTBLScalarWhereWithAggregatesInputToJson(
    MENUTBLScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('MENU_ID', instance.menuId?.toJson());
  writeNotNull('MENU_NM', instance.menuNm?.toJson());
  writeNotNull('DEPTH', instance.depth?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('OWNER_ID', instance.ownerId?.toJson());
  writeNotNull('URL', instance.url?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('DISP_YN', instance.dispYn?.toJson());
  writeNotNull('MENU_ICON', instance.menuIcon?.toJson());
  return val;
}

OFFICEASSETTBLWhereInput _$OFFICEASSETTBLWhereInputFromJson(
        Map<String, dynamic> json) =>
    OFFICEASSETTBLWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map(
          (e) => OFFICEASSETTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map(
          (e) => OFFICEASSETTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map(
          (e) => OFFICEASSETTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      seq: json['SEQ'] == null
          ? null
          : BigIntFilter.fromJson(json['SEQ'] as Map<String, dynamic>),
      assetNo: json['ASSET_NO'] == null
          ? null
          : StringFilter.fromJson(json['ASSET_NO'] as Map<String, dynamic>),
      assetType: json['ASSET_TYPE'] == null
          ? null
          : StringFilter.fromJson(json['ASSET_TYPE'] as Map<String, dynamic>),
      seller: json['SELLER'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['SELLER'] as Map<String, dynamic>),
      buyDate: json['BUY_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['BUY_DATE'] as Map<String, dynamic>),
      modelNo: json['MODEL_NO'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['MODEL_NO'] as Map<String, dynamic>),
      serialNo: json['SERIAL_NO'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['SERIAL_NO'] as Map<String, dynamic>),
      amount: json['AMOUNT'] == null
          ? null
          : IntNullableFilter.fromJson(json['AMOUNT'] as Map<String, dynamic>),
      keepYear: json['KEEP_YEAR'] == null
          ? null
          : DecimalNullableFilter.fromJson(
              json['KEEP_YEAR'] as Map<String, dynamic>),
      mngDept: json['MNG_DEPT'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['MNG_DEPT'] as Map<String, dynamic>),
      assetAccount: json['ASSET_ACCOUNT'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['ASSET_ACCOUNT'] as Map<String, dynamic>),
      remarks: json['REMARKS'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['REMARKS'] as Map<String, dynamic>),
      carryOut: json['CARRY_OUT'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['CARRY_OUT'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : StringFilter.fromJson(json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringFilter.fromJson(json['DEL_YN'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : DateTimeNullableFilter.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$OFFICEASSETTBLWhereInputToJson(
    OFFICEASSETTBLWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('ASSET_TYPE', instance.assetType?.toJson());
  writeNotNull('SELLER', instance.seller?.toJson());
  writeNotNull('BUY_DATE', instance.buyDate?.toJson());
  writeNotNull('MODEL_NO', instance.modelNo?.toJson());
  writeNotNull('SERIAL_NO', instance.serialNo?.toJson());
  writeNotNull('AMOUNT', instance.amount?.toJson());
  writeNotNull('KEEP_YEAR', instance.keepYear?.toJson());
  writeNotNull('MNG_DEPT', instance.mngDept?.toJson());
  writeNotNull('ASSET_ACCOUNT', instance.assetAccount?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('CARRY_OUT', instance.carryOut?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

OFFICEASSETTBLOrderByWithRelationInput
    _$OFFICEASSETTBLOrderByWithRelationInputFromJson(
            Map<String, dynamic> json) =>
        OFFICEASSETTBLOrderByWithRelationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          assetNo: $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_NO']),
          assetType:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_TYPE']),
          seller: $enumDecodeNullable(_$SortOrderEnumMap, json['SELLER']),
          buyDate: $enumDecodeNullable(_$SortOrderEnumMap, json['BUY_DATE']),
          modelNo: $enumDecodeNullable(_$SortOrderEnumMap, json['MODEL_NO']),
          serialNo: $enumDecodeNullable(_$SortOrderEnumMap, json['SERIAL_NO']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
          keepYear: $enumDecodeNullable(_$SortOrderEnumMap, json['KEEP_YEAR']),
          mngDept: $enumDecodeNullable(_$SortOrderEnumMap, json['MNG_DEPT']),
          assetAccount:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_ACCOUNT']),
          remarks: $enumDecodeNullable(_$SortOrderEnumMap, json['REMARKS']),
          carryOut: $enumDecodeNullable(_$SortOrderEnumMap, json['CARRY_OUT']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
        );

Map<String, dynamic> _$OFFICEASSETTBLOrderByWithRelationInputToJson(
    OFFICEASSETTBLOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ASSET_NO', _$SortOrderEnumMap[instance.assetNo]);
  writeNotNull('ASSET_TYPE', _$SortOrderEnumMap[instance.assetType]);
  writeNotNull('SELLER', _$SortOrderEnumMap[instance.seller]);
  writeNotNull('BUY_DATE', _$SortOrderEnumMap[instance.buyDate]);
  writeNotNull('MODEL_NO', _$SortOrderEnumMap[instance.modelNo]);
  writeNotNull('SERIAL_NO', _$SortOrderEnumMap[instance.serialNo]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  writeNotNull('KEEP_YEAR', _$SortOrderEnumMap[instance.keepYear]);
  writeNotNull('MNG_DEPT', _$SortOrderEnumMap[instance.mngDept]);
  writeNotNull('ASSET_ACCOUNT', _$SortOrderEnumMap[instance.assetAccount]);
  writeNotNull('REMARKS', _$SortOrderEnumMap[instance.remarks]);
  writeNotNull('CARRY_OUT', _$SortOrderEnumMap[instance.carryOut]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  return val;
}

OFFICEASSETTBLWhereUniqueInput _$OFFICEASSETTBLWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    OFFICEASSETTBLWhereUniqueInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
    );

Map<String, dynamic> _$OFFICEASSETTBLWhereUniqueInputToJson(
    OFFICEASSETTBLWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  return val;
}

OFFICEASSETTBLOrderByWithAggregationInput
    _$OFFICEASSETTBLOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        OFFICEASSETTBLOrderByWithAggregationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          assetNo: $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_NO']),
          assetType:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_TYPE']),
          seller: $enumDecodeNullable(_$SortOrderEnumMap, json['SELLER']),
          buyDate: $enumDecodeNullable(_$SortOrderEnumMap, json['BUY_DATE']),
          modelNo: $enumDecodeNullable(_$SortOrderEnumMap, json['MODEL_NO']),
          serialNo: $enumDecodeNullable(_$SortOrderEnumMap, json['SERIAL_NO']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
          keepYear: $enumDecodeNullable(_$SortOrderEnumMap, json['KEEP_YEAR']),
          mngDept: $enumDecodeNullable(_$SortOrderEnumMap, json['MNG_DEPT']),
          assetAccount:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_ACCOUNT']),
          remarks: $enumDecodeNullable(_$SortOrderEnumMap, json['REMARKS']),
          carryOut: $enumDecodeNullable(_$SortOrderEnumMap, json['CARRY_OUT']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          $count: json['_count'] == null
              ? null
              : OFFICEASSETTBLCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : OFFICEASSETTBLAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : OFFICEASSETTBLMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : OFFICEASSETTBLMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : OFFICEASSETTBLSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$OFFICEASSETTBLOrderByWithAggregationInputToJson(
    OFFICEASSETTBLOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ASSET_NO', _$SortOrderEnumMap[instance.assetNo]);
  writeNotNull('ASSET_TYPE', _$SortOrderEnumMap[instance.assetType]);
  writeNotNull('SELLER', _$SortOrderEnumMap[instance.seller]);
  writeNotNull('BUY_DATE', _$SortOrderEnumMap[instance.buyDate]);
  writeNotNull('MODEL_NO', _$SortOrderEnumMap[instance.modelNo]);
  writeNotNull('SERIAL_NO', _$SortOrderEnumMap[instance.serialNo]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  writeNotNull('KEEP_YEAR', _$SortOrderEnumMap[instance.keepYear]);
  writeNotNull('MNG_DEPT', _$SortOrderEnumMap[instance.mngDept]);
  writeNotNull('ASSET_ACCOUNT', _$SortOrderEnumMap[instance.assetAccount]);
  writeNotNull('REMARKS', _$SortOrderEnumMap[instance.remarks]);
  writeNotNull('CARRY_OUT', _$SortOrderEnumMap[instance.carryOut]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

OFFICEASSETTBLScalarWhereWithAggregatesInput
    _$OFFICEASSETTBLScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        OFFICEASSETTBLScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              OFFICEASSETTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              OFFICEASSETTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              OFFICEASSETTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          seq: json['SEQ'] == null
              ? null
              : BigIntWithAggregatesFilter.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          assetNo: json['ASSET_NO'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['ASSET_NO'] as Map<String, dynamic>),
          assetType: json['ASSET_TYPE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['ASSET_TYPE'] as Map<String, dynamic>),
          seller: json['SELLER'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['SELLER'] as Map<String, dynamic>),
          buyDate: json['BUY_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['BUY_DATE'] as Map<String, dynamic>),
          modelNo: json['MODEL_NO'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['MODEL_NO'] as Map<String, dynamic>),
          serialNo: json['SERIAL_NO'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['SERIAL_NO'] as Map<String, dynamic>),
          amount: json['AMOUNT'] == null
              ? null
              : IntNullableWithAggregatesFilter.fromJson(
                  json['AMOUNT'] as Map<String, dynamic>),
          keepYear: json['KEEP_YEAR'] == null
              ? null
              : DecimalNullableWithAggregatesFilter.fromJson(
                  json['KEEP_YEAR'] as Map<String, dynamic>),
          mngDept: json['MNG_DEPT'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['MNG_DEPT'] as Map<String, dynamic>),
          assetAccount: json['ASSET_ACCOUNT'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['ASSET_ACCOUNT'] as Map<String, dynamic>),
          remarks: json['REMARKS'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['REMARKS'] as Map<String, dynamic>),
          carryOut: json['CARRY_OUT'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['CARRY_OUT'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : DateTimeNullableWithAggregatesFilter.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$OFFICEASSETTBLScalarWhereWithAggregatesInputToJson(
    OFFICEASSETTBLScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('ASSET_TYPE', instance.assetType?.toJson());
  writeNotNull('SELLER', instance.seller?.toJson());
  writeNotNull('BUY_DATE', instance.buyDate?.toJson());
  writeNotNull('MODEL_NO', instance.modelNo?.toJson());
  writeNotNull('SERIAL_NO', instance.serialNo?.toJson());
  writeNotNull('AMOUNT', instance.amount?.toJson());
  writeNotNull('KEEP_YEAR', instance.keepYear?.toJson());
  writeNotNull('MNG_DEPT', instance.mngDept?.toJson());
  writeNotNull('ASSET_ACCOUNT', instance.assetAccount?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('CARRY_OUT', instance.carryOut?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

SERVERASSETTBLWhereInput _$SERVERASSETTBLWhereInputFromJson(
        Map<String, dynamic> json) =>
    SERVERASSETTBLWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map(
          (e) => SERVERASSETTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map(
          (e) => SERVERASSETTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map(
          (e) => SERVERASSETTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      seq: json['SEQ'] == null
          ? null
          : BigIntFilter.fromJson(json['SEQ'] as Map<String, dynamic>),
      assetNo: json['ASSET_NO'] == null
          ? null
          : StringFilter.fromJson(json['ASSET_NO'] as Map<String, dynamic>),
      assetType: json['ASSET_TYPE'] == null
          ? null
          : StringFilter.fromJson(json['ASSET_TYPE'] as Map<String, dynamic>),
      maker: json['MAKER'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['MAKER'] as Map<String, dynamic>),
      cnt: json['CNT'] == null
          ? null
          : DecimalNullableFilter.fromJson(json['CNT'] as Map<String, dynamic>),
      amount: json['AMOUNT'] == null
          ? null
          : IntNullableFilter.fromJson(json['AMOUNT'] as Map<String, dynamic>),
      buyDate: json['BUY_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['BUY_DATE'] as Map<String, dynamic>),
      seller: json['SELLER'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['SELLER'] as Map<String, dynamic>),
      modelNo: json['MODEL_NO'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['MODEL_NO'] as Map<String, dynamic>),
      serialNo: json['SERIAL_NO'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['SERIAL_NO'] as Map<String, dynamic>),
      hostname: json['HOSTNAME'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['HOSTNAME'] as Map<String, dynamic>),
      builtLoc: json['BUILT_LOC'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['BUILT_LOC'] as Map<String, dynamic>),
      useDesc: json['USE_DESC'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['USE_DESC'] as Map<String, dynamic>),
      osInfo: json['OS_INFO'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['OS_INFO'] as Map<String, dynamic>),
      cpuInfo: json['CPU_INFO'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['CPU_INFO'] as Map<String, dynamic>),
      ramInfo: json['RAM_INFO'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['RAM_INFO'] as Map<String, dynamic>),
      hddInfo: json['HDD_INFO'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['HDD_INFO'] as Map<String, dynamic>),
      ssdInfo: json['SSD_INFO'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['SSD_INFO'] as Map<String, dynamic>),
      odd: json['ODD'] == null
          ? null
          : StringNullableFilter.fromJson(json['ODD'] as Map<String, dynamic>),
      remarks: json['REMARKS'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['REMARKS'] as Map<String, dynamic>),
      carryOut: json['CARRY_OUT'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['CARRY_OUT'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : StringFilter.fromJson(json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringFilter.fromJson(json['DEL_YN'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : DateTimeNullableFilter.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$SERVERASSETTBLWhereInputToJson(
    SERVERASSETTBLWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('ASSET_TYPE', instance.assetType?.toJson());
  writeNotNull('MAKER', instance.maker?.toJson());
  writeNotNull('CNT', instance.cnt?.toJson());
  writeNotNull('AMOUNT', instance.amount?.toJson());
  writeNotNull('BUY_DATE', instance.buyDate?.toJson());
  writeNotNull('SELLER', instance.seller?.toJson());
  writeNotNull('MODEL_NO', instance.modelNo?.toJson());
  writeNotNull('SERIAL_NO', instance.serialNo?.toJson());
  writeNotNull('HOSTNAME', instance.hostname?.toJson());
  writeNotNull('BUILT_LOC', instance.builtLoc?.toJson());
  writeNotNull('USE_DESC', instance.useDesc?.toJson());
  writeNotNull('OS_INFO', instance.osInfo?.toJson());
  writeNotNull('CPU_INFO', instance.cpuInfo?.toJson());
  writeNotNull('RAM_INFO', instance.ramInfo?.toJson());
  writeNotNull('HDD_INFO', instance.hddInfo?.toJson());
  writeNotNull('SSD_INFO', instance.ssdInfo?.toJson());
  writeNotNull('ODD', instance.odd?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('CARRY_OUT', instance.carryOut?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

SERVERASSETTBLOrderByWithRelationInput
    _$SERVERASSETTBLOrderByWithRelationInputFromJson(
            Map<String, dynamic> json) =>
        SERVERASSETTBLOrderByWithRelationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          assetNo: $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_NO']),
          assetType:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_TYPE']),
          maker: $enumDecodeNullable(_$SortOrderEnumMap, json['MAKER']),
          cnt: $enumDecodeNullable(_$SortOrderEnumMap, json['CNT']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
          buyDate: $enumDecodeNullable(_$SortOrderEnumMap, json['BUY_DATE']),
          seller: $enumDecodeNullable(_$SortOrderEnumMap, json['SELLER']),
          modelNo: $enumDecodeNullable(_$SortOrderEnumMap, json['MODEL_NO']),
          serialNo: $enumDecodeNullable(_$SortOrderEnumMap, json['SERIAL_NO']),
          hostname: $enumDecodeNullable(_$SortOrderEnumMap, json['HOSTNAME']),
          builtLoc: $enumDecodeNullable(_$SortOrderEnumMap, json['BUILT_LOC']),
          useDesc: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_DESC']),
          osInfo: $enumDecodeNullable(_$SortOrderEnumMap, json['OS_INFO']),
          cpuInfo: $enumDecodeNullable(_$SortOrderEnumMap, json['CPU_INFO']),
          ramInfo: $enumDecodeNullable(_$SortOrderEnumMap, json['RAM_INFO']),
          hddInfo: $enumDecodeNullable(_$SortOrderEnumMap, json['HDD_INFO']),
          ssdInfo: $enumDecodeNullable(_$SortOrderEnumMap, json['SSD_INFO']),
          odd: $enumDecodeNullable(_$SortOrderEnumMap, json['ODD']),
          remarks: $enumDecodeNullable(_$SortOrderEnumMap, json['REMARKS']),
          carryOut: $enumDecodeNullable(_$SortOrderEnumMap, json['CARRY_OUT']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
        );

Map<String, dynamic> _$SERVERASSETTBLOrderByWithRelationInputToJson(
    SERVERASSETTBLOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ASSET_NO', _$SortOrderEnumMap[instance.assetNo]);
  writeNotNull('ASSET_TYPE', _$SortOrderEnumMap[instance.assetType]);
  writeNotNull('MAKER', _$SortOrderEnumMap[instance.maker]);
  writeNotNull('CNT', _$SortOrderEnumMap[instance.cnt]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  writeNotNull('BUY_DATE', _$SortOrderEnumMap[instance.buyDate]);
  writeNotNull('SELLER', _$SortOrderEnumMap[instance.seller]);
  writeNotNull('MODEL_NO', _$SortOrderEnumMap[instance.modelNo]);
  writeNotNull('SERIAL_NO', _$SortOrderEnumMap[instance.serialNo]);
  writeNotNull('HOSTNAME', _$SortOrderEnumMap[instance.hostname]);
  writeNotNull('BUILT_LOC', _$SortOrderEnumMap[instance.builtLoc]);
  writeNotNull('USE_DESC', _$SortOrderEnumMap[instance.useDesc]);
  writeNotNull('OS_INFO', _$SortOrderEnumMap[instance.osInfo]);
  writeNotNull('CPU_INFO', _$SortOrderEnumMap[instance.cpuInfo]);
  writeNotNull('RAM_INFO', _$SortOrderEnumMap[instance.ramInfo]);
  writeNotNull('HDD_INFO', _$SortOrderEnumMap[instance.hddInfo]);
  writeNotNull('SSD_INFO', _$SortOrderEnumMap[instance.ssdInfo]);
  writeNotNull('ODD', _$SortOrderEnumMap[instance.odd]);
  writeNotNull('REMARKS', _$SortOrderEnumMap[instance.remarks]);
  writeNotNull('CARRY_OUT', _$SortOrderEnumMap[instance.carryOut]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  return val;
}

SERVERASSETTBLWhereUniqueInput _$SERVERASSETTBLWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    SERVERASSETTBLWhereUniqueInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
    );

Map<String, dynamic> _$SERVERASSETTBLWhereUniqueInputToJson(
    SERVERASSETTBLWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  return val;
}

SERVERASSETTBLOrderByWithAggregationInput
    _$SERVERASSETTBLOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        SERVERASSETTBLOrderByWithAggregationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          assetNo: $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_NO']),
          assetType:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_TYPE']),
          maker: $enumDecodeNullable(_$SortOrderEnumMap, json['MAKER']),
          cnt: $enumDecodeNullable(_$SortOrderEnumMap, json['CNT']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
          buyDate: $enumDecodeNullable(_$SortOrderEnumMap, json['BUY_DATE']),
          seller: $enumDecodeNullable(_$SortOrderEnumMap, json['SELLER']),
          modelNo: $enumDecodeNullable(_$SortOrderEnumMap, json['MODEL_NO']),
          serialNo: $enumDecodeNullable(_$SortOrderEnumMap, json['SERIAL_NO']),
          hostname: $enumDecodeNullable(_$SortOrderEnumMap, json['HOSTNAME']),
          builtLoc: $enumDecodeNullable(_$SortOrderEnumMap, json['BUILT_LOC']),
          useDesc: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_DESC']),
          osInfo: $enumDecodeNullable(_$SortOrderEnumMap, json['OS_INFO']),
          cpuInfo: $enumDecodeNullable(_$SortOrderEnumMap, json['CPU_INFO']),
          ramInfo: $enumDecodeNullable(_$SortOrderEnumMap, json['RAM_INFO']),
          hddInfo: $enumDecodeNullable(_$SortOrderEnumMap, json['HDD_INFO']),
          ssdInfo: $enumDecodeNullable(_$SortOrderEnumMap, json['SSD_INFO']),
          odd: $enumDecodeNullable(_$SortOrderEnumMap, json['ODD']),
          remarks: $enumDecodeNullable(_$SortOrderEnumMap, json['REMARKS']),
          carryOut: $enumDecodeNullable(_$SortOrderEnumMap, json['CARRY_OUT']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          $count: json['_count'] == null
              ? null
              : SERVERASSETTBLCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : SERVERASSETTBLAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : SERVERASSETTBLMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : SERVERASSETTBLMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : SERVERASSETTBLSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$SERVERASSETTBLOrderByWithAggregationInputToJson(
    SERVERASSETTBLOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ASSET_NO', _$SortOrderEnumMap[instance.assetNo]);
  writeNotNull('ASSET_TYPE', _$SortOrderEnumMap[instance.assetType]);
  writeNotNull('MAKER', _$SortOrderEnumMap[instance.maker]);
  writeNotNull('CNT', _$SortOrderEnumMap[instance.cnt]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  writeNotNull('BUY_DATE', _$SortOrderEnumMap[instance.buyDate]);
  writeNotNull('SELLER', _$SortOrderEnumMap[instance.seller]);
  writeNotNull('MODEL_NO', _$SortOrderEnumMap[instance.modelNo]);
  writeNotNull('SERIAL_NO', _$SortOrderEnumMap[instance.serialNo]);
  writeNotNull('HOSTNAME', _$SortOrderEnumMap[instance.hostname]);
  writeNotNull('BUILT_LOC', _$SortOrderEnumMap[instance.builtLoc]);
  writeNotNull('USE_DESC', _$SortOrderEnumMap[instance.useDesc]);
  writeNotNull('OS_INFO', _$SortOrderEnumMap[instance.osInfo]);
  writeNotNull('CPU_INFO', _$SortOrderEnumMap[instance.cpuInfo]);
  writeNotNull('RAM_INFO', _$SortOrderEnumMap[instance.ramInfo]);
  writeNotNull('HDD_INFO', _$SortOrderEnumMap[instance.hddInfo]);
  writeNotNull('SSD_INFO', _$SortOrderEnumMap[instance.ssdInfo]);
  writeNotNull('ODD', _$SortOrderEnumMap[instance.odd]);
  writeNotNull('REMARKS', _$SortOrderEnumMap[instance.remarks]);
  writeNotNull('CARRY_OUT', _$SortOrderEnumMap[instance.carryOut]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

SERVERASSETTBLScalarWhereWithAggregatesInput
    _$SERVERASSETTBLScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        SERVERASSETTBLScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              SERVERASSETTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              SERVERASSETTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              SERVERASSETTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          seq: json['SEQ'] == null
              ? null
              : BigIntWithAggregatesFilter.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          assetNo: json['ASSET_NO'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['ASSET_NO'] as Map<String, dynamic>),
          assetType: json['ASSET_TYPE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['ASSET_TYPE'] as Map<String, dynamic>),
          maker: json['MAKER'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['MAKER'] as Map<String, dynamic>),
          cnt: json['CNT'] == null
              ? null
              : DecimalNullableWithAggregatesFilter.fromJson(
                  json['CNT'] as Map<String, dynamic>),
          amount: json['AMOUNT'] == null
              ? null
              : IntNullableWithAggregatesFilter.fromJson(
                  json['AMOUNT'] as Map<String, dynamic>),
          buyDate: json['BUY_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['BUY_DATE'] as Map<String, dynamic>),
          seller: json['SELLER'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['SELLER'] as Map<String, dynamic>),
          modelNo: json['MODEL_NO'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['MODEL_NO'] as Map<String, dynamic>),
          serialNo: json['SERIAL_NO'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['SERIAL_NO'] as Map<String, dynamic>),
          hostname: json['HOSTNAME'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['HOSTNAME'] as Map<String, dynamic>),
          builtLoc: json['BUILT_LOC'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['BUILT_LOC'] as Map<String, dynamic>),
          useDesc: json['USE_DESC'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['USE_DESC'] as Map<String, dynamic>),
          osInfo: json['OS_INFO'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['OS_INFO'] as Map<String, dynamic>),
          cpuInfo: json['CPU_INFO'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['CPU_INFO'] as Map<String, dynamic>),
          ramInfo: json['RAM_INFO'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['RAM_INFO'] as Map<String, dynamic>),
          hddInfo: json['HDD_INFO'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['HDD_INFO'] as Map<String, dynamic>),
          ssdInfo: json['SSD_INFO'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['SSD_INFO'] as Map<String, dynamic>),
          odd: json['ODD'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['ODD'] as Map<String, dynamic>),
          remarks: json['REMARKS'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['REMARKS'] as Map<String, dynamic>),
          carryOut: json['CARRY_OUT'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['CARRY_OUT'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : DateTimeNullableWithAggregatesFilter.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$SERVERASSETTBLScalarWhereWithAggregatesInputToJson(
    SERVERASSETTBLScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('ASSET_TYPE', instance.assetType?.toJson());
  writeNotNull('MAKER', instance.maker?.toJson());
  writeNotNull('CNT', instance.cnt?.toJson());
  writeNotNull('AMOUNT', instance.amount?.toJson());
  writeNotNull('BUY_DATE', instance.buyDate?.toJson());
  writeNotNull('SELLER', instance.seller?.toJson());
  writeNotNull('MODEL_NO', instance.modelNo?.toJson());
  writeNotNull('SERIAL_NO', instance.serialNo?.toJson());
  writeNotNull('HOSTNAME', instance.hostname?.toJson());
  writeNotNull('BUILT_LOC', instance.builtLoc?.toJson());
  writeNotNull('USE_DESC', instance.useDesc?.toJson());
  writeNotNull('OS_INFO', instance.osInfo?.toJson());
  writeNotNull('CPU_INFO', instance.cpuInfo?.toJson());
  writeNotNull('RAM_INFO', instance.ramInfo?.toJson());
  writeNotNull('HDD_INFO', instance.hddInfo?.toJson());
  writeNotNull('SSD_INFO', instance.ssdInfo?.toJson());
  writeNotNull('ODD', instance.odd?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('CARRY_OUT', instance.carryOut?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

SOFTWAREASSETTBLWhereInput _$SOFTWAREASSETTBLWhereInputFromJson(
        Map<String, dynamic> json) =>
    SOFTWAREASSETTBLWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map((e) =>
          SOFTWAREASSETTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map((e) =>
          SOFTWAREASSETTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
          SOFTWAREASSETTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      seq: json['SEQ'] == null
          ? null
          : BigIntFilter.fromJson(json['SEQ'] as Map<String, dynamic>),
      assetNo: json['ASSET_NO'] == null
          ? null
          : StringFilter.fromJson(json['ASSET_NO'] as Map<String, dynamic>),
      softwareNm: json['SOFTWARE_NM'] == null
          ? null
          : StringFilter.fromJson(json['SOFTWARE_NM'] as Map<String, dynamic>),
      versionNm: json['VERSION_NM'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['VERSION_NM'] as Map<String, dynamic>),
      cnt: json['CNT'] == null
          ? null
          : DecimalNullableFilter.fromJson(json['CNT'] as Map<String, dynamic>),
      amount: json['AMOUNT'] == null
          ? null
          : IntNullableFilter.fromJson(json['AMOUNT'] as Map<String, dynamic>),
      buyDate: json['BUY_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['BUY_DATE'] as Map<String, dynamic>),
      serialNo: json['SERIAL_NO'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['SERIAL_NO'] as Map<String, dynamic>),
      licenseNo: json['LICENSE_NO'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['LICENSE_NO'] as Map<String, dynamic>),
      userNm: json['USER_NM'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['USER_NM'] as Map<String, dynamic>),
      remarks: json['REMARKS'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['REMARKS'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : StringFilter.fromJson(json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringFilter.fromJson(json['DEL_YN'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : DateTimeNullableFilter.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$SOFTWAREASSETTBLWhereInputToJson(
    SOFTWAREASSETTBLWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('SOFTWARE_NM', instance.softwareNm?.toJson());
  writeNotNull('VERSION_NM', instance.versionNm?.toJson());
  writeNotNull('CNT', instance.cnt?.toJson());
  writeNotNull('AMOUNT', instance.amount?.toJson());
  writeNotNull('BUY_DATE', instance.buyDate?.toJson());
  writeNotNull('SERIAL_NO', instance.serialNo?.toJson());
  writeNotNull('LICENSE_NO', instance.licenseNo?.toJson());
  writeNotNull('USER_NM', instance.userNm?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

SOFTWAREASSETTBLOrderByWithRelationInput
    _$SOFTWAREASSETTBLOrderByWithRelationInputFromJson(
            Map<String, dynamic> json) =>
        SOFTWAREASSETTBLOrderByWithRelationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          assetNo: $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_NO']),
          softwareNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['SOFTWARE_NM']),
          versionNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['VERSION_NM']),
          cnt: $enumDecodeNullable(_$SortOrderEnumMap, json['CNT']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
          buyDate: $enumDecodeNullable(_$SortOrderEnumMap, json['BUY_DATE']),
          serialNo: $enumDecodeNullable(_$SortOrderEnumMap, json['SERIAL_NO']),
          licenseNo:
              $enumDecodeNullable(_$SortOrderEnumMap, json['LICENSE_NO']),
          userNm: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_NM']),
          remarks: $enumDecodeNullable(_$SortOrderEnumMap, json['REMARKS']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
        );

Map<String, dynamic> _$SOFTWAREASSETTBLOrderByWithRelationInputToJson(
    SOFTWAREASSETTBLOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ASSET_NO', _$SortOrderEnumMap[instance.assetNo]);
  writeNotNull('SOFTWARE_NM', _$SortOrderEnumMap[instance.softwareNm]);
  writeNotNull('VERSION_NM', _$SortOrderEnumMap[instance.versionNm]);
  writeNotNull('CNT', _$SortOrderEnumMap[instance.cnt]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  writeNotNull('BUY_DATE', _$SortOrderEnumMap[instance.buyDate]);
  writeNotNull('SERIAL_NO', _$SortOrderEnumMap[instance.serialNo]);
  writeNotNull('LICENSE_NO', _$SortOrderEnumMap[instance.licenseNo]);
  writeNotNull('USER_NM', _$SortOrderEnumMap[instance.userNm]);
  writeNotNull('REMARKS', _$SortOrderEnumMap[instance.remarks]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  return val;
}

SOFTWAREASSETTBLWhereUniqueInput _$SOFTWAREASSETTBLWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    SOFTWAREASSETTBLWhereUniqueInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
    );

Map<String, dynamic> _$SOFTWAREASSETTBLWhereUniqueInputToJson(
    SOFTWAREASSETTBLWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  return val;
}

SOFTWAREASSETTBLOrderByWithAggregationInput
    _$SOFTWAREASSETTBLOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        SOFTWAREASSETTBLOrderByWithAggregationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          assetNo: $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_NO']),
          softwareNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['SOFTWARE_NM']),
          versionNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['VERSION_NM']),
          cnt: $enumDecodeNullable(_$SortOrderEnumMap, json['CNT']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
          buyDate: $enumDecodeNullable(_$SortOrderEnumMap, json['BUY_DATE']),
          serialNo: $enumDecodeNullable(_$SortOrderEnumMap, json['SERIAL_NO']),
          licenseNo:
              $enumDecodeNullable(_$SortOrderEnumMap, json['LICENSE_NO']),
          userNm: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_NM']),
          remarks: $enumDecodeNullable(_$SortOrderEnumMap, json['REMARKS']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          $count: json['_count'] == null
              ? null
              : SOFTWAREASSETTBLCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : SOFTWAREASSETTBLAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : SOFTWAREASSETTBLMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : SOFTWAREASSETTBLMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : SOFTWAREASSETTBLSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$SOFTWAREASSETTBLOrderByWithAggregationInputToJson(
    SOFTWAREASSETTBLOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ASSET_NO', _$SortOrderEnumMap[instance.assetNo]);
  writeNotNull('SOFTWARE_NM', _$SortOrderEnumMap[instance.softwareNm]);
  writeNotNull('VERSION_NM', _$SortOrderEnumMap[instance.versionNm]);
  writeNotNull('CNT', _$SortOrderEnumMap[instance.cnt]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  writeNotNull('BUY_DATE', _$SortOrderEnumMap[instance.buyDate]);
  writeNotNull('SERIAL_NO', _$SortOrderEnumMap[instance.serialNo]);
  writeNotNull('LICENSE_NO', _$SortOrderEnumMap[instance.licenseNo]);
  writeNotNull('USER_NM', _$SortOrderEnumMap[instance.userNm]);
  writeNotNull('REMARKS', _$SortOrderEnumMap[instance.remarks]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

SOFTWAREASSETTBLScalarWhereWithAggregatesInput
    _$SOFTWAREASSETTBLScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        SOFTWAREASSETTBLScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              SOFTWAREASSETTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              SOFTWAREASSETTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              SOFTWAREASSETTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          seq: json['SEQ'] == null
              ? null
              : BigIntWithAggregatesFilter.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          assetNo: json['ASSET_NO'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['ASSET_NO'] as Map<String, dynamic>),
          softwareNm: json['SOFTWARE_NM'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['SOFTWARE_NM'] as Map<String, dynamic>),
          versionNm: json['VERSION_NM'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['VERSION_NM'] as Map<String, dynamic>),
          cnt: json['CNT'] == null
              ? null
              : DecimalNullableWithAggregatesFilter.fromJson(
                  json['CNT'] as Map<String, dynamic>),
          amount: json['AMOUNT'] == null
              ? null
              : IntNullableWithAggregatesFilter.fromJson(
                  json['AMOUNT'] as Map<String, dynamic>),
          buyDate: json['BUY_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['BUY_DATE'] as Map<String, dynamic>),
          serialNo: json['SERIAL_NO'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['SERIAL_NO'] as Map<String, dynamic>),
          licenseNo: json['LICENSE_NO'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['LICENSE_NO'] as Map<String, dynamic>),
          userNm: json['USER_NM'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['USER_NM'] as Map<String, dynamic>),
          remarks: json['REMARKS'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['REMARKS'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : DateTimeNullableWithAggregatesFilter.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$SOFTWAREASSETTBLScalarWhereWithAggregatesInputToJson(
    SOFTWAREASSETTBLScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('SOFTWARE_NM', instance.softwareNm?.toJson());
  writeNotNull('VERSION_NM', instance.versionNm?.toJson());
  writeNotNull('CNT', instance.cnt?.toJson());
  writeNotNull('AMOUNT', instance.amount?.toJson());
  writeNotNull('BUY_DATE', instance.buyDate?.toJson());
  writeNotNull('SERIAL_NO', instance.serialNo?.toJson());
  writeNotNull('LICENSE_NO', instance.licenseNo?.toJson());
  writeNotNull('USER_NM', instance.userNm?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

STADMINMENUWhereInput _$STADMINMENUWhereInputFromJson(
        Map<String, dynamic> json) =>
    STADMINMENUWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map(
          (e) => STADMINMENUWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map(
          (e) => STADMINMENUWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map(
          (e) => STADMINMENUWhereInput.fromJson(e as Map<String, dynamic>)),
      menuCd: json['MENU_CD'] == null
          ? null
          : StringFilter.fromJson(json['MENU_CD'] as Map<String, dynamic>),
      menuNm: json['MENU_NM'] == null
          ? null
          : StringFilter.fromJson(json['MENU_NM'] as Map<String, dynamic>),
      menuPath: json['MENU_PATH'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['MENU_PATH'] as Map<String, dynamic>),
      menuSrt: json['MENU_SRT'] == null
          ? null
          : IntFilter.fromJson(json['MENU_SRT'] as Map<String, dynamic>),
      menuDeps: json['MENU_DEPS'] == null
          ? null
          : IntFilter.fromJson(json['MENU_DEPS'] as Map<String, dynamic>),
      menuIcon: json['MENU_ICON'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['MENU_ICON'] as Map<String, dynamic>),
      menuTp: json['MENU_TP'] == null
          ? null
          : StringFilter.fromJson(json['MENU_TP'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFilter.fromJson(json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STADMINMENUWhereInputToJson(
    STADMINMENUWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('MENU_CD', instance.menuCd?.toJson());
  writeNotNull('MENU_NM', instance.menuNm?.toJson());
  writeNotNull('MENU_PATH', instance.menuPath?.toJson());
  writeNotNull('MENU_SRT', instance.menuSrt?.toJson());
  writeNotNull('MENU_DEPS', instance.menuDeps?.toJson());
  writeNotNull('MENU_ICON', instance.menuIcon?.toJson());
  writeNotNull('MENU_TP', instance.menuTp?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STADMINMENUOrderByWithRelationInput
    _$STADMINMENUOrderByWithRelationInputFromJson(Map<String, dynamic> json) =>
        STADMINMENUOrderByWithRelationInput(
          menuCd: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_CD']),
          menuNm: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_NM']),
          menuPath: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_PATH']),
          menuSrt: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_SRT']),
          menuDeps: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_DEPS']),
          menuIcon: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_ICON']),
          menuTp: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_TP']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$STADMINMENUOrderByWithRelationInputToJson(
    STADMINMENUOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_CD', _$SortOrderEnumMap[instance.menuCd]);
  writeNotNull('MENU_NM', _$SortOrderEnumMap[instance.menuNm]);
  writeNotNull('MENU_PATH', _$SortOrderEnumMap[instance.menuPath]);
  writeNotNull('MENU_SRT', _$SortOrderEnumMap[instance.menuSrt]);
  writeNotNull('MENU_DEPS', _$SortOrderEnumMap[instance.menuDeps]);
  writeNotNull('MENU_ICON', _$SortOrderEnumMap[instance.menuIcon]);
  writeNotNull('MENU_TP', _$SortOrderEnumMap[instance.menuTp]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STADMINMENUWhereUniqueInput _$STADMINMENUWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    STADMINMENUWhereUniqueInput(
      menuCd: json['MENU_CD'] as String?,
    );

Map<String, dynamic> _$STADMINMENUWhereUniqueInputToJson(
    STADMINMENUWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_CD', instance.menuCd);
  return val;
}

STADMINMENUOrderByWithAggregationInput
    _$STADMINMENUOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        STADMINMENUOrderByWithAggregationInput(
          menuCd: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_CD']),
          menuNm: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_NM']),
          menuPath: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_PATH']),
          menuSrt: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_SRT']),
          menuDeps: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_DEPS']),
          menuIcon: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_ICON']),
          menuTp: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_TP']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
          $count: json['_count'] == null
              ? null
              : STADMINMENUCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : STADMINMENUAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : STADMINMENUMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : STADMINMENUMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : STADMINMENUSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STADMINMENUOrderByWithAggregationInputToJson(
    STADMINMENUOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_CD', _$SortOrderEnumMap[instance.menuCd]);
  writeNotNull('MENU_NM', _$SortOrderEnumMap[instance.menuNm]);
  writeNotNull('MENU_PATH', _$SortOrderEnumMap[instance.menuPath]);
  writeNotNull('MENU_SRT', _$SortOrderEnumMap[instance.menuSrt]);
  writeNotNull('MENU_DEPS', _$SortOrderEnumMap[instance.menuDeps]);
  writeNotNull('MENU_ICON', _$SortOrderEnumMap[instance.menuIcon]);
  writeNotNull('MENU_TP', _$SortOrderEnumMap[instance.menuTp]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

STADMINMENUScalarWhereWithAggregatesInput
    _$STADMINMENUScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        STADMINMENUScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              STADMINMENUScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              STADMINMENUScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              STADMINMENUScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          menuCd: json['MENU_CD'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['MENU_CD'] as Map<String, dynamic>),
          menuNm: json['MENU_NM'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['MENU_NM'] as Map<String, dynamic>),
          menuPath: json['MENU_PATH'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['MENU_PATH'] as Map<String, dynamic>),
          menuSrt: json['MENU_SRT'] == null
              ? null
              : IntWithAggregatesFilter.fromJson(
                  json['MENU_SRT'] as Map<String, dynamic>),
          menuDeps: json['MENU_DEPS'] == null
              ? null
              : IntWithAggregatesFilter.fromJson(
                  json['MENU_DEPS'] as Map<String, dynamic>),
          menuIcon: json['MENU_ICON'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['MENU_ICON'] as Map<String, dynamic>),
          menuTp: json['MENU_TP'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['MENU_TP'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delId: json['DEL_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_ID'] as Map<String, dynamic>),
          delDate: json['DEL_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STADMINMENUScalarWhereWithAggregatesInputToJson(
    STADMINMENUScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('MENU_CD', instance.menuCd?.toJson());
  writeNotNull('MENU_NM', instance.menuNm?.toJson());
  writeNotNull('MENU_PATH', instance.menuPath?.toJson());
  writeNotNull('MENU_SRT', instance.menuSrt?.toJson());
  writeNotNull('MENU_DEPS', instance.menuDeps?.toJson());
  writeNotNull('MENU_ICON', instance.menuIcon?.toJson());
  writeNotNull('MENU_TP', instance.menuTp?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STALARMWhereInput _$STALARMWhereInputFromJson(Map<String, dynamic> json) =>
    STALARMWhereInput(
      AND: (json['AND'] as List<dynamic>?)
          ?.map((e) => STALARMWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)
          ?.map((e) => STALARMWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)
          ?.map((e) => STALARMWhereInput.fromJson(e as Map<String, dynamic>)),
      seq: json['SEQ'] == null
          ? null
          : IntFilter.fromJson(json['SEQ'] as Map<String, dynamic>),
      msgCd: json['MSG_CD'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['MSG_CD'] as Map<String, dynamic>),
      msgCnts: json['MSG_CNTS'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['MSG_CNTS'] as Map<String, dynamic>),
      sendDate: json['SEND_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['SEND_DATE'] as Map<String, dynamic>),
      sendDiv: json['SEND_DIV'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['SEND_DIV'] as Map<String, dynamic>),
      sendDeptCd: json['SEND_DEPT_CD'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['SEND_DEPT_CD'] as Map<String, dynamic>),
      sendId: json['SEND_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['SEND_ID'] as Map<String, dynamic>),
      recvId: json['RECV_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['RECV_ID'] as Map<String, dynamic>),
      popYn: json['POP_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['POP_YN'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STALARMWhereInputToJson(STALARMWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSG_CD', instance.msgCd?.toJson());
  writeNotNull('MSG_CNTS', instance.msgCnts?.toJson());
  writeNotNull('SEND_DATE', instance.sendDate?.toJson());
  writeNotNull('SEND_DIV', instance.sendDiv?.toJson());
  writeNotNull('SEND_DEPT_CD', instance.sendDeptCd?.toJson());
  writeNotNull('SEND_ID', instance.sendId?.toJson());
  writeNotNull('RECV_ID', instance.recvId?.toJson());
  writeNotNull('POP_YN', instance.popYn?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  return val;
}

STALARMOrderByWithRelationInput _$STALARMOrderByWithRelationInputFromJson(
        Map<String, dynamic> json) =>
    STALARMOrderByWithRelationInput(
      seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
      msgCd: $enumDecodeNullable(_$SortOrderEnumMap, json['MSG_CD']),
      msgCnts: $enumDecodeNullable(_$SortOrderEnumMap, json['MSG_CNTS']),
      sendDate: $enumDecodeNullable(_$SortOrderEnumMap, json['SEND_DATE']),
      sendDiv: $enumDecodeNullable(_$SortOrderEnumMap, json['SEND_DIV']),
      sendDeptCd: $enumDecodeNullable(_$SortOrderEnumMap, json['SEND_DEPT_CD']),
      sendId: $enumDecodeNullable(_$SortOrderEnumMap, json['SEND_ID']),
      recvId: $enumDecodeNullable(_$SortOrderEnumMap, json['RECV_ID']),
      popYn: $enumDecodeNullable(_$SortOrderEnumMap, json['POP_YN']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
    );

Map<String, dynamic> _$STALARMOrderByWithRelationInputToJson(
    STALARMOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSG_CD', _$SortOrderEnumMap[instance.msgCd]);
  writeNotNull('MSG_CNTS', _$SortOrderEnumMap[instance.msgCnts]);
  writeNotNull('SEND_DATE', _$SortOrderEnumMap[instance.sendDate]);
  writeNotNull('SEND_DIV', _$SortOrderEnumMap[instance.sendDiv]);
  writeNotNull('SEND_DEPT_CD', _$SortOrderEnumMap[instance.sendDeptCd]);
  writeNotNull('SEND_ID', _$SortOrderEnumMap[instance.sendId]);
  writeNotNull('RECV_ID', _$SortOrderEnumMap[instance.recvId]);
  writeNotNull('POP_YN', _$SortOrderEnumMap[instance.popYn]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  return val;
}

STALARMWhereUniqueInput _$STALARMWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    STALARMWhereUniqueInput(
      seq: json['SEQ'] as int?,
    );

Map<String, dynamic> _$STALARMWhereUniqueInputToJson(
    STALARMWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq);
  return val;
}

STALARMOrderByWithAggregationInput _$STALARMOrderByWithAggregationInputFromJson(
        Map<String, dynamic> json) =>
    STALARMOrderByWithAggregationInput(
      seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
      msgCd: $enumDecodeNullable(_$SortOrderEnumMap, json['MSG_CD']),
      msgCnts: $enumDecodeNullable(_$SortOrderEnumMap, json['MSG_CNTS']),
      sendDate: $enumDecodeNullable(_$SortOrderEnumMap, json['SEND_DATE']),
      sendDiv: $enumDecodeNullable(_$SortOrderEnumMap, json['SEND_DIV']),
      sendDeptCd: $enumDecodeNullable(_$SortOrderEnumMap, json['SEND_DEPT_CD']),
      sendId: $enumDecodeNullable(_$SortOrderEnumMap, json['SEND_ID']),
      recvId: $enumDecodeNullable(_$SortOrderEnumMap, json['RECV_ID']),
      popYn: $enumDecodeNullable(_$SortOrderEnumMap, json['POP_YN']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      $count: json['_count'] == null
          ? null
          : STALARMCountOrderByAggregateInput.fromJson(
              json['_count'] as Map<String, dynamic>),
      $avg: json['_avg'] == null
          ? null
          : STALARMAvgOrderByAggregateInput.fromJson(
              json['_avg'] as Map<String, dynamic>),
      $max: json['_max'] == null
          ? null
          : STALARMMaxOrderByAggregateInput.fromJson(
              json['_max'] as Map<String, dynamic>),
      $min: json['_min'] == null
          ? null
          : STALARMMinOrderByAggregateInput.fromJson(
              json['_min'] as Map<String, dynamic>),
      $sum: json['_sum'] == null
          ? null
          : STALARMSumOrderByAggregateInput.fromJson(
              json['_sum'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STALARMOrderByWithAggregationInputToJson(
    STALARMOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSG_CD', _$SortOrderEnumMap[instance.msgCd]);
  writeNotNull('MSG_CNTS', _$SortOrderEnumMap[instance.msgCnts]);
  writeNotNull('SEND_DATE', _$SortOrderEnumMap[instance.sendDate]);
  writeNotNull('SEND_DIV', _$SortOrderEnumMap[instance.sendDiv]);
  writeNotNull('SEND_DEPT_CD', _$SortOrderEnumMap[instance.sendDeptCd]);
  writeNotNull('SEND_ID', _$SortOrderEnumMap[instance.sendId]);
  writeNotNull('RECV_ID', _$SortOrderEnumMap[instance.recvId]);
  writeNotNull('POP_YN', _$SortOrderEnumMap[instance.popYn]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

STALARMScalarWhereWithAggregatesInput
    _$STALARMScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        STALARMScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              STALARMScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              STALARMScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              STALARMScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          seq: json['SEQ'] == null
              ? null
              : IntWithAggregatesFilter.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          msgCd: json['MSG_CD'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['MSG_CD'] as Map<String, dynamic>),
          msgCnts: json['MSG_CNTS'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['MSG_CNTS'] as Map<String, dynamic>),
          sendDate: json['SEND_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['SEND_DATE'] as Map<String, dynamic>),
          sendDiv: json['SEND_DIV'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['SEND_DIV'] as Map<String, dynamic>),
          sendDeptCd: json['SEND_DEPT_CD'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['SEND_DEPT_CD'] as Map<String, dynamic>),
          sendId: json['SEND_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['SEND_ID'] as Map<String, dynamic>),
          recvId: json['RECV_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['RECV_ID'] as Map<String, dynamic>),
          popYn: json['POP_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['POP_YN'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STALARMScalarWhereWithAggregatesInputToJson(
    STALARMScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSG_CD', instance.msgCd?.toJson());
  writeNotNull('MSG_CNTS', instance.msgCnts?.toJson());
  writeNotNull('SEND_DATE', instance.sendDate?.toJson());
  writeNotNull('SEND_DIV', instance.sendDiv?.toJson());
  writeNotNull('SEND_DEPT_CD', instance.sendDeptCd?.toJson());
  writeNotNull('SEND_ID', instance.sendId?.toJson());
  writeNotNull('RECV_ID', instance.recvId?.toJson());
  writeNotNull('POP_YN', instance.popYn?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  return val;
}

STAUDITLOGWhereInput _$STAUDITLOGWhereInputFromJson(
        Map<String, dynamic> json) =>
    STAUDITLOGWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map(
          (e) => STAUDITLOGWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map(
          (e) => STAUDITLOGWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map(
          (e) => STAUDITLOGWhereInput.fromJson(e as Map<String, dynamic>)),
      seq: json['SEQ'] == null
          ? null
          : IntFilter.fromJson(json['SEQ'] as Map<String, dynamic>),
      logCode: json['LOG_CODE'] == null
          ? null
          : StringFilter.fromJson(json['LOG_CODE'] as Map<String, dynamic>),
      logCnts: json['LOG_CNTS'] == null
          ? null
          : StringFilter.fromJson(json['LOG_CNTS'] as Map<String, dynamic>),
      errCode: json['ERR_CODE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['ERR_CODE'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFilter.fromJson(json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STAUDITLOGWhereInputToJson(
    STAUDITLOGWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('LOG_CODE', instance.logCode?.toJson());
  writeNotNull('LOG_CNTS', instance.logCnts?.toJson());
  writeNotNull('ERR_CODE', instance.errCode?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STAUDITLOGOrderByWithRelationInput _$STAUDITLOGOrderByWithRelationInputFromJson(
        Map<String, dynamic> json) =>
    STAUDITLOGOrderByWithRelationInput(
      seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
      logCode: $enumDecodeNullable(_$SortOrderEnumMap, json['LOG_CODE']),
      logCnts: $enumDecodeNullable(_$SortOrderEnumMap, json['LOG_CNTS']),
      errCode: $enumDecodeNullable(_$SortOrderEnumMap, json['ERR_CODE']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STAUDITLOGOrderByWithRelationInputToJson(
    STAUDITLOGOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('LOG_CODE', _$SortOrderEnumMap[instance.logCode]);
  writeNotNull('LOG_CNTS', _$SortOrderEnumMap[instance.logCnts]);
  writeNotNull('ERR_CODE', _$SortOrderEnumMap[instance.errCode]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STAUDITLOGWhereUniqueInput _$STAUDITLOGWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    STAUDITLOGWhereUniqueInput(
      seq: json['SEQ'] as int?,
    );

Map<String, dynamic> _$STAUDITLOGWhereUniqueInputToJson(
    STAUDITLOGWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq);
  return val;
}

STAUDITLOGOrderByWithAggregationInput
    _$STAUDITLOGOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        STAUDITLOGOrderByWithAggregationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          logCode: $enumDecodeNullable(_$SortOrderEnumMap, json['LOG_CODE']),
          logCnts: $enumDecodeNullable(_$SortOrderEnumMap, json['LOG_CNTS']),
          errCode: $enumDecodeNullable(_$SortOrderEnumMap, json['ERR_CODE']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
          $count: json['_count'] == null
              ? null
              : STAUDITLOGCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : STAUDITLOGAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : STAUDITLOGMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : STAUDITLOGMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : STAUDITLOGSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STAUDITLOGOrderByWithAggregationInputToJson(
    STAUDITLOGOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('LOG_CODE', _$SortOrderEnumMap[instance.logCode]);
  writeNotNull('LOG_CNTS', _$SortOrderEnumMap[instance.logCnts]);
  writeNotNull('ERR_CODE', _$SortOrderEnumMap[instance.errCode]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

STAUDITLOGScalarWhereWithAggregatesInput
    _$STAUDITLOGScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        STAUDITLOGScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              STAUDITLOGScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              STAUDITLOGScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              STAUDITLOGScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          seq: json['SEQ'] == null
              ? null
              : IntWithAggregatesFilter.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          logCode: json['LOG_CODE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['LOG_CODE'] as Map<String, dynamic>),
          logCnts: json['LOG_CNTS'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['LOG_CNTS'] as Map<String, dynamic>),
          errCode: json['ERR_CODE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['ERR_CODE'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delId: json['DEL_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_ID'] as Map<String, dynamic>),
          delDate: json['DEL_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STAUDITLOGScalarWhereWithAggregatesInputToJson(
    STAUDITLOGScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('LOG_CODE', instance.logCode?.toJson());
  writeNotNull('LOG_CNTS', instance.logCnts?.toJson());
  writeNotNull('ERR_CODE', instance.errCode?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STBANNERWhereInput _$STBANNERWhereInputFromJson(Map<String, dynamic> json) =>
    STBANNERWhereInput(
      AND: (json['AND'] as List<dynamic>?)
          ?.map((e) => STBANNERWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)
          ?.map((e) => STBANNERWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)
          ?.map((e) => STBANNERWhereInput.fromJson(e as Map<String, dynamic>)),
      bannerCd: json['BANNER_CD'] == null
          ? null
          : StringFilter.fromJson(json['BANNER_CD'] as Map<String, dynamic>),
      lkUrl: json['LK_URL'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['LK_URL'] as Map<String, dynamic>),
      lkTarget: json['LK_TARGET'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['LK_TARGET'] as Map<String, dynamic>),
      flpth: json['FLPTH'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['FLPTH'] as Map<String, dynamic>),
      fileNm: json['FILE_NM'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['FILE_NM'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFilter.fromJson(json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STBANNERWhereInputToJson(STBANNERWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('BANNER_CD', instance.bannerCd?.toJson());
  writeNotNull('LK_URL', instance.lkUrl?.toJson());
  writeNotNull('LK_TARGET', instance.lkTarget?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('FILE_NM', instance.fileNm?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STBANNEROrderByWithRelationInput _$STBANNEROrderByWithRelationInputFromJson(
        Map<String, dynamic> json) =>
    STBANNEROrderByWithRelationInput(
      bannerCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BANNER_CD']),
      lkUrl: $enumDecodeNullable(_$SortOrderEnumMap, json['LK_URL']),
      lkTarget: $enumDecodeNullable(_$SortOrderEnumMap, json['LK_TARGET']),
      flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
      fileNm: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_NM']),
      useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STBANNEROrderByWithRelationInputToJson(
    STBANNEROrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BANNER_CD', _$SortOrderEnumMap[instance.bannerCd]);
  writeNotNull('LK_URL', _$SortOrderEnumMap[instance.lkUrl]);
  writeNotNull('LK_TARGET', _$SortOrderEnumMap[instance.lkTarget]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('FILE_NM', _$SortOrderEnumMap[instance.fileNm]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STBANNERWhereUniqueInput _$STBANNERWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    STBANNERWhereUniqueInput(
      bannerCd: json['BANNER_CD'] as String?,
    );

Map<String, dynamic> _$STBANNERWhereUniqueInputToJson(
    STBANNERWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BANNER_CD', instance.bannerCd);
  return val;
}

STBANNEROrderByWithAggregationInput
    _$STBANNEROrderByWithAggregationInputFromJson(Map<String, dynamic> json) =>
        STBANNEROrderByWithAggregationInput(
          bannerCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BANNER_CD']),
          lkUrl: $enumDecodeNullable(_$SortOrderEnumMap, json['LK_URL']),
          lkTarget: $enumDecodeNullable(_$SortOrderEnumMap, json['LK_TARGET']),
          flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
          fileNm: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_NM']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
          $count: json['_count'] == null
              ? null
              : STBANNERCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : STBANNERMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : STBANNERMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STBANNEROrderByWithAggregationInputToJson(
    STBANNEROrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BANNER_CD', _$SortOrderEnumMap[instance.bannerCd]);
  writeNotNull('LK_URL', _$SortOrderEnumMap[instance.lkUrl]);
  writeNotNull('LK_TARGET', _$SortOrderEnumMap[instance.lkTarget]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('FILE_NM', _$SortOrderEnumMap[instance.fileNm]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  return val;
}

STBANNERScalarWhereWithAggregatesInput
    _$STBANNERScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        STBANNERScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              STBANNERScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              STBANNERScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              STBANNERScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          bannerCd: json['BANNER_CD'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['BANNER_CD'] as Map<String, dynamic>),
          lkUrl: json['LK_URL'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['LK_URL'] as Map<String, dynamic>),
          lkTarget: json['LK_TARGET'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['LK_TARGET'] as Map<String, dynamic>),
          flpth: json['FLPTH'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['FLPTH'] as Map<String, dynamic>),
          fileNm: json['FILE_NM'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['FILE_NM'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delId: json['DEL_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_ID'] as Map<String, dynamic>),
          delDate: json['DEL_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STBANNERScalarWhereWithAggregatesInputToJson(
    STBANNERScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('BANNER_CD', instance.bannerCd?.toJson());
  writeNotNull('LK_URL', instance.lkUrl?.toJson());
  writeNotNull('LK_TARGET', instance.lkTarget?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('FILE_NM', instance.fileNm?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STBOARDCOLUMNWhereInput _$STBOARDCOLUMNWhereInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDCOLUMNWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map(
          (e) => STBOARDCOLUMNWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map(
          (e) => STBOARDCOLUMNWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map(
          (e) => STBOARDCOLUMNWhereInput.fromJson(e as Map<String, dynamic>)),
      boardCd: json['BOARD_CD'] == null
          ? null
          : StringFilter.fromJson(json['BOARD_CD'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : IntFilter.fromJson(json['SORT'] as Map<String, dynamic>),
      colCd: json['COL_CD'] == null
          ? null
          : StringFilter.fromJson(json['COL_CD'] as Map<String, dynamic>),
      colNm: json['COL_NM'] == null
          ? null
          : StringFilter.fromJson(json['COL_NM'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFilter.fromJson(json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STBOARDCOLUMNWhereInputToJson(
    STBOARDCOLUMNWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('BOARD_CD', instance.boardCd?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('COL_CD', instance.colCd?.toJson());
  writeNotNull('COL_NM', instance.colNm?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

STBOARDCOLUMNOrderByWithRelationInput
    _$STBOARDCOLUMNOrderByWithRelationInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDCOLUMNOrderByWithRelationInput(
          boardCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_CD']),
          sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
          colCd: $enumDecodeNullable(_$SortOrderEnumMap, json['COL_CD']),
          colNm: $enumDecodeNullable(_$SortOrderEnumMap, json['COL_NM']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
        );

Map<String, dynamic> _$STBOARDCOLUMNOrderByWithRelationInputToJson(
    STBOARDCOLUMNOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_CD', _$SortOrderEnumMap[instance.boardCd]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('COL_CD', _$SortOrderEnumMap[instance.colCd]);
  writeNotNull('COL_NM', _$SortOrderEnumMap[instance.colNm]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  return val;
}

STBOARDCOLUMNWhereUniqueInput _$STBOARDCOLUMNWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDCOLUMNWhereUniqueInput(
      boardCdColCd: json['BOARD_CD_COL_CD'] == null
          ? null
          : STBOARDCOLUMNBOARDCDCOLCDCompoundUniqueInput.fromJson(
              json['BOARD_CD_COL_CD'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STBOARDCOLUMNWhereUniqueInputToJson(
    STBOARDCOLUMNWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_CD_COL_CD', instance.boardCdColCd?.toJson());
  return val;
}

STBOARDCOLUMNOrderByWithAggregationInput
    _$STBOARDCOLUMNOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDCOLUMNOrderByWithAggregationInput(
          boardCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_CD']),
          sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
          colCd: $enumDecodeNullable(_$SortOrderEnumMap, json['COL_CD']),
          colNm: $enumDecodeNullable(_$SortOrderEnumMap, json['COL_NM']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          $count: json['_count'] == null
              ? null
              : STBOARDCOLUMNCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : STBOARDCOLUMNAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : STBOARDCOLUMNMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : STBOARDCOLUMNMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : STBOARDCOLUMNSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STBOARDCOLUMNOrderByWithAggregationInputToJson(
    STBOARDCOLUMNOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_CD', _$SortOrderEnumMap[instance.boardCd]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('COL_CD', _$SortOrderEnumMap[instance.colCd]);
  writeNotNull('COL_NM', _$SortOrderEnumMap[instance.colNm]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

STBOARDCOLUMNScalarWhereWithAggregatesInput
    _$STBOARDCOLUMNScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDCOLUMNScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              STBOARDCOLUMNScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              STBOARDCOLUMNScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              STBOARDCOLUMNScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          boardCd: json['BOARD_CD'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['BOARD_CD'] as Map<String, dynamic>),
          sort: json['SORT'] == null
              ? null
              : IntWithAggregatesFilter.fromJson(
                  json['SORT'] as Map<String, dynamic>),
          colCd: json['COL_CD'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['COL_CD'] as Map<String, dynamic>),
          colNm: json['COL_NM'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['COL_NM'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STBOARDCOLUMNScalarWhereWithAggregatesInputToJson(
    STBOARDCOLUMNScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('BOARD_CD', instance.boardCd?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('COL_CD', instance.colCd?.toJson());
  writeNotNull('COL_NM', instance.colNm?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

STBOARDCOLUMNDFTWhereInput _$STBOARDCOLUMNDFTWhereInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDCOLUMNDFTWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map((e) =>
          STBOARDCOLUMNDFTWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map((e) =>
          STBOARDCOLUMNDFTWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
          STBOARDCOLUMNDFTWhereInput.fromJson(e as Map<String, dynamic>)),
      boardTy: json['BOARD_TY'] == null
          ? null
          : StringFilter.fromJson(json['BOARD_TY'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : IntFilter.fromJson(json['SORT'] as Map<String, dynamic>),
      colCd: json['COL_CD'] == null
          ? null
          : StringFilter.fromJson(json['COL_CD'] as Map<String, dynamic>),
      colNm: json['COL_NM'] == null
          ? null
          : StringFilter.fromJson(json['COL_NM'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringFilter.fromJson(json['DEL_YN'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STBOARDCOLUMNDFTWhereInputToJson(
    STBOARDCOLUMNDFTWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('BOARD_TY', instance.boardTy?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('COL_CD', instance.colCd?.toJson());
  writeNotNull('COL_NM', instance.colNm?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

STBOARDCOLUMNDFTOrderByWithRelationInput
    _$STBOARDCOLUMNDFTOrderByWithRelationInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDCOLUMNDFTOrderByWithRelationInput(
          boardTy: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_TY']),
          sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
          colCd: $enumDecodeNullable(_$SortOrderEnumMap, json['COL_CD']),
          colNm: $enumDecodeNullable(_$SortOrderEnumMap, json['COL_NM']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$STBOARDCOLUMNDFTOrderByWithRelationInputToJson(
    STBOARDCOLUMNDFTOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_TY', _$SortOrderEnumMap[instance.boardTy]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('COL_CD', _$SortOrderEnumMap[instance.colCd]);
  writeNotNull('COL_NM', _$SortOrderEnumMap[instance.colNm]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

STBOARDCOLUMNDFTWhereUniqueInput _$STBOARDCOLUMNDFTWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDCOLUMNDFTWhereUniqueInput(
      boardTyColCdDelYn: json['BOARD_TY_COL_CD_DEL_YN'] == null
          ? null
          : STBOARDCOLUMNDFTBOARDTYCOLCDDELYNCompoundUniqueInput.fromJson(
              json['BOARD_TY_COL_CD_DEL_YN'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STBOARDCOLUMNDFTWhereUniqueInputToJson(
    STBOARDCOLUMNDFTWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_TY_COL_CD_DEL_YN', instance.boardTyColCdDelYn?.toJson());
  return val;
}

STBOARDCOLUMNDFTOrderByWithAggregationInput
    _$STBOARDCOLUMNDFTOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDCOLUMNDFTOrderByWithAggregationInput(
          boardTy: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_TY']),
          sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
          colCd: $enumDecodeNullable(_$SortOrderEnumMap, json['COL_CD']),
          colNm: $enumDecodeNullable(_$SortOrderEnumMap, json['COL_NM']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          $count: json['_count'] == null
              ? null
              : STBOARDCOLUMNDFTCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : STBOARDCOLUMNDFTAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : STBOARDCOLUMNDFTMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : STBOARDCOLUMNDFTMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : STBOARDCOLUMNDFTSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STBOARDCOLUMNDFTOrderByWithAggregationInputToJson(
    STBOARDCOLUMNDFTOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_TY', _$SortOrderEnumMap[instance.boardTy]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('COL_CD', _$SortOrderEnumMap[instance.colCd]);
  writeNotNull('COL_NM', _$SortOrderEnumMap[instance.colNm]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

STBOARDCOLUMNDFTScalarWhereWithAggregatesInput
    _$STBOARDCOLUMNDFTScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDCOLUMNDFTScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              STBOARDCOLUMNDFTScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              STBOARDCOLUMNDFTScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              STBOARDCOLUMNDFTScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          boardTy: json['BOARD_TY'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['BOARD_TY'] as Map<String, dynamic>),
          sort: json['SORT'] == null
              ? null
              : IntWithAggregatesFilter.fromJson(
                  json['SORT'] as Map<String, dynamic>),
          colCd: json['COL_CD'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['COL_CD'] as Map<String, dynamic>),
          colNm: json['COL_NM'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['COL_NM'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STBOARDCOLUMNDFTScalarWhereWithAggregatesInputToJson(
    STBOARDCOLUMNDFTScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('BOARD_TY', instance.boardTy?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('COL_CD', instance.colCd?.toJson());
  writeNotNull('COL_NM', instance.colNm?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

STBOARDCOMMENTWhereInput _$STBOARDCOMMENTWhereInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDCOMMENTWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map(
          (e) => STBOARDCOMMENTWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map(
          (e) => STBOARDCOMMENTWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map(
          (e) => STBOARDCOMMENTWhereInput.fromJson(e as Map<String, dynamic>)),
      seq: json['SEQ'] == null
          ? null
          : IntFilter.fromJson(json['SEQ'] as Map<String, dynamic>),
      mseq: json['MSEQ'] == null
          ? null
          : IntFilter.fromJson(json['MSEQ'] as Map<String, dynamic>),
      boardCd: json['BOARD_CD'] == null
          ? null
          : StringFilter.fromJson(json['BOARD_CD'] as Map<String, dynamic>),
      cnts: json['CNTS'] == null
          ? null
          : StringNullableFilter.fromJson(json['CNTS'] as Map<String, dynamic>),
      upperSeq: json['UPPER_SEQ'] == null
          ? null
          : IntNullableFilter.fromJson(
              json['UPPER_SEQ'] as Map<String, dynamic>),
      replyYn: json['REPLY_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['REPLY_YN'] as Map<String, dynamic>),
      regAdminYn: json['REG_ADMIN_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['REG_ADMIN_YN'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFilter.fromJson(json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STBOARDCOMMENTWhereInputToJson(
    STBOARDCOMMENTWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('BOARD_CD', instance.boardCd?.toJson());
  writeNotNull('CNTS', instance.cnts?.toJson());
  writeNotNull('UPPER_SEQ', instance.upperSeq?.toJson());
  writeNotNull('REPLY_YN', instance.replyYn?.toJson());
  writeNotNull('REG_ADMIN_YN', instance.regAdminYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STBOARDCOMMENTOrderByWithRelationInput
    _$STBOARDCOMMENTOrderByWithRelationInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDCOMMENTOrderByWithRelationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          boardCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_CD']),
          cnts: $enumDecodeNullable(_$SortOrderEnumMap, json['CNTS']),
          upperSeq: $enumDecodeNullable(_$SortOrderEnumMap, json['UPPER_SEQ']),
          replyYn: $enumDecodeNullable(_$SortOrderEnumMap, json['REPLY_YN']),
          regAdminYn:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ADMIN_YN']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$STBOARDCOMMENTOrderByWithRelationInputToJson(
    STBOARDCOMMENTOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('BOARD_CD', _$SortOrderEnumMap[instance.boardCd]);
  writeNotNull('CNTS', _$SortOrderEnumMap[instance.cnts]);
  writeNotNull('UPPER_SEQ', _$SortOrderEnumMap[instance.upperSeq]);
  writeNotNull('REPLY_YN', _$SortOrderEnumMap[instance.replyYn]);
  writeNotNull('REG_ADMIN_YN', _$SortOrderEnumMap[instance.regAdminYn]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STBOARDCOMMENTWhereUniqueInput _$STBOARDCOMMENTWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDCOMMENTWhereUniqueInput(
      seqMseqBoardCd: json['SEQ_MSEQ_BOARD_CD'] == null
          ? null
          : STBOARDCOMMENTSEQMSEQBOARDCDCompoundUniqueInput.fromJson(
              json['SEQ_MSEQ_BOARD_CD'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STBOARDCOMMENTWhereUniqueInputToJson(
    STBOARDCOMMENTWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ_MSEQ_BOARD_CD', instance.seqMseqBoardCd?.toJson());
  return val;
}

STBOARDCOMMENTOrderByWithAggregationInput
    _$STBOARDCOMMENTOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDCOMMENTOrderByWithAggregationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          boardCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_CD']),
          cnts: $enumDecodeNullable(_$SortOrderEnumMap, json['CNTS']),
          upperSeq: $enumDecodeNullable(_$SortOrderEnumMap, json['UPPER_SEQ']),
          replyYn: $enumDecodeNullable(_$SortOrderEnumMap, json['REPLY_YN']),
          regAdminYn:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ADMIN_YN']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
          $count: json['_count'] == null
              ? null
              : STBOARDCOMMENTCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : STBOARDCOMMENTAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : STBOARDCOMMENTMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : STBOARDCOMMENTMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : STBOARDCOMMENTSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STBOARDCOMMENTOrderByWithAggregationInputToJson(
    STBOARDCOMMENTOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('BOARD_CD', _$SortOrderEnumMap[instance.boardCd]);
  writeNotNull('CNTS', _$SortOrderEnumMap[instance.cnts]);
  writeNotNull('UPPER_SEQ', _$SortOrderEnumMap[instance.upperSeq]);
  writeNotNull('REPLY_YN', _$SortOrderEnumMap[instance.replyYn]);
  writeNotNull('REG_ADMIN_YN', _$SortOrderEnumMap[instance.regAdminYn]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

STBOARDCOMMENTScalarWhereWithAggregatesInput
    _$STBOARDCOMMENTScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDCOMMENTScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              STBOARDCOMMENTScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              STBOARDCOMMENTScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              STBOARDCOMMENTScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          seq: json['SEQ'] == null
              ? null
              : IntWithAggregatesFilter.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          mseq: json['MSEQ'] == null
              ? null
              : IntWithAggregatesFilter.fromJson(
                  json['MSEQ'] as Map<String, dynamic>),
          boardCd: json['BOARD_CD'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['BOARD_CD'] as Map<String, dynamic>),
          cnts: json['CNTS'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['CNTS'] as Map<String, dynamic>),
          upperSeq: json['UPPER_SEQ'] == null
              ? null
              : IntNullableWithAggregatesFilter.fromJson(
                  json['UPPER_SEQ'] as Map<String, dynamic>),
          replyYn: json['REPLY_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['REPLY_YN'] as Map<String, dynamic>),
          regAdminYn: json['REG_ADMIN_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['REG_ADMIN_YN'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delId: json['DEL_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_ID'] as Map<String, dynamic>),
          delDate: json['DEL_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STBOARDCOMMENTScalarWhereWithAggregatesInputToJson(
    STBOARDCOMMENTScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('BOARD_CD', instance.boardCd?.toJson());
  writeNotNull('CNTS', instance.cnts?.toJson());
  writeNotNull('UPPER_SEQ', instance.upperSeq?.toJson());
  writeNotNull('REPLY_YN', instance.replyYn?.toJson());
  writeNotNull('REG_ADMIN_YN', instance.regAdminYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STBOARDFILEWhereInput _$STBOARDFILEWhereInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDFILEWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map(
          (e) => STBOARDFILEWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map(
          (e) => STBOARDFILEWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map(
          (e) => STBOARDFILEWhereInput.fromJson(e as Map<String, dynamic>)),
      seq: json['SEQ'] == null
          ? null
          : IntFilter.fromJson(json['SEQ'] as Map<String, dynamic>),
      mseq: json['MSEQ'] == null
          ? null
          : IntFilter.fromJson(json['MSEQ'] as Map<String, dynamic>),
      boardCd: json['BOARD_CD'] == null
          ? null
          : StringFilter.fromJson(json['BOARD_CD'] as Map<String, dynamic>),
      fileTp: json['FILE_TP'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['FILE_TP'] as Map<String, dynamic>),
      flpth: json['FLPTH'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['FLPTH'] as Map<String, dynamic>),
      orginalFileNm: json['ORGINAL_FILE_NM'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['ORGINAL_FILE_NM'] as Map<String, dynamic>),
      streFileNm: json['STRE_FILE_NM'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['STRE_FILE_NM'] as Map<String, dynamic>),
      fileSize: json['FILE_SIZE'] == null
          ? null
          : IntNullableFilter.fromJson(
              json['FILE_SIZE'] as Map<String, dynamic>),
      repreYn: json['REPRE_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['REPRE_YN'] as Map<String, dynamic>),
      dwldCo: json['DWLD_CO'] == null
          ? null
          : IntNullableFilter.fromJson(json['DWLD_CO'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STBOARDFILEWhereInputToJson(
    STBOARDFILEWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('BOARD_CD', instance.boardCd?.toJson());
  writeNotNull('FILE_TP', instance.fileTp?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm?.toJson());
  writeNotNull('STRE_FILE_NM', instance.streFileNm?.toJson());
  writeNotNull('FILE_SIZE', instance.fileSize?.toJson());
  writeNotNull('REPRE_YN', instance.repreYn?.toJson());
  writeNotNull('DWLD_CO', instance.dwldCo?.toJson());
  return val;
}

STBOARDFILEOrderByWithRelationInput
    _$STBOARDFILEOrderByWithRelationInputFromJson(Map<String, dynamic> json) =>
        STBOARDFILEOrderByWithRelationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          boardCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_CD']),
          fileTp: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_TP']),
          flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
          orginalFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ORGINAL_FILE_NM']),
          streFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['STRE_FILE_NM']),
          fileSize: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_SIZE']),
          repreYn: $enumDecodeNullable(_$SortOrderEnumMap, json['REPRE_YN']),
          dwldCo: $enumDecodeNullable(_$SortOrderEnumMap, json['DWLD_CO']),
        );

Map<String, dynamic> _$STBOARDFILEOrderByWithRelationInputToJson(
    STBOARDFILEOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('BOARD_CD', _$SortOrderEnumMap[instance.boardCd]);
  writeNotNull('FILE_TP', _$SortOrderEnumMap[instance.fileTp]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('ORGINAL_FILE_NM', _$SortOrderEnumMap[instance.orginalFileNm]);
  writeNotNull('STRE_FILE_NM', _$SortOrderEnumMap[instance.streFileNm]);
  writeNotNull('FILE_SIZE', _$SortOrderEnumMap[instance.fileSize]);
  writeNotNull('REPRE_YN', _$SortOrderEnumMap[instance.repreYn]);
  writeNotNull('DWLD_CO', _$SortOrderEnumMap[instance.dwldCo]);
  return val;
}

STBOARDFILEWhereUniqueInput _$STBOARDFILEWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDFILEWhereUniqueInput(
      seqMseqBoardCd: json['SEQ_MSEQ_BOARD_CD'] == null
          ? null
          : STBOARDFILESEQMSEQBOARDCDCompoundUniqueInput.fromJson(
              json['SEQ_MSEQ_BOARD_CD'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STBOARDFILEWhereUniqueInputToJson(
    STBOARDFILEWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ_MSEQ_BOARD_CD', instance.seqMseqBoardCd?.toJson());
  return val;
}

STBOARDFILEOrderByWithAggregationInput
    _$STBOARDFILEOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDFILEOrderByWithAggregationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          boardCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_CD']),
          fileTp: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_TP']),
          flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
          orginalFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ORGINAL_FILE_NM']),
          streFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['STRE_FILE_NM']),
          fileSize: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_SIZE']),
          repreYn: $enumDecodeNullable(_$SortOrderEnumMap, json['REPRE_YN']),
          dwldCo: $enumDecodeNullable(_$SortOrderEnumMap, json['DWLD_CO']),
          $count: json['_count'] == null
              ? null
              : STBOARDFILECountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : STBOARDFILEAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : STBOARDFILEMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : STBOARDFILEMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : STBOARDFILESumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STBOARDFILEOrderByWithAggregationInputToJson(
    STBOARDFILEOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('BOARD_CD', _$SortOrderEnumMap[instance.boardCd]);
  writeNotNull('FILE_TP', _$SortOrderEnumMap[instance.fileTp]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('ORGINAL_FILE_NM', _$SortOrderEnumMap[instance.orginalFileNm]);
  writeNotNull('STRE_FILE_NM', _$SortOrderEnumMap[instance.streFileNm]);
  writeNotNull('FILE_SIZE', _$SortOrderEnumMap[instance.fileSize]);
  writeNotNull('REPRE_YN', _$SortOrderEnumMap[instance.repreYn]);
  writeNotNull('DWLD_CO', _$SortOrderEnumMap[instance.dwldCo]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

STBOARDFILEScalarWhereWithAggregatesInput
    _$STBOARDFILEScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDFILEScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              STBOARDFILEScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              STBOARDFILEScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              STBOARDFILEScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          seq: json['SEQ'] == null
              ? null
              : IntWithAggregatesFilter.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          mseq: json['MSEQ'] == null
              ? null
              : IntWithAggregatesFilter.fromJson(
                  json['MSEQ'] as Map<String, dynamic>),
          boardCd: json['BOARD_CD'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['BOARD_CD'] as Map<String, dynamic>),
          fileTp: json['FILE_TP'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['FILE_TP'] as Map<String, dynamic>),
          flpth: json['FLPTH'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['FLPTH'] as Map<String, dynamic>),
          orginalFileNm: json['ORGINAL_FILE_NM'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['ORGINAL_FILE_NM'] as Map<String, dynamic>),
          streFileNm: json['STRE_FILE_NM'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['STRE_FILE_NM'] as Map<String, dynamic>),
          fileSize: json['FILE_SIZE'] == null
              ? null
              : IntNullableWithAggregatesFilter.fromJson(
                  json['FILE_SIZE'] as Map<String, dynamic>),
          repreYn: json['REPRE_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['REPRE_YN'] as Map<String, dynamic>),
          dwldCo: json['DWLD_CO'] == null
              ? null
              : IntNullableWithAggregatesFilter.fromJson(
                  json['DWLD_CO'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STBOARDFILEScalarWhereWithAggregatesInputToJson(
    STBOARDFILEScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('BOARD_CD', instance.boardCd?.toJson());
  writeNotNull('FILE_TP', instance.fileTp?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm?.toJson());
  writeNotNull('STRE_FILE_NM', instance.streFileNm?.toJson());
  writeNotNull('FILE_SIZE', instance.fileSize?.toJson());
  writeNotNull('REPRE_YN', instance.repreYn?.toJson());
  writeNotNull('DWLD_CO', instance.dwldCo?.toJson());
  return val;
}

STBOARDMSTWhereInput _$STBOARDMSTWhereInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDMSTWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map(
          (e) => STBOARDMSTWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map(
          (e) => STBOARDMSTWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map(
          (e) => STBOARDMSTWhereInput.fromJson(e as Map<String, dynamic>)),
      seq: json['SEQ'] == null
          ? null
          : IntFilter.fromJson(json['SEQ'] as Map<String, dynamic>),
      boardCd: json['BOARD_CD'] == null
          ? null
          : StringFilter.fromJson(json['BOARD_CD'] as Map<String, dynamic>),
      clsCd: json['CLS_CD'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['CLS_CD'] as Map<String, dynamic>),
      ttl: json['TTL'] == null
          ? null
          : StringFilter.fromJson(json['TTL'] as Map<String, dynamic>),
      cnts: json['CNTS'] == null
          ? null
          : StringFilter.fromJson(json['CNTS'] as Map<String, dynamic>),
      fileYn: json['FILE_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['FILE_YN'] as Map<String, dynamic>),
      imageYn: json['IMAGE_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['IMAGE_YN'] as Map<String, dynamic>),
      noticeYn: json['NOTICE_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['NOTICE_YN'] as Map<String, dynamic>),
      lkUrl: json['LK_URL'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['LK_URL'] as Map<String, dynamic>),
      lkTarget: json['LK_TARGET'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['LK_TARGET'] as Map<String, dynamic>),
      readCnt: json['READ_CNT'] == null
          ? null
          : IntNullableFilter.fromJson(
              json['READ_CNT'] as Map<String, dynamic>),
      regAdminYn: json['REG_ADMIN_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['REG_ADMIN_YN'] as Map<String, dynamic>),
      replyYn: json['REPLY_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['REPLY_YN'] as Map<String, dynamic>),
      upperSeq: json['UPPER_SEQ'] == null
          ? null
          : IntNullableFilter.fromJson(
              json['UPPER_SEQ'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFilter.fromJson(json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STBOARDMSTWhereInputToJson(
    STBOARDMSTWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('BOARD_CD', instance.boardCd?.toJson());
  writeNotNull('CLS_CD', instance.clsCd?.toJson());
  writeNotNull('TTL', instance.ttl?.toJson());
  writeNotNull('CNTS', instance.cnts?.toJson());
  writeNotNull('FILE_YN', instance.fileYn?.toJson());
  writeNotNull('IMAGE_YN', instance.imageYn?.toJson());
  writeNotNull('NOTICE_YN', instance.noticeYn?.toJson());
  writeNotNull('LK_URL', instance.lkUrl?.toJson());
  writeNotNull('LK_TARGET', instance.lkTarget?.toJson());
  writeNotNull('READ_CNT', instance.readCnt?.toJson());
  writeNotNull('REG_ADMIN_YN', instance.regAdminYn?.toJson());
  writeNotNull('REPLY_YN', instance.replyYn?.toJson());
  writeNotNull('UPPER_SEQ', instance.upperSeq?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STBOARDMSTOrderByWithRelationInput _$STBOARDMSTOrderByWithRelationInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDMSTOrderByWithRelationInput(
      seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
      boardCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_CD']),
      clsCd: $enumDecodeNullable(_$SortOrderEnumMap, json['CLS_CD']),
      ttl: $enumDecodeNullable(_$SortOrderEnumMap, json['TTL']),
      cnts: $enumDecodeNullable(_$SortOrderEnumMap, json['CNTS']),
      fileYn: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_YN']),
      imageYn: $enumDecodeNullable(_$SortOrderEnumMap, json['IMAGE_YN']),
      noticeYn: $enumDecodeNullable(_$SortOrderEnumMap, json['NOTICE_YN']),
      lkUrl: $enumDecodeNullable(_$SortOrderEnumMap, json['LK_URL']),
      lkTarget: $enumDecodeNullable(_$SortOrderEnumMap, json['LK_TARGET']),
      readCnt: $enumDecodeNullable(_$SortOrderEnumMap, json['READ_CNT']),
      regAdminYn: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ADMIN_YN']),
      replyYn: $enumDecodeNullable(_$SortOrderEnumMap, json['REPLY_YN']),
      upperSeq: $enumDecodeNullable(_$SortOrderEnumMap, json['UPPER_SEQ']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STBOARDMSTOrderByWithRelationInputToJson(
    STBOARDMSTOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('BOARD_CD', _$SortOrderEnumMap[instance.boardCd]);
  writeNotNull('CLS_CD', _$SortOrderEnumMap[instance.clsCd]);
  writeNotNull('TTL', _$SortOrderEnumMap[instance.ttl]);
  writeNotNull('CNTS', _$SortOrderEnumMap[instance.cnts]);
  writeNotNull('FILE_YN', _$SortOrderEnumMap[instance.fileYn]);
  writeNotNull('IMAGE_YN', _$SortOrderEnumMap[instance.imageYn]);
  writeNotNull('NOTICE_YN', _$SortOrderEnumMap[instance.noticeYn]);
  writeNotNull('LK_URL', _$SortOrderEnumMap[instance.lkUrl]);
  writeNotNull('LK_TARGET', _$SortOrderEnumMap[instance.lkTarget]);
  writeNotNull('READ_CNT', _$SortOrderEnumMap[instance.readCnt]);
  writeNotNull('REG_ADMIN_YN', _$SortOrderEnumMap[instance.regAdminYn]);
  writeNotNull('REPLY_YN', _$SortOrderEnumMap[instance.replyYn]);
  writeNotNull('UPPER_SEQ', _$SortOrderEnumMap[instance.upperSeq]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STBOARDMSTWhereUniqueInput _$STBOARDMSTWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDMSTWhereUniqueInput(
      seqBoardCd: json['SEQ_BOARD_CD'] == null
          ? null
          : STBOARDMSTSEQBOARDCDCompoundUniqueInput.fromJson(
              json['SEQ_BOARD_CD'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STBOARDMSTWhereUniqueInputToJson(
    STBOARDMSTWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ_BOARD_CD', instance.seqBoardCd?.toJson());
  return val;
}

STBOARDMSTOrderByWithAggregationInput
    _$STBOARDMSTOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDMSTOrderByWithAggregationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          boardCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_CD']),
          clsCd: $enumDecodeNullable(_$SortOrderEnumMap, json['CLS_CD']),
          ttl: $enumDecodeNullable(_$SortOrderEnumMap, json['TTL']),
          cnts: $enumDecodeNullable(_$SortOrderEnumMap, json['CNTS']),
          fileYn: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_YN']),
          imageYn: $enumDecodeNullable(_$SortOrderEnumMap, json['IMAGE_YN']),
          noticeYn: $enumDecodeNullable(_$SortOrderEnumMap, json['NOTICE_YN']),
          lkUrl: $enumDecodeNullable(_$SortOrderEnumMap, json['LK_URL']),
          lkTarget: $enumDecodeNullable(_$SortOrderEnumMap, json['LK_TARGET']),
          readCnt: $enumDecodeNullable(_$SortOrderEnumMap, json['READ_CNT']),
          regAdminYn:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ADMIN_YN']),
          replyYn: $enumDecodeNullable(_$SortOrderEnumMap, json['REPLY_YN']),
          upperSeq: $enumDecodeNullable(_$SortOrderEnumMap, json['UPPER_SEQ']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
          $count: json['_count'] == null
              ? null
              : STBOARDMSTCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : STBOARDMSTAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : STBOARDMSTMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : STBOARDMSTMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : STBOARDMSTSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STBOARDMSTOrderByWithAggregationInputToJson(
    STBOARDMSTOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('BOARD_CD', _$SortOrderEnumMap[instance.boardCd]);
  writeNotNull('CLS_CD', _$SortOrderEnumMap[instance.clsCd]);
  writeNotNull('TTL', _$SortOrderEnumMap[instance.ttl]);
  writeNotNull('CNTS', _$SortOrderEnumMap[instance.cnts]);
  writeNotNull('FILE_YN', _$SortOrderEnumMap[instance.fileYn]);
  writeNotNull('IMAGE_YN', _$SortOrderEnumMap[instance.imageYn]);
  writeNotNull('NOTICE_YN', _$SortOrderEnumMap[instance.noticeYn]);
  writeNotNull('LK_URL', _$SortOrderEnumMap[instance.lkUrl]);
  writeNotNull('LK_TARGET', _$SortOrderEnumMap[instance.lkTarget]);
  writeNotNull('READ_CNT', _$SortOrderEnumMap[instance.readCnt]);
  writeNotNull('REG_ADMIN_YN', _$SortOrderEnumMap[instance.regAdminYn]);
  writeNotNull('REPLY_YN', _$SortOrderEnumMap[instance.replyYn]);
  writeNotNull('UPPER_SEQ', _$SortOrderEnumMap[instance.upperSeq]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

STBOARDMSTScalarWhereWithAggregatesInput
    _$STBOARDMSTScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDMSTScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              STBOARDMSTScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              STBOARDMSTScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              STBOARDMSTScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          seq: json['SEQ'] == null
              ? null
              : IntWithAggregatesFilter.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          boardCd: json['BOARD_CD'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['BOARD_CD'] as Map<String, dynamic>),
          clsCd: json['CLS_CD'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['CLS_CD'] as Map<String, dynamic>),
          ttl: json['TTL'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['TTL'] as Map<String, dynamic>),
          cnts: json['CNTS'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['CNTS'] as Map<String, dynamic>),
          fileYn: json['FILE_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['FILE_YN'] as Map<String, dynamic>),
          imageYn: json['IMAGE_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['IMAGE_YN'] as Map<String, dynamic>),
          noticeYn: json['NOTICE_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['NOTICE_YN'] as Map<String, dynamic>),
          lkUrl: json['LK_URL'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['LK_URL'] as Map<String, dynamic>),
          lkTarget: json['LK_TARGET'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['LK_TARGET'] as Map<String, dynamic>),
          readCnt: json['READ_CNT'] == null
              ? null
              : IntNullableWithAggregatesFilter.fromJson(
                  json['READ_CNT'] as Map<String, dynamic>),
          regAdminYn: json['REG_ADMIN_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['REG_ADMIN_YN'] as Map<String, dynamic>),
          replyYn: json['REPLY_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['REPLY_YN'] as Map<String, dynamic>),
          upperSeq: json['UPPER_SEQ'] == null
              ? null
              : IntNullableWithAggregatesFilter.fromJson(
                  json['UPPER_SEQ'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delId: json['DEL_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_ID'] as Map<String, dynamic>),
          delDate: json['DEL_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STBOARDMSTScalarWhereWithAggregatesInputToJson(
    STBOARDMSTScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('BOARD_CD', instance.boardCd?.toJson());
  writeNotNull('CLS_CD', instance.clsCd?.toJson());
  writeNotNull('TTL', instance.ttl?.toJson());
  writeNotNull('CNTS', instance.cnts?.toJson());
  writeNotNull('FILE_YN', instance.fileYn?.toJson());
  writeNotNull('IMAGE_YN', instance.imageYn?.toJson());
  writeNotNull('NOTICE_YN', instance.noticeYn?.toJson());
  writeNotNull('LK_URL', instance.lkUrl?.toJson());
  writeNotNull('LK_TARGET', instance.lkTarget?.toJson());
  writeNotNull('READ_CNT', instance.readCnt?.toJson());
  writeNotNull('REG_ADMIN_YN', instance.regAdminYn?.toJson());
  writeNotNull('REPLY_YN', instance.replyYn?.toJson());
  writeNotNull('UPPER_SEQ', instance.upperSeq?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STBOARDSTNGWhereInput _$STBOARDSTNGWhereInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDSTNGWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map(
          (e) => STBOARDSTNGWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map(
          (e) => STBOARDSTNGWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map(
          (e) => STBOARDSTNGWhereInput.fromJson(e as Map<String, dynamic>)),
      boardCd: json['BOARD_CD'] == null
          ? null
          : StringFilter.fromJson(json['BOARD_CD'] as Map<String, dynamic>),
      boardNm: json['BOARD_NM'] == null
          ? null
          : StringFilter.fromJson(json['BOARD_NM'] as Map<String, dynamic>),
      boardTy: json['BOARD_TY'] == null
          ? null
          : StringFilter.fromJson(json['BOARD_TY'] as Map<String, dynamic>),
      editorYn: json['EDITOR_YN'] == null
          ? null
          : StringFilter.fromJson(json['EDITOR_YN'] as Map<String, dynamic>),
      rlsYn: json['RLS_YN'] == null
          ? null
          : StringFilter.fromJson(json['RLS_YN'] as Map<String, dynamic>),
      cclSeq: json['CCL_SEQ'] == null
          ? null
          : IntNullableFilter.fromJson(json['CCL_SEQ'] as Map<String, dynamic>),
      listCnt: json['LIST_CNT'] == null
          ? null
          : IntNullableFilter.fromJson(
              json['LIST_CNT'] as Map<String, dynamic>),
      writeYn: json['WRITE_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['WRITE_YN'] as Map<String, dynamic>),
      commentYn: json['COMMENT_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['COMMENT_YN'] as Map<String, dynamic>),
      replyYn: json['REPLY_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['REPLY_YN'] as Map<String, dynamic>),
      attachYn: json['ATTACH_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['ATTACH_YN'] as Map<String, dynamic>),
      attachSize: json['ATTACH_SIZE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['ATTACH_SIZE'] as Map<String, dynamic>),
      attachCnt: json['ATTACH_CNT'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['ATTACH_CNT'] as Map<String, dynamic>),
      attachExt: json['ATTACH_EXT'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['ATTACH_EXT'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFilter.fromJson(json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STBOARDSTNGWhereInputToJson(
    STBOARDSTNGWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('BOARD_CD', instance.boardCd?.toJson());
  writeNotNull('BOARD_NM', instance.boardNm?.toJson());
  writeNotNull('BOARD_TY', instance.boardTy?.toJson());
  writeNotNull('EDITOR_YN', instance.editorYn?.toJson());
  writeNotNull('RLS_YN', instance.rlsYn?.toJson());
  writeNotNull('CCL_SEQ', instance.cclSeq?.toJson());
  writeNotNull('LIST_CNT', instance.listCnt?.toJson());
  writeNotNull('WRITE_YN', instance.writeYn?.toJson());
  writeNotNull('COMMENT_YN', instance.commentYn?.toJson());
  writeNotNull('REPLY_YN', instance.replyYn?.toJson());
  writeNotNull('ATTACH_YN', instance.attachYn?.toJson());
  writeNotNull('ATTACH_SIZE', instance.attachSize?.toJson());
  writeNotNull('ATTACH_CNT', instance.attachCnt?.toJson());
  writeNotNull('ATTACH_EXT', instance.attachExt?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STBOARDSTNGOrderByWithRelationInput
    _$STBOARDSTNGOrderByWithRelationInputFromJson(Map<String, dynamic> json) =>
        STBOARDSTNGOrderByWithRelationInput(
          boardCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_CD']),
          boardNm: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_NM']),
          boardTy: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_TY']),
          editorYn: $enumDecodeNullable(_$SortOrderEnumMap, json['EDITOR_YN']),
          rlsYn: $enumDecodeNullable(_$SortOrderEnumMap, json['RLS_YN']),
          cclSeq: $enumDecodeNullable(_$SortOrderEnumMap, json['CCL_SEQ']),
          listCnt: $enumDecodeNullable(_$SortOrderEnumMap, json['LIST_CNT']),
          writeYn: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITE_YN']),
          commentYn:
              $enumDecodeNullable(_$SortOrderEnumMap, json['COMMENT_YN']),
          replyYn: $enumDecodeNullable(_$SortOrderEnumMap, json['REPLY_YN']),
          attachYn: $enumDecodeNullable(_$SortOrderEnumMap, json['ATTACH_YN']),
          attachSize:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ATTACH_SIZE']),
          attachCnt:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ATTACH_CNT']),
          attachExt:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ATTACH_EXT']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$STBOARDSTNGOrderByWithRelationInputToJson(
    STBOARDSTNGOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_CD', _$SortOrderEnumMap[instance.boardCd]);
  writeNotNull('BOARD_NM', _$SortOrderEnumMap[instance.boardNm]);
  writeNotNull('BOARD_TY', _$SortOrderEnumMap[instance.boardTy]);
  writeNotNull('EDITOR_YN', _$SortOrderEnumMap[instance.editorYn]);
  writeNotNull('RLS_YN', _$SortOrderEnumMap[instance.rlsYn]);
  writeNotNull('CCL_SEQ', _$SortOrderEnumMap[instance.cclSeq]);
  writeNotNull('LIST_CNT', _$SortOrderEnumMap[instance.listCnt]);
  writeNotNull('WRITE_YN', _$SortOrderEnumMap[instance.writeYn]);
  writeNotNull('COMMENT_YN', _$SortOrderEnumMap[instance.commentYn]);
  writeNotNull('REPLY_YN', _$SortOrderEnumMap[instance.replyYn]);
  writeNotNull('ATTACH_YN', _$SortOrderEnumMap[instance.attachYn]);
  writeNotNull('ATTACH_SIZE', _$SortOrderEnumMap[instance.attachSize]);
  writeNotNull('ATTACH_CNT', _$SortOrderEnumMap[instance.attachCnt]);
  writeNotNull('ATTACH_EXT', _$SortOrderEnumMap[instance.attachExt]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STBOARDSTNGWhereUniqueInput _$STBOARDSTNGWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDSTNGWhereUniqueInput(
      boardCd: json['BOARD_CD'] as String?,
    );

Map<String, dynamic> _$STBOARDSTNGWhereUniqueInputToJson(
    STBOARDSTNGWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_CD', instance.boardCd);
  return val;
}

STBOARDSTNGOrderByWithAggregationInput
    _$STBOARDSTNGOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDSTNGOrderByWithAggregationInput(
          boardCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_CD']),
          boardNm: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_NM']),
          boardTy: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_TY']),
          editorYn: $enumDecodeNullable(_$SortOrderEnumMap, json['EDITOR_YN']),
          rlsYn: $enumDecodeNullable(_$SortOrderEnumMap, json['RLS_YN']),
          cclSeq: $enumDecodeNullable(_$SortOrderEnumMap, json['CCL_SEQ']),
          listCnt: $enumDecodeNullable(_$SortOrderEnumMap, json['LIST_CNT']),
          writeYn: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITE_YN']),
          commentYn:
              $enumDecodeNullable(_$SortOrderEnumMap, json['COMMENT_YN']),
          replyYn: $enumDecodeNullable(_$SortOrderEnumMap, json['REPLY_YN']),
          attachYn: $enumDecodeNullable(_$SortOrderEnumMap, json['ATTACH_YN']),
          attachSize:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ATTACH_SIZE']),
          attachCnt:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ATTACH_CNT']),
          attachExt:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ATTACH_EXT']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
          $count: json['_count'] == null
              ? null
              : STBOARDSTNGCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : STBOARDSTNGAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : STBOARDSTNGMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : STBOARDSTNGMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : STBOARDSTNGSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STBOARDSTNGOrderByWithAggregationInputToJson(
    STBOARDSTNGOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_CD', _$SortOrderEnumMap[instance.boardCd]);
  writeNotNull('BOARD_NM', _$SortOrderEnumMap[instance.boardNm]);
  writeNotNull('BOARD_TY', _$SortOrderEnumMap[instance.boardTy]);
  writeNotNull('EDITOR_YN', _$SortOrderEnumMap[instance.editorYn]);
  writeNotNull('RLS_YN', _$SortOrderEnumMap[instance.rlsYn]);
  writeNotNull('CCL_SEQ', _$SortOrderEnumMap[instance.cclSeq]);
  writeNotNull('LIST_CNT', _$SortOrderEnumMap[instance.listCnt]);
  writeNotNull('WRITE_YN', _$SortOrderEnumMap[instance.writeYn]);
  writeNotNull('COMMENT_YN', _$SortOrderEnumMap[instance.commentYn]);
  writeNotNull('REPLY_YN', _$SortOrderEnumMap[instance.replyYn]);
  writeNotNull('ATTACH_YN', _$SortOrderEnumMap[instance.attachYn]);
  writeNotNull('ATTACH_SIZE', _$SortOrderEnumMap[instance.attachSize]);
  writeNotNull('ATTACH_CNT', _$SortOrderEnumMap[instance.attachCnt]);
  writeNotNull('ATTACH_EXT', _$SortOrderEnumMap[instance.attachExt]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

STBOARDSTNGScalarWhereWithAggregatesInput
    _$STBOARDSTNGScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDSTNGScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              STBOARDSTNGScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              STBOARDSTNGScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              STBOARDSTNGScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          boardCd: json['BOARD_CD'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['BOARD_CD'] as Map<String, dynamic>),
          boardNm: json['BOARD_NM'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['BOARD_NM'] as Map<String, dynamic>),
          boardTy: json['BOARD_TY'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['BOARD_TY'] as Map<String, dynamic>),
          editorYn: json['EDITOR_YN'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['EDITOR_YN'] as Map<String, dynamic>),
          rlsYn: json['RLS_YN'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['RLS_YN'] as Map<String, dynamic>),
          cclSeq: json['CCL_SEQ'] == null
              ? null
              : IntNullableWithAggregatesFilter.fromJson(
                  json['CCL_SEQ'] as Map<String, dynamic>),
          listCnt: json['LIST_CNT'] == null
              ? null
              : IntNullableWithAggregatesFilter.fromJson(
                  json['LIST_CNT'] as Map<String, dynamic>),
          writeYn: json['WRITE_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['WRITE_YN'] as Map<String, dynamic>),
          commentYn: json['COMMENT_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['COMMENT_YN'] as Map<String, dynamic>),
          replyYn: json['REPLY_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['REPLY_YN'] as Map<String, dynamic>),
          attachYn: json['ATTACH_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['ATTACH_YN'] as Map<String, dynamic>),
          attachSize: json['ATTACH_SIZE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['ATTACH_SIZE'] as Map<String, dynamic>),
          attachCnt: json['ATTACH_CNT'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['ATTACH_CNT'] as Map<String, dynamic>),
          attachExt: json['ATTACH_EXT'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['ATTACH_EXT'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delId: json['DEL_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_ID'] as Map<String, dynamic>),
          delDate: json['DEL_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STBOARDSTNGScalarWhereWithAggregatesInputToJson(
    STBOARDSTNGScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('BOARD_CD', instance.boardCd?.toJson());
  writeNotNull('BOARD_NM', instance.boardNm?.toJson());
  writeNotNull('BOARD_TY', instance.boardTy?.toJson());
  writeNotNull('EDITOR_YN', instance.editorYn?.toJson());
  writeNotNull('RLS_YN', instance.rlsYn?.toJson());
  writeNotNull('CCL_SEQ', instance.cclSeq?.toJson());
  writeNotNull('LIST_CNT', instance.listCnt?.toJson());
  writeNotNull('WRITE_YN', instance.writeYn?.toJson());
  writeNotNull('COMMENT_YN', instance.commentYn?.toJson());
  writeNotNull('REPLY_YN', instance.replyYn?.toJson());
  writeNotNull('ATTACH_YN', instance.attachYn?.toJson());
  writeNotNull('ATTACH_SIZE', instance.attachSize?.toJson());
  writeNotNull('ATTACH_CNT', instance.attachCnt?.toJson());
  writeNotNull('ATTACH_EXT', instance.attachExt?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STCCLWhereInput _$STCCLWhereInputFromJson(Map<String, dynamic> json) =>
    STCCLWhereInput(
      AND: (json['AND'] as List<dynamic>?)
          ?.map((e) => STCCLWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)
          ?.map((e) => STCCLWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)
          ?.map((e) => STCCLWhereInput.fromJson(e as Map<String, dynamic>)),
      seq: json['SEQ'] == null
          ? null
          : IntFilter.fromJson(json['SEQ'] as Map<String, dynamic>),
      cclType: json['CCL_TYPE'] == null
          ? null
          : StringFilter.fromJson(json['CCL_TYPE'] as Map<String, dynamic>),
      cclNm: json['CCL_NM'] == null
          ? null
          : StringFilter.fromJson(json['CCL_NM'] as Map<String, dynamic>),
      flpth: json['FLPTH'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['FLPTH'] as Map<String, dynamic>),
      orginalFileNm: json['ORGINAL_FILE_NM'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['ORGINAL_FILE_NM'] as Map<String, dynamic>),
      streFileNm: json['STRE_FILE_NM'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['STRE_FILE_NM'] as Map<String, dynamic>),
      fileExtsn: json['FILE_EXTSN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['FILE_EXTSN'] as Map<String, dynamic>),
      fileSize: json['FILE_SIZE'] == null
          ? null
          : IntNullableFilter.fromJson(
              json['FILE_SIZE'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFilter.fromJson(json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STCCLWhereInputToJson(STCCLWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('CCL_TYPE', instance.cclType?.toJson());
  writeNotNull('CCL_NM', instance.cclNm?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm?.toJson());
  writeNotNull('STRE_FILE_NM', instance.streFileNm?.toJson());
  writeNotNull('FILE_EXTSN', instance.fileExtsn?.toJson());
  writeNotNull('FILE_SIZE', instance.fileSize?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STCCLOrderByWithRelationInput _$STCCLOrderByWithRelationInputFromJson(
        Map<String, dynamic> json) =>
    STCCLOrderByWithRelationInput(
      seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
      cclType: $enumDecodeNullable(_$SortOrderEnumMap, json['CCL_TYPE']),
      cclNm: $enumDecodeNullable(_$SortOrderEnumMap, json['CCL_NM']),
      flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
      orginalFileNm:
          $enumDecodeNullable(_$SortOrderEnumMap, json['ORGINAL_FILE_NM']),
      streFileNm: $enumDecodeNullable(_$SortOrderEnumMap, json['STRE_FILE_NM']),
      fileExtsn: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_EXTSN']),
      fileSize: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_SIZE']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STCCLOrderByWithRelationInputToJson(
    STCCLOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('CCL_TYPE', _$SortOrderEnumMap[instance.cclType]);
  writeNotNull('CCL_NM', _$SortOrderEnumMap[instance.cclNm]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('ORGINAL_FILE_NM', _$SortOrderEnumMap[instance.orginalFileNm]);
  writeNotNull('STRE_FILE_NM', _$SortOrderEnumMap[instance.streFileNm]);
  writeNotNull('FILE_EXTSN', _$SortOrderEnumMap[instance.fileExtsn]);
  writeNotNull('FILE_SIZE', _$SortOrderEnumMap[instance.fileSize]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STCCLWhereUniqueInput _$STCCLWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    STCCLWhereUniqueInput(
      seq: json['SEQ'] as int?,
    );

Map<String, dynamic> _$STCCLWhereUniqueInputToJson(
    STCCLWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq);
  return val;
}

STCCLOrderByWithAggregationInput _$STCCLOrderByWithAggregationInputFromJson(
        Map<String, dynamic> json) =>
    STCCLOrderByWithAggregationInput(
      seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
      cclType: $enumDecodeNullable(_$SortOrderEnumMap, json['CCL_TYPE']),
      cclNm: $enumDecodeNullable(_$SortOrderEnumMap, json['CCL_NM']),
      flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
      orginalFileNm:
          $enumDecodeNullable(_$SortOrderEnumMap, json['ORGINAL_FILE_NM']),
      streFileNm: $enumDecodeNullable(_$SortOrderEnumMap, json['STRE_FILE_NM']),
      fileExtsn: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_EXTSN']),
      fileSize: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_SIZE']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
      $count: json['_count'] == null
          ? null
          : STCCLCountOrderByAggregateInput.fromJson(
              json['_count'] as Map<String, dynamic>),
      $avg: json['_avg'] == null
          ? null
          : STCCLAvgOrderByAggregateInput.fromJson(
              json['_avg'] as Map<String, dynamic>),
      $max: json['_max'] == null
          ? null
          : STCCLMaxOrderByAggregateInput.fromJson(
              json['_max'] as Map<String, dynamic>),
      $min: json['_min'] == null
          ? null
          : STCCLMinOrderByAggregateInput.fromJson(
              json['_min'] as Map<String, dynamic>),
      $sum: json['_sum'] == null
          ? null
          : STCCLSumOrderByAggregateInput.fromJson(
              json['_sum'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STCCLOrderByWithAggregationInputToJson(
    STCCLOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('CCL_TYPE', _$SortOrderEnumMap[instance.cclType]);
  writeNotNull('CCL_NM', _$SortOrderEnumMap[instance.cclNm]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('ORGINAL_FILE_NM', _$SortOrderEnumMap[instance.orginalFileNm]);
  writeNotNull('STRE_FILE_NM', _$SortOrderEnumMap[instance.streFileNm]);
  writeNotNull('FILE_EXTSN', _$SortOrderEnumMap[instance.fileExtsn]);
  writeNotNull('FILE_SIZE', _$SortOrderEnumMap[instance.fileSize]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

STCCLScalarWhereWithAggregatesInput
    _$STCCLScalarWhereWithAggregatesInputFromJson(Map<String, dynamic> json) =>
        STCCLScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              STCCLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              STCCLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              STCCLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          seq: json['SEQ'] == null
              ? null
              : IntWithAggregatesFilter.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          cclType: json['CCL_TYPE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['CCL_TYPE'] as Map<String, dynamic>),
          cclNm: json['CCL_NM'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['CCL_NM'] as Map<String, dynamic>),
          flpth: json['FLPTH'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['FLPTH'] as Map<String, dynamic>),
          orginalFileNm: json['ORGINAL_FILE_NM'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['ORGINAL_FILE_NM'] as Map<String, dynamic>),
          streFileNm: json['STRE_FILE_NM'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['STRE_FILE_NM'] as Map<String, dynamic>),
          fileExtsn: json['FILE_EXTSN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['FILE_EXTSN'] as Map<String, dynamic>),
          fileSize: json['FILE_SIZE'] == null
              ? null
              : IntNullableWithAggregatesFilter.fromJson(
                  json['FILE_SIZE'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delId: json['DEL_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_ID'] as Map<String, dynamic>),
          delDate: json['DEL_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STCCLScalarWhereWithAggregatesInputToJson(
    STCCLScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('CCL_TYPE', instance.cclType?.toJson());
  writeNotNull('CCL_NM', instance.cclNm?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm?.toJson());
  writeNotNull('STRE_FILE_NM', instance.streFileNm?.toJson());
  writeNotNull('FILE_EXTSN', instance.fileExtsn?.toJson());
  writeNotNull('FILE_SIZE', instance.fileSize?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STCODEMSTWhereInput _$STCODEMSTWhereInputFromJson(Map<String, dynamic> json) =>
    STCODEMSTWhereInput(
      AND: (json['AND'] as List<dynamic>?)
          ?.map((e) => STCODEMSTWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)
          ?.map((e) => STCODEMSTWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)
          ?.map((e) => STCODEMSTWhereInput.fromJson(e as Map<String, dynamic>)),
      cdGrp: json['CD_GRP'] == null
          ? null
          : StringFilter.fromJson(json['CD_GRP'] as Map<String, dynamic>),
      cdKey: json['CD_KEY'] == null
          ? null
          : StringFilter.fromJson(json['CD_KEY'] as Map<String, dynamic>),
      cdVal: json['CD_VAL'] == null
          ? null
          : StringFilter.fromJson(json['CD_VAL'] as Map<String, dynamic>),
      cdDesc: json['CD_DESC'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['CD_DESC'] as Map<String, dynamic>),
      cdSrt: json['CD_SRT'] == null
          ? null
          : IntFilter.fromJson(json['CD_SRT'] as Map<String, dynamic>),
      depth: json['DEPTH'] == null
          ? null
          : IntNullableFilter.fromJson(json['DEPTH'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFilter.fromJson(json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STCODEMSTWhereInputToJson(STCODEMSTWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('CD_GRP', instance.cdGrp?.toJson());
  writeNotNull('CD_KEY', instance.cdKey?.toJson());
  writeNotNull('CD_VAL', instance.cdVal?.toJson());
  writeNotNull('CD_DESC', instance.cdDesc?.toJson());
  writeNotNull('CD_SRT', instance.cdSrt?.toJson());
  writeNotNull('DEPTH', instance.depth?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STCODEMSTOrderByWithRelationInput _$STCODEMSTOrderByWithRelationInputFromJson(
        Map<String, dynamic> json) =>
    STCODEMSTOrderByWithRelationInput(
      cdGrp: $enumDecodeNullable(_$SortOrderEnumMap, json['CD_GRP']),
      cdKey: $enumDecodeNullable(_$SortOrderEnumMap, json['CD_KEY']),
      cdVal: $enumDecodeNullable(_$SortOrderEnumMap, json['CD_VAL']),
      cdDesc: $enumDecodeNullable(_$SortOrderEnumMap, json['CD_DESC']),
      cdSrt: $enumDecodeNullable(_$SortOrderEnumMap, json['CD_SRT']),
      depth: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPTH']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STCODEMSTOrderByWithRelationInputToJson(
    STCODEMSTOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CD_GRP', _$SortOrderEnumMap[instance.cdGrp]);
  writeNotNull('CD_KEY', _$SortOrderEnumMap[instance.cdKey]);
  writeNotNull('CD_VAL', _$SortOrderEnumMap[instance.cdVal]);
  writeNotNull('CD_DESC', _$SortOrderEnumMap[instance.cdDesc]);
  writeNotNull('CD_SRT', _$SortOrderEnumMap[instance.cdSrt]);
  writeNotNull('DEPTH', _$SortOrderEnumMap[instance.depth]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STCODEMSTWhereUniqueInput _$STCODEMSTWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    STCODEMSTWhereUniqueInput(
      cdGrpCdKey: json['CD_GRP_CD_KEY'] == null
          ? null
          : STCODEMSTCDGRPCDKEYCompoundUniqueInput.fromJson(
              json['CD_GRP_CD_KEY'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STCODEMSTWhereUniqueInputToJson(
    STCODEMSTWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CD_GRP_CD_KEY', instance.cdGrpCdKey?.toJson());
  return val;
}

STCODEMSTOrderByWithAggregationInput
    _$STCODEMSTOrderByWithAggregationInputFromJson(Map<String, dynamic> json) =>
        STCODEMSTOrderByWithAggregationInput(
          cdGrp: $enumDecodeNullable(_$SortOrderEnumMap, json['CD_GRP']),
          cdKey: $enumDecodeNullable(_$SortOrderEnumMap, json['CD_KEY']),
          cdVal: $enumDecodeNullable(_$SortOrderEnumMap, json['CD_VAL']),
          cdDesc: $enumDecodeNullable(_$SortOrderEnumMap, json['CD_DESC']),
          cdSrt: $enumDecodeNullable(_$SortOrderEnumMap, json['CD_SRT']),
          depth: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPTH']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
          $count: json['_count'] == null
              ? null
              : STCODEMSTCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : STCODEMSTAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : STCODEMSTMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : STCODEMSTMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : STCODEMSTSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STCODEMSTOrderByWithAggregationInputToJson(
    STCODEMSTOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CD_GRP', _$SortOrderEnumMap[instance.cdGrp]);
  writeNotNull('CD_KEY', _$SortOrderEnumMap[instance.cdKey]);
  writeNotNull('CD_VAL', _$SortOrderEnumMap[instance.cdVal]);
  writeNotNull('CD_DESC', _$SortOrderEnumMap[instance.cdDesc]);
  writeNotNull('CD_SRT', _$SortOrderEnumMap[instance.cdSrt]);
  writeNotNull('DEPTH', _$SortOrderEnumMap[instance.depth]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

STCODEMSTScalarWhereWithAggregatesInput
    _$STCODEMSTScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        STCODEMSTScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              STCODEMSTScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              STCODEMSTScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              STCODEMSTScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          cdGrp: json['CD_GRP'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['CD_GRP'] as Map<String, dynamic>),
          cdKey: json['CD_KEY'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['CD_KEY'] as Map<String, dynamic>),
          cdVal: json['CD_VAL'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['CD_VAL'] as Map<String, dynamic>),
          cdDesc: json['CD_DESC'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['CD_DESC'] as Map<String, dynamic>),
          cdSrt: json['CD_SRT'] == null
              ? null
              : IntWithAggregatesFilter.fromJson(
                  json['CD_SRT'] as Map<String, dynamic>),
          depth: json['DEPTH'] == null
              ? null
              : IntNullableWithAggregatesFilter.fromJson(
                  json['DEPTH'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delId: json['DEL_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_ID'] as Map<String, dynamic>),
          delDate: json['DEL_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STCODEMSTScalarWhereWithAggregatesInputToJson(
    STCODEMSTScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('CD_GRP', instance.cdGrp?.toJson());
  writeNotNull('CD_KEY', instance.cdKey?.toJson());
  writeNotNull('CD_VAL', instance.cdVal?.toJson());
  writeNotNull('CD_DESC', instance.cdDesc?.toJson());
  writeNotNull('CD_SRT', instance.cdSrt?.toJson());
  writeNotNull('DEPTH', instance.depth?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STCONNECTLOGWhereInput _$STCONNECTLOGWhereInputFromJson(
        Map<String, dynamic> json) =>
    STCONNECTLOGWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map(
          (e) => STCONNECTLOGWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map(
          (e) => STCONNECTLOGWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map(
          (e) => STCONNECTLOGWhereInput.fromJson(e as Map<String, dynamic>)),
      seq: json['SEQ'] == null
          ? null
          : IntFilter.fromJson(json['SEQ'] as Map<String, dynamic>),
      userId: json['USER_ID'] == null
          ? null
          : StringFilter.fromJson(json['USER_ID'] as Map<String, dynamic>),
      connType: json['CONN_TYPE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['CONN_TYPE'] as Map<String, dynamic>),
      osType: json['OS_TYPE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['OS_TYPE'] as Map<String, dynamic>),
      browserType: json['BROWSER_TYPE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['BROWSER_TYPE'] as Map<String, dynamic>),
      conneIp: json['CONNE_IP'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['CONNE_IP'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STCONNECTLOGWhereInputToJson(
    STCONNECTLOGWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('CONN_TYPE', instance.connType?.toJson());
  writeNotNull('OS_TYPE', instance.osType?.toJson());
  writeNotNull('BROWSER_TYPE', instance.browserType?.toJson());
  writeNotNull('CONNE_IP', instance.conneIp?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

STCONNECTLOGOrderByWithRelationInput
    _$STCONNECTLOGOrderByWithRelationInputFromJson(Map<String, dynamic> json) =>
        STCONNECTLOGOrderByWithRelationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
          connType: $enumDecodeNullable(_$SortOrderEnumMap, json['CONN_TYPE']),
          osType: $enumDecodeNullable(_$SortOrderEnumMap, json['OS_TYPE']),
          browserType:
              $enumDecodeNullable(_$SortOrderEnumMap, json['BROWSER_TYPE']),
          conneIp: $enumDecodeNullable(_$SortOrderEnumMap, json['CONNE_IP']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
        );

Map<String, dynamic> _$STCONNECTLOGOrderByWithRelationInputToJson(
    STCONNECTLOGOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('CONN_TYPE', _$SortOrderEnumMap[instance.connType]);
  writeNotNull('OS_TYPE', _$SortOrderEnumMap[instance.osType]);
  writeNotNull('BROWSER_TYPE', _$SortOrderEnumMap[instance.browserType]);
  writeNotNull('CONNE_IP', _$SortOrderEnumMap[instance.conneIp]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  return val;
}

STCONNECTLOGWhereUniqueInput _$STCONNECTLOGWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    STCONNECTLOGWhereUniqueInput(
      seq: json['SEQ'] as int?,
    );

Map<String, dynamic> _$STCONNECTLOGWhereUniqueInputToJson(
    STCONNECTLOGWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq);
  return val;
}

STCONNECTLOGOrderByWithAggregationInput
    _$STCONNECTLOGOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        STCONNECTLOGOrderByWithAggregationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
          connType: $enumDecodeNullable(_$SortOrderEnumMap, json['CONN_TYPE']),
          osType: $enumDecodeNullable(_$SortOrderEnumMap, json['OS_TYPE']),
          browserType:
              $enumDecodeNullable(_$SortOrderEnumMap, json['BROWSER_TYPE']),
          conneIp: $enumDecodeNullable(_$SortOrderEnumMap, json['CONNE_IP']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          $count: json['_count'] == null
              ? null
              : STCONNECTLOGCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : STCONNECTLOGAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : STCONNECTLOGMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : STCONNECTLOGMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : STCONNECTLOGSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STCONNECTLOGOrderByWithAggregationInputToJson(
    STCONNECTLOGOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('CONN_TYPE', _$SortOrderEnumMap[instance.connType]);
  writeNotNull('OS_TYPE', _$SortOrderEnumMap[instance.osType]);
  writeNotNull('BROWSER_TYPE', _$SortOrderEnumMap[instance.browserType]);
  writeNotNull('CONNE_IP', _$SortOrderEnumMap[instance.conneIp]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

STCONNECTLOGScalarWhereWithAggregatesInput
    _$STCONNECTLOGScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        STCONNECTLOGScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              STCONNECTLOGScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              STCONNECTLOGScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              STCONNECTLOGScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          seq: json['SEQ'] == null
              ? null
              : IntWithAggregatesFilter.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          userId: json['USER_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['USER_ID'] as Map<String, dynamic>),
          connType: json['CONN_TYPE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['CONN_TYPE'] as Map<String, dynamic>),
          osType: json['OS_TYPE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['OS_TYPE'] as Map<String, dynamic>),
          browserType: json['BROWSER_TYPE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['BROWSER_TYPE'] as Map<String, dynamic>),
          conneIp: json['CONNE_IP'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['CONNE_IP'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STCONNECTLOGScalarWhereWithAggregatesInputToJson(
    STCONNECTLOGScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('CONN_TYPE', instance.connType?.toJson());
  writeNotNull('OS_TYPE', instance.osType?.toJson());
  writeNotNull('BROWSER_TYPE', instance.browserType?.toJson());
  writeNotNull('CONNE_IP', instance.conneIp?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

STCONTENTSFILEWhereInput _$STCONTENTSFILEWhereInputFromJson(
        Map<String, dynamic> json) =>
    STCONTENTSFILEWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map(
          (e) => STCONTENTSFILEWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map(
          (e) => STCONTENTSFILEWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map(
          (e) => STCONTENTSFILEWhereInput.fromJson(e as Map<String, dynamic>)),
      seq: json['SEQ'] == null
          ? null
          : IntFilter.fromJson(json['SEQ'] as Map<String, dynamic>),
      mseq: json['MSEQ'] == null
          ? null
          : StringFilter.fromJson(json['MSEQ'] as Map<String, dynamic>),
      fileTp: json['FILE_TP'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['FILE_TP'] as Map<String, dynamic>),
      flpth: json['FLPTH'] == null
          ? null
          : StringFilter.fromJson(json['FLPTH'] as Map<String, dynamic>),
      orginalFileNm: json['ORGINAL_FILE_NM'] == null
          ? null
          : StringFilter.fromJson(
              json['ORGINAL_FILE_NM'] as Map<String, dynamic>),
      streFileNm: json['STRE_FILE_NM'] == null
          ? null
          : StringFilter.fromJson(json['STRE_FILE_NM'] as Map<String, dynamic>),
      fileSize: json['FILE_SIZE'] == null
          ? null
          : IntFilter.fromJson(json['FILE_SIZE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STCONTENTSFILEWhereInputToJson(
    STCONTENTSFILEWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('FILE_TP', instance.fileTp?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm?.toJson());
  writeNotNull('STRE_FILE_NM', instance.streFileNm?.toJson());
  writeNotNull('FILE_SIZE', instance.fileSize?.toJson());
  return val;
}

STCONTENTSFILEOrderByWithRelationInput
    _$STCONTENTSFILEOrderByWithRelationInputFromJson(
            Map<String, dynamic> json) =>
        STCONTENTSFILEOrderByWithRelationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          fileTp: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_TP']),
          flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
          orginalFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ORGINAL_FILE_NM']),
          streFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['STRE_FILE_NM']),
          fileSize: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_SIZE']),
        );

Map<String, dynamic> _$STCONTENTSFILEOrderByWithRelationInputToJson(
    STCONTENTSFILEOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('FILE_TP', _$SortOrderEnumMap[instance.fileTp]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('ORGINAL_FILE_NM', _$SortOrderEnumMap[instance.orginalFileNm]);
  writeNotNull('STRE_FILE_NM', _$SortOrderEnumMap[instance.streFileNm]);
  writeNotNull('FILE_SIZE', _$SortOrderEnumMap[instance.fileSize]);
  return val;
}

STCONTENTSFILEWhereUniqueInput _$STCONTENTSFILEWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    STCONTENTSFILEWhereUniqueInput(
      seq: json['SEQ'] as int?,
    );

Map<String, dynamic> _$STCONTENTSFILEWhereUniqueInputToJson(
    STCONTENTSFILEWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq);
  return val;
}

STCONTENTSFILEOrderByWithAggregationInput
    _$STCONTENTSFILEOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        STCONTENTSFILEOrderByWithAggregationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          fileTp: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_TP']),
          flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
          orginalFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ORGINAL_FILE_NM']),
          streFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['STRE_FILE_NM']),
          fileSize: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_SIZE']),
          $count: json['_count'] == null
              ? null
              : STCONTENTSFILECountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : STCONTENTSFILEAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : STCONTENTSFILEMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : STCONTENTSFILEMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : STCONTENTSFILESumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STCONTENTSFILEOrderByWithAggregationInputToJson(
    STCONTENTSFILEOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('FILE_TP', _$SortOrderEnumMap[instance.fileTp]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('ORGINAL_FILE_NM', _$SortOrderEnumMap[instance.orginalFileNm]);
  writeNotNull('STRE_FILE_NM', _$SortOrderEnumMap[instance.streFileNm]);
  writeNotNull('FILE_SIZE', _$SortOrderEnumMap[instance.fileSize]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

STCONTENTSFILEScalarWhereWithAggregatesInput
    _$STCONTENTSFILEScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        STCONTENTSFILEScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              STCONTENTSFILEScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              STCONTENTSFILEScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              STCONTENTSFILEScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          seq: json['SEQ'] == null
              ? null
              : IntWithAggregatesFilter.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          mseq: json['MSEQ'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['MSEQ'] as Map<String, dynamic>),
          fileTp: json['FILE_TP'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['FILE_TP'] as Map<String, dynamic>),
          flpth: json['FLPTH'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['FLPTH'] as Map<String, dynamic>),
          orginalFileNm: json['ORGINAL_FILE_NM'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['ORGINAL_FILE_NM'] as Map<String, dynamic>),
          streFileNm: json['STRE_FILE_NM'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['STRE_FILE_NM'] as Map<String, dynamic>),
          fileSize: json['FILE_SIZE'] == null
              ? null
              : IntWithAggregatesFilter.fromJson(
                  json['FILE_SIZE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STCONTENTSFILEScalarWhereWithAggregatesInputToJson(
    STCONTENTSFILEScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('FILE_TP', instance.fileTp?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm?.toJson());
  writeNotNull('STRE_FILE_NM', instance.streFileNm?.toJson());
  writeNotNull('FILE_SIZE', instance.fileSize?.toJson());
  return val;
}

STCONTENTSMSTWhereInput _$STCONTENTSMSTWhereInputFromJson(
        Map<String, dynamic> json) =>
    STCONTENTSMSTWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map(
          (e) => STCONTENTSMSTWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map(
          (e) => STCONTENTSMSTWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map(
          (e) => STCONTENTSMSTWhereInput.fromJson(e as Map<String, dynamic>)),
      seq: json['SEQ'] == null
          ? null
          : IntFilter.fromJson(json['SEQ'] as Map<String, dynamic>),
      cntsNm: json['CNTS_NM'] == null
          ? null
          : StringFilter.fromJson(json['CNTS_NM'] as Map<String, dynamic>),
      pubDate: json['PUB_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['PUB_DATE'] as Map<String, dynamic>),
      pubState: json['PUB_STATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['PUB_STATE'] as Map<String, dynamic>),
      cn: json['CN'] == null
          ? null
          : StringNullableFilter.fromJson(json['CN'] as Map<String, dynamic>),
      srchYn: json['SRCH_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['SRCH_YN'] as Map<String, dynamic>),
      fileYn: json['FILE_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['FILE_YN'] as Map<String, dynamic>),
      imageYn: json['IMAGE_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['IMAGE_YN'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFilter.fromJson(json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STCONTENTSMSTWhereInputToJson(
    STCONTENTSMSTWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('CNTS_NM', instance.cntsNm?.toJson());
  writeNotNull('PUB_DATE', instance.pubDate?.toJson());
  writeNotNull('PUB_STATE', instance.pubState?.toJson());
  writeNotNull('CN', instance.cn?.toJson());
  writeNotNull('SRCH_YN', instance.srchYn?.toJson());
  writeNotNull('FILE_YN', instance.fileYn?.toJson());
  writeNotNull('IMAGE_YN', instance.imageYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STCONTENTSMSTOrderByWithRelationInput
    _$STCONTENTSMSTOrderByWithRelationInputFromJson(
            Map<String, dynamic> json) =>
        STCONTENTSMSTOrderByWithRelationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          cntsNm: $enumDecodeNullable(_$SortOrderEnumMap, json['CNTS_NM']),
          pubDate: $enumDecodeNullable(_$SortOrderEnumMap, json['PUB_DATE']),
          pubState: $enumDecodeNullable(_$SortOrderEnumMap, json['PUB_STATE']),
          cn: $enumDecodeNullable(_$SortOrderEnumMap, json['CN']),
          srchYn: $enumDecodeNullable(_$SortOrderEnumMap, json['SRCH_YN']),
          fileYn: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_YN']),
          imageYn: $enumDecodeNullable(_$SortOrderEnumMap, json['IMAGE_YN']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$STCONTENTSMSTOrderByWithRelationInputToJson(
    STCONTENTSMSTOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('CNTS_NM', _$SortOrderEnumMap[instance.cntsNm]);
  writeNotNull('PUB_DATE', _$SortOrderEnumMap[instance.pubDate]);
  writeNotNull('PUB_STATE', _$SortOrderEnumMap[instance.pubState]);
  writeNotNull('CN', _$SortOrderEnumMap[instance.cn]);
  writeNotNull('SRCH_YN', _$SortOrderEnumMap[instance.srchYn]);
  writeNotNull('FILE_YN', _$SortOrderEnumMap[instance.fileYn]);
  writeNotNull('IMAGE_YN', _$SortOrderEnumMap[instance.imageYn]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STCONTENTSMSTWhereUniqueInput _$STCONTENTSMSTWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    STCONTENTSMSTWhereUniqueInput(
      seq: json['SEQ'] as int?,
    );

Map<String, dynamic> _$STCONTENTSMSTWhereUniqueInputToJson(
    STCONTENTSMSTWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq);
  return val;
}

STCONTENTSMSTOrderByWithAggregationInput
    _$STCONTENTSMSTOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        STCONTENTSMSTOrderByWithAggregationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          cntsNm: $enumDecodeNullable(_$SortOrderEnumMap, json['CNTS_NM']),
          pubDate: $enumDecodeNullable(_$SortOrderEnumMap, json['PUB_DATE']),
          pubState: $enumDecodeNullable(_$SortOrderEnumMap, json['PUB_STATE']),
          cn: $enumDecodeNullable(_$SortOrderEnumMap, json['CN']),
          srchYn: $enumDecodeNullable(_$SortOrderEnumMap, json['SRCH_YN']),
          fileYn: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_YN']),
          imageYn: $enumDecodeNullable(_$SortOrderEnumMap, json['IMAGE_YN']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
          $count: json['_count'] == null
              ? null
              : STCONTENTSMSTCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : STCONTENTSMSTAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : STCONTENTSMSTMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : STCONTENTSMSTMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : STCONTENTSMSTSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STCONTENTSMSTOrderByWithAggregationInputToJson(
    STCONTENTSMSTOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('CNTS_NM', _$SortOrderEnumMap[instance.cntsNm]);
  writeNotNull('PUB_DATE', _$SortOrderEnumMap[instance.pubDate]);
  writeNotNull('PUB_STATE', _$SortOrderEnumMap[instance.pubState]);
  writeNotNull('CN', _$SortOrderEnumMap[instance.cn]);
  writeNotNull('SRCH_YN', _$SortOrderEnumMap[instance.srchYn]);
  writeNotNull('FILE_YN', _$SortOrderEnumMap[instance.fileYn]);
  writeNotNull('IMAGE_YN', _$SortOrderEnumMap[instance.imageYn]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

STCONTENTSMSTScalarWhereWithAggregatesInput
    _$STCONTENTSMSTScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        STCONTENTSMSTScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              STCONTENTSMSTScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              STCONTENTSMSTScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              STCONTENTSMSTScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          seq: json['SEQ'] == null
              ? null
              : IntWithAggregatesFilter.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          cntsNm: json['CNTS_NM'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['CNTS_NM'] as Map<String, dynamic>),
          pubDate: json['PUB_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['PUB_DATE'] as Map<String, dynamic>),
          pubState: json['PUB_STATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['PUB_STATE'] as Map<String, dynamic>),
          cn: json['CN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['CN'] as Map<String, dynamic>),
          srchYn: json['SRCH_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['SRCH_YN'] as Map<String, dynamic>),
          fileYn: json['FILE_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['FILE_YN'] as Map<String, dynamic>),
          imageYn: json['IMAGE_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['IMAGE_YN'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delId: json['DEL_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_ID'] as Map<String, dynamic>),
          delDate: json['DEL_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STCONTENTSMSTScalarWhereWithAggregatesInputToJson(
    STCONTENTSMSTScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('CNTS_NM', instance.cntsNm?.toJson());
  writeNotNull('PUB_DATE', instance.pubDate?.toJson());
  writeNotNull('PUB_STATE', instance.pubState?.toJson());
  writeNotNull('CN', instance.cn?.toJson());
  writeNotNull('SRCH_YN', instance.srchYn?.toJson());
  writeNotNull('FILE_YN', instance.fileYn?.toJson());
  writeNotNull('IMAGE_YN', instance.imageYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STDEPTWhereInput _$STDEPTWhereInputFromJson(Map<String, dynamic> json) =>
    STDEPTWhereInput(
      AND: (json['AND'] as List<dynamic>?)
          ?.map((e) => STDEPTWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)
          ?.map((e) => STDEPTWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)
          ?.map((e) => STDEPTWhereInput.fromJson(e as Map<String, dynamic>)),
      deptCd: json['DEPT_CD'] == null
          ? null
          : StringFilter.fromJson(json['DEPT_CD'] as Map<String, dynamic>),
      deptNm: json['DEPT_NM'] == null
          ? null
          : StringFilter.fromJson(json['DEPT_NM'] as Map<String, dynamic>),
      upperDeptCd: json['UPPER_DEPT_CD'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['UPPER_DEPT_CD'] as Map<String, dynamic>),
      upperDeptNm: json['UPPER_DEPT_NM'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['UPPER_DEPT_NM'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : IntNullableFilter.fromJson(json['SORT'] as Map<String, dynamic>),
      mainYn: json['MAIN_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['MAIN_YN'] as Map<String, dynamic>),
      deptDesc: json['DEPT_DESC'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEPT_DESC'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFilter.fromJson(json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STDEPTWhereInputToJson(STDEPTWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('DEPT_CD', instance.deptCd?.toJson());
  writeNotNull('DEPT_NM', instance.deptNm?.toJson());
  writeNotNull('UPPER_DEPT_CD', instance.upperDeptCd?.toJson());
  writeNotNull('UPPER_DEPT_NM', instance.upperDeptNm?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('MAIN_YN', instance.mainYn?.toJson());
  writeNotNull('DEPT_DESC', instance.deptDesc?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STDEPTOrderByWithRelationInput _$STDEPTOrderByWithRelationInputFromJson(
        Map<String, dynamic> json) =>
    STDEPTOrderByWithRelationInput(
      deptCd: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT_CD']),
      deptNm: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT_NM']),
      upperDeptCd:
          $enumDecodeNullable(_$SortOrderEnumMap, json['UPPER_DEPT_CD']),
      upperDeptNm:
          $enumDecodeNullable(_$SortOrderEnumMap, json['UPPER_DEPT_NM']),
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
      mainYn: $enumDecodeNullable(_$SortOrderEnumMap, json['MAIN_YN']),
      deptDesc: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT_DESC']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STDEPTOrderByWithRelationInputToJson(
    STDEPTOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('DEPT_CD', _$SortOrderEnumMap[instance.deptCd]);
  writeNotNull('DEPT_NM', _$SortOrderEnumMap[instance.deptNm]);
  writeNotNull('UPPER_DEPT_CD', _$SortOrderEnumMap[instance.upperDeptCd]);
  writeNotNull('UPPER_DEPT_NM', _$SortOrderEnumMap[instance.upperDeptNm]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('MAIN_YN', _$SortOrderEnumMap[instance.mainYn]);
  writeNotNull('DEPT_DESC', _$SortOrderEnumMap[instance.deptDesc]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STDEPTWhereUniqueInput _$STDEPTWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    STDEPTWhereUniqueInput(
      deptCd: json['DEPT_CD'] as String?,
    );

Map<String, dynamic> _$STDEPTWhereUniqueInputToJson(
    STDEPTWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('DEPT_CD', instance.deptCd);
  return val;
}

STDEPTOrderByWithAggregationInput _$STDEPTOrderByWithAggregationInputFromJson(
        Map<String, dynamic> json) =>
    STDEPTOrderByWithAggregationInput(
      deptCd: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT_CD']),
      deptNm: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT_NM']),
      upperDeptCd:
          $enumDecodeNullable(_$SortOrderEnumMap, json['UPPER_DEPT_CD']),
      upperDeptNm:
          $enumDecodeNullable(_$SortOrderEnumMap, json['UPPER_DEPT_NM']),
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
      mainYn: $enumDecodeNullable(_$SortOrderEnumMap, json['MAIN_YN']),
      deptDesc: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT_DESC']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
      $count: json['_count'] == null
          ? null
          : STDEPTCountOrderByAggregateInput.fromJson(
              json['_count'] as Map<String, dynamic>),
      $avg: json['_avg'] == null
          ? null
          : STDEPTAvgOrderByAggregateInput.fromJson(
              json['_avg'] as Map<String, dynamic>),
      $max: json['_max'] == null
          ? null
          : STDEPTMaxOrderByAggregateInput.fromJson(
              json['_max'] as Map<String, dynamic>),
      $min: json['_min'] == null
          ? null
          : STDEPTMinOrderByAggregateInput.fromJson(
              json['_min'] as Map<String, dynamic>),
      $sum: json['_sum'] == null
          ? null
          : STDEPTSumOrderByAggregateInput.fromJson(
              json['_sum'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STDEPTOrderByWithAggregationInputToJson(
    STDEPTOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('DEPT_CD', _$SortOrderEnumMap[instance.deptCd]);
  writeNotNull('DEPT_NM', _$SortOrderEnumMap[instance.deptNm]);
  writeNotNull('UPPER_DEPT_CD', _$SortOrderEnumMap[instance.upperDeptCd]);
  writeNotNull('UPPER_DEPT_NM', _$SortOrderEnumMap[instance.upperDeptNm]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('MAIN_YN', _$SortOrderEnumMap[instance.mainYn]);
  writeNotNull('DEPT_DESC', _$SortOrderEnumMap[instance.deptDesc]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

STDEPTScalarWhereWithAggregatesInput
    _$STDEPTScalarWhereWithAggregatesInputFromJson(Map<String, dynamic> json) =>
        STDEPTScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              STDEPTScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              STDEPTScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              STDEPTScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          deptCd: json['DEPT_CD'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['DEPT_CD'] as Map<String, dynamic>),
          deptNm: json['DEPT_NM'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['DEPT_NM'] as Map<String, dynamic>),
          upperDeptCd: json['UPPER_DEPT_CD'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['UPPER_DEPT_CD'] as Map<String, dynamic>),
          upperDeptNm: json['UPPER_DEPT_NM'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['UPPER_DEPT_NM'] as Map<String, dynamic>),
          sort: json['SORT'] == null
              ? null
              : IntNullableWithAggregatesFilter.fromJson(
                  json['SORT'] as Map<String, dynamic>),
          mainYn: json['MAIN_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['MAIN_YN'] as Map<String, dynamic>),
          deptDesc: json['DEPT_DESC'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEPT_DESC'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delId: json['DEL_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_ID'] as Map<String, dynamic>),
          delDate: json['DEL_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STDEPTScalarWhereWithAggregatesInputToJson(
    STDEPTScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('DEPT_CD', instance.deptCd?.toJson());
  writeNotNull('DEPT_NM', instance.deptNm?.toJson());
  writeNotNull('UPPER_DEPT_CD', instance.upperDeptCd?.toJson());
  writeNotNull('UPPER_DEPT_NM', instance.upperDeptNm?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('MAIN_YN', instance.mainYn?.toJson());
  writeNotNull('DEPT_DESC', instance.deptDesc?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STDEPTEMPWhereInput _$STDEPTEMPWhereInputFromJson(Map<String, dynamic> json) =>
    STDEPTEMPWhereInput(
      AND: (json['AND'] as List<dynamic>?)
          ?.map((e) => STDEPTEMPWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)
          ?.map((e) => STDEPTEMPWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)
          ?.map((e) => STDEPTEMPWhereInput.fromJson(e as Map<String, dynamic>)),
      empNo: json['EMP_NO'] == null
          ? null
          : StringFilter.fromJson(json['EMP_NO'] as Map<String, dynamic>),
      empNm: json['EMP_NM'] == null
          ? null
          : StringFilter.fromJson(json['EMP_NM'] as Map<String, dynamic>),
      deptCd: json['DEPT_CD'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEPT_CD'] as Map<String, dynamic>),
      deptNm: json['DEPT_NM'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEPT_NM'] as Map<String, dynamic>),
      fctnCd: json['FCTN_CD'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['FCTN_CD'] as Map<String, dynamic>),
      fctnNm: json['FCTN_NM'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['FCTN_NM'] as Map<String, dynamic>),
      ofcpCd: json['OFCP_CD'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['OFCP_CD'] as Map<String, dynamic>),
      ofcpNm: json['OFCP_NM'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['OFCP_NM'] as Map<String, dynamic>),
      emailAddr: json['EMAIL_ADDR'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EMAIL_ADDR'] as Map<String, dynamic>),
      offmTelno: json['OFFM_TELNO'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['OFFM_TELNO'] as Map<String, dynamic>),
      htelTelno: json['HTEL_TELNO'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['HTEL_TELNO'] as Map<String, dynamic>),
      deptYn: json['DEPT_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEPT_YN'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFilter.fromJson(json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STDEPTEMPWhereInputToJson(STDEPTEMPWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('EMP_NO', instance.empNo?.toJson());
  writeNotNull('EMP_NM', instance.empNm?.toJson());
  writeNotNull('DEPT_CD', instance.deptCd?.toJson());
  writeNotNull('DEPT_NM', instance.deptNm?.toJson());
  writeNotNull('FCTN_CD', instance.fctnCd?.toJson());
  writeNotNull('FCTN_NM', instance.fctnNm?.toJson());
  writeNotNull('OFCP_CD', instance.ofcpCd?.toJson());
  writeNotNull('OFCP_NM', instance.ofcpNm?.toJson());
  writeNotNull('EMAIL_ADDR', instance.emailAddr?.toJson());
  writeNotNull('OFFM_TELNO', instance.offmTelno?.toJson());
  writeNotNull('HTEL_TELNO', instance.htelTelno?.toJson());
  writeNotNull('DEPT_YN', instance.deptYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STDEPTEMPOrderByWithRelationInput _$STDEPTEMPOrderByWithRelationInputFromJson(
        Map<String, dynamic> json) =>
    STDEPTEMPOrderByWithRelationInput(
      empNo: $enumDecodeNullable(_$SortOrderEnumMap, json['EMP_NO']),
      empNm: $enumDecodeNullable(_$SortOrderEnumMap, json['EMP_NM']),
      deptCd: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT_CD']),
      deptNm: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT_NM']),
      fctnCd: $enumDecodeNullable(_$SortOrderEnumMap, json['FCTN_CD']),
      fctnNm: $enumDecodeNullable(_$SortOrderEnumMap, json['FCTN_NM']),
      ofcpCd: $enumDecodeNullable(_$SortOrderEnumMap, json['OFCP_CD']),
      ofcpNm: $enumDecodeNullable(_$SortOrderEnumMap, json['OFCP_NM']),
      emailAddr: $enumDecodeNullable(_$SortOrderEnumMap, json['EMAIL_ADDR']),
      offmTelno: $enumDecodeNullable(_$SortOrderEnumMap, json['OFFM_TELNO']),
      htelTelno: $enumDecodeNullable(_$SortOrderEnumMap, json['HTEL_TELNO']),
      deptYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT_YN']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STDEPTEMPOrderByWithRelationInputToJson(
    STDEPTEMPOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('EMP_NO', _$SortOrderEnumMap[instance.empNo]);
  writeNotNull('EMP_NM', _$SortOrderEnumMap[instance.empNm]);
  writeNotNull('DEPT_CD', _$SortOrderEnumMap[instance.deptCd]);
  writeNotNull('DEPT_NM', _$SortOrderEnumMap[instance.deptNm]);
  writeNotNull('FCTN_CD', _$SortOrderEnumMap[instance.fctnCd]);
  writeNotNull('FCTN_NM', _$SortOrderEnumMap[instance.fctnNm]);
  writeNotNull('OFCP_CD', _$SortOrderEnumMap[instance.ofcpCd]);
  writeNotNull('OFCP_NM', _$SortOrderEnumMap[instance.ofcpNm]);
  writeNotNull('EMAIL_ADDR', _$SortOrderEnumMap[instance.emailAddr]);
  writeNotNull('OFFM_TELNO', _$SortOrderEnumMap[instance.offmTelno]);
  writeNotNull('HTEL_TELNO', _$SortOrderEnumMap[instance.htelTelno]);
  writeNotNull('DEPT_YN', _$SortOrderEnumMap[instance.deptYn]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STDEPTEMPWhereUniqueInput _$STDEPTEMPWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    STDEPTEMPWhereUniqueInput(
      empNo: json['EMP_NO'] as String?,
    );

Map<String, dynamic> _$STDEPTEMPWhereUniqueInputToJson(
    STDEPTEMPWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('EMP_NO', instance.empNo);
  return val;
}

STDEPTEMPOrderByWithAggregationInput
    _$STDEPTEMPOrderByWithAggregationInputFromJson(Map<String, dynamic> json) =>
        STDEPTEMPOrderByWithAggregationInput(
          empNo: $enumDecodeNullable(_$SortOrderEnumMap, json['EMP_NO']),
          empNm: $enumDecodeNullable(_$SortOrderEnumMap, json['EMP_NM']),
          deptCd: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT_CD']),
          deptNm: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT_NM']),
          fctnCd: $enumDecodeNullable(_$SortOrderEnumMap, json['FCTN_CD']),
          fctnNm: $enumDecodeNullable(_$SortOrderEnumMap, json['FCTN_NM']),
          ofcpCd: $enumDecodeNullable(_$SortOrderEnumMap, json['OFCP_CD']),
          ofcpNm: $enumDecodeNullable(_$SortOrderEnumMap, json['OFCP_NM']),
          emailAddr:
              $enumDecodeNullable(_$SortOrderEnumMap, json['EMAIL_ADDR']),
          offmTelno:
              $enumDecodeNullable(_$SortOrderEnumMap, json['OFFM_TELNO']),
          htelTelno:
              $enumDecodeNullable(_$SortOrderEnumMap, json['HTEL_TELNO']),
          deptYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT_YN']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
          $count: json['_count'] == null
              ? null
              : STDEPTEMPCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : STDEPTEMPMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : STDEPTEMPMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STDEPTEMPOrderByWithAggregationInputToJson(
    STDEPTEMPOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('EMP_NO', _$SortOrderEnumMap[instance.empNo]);
  writeNotNull('EMP_NM', _$SortOrderEnumMap[instance.empNm]);
  writeNotNull('DEPT_CD', _$SortOrderEnumMap[instance.deptCd]);
  writeNotNull('DEPT_NM', _$SortOrderEnumMap[instance.deptNm]);
  writeNotNull('FCTN_CD', _$SortOrderEnumMap[instance.fctnCd]);
  writeNotNull('FCTN_NM', _$SortOrderEnumMap[instance.fctnNm]);
  writeNotNull('OFCP_CD', _$SortOrderEnumMap[instance.ofcpCd]);
  writeNotNull('OFCP_NM', _$SortOrderEnumMap[instance.ofcpNm]);
  writeNotNull('EMAIL_ADDR', _$SortOrderEnumMap[instance.emailAddr]);
  writeNotNull('OFFM_TELNO', _$SortOrderEnumMap[instance.offmTelno]);
  writeNotNull('HTEL_TELNO', _$SortOrderEnumMap[instance.htelTelno]);
  writeNotNull('DEPT_YN', _$SortOrderEnumMap[instance.deptYn]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  return val;
}

STDEPTEMPScalarWhereWithAggregatesInput
    _$STDEPTEMPScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        STDEPTEMPScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              STDEPTEMPScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              STDEPTEMPScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              STDEPTEMPScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          empNo: json['EMP_NO'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['EMP_NO'] as Map<String, dynamic>),
          empNm: json['EMP_NM'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['EMP_NM'] as Map<String, dynamic>),
          deptCd: json['DEPT_CD'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEPT_CD'] as Map<String, dynamic>),
          deptNm: json['DEPT_NM'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEPT_NM'] as Map<String, dynamic>),
          fctnCd: json['FCTN_CD'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['FCTN_CD'] as Map<String, dynamic>),
          fctnNm: json['FCTN_NM'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['FCTN_NM'] as Map<String, dynamic>),
          ofcpCd: json['OFCP_CD'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['OFCP_CD'] as Map<String, dynamic>),
          ofcpNm: json['OFCP_NM'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['OFCP_NM'] as Map<String, dynamic>),
          emailAddr: json['EMAIL_ADDR'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EMAIL_ADDR'] as Map<String, dynamic>),
          offmTelno: json['OFFM_TELNO'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['OFFM_TELNO'] as Map<String, dynamic>),
          htelTelno: json['HTEL_TELNO'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['HTEL_TELNO'] as Map<String, dynamic>),
          deptYn: json['DEPT_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEPT_YN'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delId: json['DEL_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_ID'] as Map<String, dynamic>),
          delDate: json['DEL_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STDEPTEMPScalarWhereWithAggregatesInputToJson(
    STDEPTEMPScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('EMP_NO', instance.empNo?.toJson());
  writeNotNull('EMP_NM', instance.empNm?.toJson());
  writeNotNull('DEPT_CD', instance.deptCd?.toJson());
  writeNotNull('DEPT_NM', instance.deptNm?.toJson());
  writeNotNull('FCTN_CD', instance.fctnCd?.toJson());
  writeNotNull('FCTN_NM', instance.fctnNm?.toJson());
  writeNotNull('OFCP_CD', instance.ofcpCd?.toJson());
  writeNotNull('OFCP_NM', instance.ofcpNm?.toJson());
  writeNotNull('EMAIL_ADDR', instance.emailAddr?.toJson());
  writeNotNull('OFFM_TELNO', instance.offmTelno?.toJson());
  writeNotNull('HTEL_TELNO', instance.htelTelno?.toJson());
  writeNotNull('DEPT_YN', instance.deptYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STMENUWhereInput _$STMENUWhereInputFromJson(Map<String, dynamic> json) =>
    STMENUWhereInput(
      AND: (json['AND'] as List<dynamic>?)
          ?.map((e) => STMENUWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)
          ?.map((e) => STMENUWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)
          ?.map((e) => STMENUWhereInput.fromJson(e as Map<String, dynamic>)),
      menuCd: json['MENU_CD'] == null
          ? null
          : StringFilter.fromJson(json['MENU_CD'] as Map<String, dynamic>),
      menuNm: json['MENU_NM'] == null
          ? null
          : StringFilter.fromJson(json['MENU_NM'] as Map<String, dynamic>),
      menuPath: json['MENU_PATH'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['MENU_PATH'] as Map<String, dynamic>),
      menuMapping: json['MENU_MAPPING'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['MENU_MAPPING'] as Map<String, dynamic>),
      menuSrt: json['MENU_SRT'] == null
          ? null
          : IntFilter.fromJson(json['MENU_SRT'] as Map<String, dynamic>),
      menuDeps: json['MENU_DEPS'] == null
          ? null
          : IntFilter.fromJson(json['MENU_DEPS'] as Map<String, dynamic>),
      menuIcon: json['MENU_ICON'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['MENU_ICON'] as Map<String, dynamic>),
      menuTp: json['MENU_TP'] == null
          ? null
          : StringFilter.fromJson(json['MENU_TP'] as Map<String, dynamic>),
      mainExpsrYn: json['MAIN_EXPSR_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['MAIN_EXPSR_YN'] as Map<String, dynamic>),
      subExpsrYn: json['SUB_EXPSR_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['SUB_EXPSR_YN'] as Map<String, dynamic>),
      upendClas: json['UPEND_CLAS'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['UPEND_CLAS'] as Map<String, dynamic>),
      upendCn: json['UPEND_CN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['UPEND_CN'] as Map<String, dynamic>),
      cclType: json['CCL_TYPE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['CCL_TYPE'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFilter.fromJson(json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STMENUWhereInputToJson(STMENUWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('MENU_CD', instance.menuCd?.toJson());
  writeNotNull('MENU_NM', instance.menuNm?.toJson());
  writeNotNull('MENU_PATH', instance.menuPath?.toJson());
  writeNotNull('MENU_MAPPING', instance.menuMapping?.toJson());
  writeNotNull('MENU_SRT', instance.menuSrt?.toJson());
  writeNotNull('MENU_DEPS', instance.menuDeps?.toJson());
  writeNotNull('MENU_ICON', instance.menuIcon?.toJson());
  writeNotNull('MENU_TP', instance.menuTp?.toJson());
  writeNotNull('MAIN_EXPSR_YN', instance.mainExpsrYn?.toJson());
  writeNotNull('SUB_EXPSR_YN', instance.subExpsrYn?.toJson());
  writeNotNull('UPEND_CLAS', instance.upendClas?.toJson());
  writeNotNull('UPEND_CN', instance.upendCn?.toJson());
  writeNotNull('CCL_TYPE', instance.cclType?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STMENUOrderByWithRelationInput _$STMENUOrderByWithRelationInputFromJson(
        Map<String, dynamic> json) =>
    STMENUOrderByWithRelationInput(
      menuCd: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_CD']),
      menuNm: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_NM']),
      menuPath: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_PATH']),
      menuMapping:
          $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_MAPPING']),
      menuSrt: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_SRT']),
      menuDeps: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_DEPS']),
      menuIcon: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_ICON']),
      menuTp: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_TP']),
      mainExpsrYn:
          $enumDecodeNullable(_$SortOrderEnumMap, json['MAIN_EXPSR_YN']),
      subExpsrYn: $enumDecodeNullable(_$SortOrderEnumMap, json['SUB_EXPSR_YN']),
      upendClas: $enumDecodeNullable(_$SortOrderEnumMap, json['UPEND_CLAS']),
      upendCn: $enumDecodeNullable(_$SortOrderEnumMap, json['UPEND_CN']),
      cclType: $enumDecodeNullable(_$SortOrderEnumMap, json['CCL_TYPE']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STMENUOrderByWithRelationInputToJson(
    STMENUOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_CD', _$SortOrderEnumMap[instance.menuCd]);
  writeNotNull('MENU_NM', _$SortOrderEnumMap[instance.menuNm]);
  writeNotNull('MENU_PATH', _$SortOrderEnumMap[instance.menuPath]);
  writeNotNull('MENU_MAPPING', _$SortOrderEnumMap[instance.menuMapping]);
  writeNotNull('MENU_SRT', _$SortOrderEnumMap[instance.menuSrt]);
  writeNotNull('MENU_DEPS', _$SortOrderEnumMap[instance.menuDeps]);
  writeNotNull('MENU_ICON', _$SortOrderEnumMap[instance.menuIcon]);
  writeNotNull('MENU_TP', _$SortOrderEnumMap[instance.menuTp]);
  writeNotNull('MAIN_EXPSR_YN', _$SortOrderEnumMap[instance.mainExpsrYn]);
  writeNotNull('SUB_EXPSR_YN', _$SortOrderEnumMap[instance.subExpsrYn]);
  writeNotNull('UPEND_CLAS', _$SortOrderEnumMap[instance.upendClas]);
  writeNotNull('UPEND_CN', _$SortOrderEnumMap[instance.upendCn]);
  writeNotNull('CCL_TYPE', _$SortOrderEnumMap[instance.cclType]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STMENUWhereUniqueInput _$STMENUWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    STMENUWhereUniqueInput(
      menuCd: json['MENU_CD'] as String?,
    );

Map<String, dynamic> _$STMENUWhereUniqueInputToJson(
    STMENUWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_CD', instance.menuCd);
  return val;
}

STMENUOrderByWithAggregationInput _$STMENUOrderByWithAggregationInputFromJson(
        Map<String, dynamic> json) =>
    STMENUOrderByWithAggregationInput(
      menuCd: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_CD']),
      menuNm: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_NM']),
      menuPath: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_PATH']),
      menuMapping:
          $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_MAPPING']),
      menuSrt: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_SRT']),
      menuDeps: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_DEPS']),
      menuIcon: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_ICON']),
      menuTp: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_TP']),
      mainExpsrYn:
          $enumDecodeNullable(_$SortOrderEnumMap, json['MAIN_EXPSR_YN']),
      subExpsrYn: $enumDecodeNullable(_$SortOrderEnumMap, json['SUB_EXPSR_YN']),
      upendClas: $enumDecodeNullable(_$SortOrderEnumMap, json['UPEND_CLAS']),
      upendCn: $enumDecodeNullable(_$SortOrderEnumMap, json['UPEND_CN']),
      cclType: $enumDecodeNullable(_$SortOrderEnumMap, json['CCL_TYPE']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
      $count: json['_count'] == null
          ? null
          : STMENUCountOrderByAggregateInput.fromJson(
              json['_count'] as Map<String, dynamic>),
      $avg: json['_avg'] == null
          ? null
          : STMENUAvgOrderByAggregateInput.fromJson(
              json['_avg'] as Map<String, dynamic>),
      $max: json['_max'] == null
          ? null
          : STMENUMaxOrderByAggregateInput.fromJson(
              json['_max'] as Map<String, dynamic>),
      $min: json['_min'] == null
          ? null
          : STMENUMinOrderByAggregateInput.fromJson(
              json['_min'] as Map<String, dynamic>),
      $sum: json['_sum'] == null
          ? null
          : STMENUSumOrderByAggregateInput.fromJson(
              json['_sum'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STMENUOrderByWithAggregationInputToJson(
    STMENUOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_CD', _$SortOrderEnumMap[instance.menuCd]);
  writeNotNull('MENU_NM', _$SortOrderEnumMap[instance.menuNm]);
  writeNotNull('MENU_PATH', _$SortOrderEnumMap[instance.menuPath]);
  writeNotNull('MENU_MAPPING', _$SortOrderEnumMap[instance.menuMapping]);
  writeNotNull('MENU_SRT', _$SortOrderEnumMap[instance.menuSrt]);
  writeNotNull('MENU_DEPS', _$SortOrderEnumMap[instance.menuDeps]);
  writeNotNull('MENU_ICON', _$SortOrderEnumMap[instance.menuIcon]);
  writeNotNull('MENU_TP', _$SortOrderEnumMap[instance.menuTp]);
  writeNotNull('MAIN_EXPSR_YN', _$SortOrderEnumMap[instance.mainExpsrYn]);
  writeNotNull('SUB_EXPSR_YN', _$SortOrderEnumMap[instance.subExpsrYn]);
  writeNotNull('UPEND_CLAS', _$SortOrderEnumMap[instance.upendClas]);
  writeNotNull('UPEND_CN', _$SortOrderEnumMap[instance.upendCn]);
  writeNotNull('CCL_TYPE', _$SortOrderEnumMap[instance.cclType]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

STMENUScalarWhereWithAggregatesInput
    _$STMENUScalarWhereWithAggregatesInputFromJson(Map<String, dynamic> json) =>
        STMENUScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              STMENUScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              STMENUScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              STMENUScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          menuCd: json['MENU_CD'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['MENU_CD'] as Map<String, dynamic>),
          menuNm: json['MENU_NM'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['MENU_NM'] as Map<String, dynamic>),
          menuPath: json['MENU_PATH'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['MENU_PATH'] as Map<String, dynamic>),
          menuMapping: json['MENU_MAPPING'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['MENU_MAPPING'] as Map<String, dynamic>),
          menuSrt: json['MENU_SRT'] == null
              ? null
              : IntWithAggregatesFilter.fromJson(
                  json['MENU_SRT'] as Map<String, dynamic>),
          menuDeps: json['MENU_DEPS'] == null
              ? null
              : IntWithAggregatesFilter.fromJson(
                  json['MENU_DEPS'] as Map<String, dynamic>),
          menuIcon: json['MENU_ICON'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['MENU_ICON'] as Map<String, dynamic>),
          menuTp: json['MENU_TP'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['MENU_TP'] as Map<String, dynamic>),
          mainExpsrYn: json['MAIN_EXPSR_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['MAIN_EXPSR_YN'] as Map<String, dynamic>),
          subExpsrYn: json['SUB_EXPSR_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['SUB_EXPSR_YN'] as Map<String, dynamic>),
          upendClas: json['UPEND_CLAS'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['UPEND_CLAS'] as Map<String, dynamic>),
          upendCn: json['UPEND_CN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['UPEND_CN'] as Map<String, dynamic>),
          cclType: json['CCL_TYPE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['CCL_TYPE'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delId: json['DEL_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_ID'] as Map<String, dynamic>),
          delDate: json['DEL_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STMENUScalarWhereWithAggregatesInputToJson(
    STMENUScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('MENU_CD', instance.menuCd?.toJson());
  writeNotNull('MENU_NM', instance.menuNm?.toJson());
  writeNotNull('MENU_PATH', instance.menuPath?.toJson());
  writeNotNull('MENU_MAPPING', instance.menuMapping?.toJson());
  writeNotNull('MENU_SRT', instance.menuSrt?.toJson());
  writeNotNull('MENU_DEPS', instance.menuDeps?.toJson());
  writeNotNull('MENU_ICON', instance.menuIcon?.toJson());
  writeNotNull('MENU_TP', instance.menuTp?.toJson());
  writeNotNull('MAIN_EXPSR_YN', instance.mainExpsrYn?.toJson());
  writeNotNull('SUB_EXPSR_YN', instance.subExpsrYn?.toJson());
  writeNotNull('UPEND_CLAS', instance.upendClas?.toJson());
  writeNotNull('UPEND_CN', instance.upendCn?.toJson());
  writeNotNull('CCL_TYPE', instance.cclType?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STMESSAGETMPLATWhereInput _$STMESSAGETMPLATWhereInputFromJson(
        Map<String, dynamic> json) =>
    STMESSAGETMPLATWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map(
          (e) => STMESSAGETMPLATWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map(
          (e) => STMESSAGETMPLATWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map(
          (e) => STMESSAGETMPLATWhereInput.fromJson(e as Map<String, dynamic>)),
      msgDivCd: json['MSG_DIV_CD'] == null
          ? null
          : StringFilter.fromJson(json['MSG_DIV_CD'] as Map<String, dynamic>),
      msgCd: json['MSG_CD'] == null
          ? null
          : StringFilter.fromJson(json['MSG_CD'] as Map<String, dynamic>),
      msgNm: json['MSG_NM'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['MSG_NM'] as Map<String, dynamic>),
      msgTmplat: json['MSG_TMPLAT'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['MSG_TMPLAT'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STMESSAGETMPLATWhereInputToJson(
    STMESSAGETMPLATWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('MSG_DIV_CD', instance.msgDivCd?.toJson());
  writeNotNull('MSG_CD', instance.msgCd?.toJson());
  writeNotNull('MSG_NM', instance.msgNm?.toJson());
  writeNotNull('MSG_TMPLAT', instance.msgTmplat?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  return val;
}

STMESSAGETMPLATOrderByWithRelationInput
    _$STMESSAGETMPLATOrderByWithRelationInputFromJson(
            Map<String, dynamic> json) =>
        STMESSAGETMPLATOrderByWithRelationInput(
          msgDivCd: $enumDecodeNullable(_$SortOrderEnumMap, json['MSG_DIV_CD']),
          msgCd: $enumDecodeNullable(_$SortOrderEnumMap, json['MSG_CD']),
          msgNm: $enumDecodeNullable(_$SortOrderEnumMap, json['MSG_NM']),
          msgTmplat:
              $enumDecodeNullable(_$SortOrderEnumMap, json['MSG_TMPLAT']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
        );

Map<String, dynamic> _$STMESSAGETMPLATOrderByWithRelationInputToJson(
    STMESSAGETMPLATOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MSG_DIV_CD', _$SortOrderEnumMap[instance.msgDivCd]);
  writeNotNull('MSG_CD', _$SortOrderEnumMap[instance.msgCd]);
  writeNotNull('MSG_NM', _$SortOrderEnumMap[instance.msgNm]);
  writeNotNull('MSG_TMPLAT', _$SortOrderEnumMap[instance.msgTmplat]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  return val;
}

STMESSAGETMPLATWhereUniqueInput _$STMESSAGETMPLATWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    STMESSAGETMPLATWhereUniqueInput(
      msgDivCdMsgCd: json['MSG_DIV_CD_MSG_CD'] == null
          ? null
          : STMESSAGETMPLATMSGDIVCDMSGCDCompoundUniqueInput.fromJson(
              json['MSG_DIV_CD_MSG_CD'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STMESSAGETMPLATWhereUniqueInputToJson(
    STMESSAGETMPLATWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MSG_DIV_CD_MSG_CD', instance.msgDivCdMsgCd?.toJson());
  return val;
}

STMESSAGETMPLATOrderByWithAggregationInput
    _$STMESSAGETMPLATOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        STMESSAGETMPLATOrderByWithAggregationInput(
          msgDivCd: $enumDecodeNullable(_$SortOrderEnumMap, json['MSG_DIV_CD']),
          msgCd: $enumDecodeNullable(_$SortOrderEnumMap, json['MSG_CD']),
          msgNm: $enumDecodeNullable(_$SortOrderEnumMap, json['MSG_NM']),
          msgTmplat:
              $enumDecodeNullable(_$SortOrderEnumMap, json['MSG_TMPLAT']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          $count: json['_count'] == null
              ? null
              : STMESSAGETMPLATCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : STMESSAGETMPLATMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : STMESSAGETMPLATMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STMESSAGETMPLATOrderByWithAggregationInputToJson(
    STMESSAGETMPLATOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MSG_DIV_CD', _$SortOrderEnumMap[instance.msgDivCd]);
  writeNotNull('MSG_CD', _$SortOrderEnumMap[instance.msgCd]);
  writeNotNull('MSG_NM', _$SortOrderEnumMap[instance.msgNm]);
  writeNotNull('MSG_TMPLAT', _$SortOrderEnumMap[instance.msgTmplat]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  return val;
}

STMESSAGETMPLATScalarWhereWithAggregatesInput
    _$STMESSAGETMPLATScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        STMESSAGETMPLATScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              STMESSAGETMPLATScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              STMESSAGETMPLATScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              STMESSAGETMPLATScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          msgDivCd: json['MSG_DIV_CD'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['MSG_DIV_CD'] as Map<String, dynamic>),
          msgCd: json['MSG_CD'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['MSG_CD'] as Map<String, dynamic>),
          msgNm: json['MSG_NM'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['MSG_NM'] as Map<String, dynamic>),
          msgTmplat: json['MSG_TMPLAT'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['MSG_TMPLAT'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STMESSAGETMPLATScalarWhereWithAggregatesInputToJson(
    STMESSAGETMPLATScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('MSG_DIV_CD', instance.msgDivCd?.toJson());
  writeNotNull('MSG_CD', instance.msgCd?.toJson());
  writeNotNull('MSG_NM', instance.msgNm?.toJson());
  writeNotNull('MSG_TMPLAT', instance.msgTmplat?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  return val;
}

STMIMETYPEWhereInput _$STMIMETYPEWhereInputFromJson(
        Map<String, dynamic> json) =>
    STMIMETYPEWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map(
          (e) => STMIMETYPEWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map(
          (e) => STMIMETYPEWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map(
          (e) => STMIMETYPEWhereInput.fromJson(e as Map<String, dynamic>)),
      seq: json['SEQ'] == null
          ? null
          : IntFilter.fromJson(json['SEQ'] as Map<String, dynamic>),
      extnNm: json['EXTN_NM'] == null
          ? null
          : StringFilter.fromJson(json['EXTN_NM'] as Map<String, dynamic>),
      fileMt: json['FILE_MT'] == null
          ? null
          : StringFilter.fromJson(json['FILE_MT'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STMIMETYPEWhereInputToJson(
    STMIMETYPEWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('EXTN_NM', instance.extnNm?.toJson());
  writeNotNull('FILE_MT', instance.fileMt?.toJson());
  return val;
}

STMIMETYPEOrderByWithRelationInput _$STMIMETYPEOrderByWithRelationInputFromJson(
        Map<String, dynamic> json) =>
    STMIMETYPEOrderByWithRelationInput(
      seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
      extnNm: $enumDecodeNullable(_$SortOrderEnumMap, json['EXTN_NM']),
      fileMt: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_MT']),
    );

Map<String, dynamic> _$STMIMETYPEOrderByWithRelationInputToJson(
    STMIMETYPEOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('EXTN_NM', _$SortOrderEnumMap[instance.extnNm]);
  writeNotNull('FILE_MT', _$SortOrderEnumMap[instance.fileMt]);
  return val;
}

STMIMETYPEWhereUniqueInput _$STMIMETYPEWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    STMIMETYPEWhereUniqueInput(
      seq: json['SEQ'] as int?,
    );

Map<String, dynamic> _$STMIMETYPEWhereUniqueInputToJson(
    STMIMETYPEWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq);
  return val;
}

STMIMETYPEOrderByWithAggregationInput
    _$STMIMETYPEOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        STMIMETYPEOrderByWithAggregationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          extnNm: $enumDecodeNullable(_$SortOrderEnumMap, json['EXTN_NM']),
          fileMt: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_MT']),
          $count: json['_count'] == null
              ? null
              : STMIMETYPECountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : STMIMETYPEAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : STMIMETYPEMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : STMIMETYPEMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : STMIMETYPESumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STMIMETYPEOrderByWithAggregationInputToJson(
    STMIMETYPEOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('EXTN_NM', _$SortOrderEnumMap[instance.extnNm]);
  writeNotNull('FILE_MT', _$SortOrderEnumMap[instance.fileMt]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

STMIMETYPEScalarWhereWithAggregatesInput
    _$STMIMETYPEScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        STMIMETYPEScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              STMIMETYPEScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              STMIMETYPEScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              STMIMETYPEScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          seq: json['SEQ'] == null
              ? null
              : IntWithAggregatesFilter.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          extnNm: json['EXTN_NM'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['EXTN_NM'] as Map<String, dynamic>),
          fileMt: json['FILE_MT'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['FILE_MT'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STMIMETYPEScalarWhereWithAggregatesInputToJson(
    STMIMETYPEScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('EXTN_NM', instance.extnNm?.toJson());
  writeNotNull('FILE_MT', instance.fileMt?.toJson());
  return val;
}

STMNGRGRPWhereInput _$STMNGRGRPWhereInputFromJson(Map<String, dynamic> json) =>
    STMNGRGRPWhereInput(
      AND: (json['AND'] as List<dynamic>?)
          ?.map((e) => STMNGRGRPWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)
          ?.map((e) => STMNGRGRPWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)
          ?.map((e) => STMNGRGRPWhereInput.fromJson(e as Map<String, dynamic>)),
      grpCd: json['GRP_CD'] == null
          ? null
          : StringFilter.fromJson(json['GRP_CD'] as Map<String, dynamic>),
      grpNm: json['GRP_NM'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['GRP_NM'] as Map<String, dynamic>),
      grpDesc: json['GRP_DESC'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['GRP_DESC'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : IntNullableFilter.fromJson(json['SORT'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFilter.fromJson(json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STMNGRGRPWhereInputToJson(STMNGRGRPWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('GRP_CD', instance.grpCd?.toJson());
  writeNotNull('GRP_NM', instance.grpNm?.toJson());
  writeNotNull('GRP_DESC', instance.grpDesc?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STMNGRGRPOrderByWithRelationInput _$STMNGRGRPOrderByWithRelationInputFromJson(
        Map<String, dynamic> json) =>
    STMNGRGRPOrderByWithRelationInput(
      grpCd: $enumDecodeNullable(_$SortOrderEnumMap, json['GRP_CD']),
      grpNm: $enumDecodeNullable(_$SortOrderEnumMap, json['GRP_NM']),
      grpDesc: $enumDecodeNullable(_$SortOrderEnumMap, json['GRP_DESC']),
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STMNGRGRPOrderByWithRelationInputToJson(
    STMNGRGRPOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('GRP_CD', _$SortOrderEnumMap[instance.grpCd]);
  writeNotNull('GRP_NM', _$SortOrderEnumMap[instance.grpNm]);
  writeNotNull('GRP_DESC', _$SortOrderEnumMap[instance.grpDesc]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STMNGRGRPWhereUniqueInput _$STMNGRGRPWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    STMNGRGRPWhereUniqueInput(
      grpCd: json['GRP_CD'] as String?,
    );

Map<String, dynamic> _$STMNGRGRPWhereUniqueInputToJson(
    STMNGRGRPWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('GRP_CD', instance.grpCd);
  return val;
}

STMNGRGRPOrderByWithAggregationInput
    _$STMNGRGRPOrderByWithAggregationInputFromJson(Map<String, dynamic> json) =>
        STMNGRGRPOrderByWithAggregationInput(
          grpCd: $enumDecodeNullable(_$SortOrderEnumMap, json['GRP_CD']),
          grpNm: $enumDecodeNullable(_$SortOrderEnumMap, json['GRP_NM']),
          grpDesc: $enumDecodeNullable(_$SortOrderEnumMap, json['GRP_DESC']),
          sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
          $count: json['_count'] == null
              ? null
              : STMNGRGRPCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : STMNGRGRPAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : STMNGRGRPMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : STMNGRGRPMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : STMNGRGRPSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STMNGRGRPOrderByWithAggregationInputToJson(
    STMNGRGRPOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('GRP_CD', _$SortOrderEnumMap[instance.grpCd]);
  writeNotNull('GRP_NM', _$SortOrderEnumMap[instance.grpNm]);
  writeNotNull('GRP_DESC', _$SortOrderEnumMap[instance.grpDesc]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

STMNGRGRPScalarWhereWithAggregatesInput
    _$STMNGRGRPScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        STMNGRGRPScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              STMNGRGRPScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              STMNGRGRPScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              STMNGRGRPScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          grpCd: json['GRP_CD'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['GRP_CD'] as Map<String, dynamic>),
          grpNm: json['GRP_NM'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['GRP_NM'] as Map<String, dynamic>),
          grpDesc: json['GRP_DESC'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['GRP_DESC'] as Map<String, dynamic>),
          sort: json['SORT'] == null
              ? null
              : IntNullableWithAggregatesFilter.fromJson(
                  json['SORT'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delId: json['DEL_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_ID'] as Map<String, dynamic>),
          delDate: json['DEL_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STMNGRGRPScalarWhereWithAggregatesInputToJson(
    STMNGRGRPScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('GRP_CD', instance.grpCd?.toJson());
  writeNotNull('GRP_NM', instance.grpNm?.toJson());
  writeNotNull('GRP_DESC', instance.grpDesc?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STMNGRMSTWhereInput _$STMNGRMSTWhereInputFromJson(Map<String, dynamic> json) =>
    STMNGRMSTWhereInput(
      AND: (json['AND'] as List<dynamic>?)
          ?.map((e) => STMNGRMSTWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)
          ?.map((e) => STMNGRMSTWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)
          ?.map((e) => STMNGRMSTWhereInput.fromJson(e as Map<String, dynamic>)),
      mngrId: json['MNGR_ID'] == null
          ? null
          : StringFilter.fromJson(json['MNGR_ID'] as Map<String, dynamic>),
      mngrNm: json['MNGR_NM'] == null
          ? null
          : StringFilter.fromJson(json['MNGR_NM'] as Map<String, dynamic>),
      mngrPw: json['MNGR_PW'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['MNGR_PW'] as Map<String, dynamic>),
      grpCd: json['GRP_CD'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['GRP_CD'] as Map<String, dynamic>),
      grade: json['GRADE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['GRADE'] as Map<String, dynamic>),
      permCd: json['PERM_CD'] == null
          ? null
          : StringFilter.fromJson(json['PERM_CD'] as Map<String, dynamic>),
      acsYn: json['ACS_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['ACS_YN'] as Map<String, dynamic>),
      clph: json['CLPH'] == null
          ? null
          : StringNullableFilter.fromJson(json['CLPH'] as Map<String, dynamic>),
      empNo: json['EMP_NO'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EMP_NO'] as Map<String, dynamic>),
      joinDate: json['JOIN_DATE'] == null
          ? null
          : StringFilter.fromJson(json['JOIN_DATE'] as Map<String, dynamic>),
      retireDate: json['RETIRE_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(
              json['RETIRE_DATE'] as Map<String, dynamic>),
      pwdChgDate: json['PWD_CHG_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(
              json['PWD_CHG_DATE'] as Map<String, dynamic>),
      pwdWrongCnt: json['PWD_WRONG_CNT'] == null
          ? null
          : IntNullableFilter.fromJson(
              json['PWD_WRONG_CNT'] as Map<String, dynamic>),
      pwdWrongDate: json['PWD_WRONG_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['PWD_WRONG_DATE'] as Map<String, dynamic>),
      lstLoginDate: json['LST_LOGIN_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['LST_LOGIN_DATE'] as Map<String, dynamic>),
      flpth: json['FLPTH'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['FLPTH'] as Map<String, dynamic>),
      fileNm: json['FILE_NM'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['FILE_NM'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFilter.fromJson(json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STMNGRMSTWhereInputToJson(STMNGRMSTWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('MNGR_ID', instance.mngrId?.toJson());
  writeNotNull('MNGR_NM', instance.mngrNm?.toJson());
  writeNotNull('MNGR_PW', instance.mngrPw?.toJson());
  writeNotNull('GRP_CD', instance.grpCd?.toJson());
  writeNotNull('GRADE', instance.grade?.toJson());
  writeNotNull('PERM_CD', instance.permCd?.toJson());
  writeNotNull('ACS_YN', instance.acsYn?.toJson());
  writeNotNull('CLPH', instance.clph?.toJson());
  writeNotNull('EMP_NO', instance.empNo?.toJson());
  writeNotNull('JOIN_DATE', instance.joinDate?.toJson());
  writeNotNull('RETIRE_DATE', instance.retireDate?.toJson());
  writeNotNull('PWD_CHG_DATE', instance.pwdChgDate?.toJson());
  writeNotNull('PWD_WRONG_CNT', instance.pwdWrongCnt?.toJson());
  writeNotNull('PWD_WRONG_DATE', instance.pwdWrongDate?.toJson());
  writeNotNull('LST_LOGIN_DATE', instance.lstLoginDate?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('FILE_NM', instance.fileNm?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STMNGRMSTOrderByWithRelationInput _$STMNGRMSTOrderByWithRelationInputFromJson(
        Map<String, dynamic> json) =>
    STMNGRMSTOrderByWithRelationInput(
      mngrId: $enumDecodeNullable(_$SortOrderEnumMap, json['MNGR_ID']),
      mngrNm: $enumDecodeNullable(_$SortOrderEnumMap, json['MNGR_NM']),
      mngrPw: $enumDecodeNullable(_$SortOrderEnumMap, json['MNGR_PW']),
      grpCd: $enumDecodeNullable(_$SortOrderEnumMap, json['GRP_CD']),
      grade: $enumDecodeNullable(_$SortOrderEnumMap, json['GRADE']),
      permCd: $enumDecodeNullable(_$SortOrderEnumMap, json['PERM_CD']),
      acsYn: $enumDecodeNullable(_$SortOrderEnumMap, json['ACS_YN']),
      clph: $enumDecodeNullable(_$SortOrderEnumMap, json['CLPH']),
      empNo: $enumDecodeNullable(_$SortOrderEnumMap, json['EMP_NO']),
      joinDate: $enumDecodeNullable(_$SortOrderEnumMap, json['JOIN_DATE']),
      retireDate: $enumDecodeNullable(_$SortOrderEnumMap, json['RETIRE_DATE']),
      pwdChgDate: $enumDecodeNullable(_$SortOrderEnumMap, json['PWD_CHG_DATE']),
      pwdWrongCnt:
          $enumDecodeNullable(_$SortOrderEnumMap, json['PWD_WRONG_CNT']),
      pwdWrongDate:
          $enumDecodeNullable(_$SortOrderEnumMap, json['PWD_WRONG_DATE']),
      lstLoginDate:
          $enumDecodeNullable(_$SortOrderEnumMap, json['LST_LOGIN_DATE']),
      flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
      fileNm: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_NM']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STMNGRMSTOrderByWithRelationInputToJson(
    STMNGRMSTOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MNGR_ID', _$SortOrderEnumMap[instance.mngrId]);
  writeNotNull('MNGR_NM', _$SortOrderEnumMap[instance.mngrNm]);
  writeNotNull('MNGR_PW', _$SortOrderEnumMap[instance.mngrPw]);
  writeNotNull('GRP_CD', _$SortOrderEnumMap[instance.grpCd]);
  writeNotNull('GRADE', _$SortOrderEnumMap[instance.grade]);
  writeNotNull('PERM_CD', _$SortOrderEnumMap[instance.permCd]);
  writeNotNull('ACS_YN', _$SortOrderEnumMap[instance.acsYn]);
  writeNotNull('CLPH', _$SortOrderEnumMap[instance.clph]);
  writeNotNull('EMP_NO', _$SortOrderEnumMap[instance.empNo]);
  writeNotNull('JOIN_DATE', _$SortOrderEnumMap[instance.joinDate]);
  writeNotNull('RETIRE_DATE', _$SortOrderEnumMap[instance.retireDate]);
  writeNotNull('PWD_CHG_DATE', _$SortOrderEnumMap[instance.pwdChgDate]);
  writeNotNull('PWD_WRONG_CNT', _$SortOrderEnumMap[instance.pwdWrongCnt]);
  writeNotNull('PWD_WRONG_DATE', _$SortOrderEnumMap[instance.pwdWrongDate]);
  writeNotNull('LST_LOGIN_DATE', _$SortOrderEnumMap[instance.lstLoginDate]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('FILE_NM', _$SortOrderEnumMap[instance.fileNm]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STMNGRMSTWhereUniqueInput _$STMNGRMSTWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    STMNGRMSTWhereUniqueInput(
      mngrId: json['MNGR_ID'] as String?,
    );

Map<String, dynamic> _$STMNGRMSTWhereUniqueInputToJson(
    STMNGRMSTWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MNGR_ID', instance.mngrId);
  return val;
}

STMNGRMSTOrderByWithAggregationInput
    _$STMNGRMSTOrderByWithAggregationInputFromJson(Map<String, dynamic> json) =>
        STMNGRMSTOrderByWithAggregationInput(
          mngrId: $enumDecodeNullable(_$SortOrderEnumMap, json['MNGR_ID']),
          mngrNm: $enumDecodeNullable(_$SortOrderEnumMap, json['MNGR_NM']),
          mngrPw: $enumDecodeNullable(_$SortOrderEnumMap, json['MNGR_PW']),
          grpCd: $enumDecodeNullable(_$SortOrderEnumMap, json['GRP_CD']),
          grade: $enumDecodeNullable(_$SortOrderEnumMap, json['GRADE']),
          permCd: $enumDecodeNullable(_$SortOrderEnumMap, json['PERM_CD']),
          acsYn: $enumDecodeNullable(_$SortOrderEnumMap, json['ACS_YN']),
          clph: $enumDecodeNullable(_$SortOrderEnumMap, json['CLPH']),
          empNo: $enumDecodeNullable(_$SortOrderEnumMap, json['EMP_NO']),
          joinDate: $enumDecodeNullable(_$SortOrderEnumMap, json['JOIN_DATE']),
          retireDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['RETIRE_DATE']),
          pwdChgDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PWD_CHG_DATE']),
          pwdWrongCnt:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PWD_WRONG_CNT']),
          pwdWrongDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PWD_WRONG_DATE']),
          lstLoginDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['LST_LOGIN_DATE']),
          flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
          fileNm: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_NM']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
          $count: json['_count'] == null
              ? null
              : STMNGRMSTCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : STMNGRMSTAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : STMNGRMSTMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : STMNGRMSTMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : STMNGRMSTSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STMNGRMSTOrderByWithAggregationInputToJson(
    STMNGRMSTOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MNGR_ID', _$SortOrderEnumMap[instance.mngrId]);
  writeNotNull('MNGR_NM', _$SortOrderEnumMap[instance.mngrNm]);
  writeNotNull('MNGR_PW', _$SortOrderEnumMap[instance.mngrPw]);
  writeNotNull('GRP_CD', _$SortOrderEnumMap[instance.grpCd]);
  writeNotNull('GRADE', _$SortOrderEnumMap[instance.grade]);
  writeNotNull('PERM_CD', _$SortOrderEnumMap[instance.permCd]);
  writeNotNull('ACS_YN', _$SortOrderEnumMap[instance.acsYn]);
  writeNotNull('CLPH', _$SortOrderEnumMap[instance.clph]);
  writeNotNull('EMP_NO', _$SortOrderEnumMap[instance.empNo]);
  writeNotNull('JOIN_DATE', _$SortOrderEnumMap[instance.joinDate]);
  writeNotNull('RETIRE_DATE', _$SortOrderEnumMap[instance.retireDate]);
  writeNotNull('PWD_CHG_DATE', _$SortOrderEnumMap[instance.pwdChgDate]);
  writeNotNull('PWD_WRONG_CNT', _$SortOrderEnumMap[instance.pwdWrongCnt]);
  writeNotNull('PWD_WRONG_DATE', _$SortOrderEnumMap[instance.pwdWrongDate]);
  writeNotNull('LST_LOGIN_DATE', _$SortOrderEnumMap[instance.lstLoginDate]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('FILE_NM', _$SortOrderEnumMap[instance.fileNm]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

STMNGRMSTScalarWhereWithAggregatesInput
    _$STMNGRMSTScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        STMNGRMSTScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              STMNGRMSTScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              STMNGRMSTScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              STMNGRMSTScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          mngrId: json['MNGR_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['MNGR_ID'] as Map<String, dynamic>),
          mngrNm: json['MNGR_NM'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['MNGR_NM'] as Map<String, dynamic>),
          mngrPw: json['MNGR_PW'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['MNGR_PW'] as Map<String, dynamic>),
          grpCd: json['GRP_CD'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['GRP_CD'] as Map<String, dynamic>),
          grade: json['GRADE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['GRADE'] as Map<String, dynamic>),
          permCd: json['PERM_CD'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['PERM_CD'] as Map<String, dynamic>),
          acsYn: json['ACS_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['ACS_YN'] as Map<String, dynamic>),
          clph: json['CLPH'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['CLPH'] as Map<String, dynamic>),
          empNo: json['EMP_NO'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EMP_NO'] as Map<String, dynamic>),
          joinDate: json['JOIN_DATE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['JOIN_DATE'] as Map<String, dynamic>),
          retireDate: json['RETIRE_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['RETIRE_DATE'] as Map<String, dynamic>),
          pwdChgDate: json['PWD_CHG_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['PWD_CHG_DATE'] as Map<String, dynamic>),
          pwdWrongCnt: json['PWD_WRONG_CNT'] == null
              ? null
              : IntNullableWithAggregatesFilter.fromJson(
                  json['PWD_WRONG_CNT'] as Map<String, dynamic>),
          pwdWrongDate: json['PWD_WRONG_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['PWD_WRONG_DATE'] as Map<String, dynamic>),
          lstLoginDate: json['LST_LOGIN_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['LST_LOGIN_DATE'] as Map<String, dynamic>),
          flpth: json['FLPTH'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['FLPTH'] as Map<String, dynamic>),
          fileNm: json['FILE_NM'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['FILE_NM'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delId: json['DEL_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_ID'] as Map<String, dynamic>),
          delDate: json['DEL_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STMNGRMSTScalarWhereWithAggregatesInputToJson(
    STMNGRMSTScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('MNGR_ID', instance.mngrId?.toJson());
  writeNotNull('MNGR_NM', instance.mngrNm?.toJson());
  writeNotNull('MNGR_PW', instance.mngrPw?.toJson());
  writeNotNull('GRP_CD', instance.grpCd?.toJson());
  writeNotNull('GRADE', instance.grade?.toJson());
  writeNotNull('PERM_CD', instance.permCd?.toJson());
  writeNotNull('ACS_YN', instance.acsYn?.toJson());
  writeNotNull('CLPH', instance.clph?.toJson());
  writeNotNull('EMP_NO', instance.empNo?.toJson());
  writeNotNull('JOIN_DATE', instance.joinDate?.toJson());
  writeNotNull('RETIRE_DATE', instance.retireDate?.toJson());
  writeNotNull('PWD_CHG_DATE', instance.pwdChgDate?.toJson());
  writeNotNull('PWD_WRONG_CNT', instance.pwdWrongCnt?.toJson());
  writeNotNull('PWD_WRONG_DATE', instance.pwdWrongDate?.toJson());
  writeNotNull('LST_LOGIN_DATE', instance.lstLoginDate?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('FILE_NM', instance.fileNm?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STMYSTNGWhereInput _$STMYSTNGWhereInputFromJson(Map<String, dynamic> json) =>
    STMYSTNGWhereInput(
      AND: (json['AND'] as List<dynamic>?)
          ?.map((e) => STMYSTNGWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)
          ?.map((e) => STMYSTNGWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)
          ?.map((e) => STMYSTNGWhereInput.fromJson(e as Map<String, dynamic>)),
      userId: json['USER_ID'] == null
          ? null
          : StringFilter.fromJson(json['USER_ID'] as Map<String, dynamic>),
      stngCd: json['STNG_CD'] == null
          ? null
          : StringFilter.fromJson(json['STNG_CD'] as Map<String, dynamic>),
      userDiv: json['USER_DIV'] == null
          ? null
          : StringFilter.fromJson(json['USER_DIV'] as Map<String, dynamic>),
      stngData: json['STNG_DATA'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['STNG_DATA'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STMYSTNGWhereInputToJson(STMYSTNGWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('STNG_CD', instance.stngCd?.toJson());
  writeNotNull('USER_DIV', instance.userDiv?.toJson());
  writeNotNull('STNG_DATA', instance.stngData?.toJson());
  return val;
}

STMYSTNGOrderByWithRelationInput _$STMYSTNGOrderByWithRelationInputFromJson(
        Map<String, dynamic> json) =>
    STMYSTNGOrderByWithRelationInput(
      userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
      stngCd: $enumDecodeNullable(_$SortOrderEnumMap, json['STNG_CD']),
      userDiv: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_DIV']),
      stngData: $enumDecodeNullable(_$SortOrderEnumMap, json['STNG_DATA']),
    );

Map<String, dynamic> _$STMYSTNGOrderByWithRelationInputToJson(
    STMYSTNGOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('STNG_CD', _$SortOrderEnumMap[instance.stngCd]);
  writeNotNull('USER_DIV', _$SortOrderEnumMap[instance.userDiv]);
  writeNotNull('STNG_DATA', _$SortOrderEnumMap[instance.stngData]);
  return val;
}

STMYSTNGWhereUniqueInput _$STMYSTNGWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    STMYSTNGWhereUniqueInput(
      userIdStngCdUserDiv: json['USER_ID_STNG_CD_USER_DIV'] == null
          ? null
          : STMYSTNGUSERIDSTNGCDUSERDIVCompoundUniqueInput.fromJson(
              json['USER_ID_STNG_CD_USER_DIV'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STMYSTNGWhereUniqueInputToJson(
    STMYSTNGWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull(
      'USER_ID_STNG_CD_USER_DIV', instance.userIdStngCdUserDiv?.toJson());
  return val;
}

STMYSTNGOrderByWithAggregationInput
    _$STMYSTNGOrderByWithAggregationInputFromJson(Map<String, dynamic> json) =>
        STMYSTNGOrderByWithAggregationInput(
          userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
          stngCd: $enumDecodeNullable(_$SortOrderEnumMap, json['STNG_CD']),
          userDiv: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_DIV']),
          stngData: $enumDecodeNullable(_$SortOrderEnumMap, json['STNG_DATA']),
          $count: json['_count'] == null
              ? null
              : STMYSTNGCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : STMYSTNGMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : STMYSTNGMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STMYSTNGOrderByWithAggregationInputToJson(
    STMYSTNGOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('STNG_CD', _$SortOrderEnumMap[instance.stngCd]);
  writeNotNull('USER_DIV', _$SortOrderEnumMap[instance.userDiv]);
  writeNotNull('STNG_DATA', _$SortOrderEnumMap[instance.stngData]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  return val;
}

STMYSTNGScalarWhereWithAggregatesInput
    _$STMYSTNGScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        STMYSTNGScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              STMYSTNGScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              STMYSTNGScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              STMYSTNGScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          userId: json['USER_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['USER_ID'] as Map<String, dynamic>),
          stngCd: json['STNG_CD'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['STNG_CD'] as Map<String, dynamic>),
          userDiv: json['USER_DIV'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['USER_DIV'] as Map<String, dynamic>),
          stngData: json['STNG_DATA'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['STNG_DATA'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STMYSTNGScalarWhereWithAggregatesInputToJson(
    STMYSTNGScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('STNG_CD', instance.stngCd?.toJson());
  writeNotNull('USER_DIV', instance.userDiv?.toJson());
  writeNotNull('STNG_DATA', instance.stngData?.toJson());
  return val;
}

STPERMDTLWhereInput _$STPERMDTLWhereInputFromJson(Map<String, dynamic> json) =>
    STPERMDTLWhereInput(
      AND: (json['AND'] as List<dynamic>?)
          ?.map((e) => STPERMDTLWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)
          ?.map((e) => STPERMDTLWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)
          ?.map((e) => STPERMDTLWhereInput.fromJson(e as Map<String, dynamic>)),
      permCd: json['PERM_CD'] == null
          ? null
          : StringFilter.fromJson(json['PERM_CD'] as Map<String, dynamic>),
      menuCd: json['MENU_CD'] == null
          ? null
          : StringFilter.fromJson(json['MENU_CD'] as Map<String, dynamic>),
      readYn: json['READ_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['READ_YN'] as Map<String, dynamic>),
      regYn: json['REG_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['REG_YN'] as Map<String, dynamic>),
      mdfcnYn: json['MDFCN_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['MDFCN_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      manageYn: json['MANAGE_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['MANAGE_YN'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFilter.fromJson(json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STPERMDTLWhereInputToJson(STPERMDTLWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('PERM_CD', instance.permCd?.toJson());
  writeNotNull('MENU_CD', instance.menuCd?.toJson());
  writeNotNull('READ_YN', instance.readYn?.toJson());
  writeNotNull('REG_YN', instance.regYn?.toJson());
  writeNotNull('MDFCN_YN', instance.mdfcnYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('MANAGE_YN', instance.manageYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

STPERMDTLOrderByWithRelationInput _$STPERMDTLOrderByWithRelationInputFromJson(
        Map<String, dynamic> json) =>
    STPERMDTLOrderByWithRelationInput(
      permCd: $enumDecodeNullable(_$SortOrderEnumMap, json['PERM_CD']),
      menuCd: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_CD']),
      readYn: $enumDecodeNullable(_$SortOrderEnumMap, json['READ_YN']),
      regYn: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_YN']),
      mdfcnYn: $enumDecodeNullable(_$SortOrderEnumMap, json['MDFCN_YN']),
      delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
      manageYn: $enumDecodeNullable(_$SortOrderEnumMap, json['MANAGE_YN']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
    );

Map<String, dynamic> _$STPERMDTLOrderByWithRelationInputToJson(
    STPERMDTLOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('PERM_CD', _$SortOrderEnumMap[instance.permCd]);
  writeNotNull('MENU_CD', _$SortOrderEnumMap[instance.menuCd]);
  writeNotNull('READ_YN', _$SortOrderEnumMap[instance.readYn]);
  writeNotNull('REG_YN', _$SortOrderEnumMap[instance.regYn]);
  writeNotNull('MDFCN_YN', _$SortOrderEnumMap[instance.mdfcnYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('MANAGE_YN', _$SortOrderEnumMap[instance.manageYn]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  return val;
}

STPERMDTLWhereUniqueInput _$STPERMDTLWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    STPERMDTLWhereUniqueInput(
      permCdMenuCd: json['PERM_CD_MENU_CD'] == null
          ? null
          : STPERMDTLPERMCDMENUCDCompoundUniqueInput.fromJson(
              json['PERM_CD_MENU_CD'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STPERMDTLWhereUniqueInputToJson(
    STPERMDTLWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('PERM_CD_MENU_CD', instance.permCdMenuCd?.toJson());
  return val;
}

STPERMDTLOrderByWithAggregationInput
    _$STPERMDTLOrderByWithAggregationInputFromJson(Map<String, dynamic> json) =>
        STPERMDTLOrderByWithAggregationInput(
          permCd: $enumDecodeNullable(_$SortOrderEnumMap, json['PERM_CD']),
          menuCd: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_CD']),
          readYn: $enumDecodeNullable(_$SortOrderEnumMap, json['READ_YN']),
          regYn: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_YN']),
          mdfcnYn: $enumDecodeNullable(_$SortOrderEnumMap, json['MDFCN_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          manageYn: $enumDecodeNullable(_$SortOrderEnumMap, json['MANAGE_YN']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          $count: json['_count'] == null
              ? null
              : STPERMDTLCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : STPERMDTLMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : STPERMDTLMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STPERMDTLOrderByWithAggregationInputToJson(
    STPERMDTLOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('PERM_CD', _$SortOrderEnumMap[instance.permCd]);
  writeNotNull('MENU_CD', _$SortOrderEnumMap[instance.menuCd]);
  writeNotNull('READ_YN', _$SortOrderEnumMap[instance.readYn]);
  writeNotNull('REG_YN', _$SortOrderEnumMap[instance.regYn]);
  writeNotNull('MDFCN_YN', _$SortOrderEnumMap[instance.mdfcnYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('MANAGE_YN', _$SortOrderEnumMap[instance.manageYn]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  return val;
}

STPERMDTLScalarWhereWithAggregatesInput
    _$STPERMDTLScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        STPERMDTLScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              STPERMDTLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              STPERMDTLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              STPERMDTLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          permCd: json['PERM_CD'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['PERM_CD'] as Map<String, dynamic>),
          menuCd: json['MENU_CD'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['MENU_CD'] as Map<String, dynamic>),
          readYn: json['READ_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['READ_YN'] as Map<String, dynamic>),
          regYn: json['REG_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['REG_YN'] as Map<String, dynamic>),
          mdfcnYn: json['MDFCN_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['MDFCN_YN'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
          manageYn: json['MANAGE_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['MANAGE_YN'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STPERMDTLScalarWhereWithAggregatesInputToJson(
    STPERMDTLScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('PERM_CD', instance.permCd?.toJson());
  writeNotNull('MENU_CD', instance.menuCd?.toJson());
  writeNotNull('READ_YN', instance.readYn?.toJson());
  writeNotNull('REG_YN', instance.regYn?.toJson());
  writeNotNull('MDFCN_YN', instance.mdfcnYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('MANAGE_YN', instance.manageYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

STPERMMSTWhereInput _$STPERMMSTWhereInputFromJson(Map<String, dynamic> json) =>
    STPERMMSTWhereInput(
      AND: (json['AND'] as List<dynamic>?)
          ?.map((e) => STPERMMSTWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)
          ?.map((e) => STPERMMSTWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)
          ?.map((e) => STPERMMSTWhereInput.fromJson(e as Map<String, dynamic>)),
      permCd: json['PERM_CD'] == null
          ? null
          : StringFilter.fromJson(json['PERM_CD'] as Map<String, dynamic>),
      permNm: json['PERM_NM'] == null
          ? null
          : StringFilter.fromJson(json['PERM_NM'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : StringNullableFilter.fromJson(json['SORT'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFilter.fromJson(json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STPERMMSTWhereInputToJson(STPERMMSTWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('PERM_CD', instance.permCd?.toJson());
  writeNotNull('PERM_NM', instance.permNm?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STPERMMSTOrderByWithRelationInput _$STPERMMSTOrderByWithRelationInputFromJson(
        Map<String, dynamic> json) =>
    STPERMMSTOrderByWithRelationInput(
      permCd: $enumDecodeNullable(_$SortOrderEnumMap, json['PERM_CD']),
      permNm: $enumDecodeNullable(_$SortOrderEnumMap, json['PERM_NM']),
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STPERMMSTOrderByWithRelationInputToJson(
    STPERMMSTOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('PERM_CD', _$SortOrderEnumMap[instance.permCd]);
  writeNotNull('PERM_NM', _$SortOrderEnumMap[instance.permNm]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STPERMMSTWhereUniqueInput _$STPERMMSTWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    STPERMMSTWhereUniqueInput(
      permCd: json['PERM_CD'] as String?,
    );

Map<String, dynamic> _$STPERMMSTWhereUniqueInputToJson(
    STPERMMSTWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('PERM_CD', instance.permCd);
  return val;
}

STPERMMSTOrderByWithAggregationInput
    _$STPERMMSTOrderByWithAggregationInputFromJson(Map<String, dynamic> json) =>
        STPERMMSTOrderByWithAggregationInput(
          permCd: $enumDecodeNullable(_$SortOrderEnumMap, json['PERM_CD']),
          permNm: $enumDecodeNullable(_$SortOrderEnumMap, json['PERM_NM']),
          sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
          $count: json['_count'] == null
              ? null
              : STPERMMSTCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : STPERMMSTMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : STPERMMSTMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STPERMMSTOrderByWithAggregationInputToJson(
    STPERMMSTOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('PERM_CD', _$SortOrderEnumMap[instance.permCd]);
  writeNotNull('PERM_NM', _$SortOrderEnumMap[instance.permNm]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  return val;
}

STPERMMSTScalarWhereWithAggregatesInput
    _$STPERMMSTScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        STPERMMSTScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              STPERMMSTScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              STPERMMSTScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              STPERMMSTScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          permCd: json['PERM_CD'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['PERM_CD'] as Map<String, dynamic>),
          permNm: json['PERM_NM'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['PERM_NM'] as Map<String, dynamic>),
          sort: json['SORT'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['SORT'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delId: json['DEL_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_ID'] as Map<String, dynamic>),
          delDate: json['DEL_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STPERMMSTScalarWhereWithAggregatesInputToJson(
    STPERMMSTScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('PERM_CD', instance.permCd?.toJson());
  writeNotNull('PERM_NM', instance.permNm?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STPOPUPWhereInput _$STPOPUPWhereInputFromJson(Map<String, dynamic> json) =>
    STPOPUPWhereInput(
      AND: (json['AND'] as List<dynamic>?)
          ?.map((e) => STPOPUPWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)
          ?.map((e) => STPOPUPWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)
          ?.map((e) => STPOPUPWhereInput.fromJson(e as Map<String, dynamic>)),
      popCd: json['POP_CD'] == null
          ? null
          : StringFilter.fromJson(json['POP_CD'] as Map<String, dynamic>),
      popNm: json['POP_NM'] == null
          ? null
          : StringFilter.fromJson(json['POP_NM'] as Map<String, dynamic>),
      popTy: json['POP_TY'] == null
          ? null
          : StringFilter.fromJson(json['POP_TY'] as Map<String, dynamic>),
      imgText: json['IMG_TEXT'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['IMG_TEXT'] as Map<String, dynamic>),
      lkUrl: json['LK_URL'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['LK_URL'] as Map<String, dynamic>),
      lkTarget: json['LK_TARGET'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['LK_TARGET'] as Map<String, dynamic>),
      bgngDate: json['BGNG_DATE'] == null
          ? null
          : StringFilter.fromJson(json['BGNG_DATE'] as Map<String, dynamic>),
      endDate: json['END_DATE'] == null
          ? null
          : StringFilter.fromJson(json['END_DATE'] as Map<String, dynamic>),
      spwgPred: json['SPWG_PRED'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['SPWG_PRED'] as Map<String, dynamic>),
      flpth: json['FLPTH'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['FLPTH'] as Map<String, dynamic>),
      fileNm: json['FILE_NM'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['FILE_NM'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      beforeCd: json['BEFORE_CD'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['BEFORE_CD'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFilter.fromJson(json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STPOPUPWhereInputToJson(STPOPUPWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('POP_CD', instance.popCd?.toJson());
  writeNotNull('POP_NM', instance.popNm?.toJson());
  writeNotNull('POP_TY', instance.popTy?.toJson());
  writeNotNull('IMG_TEXT', instance.imgText?.toJson());
  writeNotNull('LK_URL', instance.lkUrl?.toJson());
  writeNotNull('LK_TARGET', instance.lkTarget?.toJson());
  writeNotNull('BGNG_DATE', instance.bgngDate?.toJson());
  writeNotNull('END_DATE', instance.endDate?.toJson());
  writeNotNull('SPWG_PRED', instance.spwgPred?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('FILE_NM', instance.fileNm?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('BEFORE_CD', instance.beforeCd?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STPOPUPOrderByWithRelationInput _$STPOPUPOrderByWithRelationInputFromJson(
        Map<String, dynamic> json) =>
    STPOPUPOrderByWithRelationInput(
      popCd: $enumDecodeNullable(_$SortOrderEnumMap, json['POP_CD']),
      popNm: $enumDecodeNullable(_$SortOrderEnumMap, json['POP_NM']),
      popTy: $enumDecodeNullable(_$SortOrderEnumMap, json['POP_TY']),
      imgText: $enumDecodeNullable(_$SortOrderEnumMap, json['IMG_TEXT']),
      lkUrl: $enumDecodeNullable(_$SortOrderEnumMap, json['LK_URL']),
      lkTarget: $enumDecodeNullable(_$SortOrderEnumMap, json['LK_TARGET']),
      bgngDate: $enumDecodeNullable(_$SortOrderEnumMap, json['BGNG_DATE']),
      endDate: $enumDecodeNullable(_$SortOrderEnumMap, json['END_DATE']),
      spwgPred: $enumDecodeNullable(_$SortOrderEnumMap, json['SPWG_PRED']),
      flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
      fileNm: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_NM']),
      useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
      beforeCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BEFORE_CD']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STPOPUPOrderByWithRelationInputToJson(
    STPOPUPOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('POP_CD', _$SortOrderEnumMap[instance.popCd]);
  writeNotNull('POP_NM', _$SortOrderEnumMap[instance.popNm]);
  writeNotNull('POP_TY', _$SortOrderEnumMap[instance.popTy]);
  writeNotNull('IMG_TEXT', _$SortOrderEnumMap[instance.imgText]);
  writeNotNull('LK_URL', _$SortOrderEnumMap[instance.lkUrl]);
  writeNotNull('LK_TARGET', _$SortOrderEnumMap[instance.lkTarget]);
  writeNotNull('BGNG_DATE', _$SortOrderEnumMap[instance.bgngDate]);
  writeNotNull('END_DATE', _$SortOrderEnumMap[instance.endDate]);
  writeNotNull('SPWG_PRED', _$SortOrderEnumMap[instance.spwgPred]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('FILE_NM', _$SortOrderEnumMap[instance.fileNm]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('BEFORE_CD', _$SortOrderEnumMap[instance.beforeCd]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STPOPUPWhereUniqueInput _$STPOPUPWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    STPOPUPWhereUniqueInput(
      popCd: json['POP_CD'] as String?,
    );

Map<String, dynamic> _$STPOPUPWhereUniqueInputToJson(
    STPOPUPWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('POP_CD', instance.popCd);
  return val;
}

STPOPUPOrderByWithAggregationInput _$STPOPUPOrderByWithAggregationInputFromJson(
        Map<String, dynamic> json) =>
    STPOPUPOrderByWithAggregationInput(
      popCd: $enumDecodeNullable(_$SortOrderEnumMap, json['POP_CD']),
      popNm: $enumDecodeNullable(_$SortOrderEnumMap, json['POP_NM']),
      popTy: $enumDecodeNullable(_$SortOrderEnumMap, json['POP_TY']),
      imgText: $enumDecodeNullable(_$SortOrderEnumMap, json['IMG_TEXT']),
      lkUrl: $enumDecodeNullable(_$SortOrderEnumMap, json['LK_URL']),
      lkTarget: $enumDecodeNullable(_$SortOrderEnumMap, json['LK_TARGET']),
      bgngDate: $enumDecodeNullable(_$SortOrderEnumMap, json['BGNG_DATE']),
      endDate: $enumDecodeNullable(_$SortOrderEnumMap, json['END_DATE']),
      spwgPred: $enumDecodeNullable(_$SortOrderEnumMap, json['SPWG_PRED']),
      flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
      fileNm: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_NM']),
      useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
      beforeCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BEFORE_CD']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
      $count: json['_count'] == null
          ? null
          : STPOPUPCountOrderByAggregateInput.fromJson(
              json['_count'] as Map<String, dynamic>),
      $max: json['_max'] == null
          ? null
          : STPOPUPMaxOrderByAggregateInput.fromJson(
              json['_max'] as Map<String, dynamic>),
      $min: json['_min'] == null
          ? null
          : STPOPUPMinOrderByAggregateInput.fromJson(
              json['_min'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STPOPUPOrderByWithAggregationInputToJson(
    STPOPUPOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('POP_CD', _$SortOrderEnumMap[instance.popCd]);
  writeNotNull('POP_NM', _$SortOrderEnumMap[instance.popNm]);
  writeNotNull('POP_TY', _$SortOrderEnumMap[instance.popTy]);
  writeNotNull('IMG_TEXT', _$SortOrderEnumMap[instance.imgText]);
  writeNotNull('LK_URL', _$SortOrderEnumMap[instance.lkUrl]);
  writeNotNull('LK_TARGET', _$SortOrderEnumMap[instance.lkTarget]);
  writeNotNull('BGNG_DATE', _$SortOrderEnumMap[instance.bgngDate]);
  writeNotNull('END_DATE', _$SortOrderEnumMap[instance.endDate]);
  writeNotNull('SPWG_PRED', _$SortOrderEnumMap[instance.spwgPred]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('FILE_NM', _$SortOrderEnumMap[instance.fileNm]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('BEFORE_CD', _$SortOrderEnumMap[instance.beforeCd]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  return val;
}

STPOPUPScalarWhereWithAggregatesInput
    _$STPOPUPScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        STPOPUPScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              STPOPUPScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              STPOPUPScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              STPOPUPScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          popCd: json['POP_CD'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['POP_CD'] as Map<String, dynamic>),
          popNm: json['POP_NM'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['POP_NM'] as Map<String, dynamic>),
          popTy: json['POP_TY'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['POP_TY'] as Map<String, dynamic>),
          imgText: json['IMG_TEXT'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['IMG_TEXT'] as Map<String, dynamic>),
          lkUrl: json['LK_URL'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['LK_URL'] as Map<String, dynamic>),
          lkTarget: json['LK_TARGET'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['LK_TARGET'] as Map<String, dynamic>),
          bgngDate: json['BGNG_DATE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['BGNG_DATE'] as Map<String, dynamic>),
          endDate: json['END_DATE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['END_DATE'] as Map<String, dynamic>),
          spwgPred: json['SPWG_PRED'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['SPWG_PRED'] as Map<String, dynamic>),
          flpth: json['FLPTH'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['FLPTH'] as Map<String, dynamic>),
          fileNm: json['FILE_NM'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['FILE_NM'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          beforeCd: json['BEFORE_CD'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['BEFORE_CD'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delId: json['DEL_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_ID'] as Map<String, dynamic>),
          delDate: json['DEL_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STPOPUPScalarWhereWithAggregatesInputToJson(
    STPOPUPScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('POP_CD', instance.popCd?.toJson());
  writeNotNull('POP_NM', instance.popNm?.toJson());
  writeNotNull('POP_TY', instance.popTy?.toJson());
  writeNotNull('IMG_TEXT', instance.imgText?.toJson());
  writeNotNull('LK_URL', instance.lkUrl?.toJson());
  writeNotNull('LK_TARGET', instance.lkTarget?.toJson());
  writeNotNull('BGNG_DATE', instance.bgngDate?.toJson());
  writeNotNull('END_DATE', instance.endDate?.toJson());
  writeNotNull('SPWG_PRED', instance.spwgPred?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('FILE_NM', instance.fileNm?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('BEFORE_CD', instance.beforeCd?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STSTNGWhereInput _$STSTNGWhereInputFromJson(Map<String, dynamic> json) =>
    STSTNGWhereInput(
      AND: (json['AND'] as List<dynamic>?)
          ?.map((e) => STSTNGWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)
          ?.map((e) => STSTNGWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)
          ?.map((e) => STSTNGWhereInput.fromJson(e as Map<String, dynamic>)),
      stngCd: json['STNG_CD'] == null
          ? null
          : StringFilter.fromJson(json['STNG_CD'] as Map<String, dynamic>),
      stngData: json['STNG_DATA'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['STNG_DATA'] as Map<String, dynamic>),
      title: json['TITLE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['TITLE'] as Map<String, dynamic>),
      descCn: json['DESC_CN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DESC_CN'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : IntNullableFilter.fromJson(json['SORT'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STSTNGWhereInputToJson(STSTNGWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('STNG_CD', instance.stngCd?.toJson());
  writeNotNull('STNG_DATA', instance.stngData?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('DESC_CN', instance.descCn?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  return val;
}

STSTNGOrderByWithRelationInput _$STSTNGOrderByWithRelationInputFromJson(
        Map<String, dynamic> json) =>
    STSTNGOrderByWithRelationInput(
      stngCd: $enumDecodeNullable(_$SortOrderEnumMap, json['STNG_CD']),
      stngData: $enumDecodeNullable(_$SortOrderEnumMap, json['STNG_DATA']),
      title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
      descCn: $enumDecodeNullable(_$SortOrderEnumMap, json['DESC_CN']),
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
    );

Map<String, dynamic> _$STSTNGOrderByWithRelationInputToJson(
    STSTNGOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('STNG_CD', _$SortOrderEnumMap[instance.stngCd]);
  writeNotNull('STNG_DATA', _$SortOrderEnumMap[instance.stngData]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull('DESC_CN', _$SortOrderEnumMap[instance.descCn]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  return val;
}

STSTNGWhereUniqueInput _$STSTNGWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    STSTNGWhereUniqueInput(
      stngCd: json['STNG_CD'] as String?,
    );

Map<String, dynamic> _$STSTNGWhereUniqueInputToJson(
    STSTNGWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('STNG_CD', instance.stngCd);
  return val;
}

STSTNGOrderByWithAggregationInput _$STSTNGOrderByWithAggregationInputFromJson(
        Map<String, dynamic> json) =>
    STSTNGOrderByWithAggregationInput(
      stngCd: $enumDecodeNullable(_$SortOrderEnumMap, json['STNG_CD']),
      stngData: $enumDecodeNullable(_$SortOrderEnumMap, json['STNG_DATA']),
      title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
      descCn: $enumDecodeNullable(_$SortOrderEnumMap, json['DESC_CN']),
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      $count: json['_count'] == null
          ? null
          : STSTNGCountOrderByAggregateInput.fromJson(
              json['_count'] as Map<String, dynamic>),
      $avg: json['_avg'] == null
          ? null
          : STSTNGAvgOrderByAggregateInput.fromJson(
              json['_avg'] as Map<String, dynamic>),
      $max: json['_max'] == null
          ? null
          : STSTNGMaxOrderByAggregateInput.fromJson(
              json['_max'] as Map<String, dynamic>),
      $min: json['_min'] == null
          ? null
          : STSTNGMinOrderByAggregateInput.fromJson(
              json['_min'] as Map<String, dynamic>),
      $sum: json['_sum'] == null
          ? null
          : STSTNGSumOrderByAggregateInput.fromJson(
              json['_sum'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STSTNGOrderByWithAggregationInputToJson(
    STSTNGOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('STNG_CD', _$SortOrderEnumMap[instance.stngCd]);
  writeNotNull('STNG_DATA', _$SortOrderEnumMap[instance.stngData]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull('DESC_CN', _$SortOrderEnumMap[instance.descCn]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

STSTNGScalarWhereWithAggregatesInput
    _$STSTNGScalarWhereWithAggregatesInputFromJson(Map<String, dynamic> json) =>
        STSTNGScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              STSTNGScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              STSTNGScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              STSTNGScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          stngCd: json['STNG_CD'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['STNG_CD'] as Map<String, dynamic>),
          stngData: json['STNG_DATA'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['STNG_DATA'] as Map<String, dynamic>),
          title: json['TITLE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['TITLE'] as Map<String, dynamic>),
          descCn: json['DESC_CN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DESC_CN'] as Map<String, dynamic>),
          sort: json['SORT'] == null
              ? null
              : IntNullableWithAggregatesFilter.fromJson(
                  json['SORT'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STSTNGScalarWhereWithAggregatesInputToJson(
    STSTNGScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('STNG_CD', instance.stngCd?.toJson());
  writeNotNull('STNG_DATA', instance.stngData?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('DESC_CN', instance.descCn?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  return val;
}

STUSERMSTWhereInput _$STUSERMSTWhereInputFromJson(Map<String, dynamic> json) =>
    STUSERMSTWhereInput(
      AND: (json['AND'] as List<dynamic>?)
          ?.map((e) => STUSERMSTWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)
          ?.map((e) => STUSERMSTWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)
          ?.map((e) => STUSERMSTWhereInput.fromJson(e as Map<String, dynamic>)),
      userId: json['USER_ID'] == null
          ? null
          : StringFilter.fromJson(json['USER_ID'] as Map<String, dynamic>),
      userNm: json['USER_NM'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['USER_NM'] as Map<String, dynamic>),
      userPw: json['USER_PW'] == null
          ? null
          : StringFilter.fromJson(json['USER_PW'] as Map<String, dynamic>),
      userDiv: json['USER_DIV'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['USER_DIV'] as Map<String, dynamic>),
      status: json['STATUS'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['STATUS'] as Map<String, dynamic>),
      prevLoginYn: json['PREV_LOGIN_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['PREV_LOGIN_YN'] as Map<String, dynamic>),
      withdrawnYn: json['WITHDRAWN_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['WITHDRAWN_YN'] as Map<String, dynamic>),
      clph: json['CLPH'] == null
          ? null
          : StringNullableFilter.fromJson(json['CLPH'] as Map<String, dynamic>),
      email: json['EMAIL'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EMAIL'] as Map<String, dynamic>),
      lstLoginDate: json['LST_LOGIN_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['LST_LOGIN_DATE'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFilter.fromJson(json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STUSERMSTWhereInputToJson(STUSERMSTWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('USER_NM', instance.userNm?.toJson());
  writeNotNull('USER_PW', instance.userPw?.toJson());
  writeNotNull('USER_DIV', instance.userDiv?.toJson());
  writeNotNull('STATUS', instance.status?.toJson());
  writeNotNull('PREV_LOGIN_YN', instance.prevLoginYn?.toJson());
  writeNotNull('WITHDRAWN_YN', instance.withdrawnYn?.toJson());
  writeNotNull('CLPH', instance.clph?.toJson());
  writeNotNull('EMAIL', instance.email?.toJson());
  writeNotNull('LST_LOGIN_DATE', instance.lstLoginDate?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STUSERMSTOrderByWithRelationInput _$STUSERMSTOrderByWithRelationInputFromJson(
        Map<String, dynamic> json) =>
    STUSERMSTOrderByWithRelationInput(
      userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
      userNm: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_NM']),
      userPw: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_PW']),
      userDiv: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_DIV']),
      status: $enumDecodeNullable(_$SortOrderEnumMap, json['STATUS']),
      prevLoginYn:
          $enumDecodeNullable(_$SortOrderEnumMap, json['PREV_LOGIN_YN']),
      withdrawnYn:
          $enumDecodeNullable(_$SortOrderEnumMap, json['WITHDRAWN_YN']),
      clph: $enumDecodeNullable(_$SortOrderEnumMap, json['CLPH']),
      email: $enumDecodeNullable(_$SortOrderEnumMap, json['EMAIL']),
      lstLoginDate:
          $enumDecodeNullable(_$SortOrderEnumMap, json['LST_LOGIN_DATE']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STUSERMSTOrderByWithRelationInputToJson(
    STUSERMSTOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('USER_NM', _$SortOrderEnumMap[instance.userNm]);
  writeNotNull('USER_PW', _$SortOrderEnumMap[instance.userPw]);
  writeNotNull('USER_DIV', _$SortOrderEnumMap[instance.userDiv]);
  writeNotNull('STATUS', _$SortOrderEnumMap[instance.status]);
  writeNotNull('PREV_LOGIN_YN', _$SortOrderEnumMap[instance.prevLoginYn]);
  writeNotNull('WITHDRAWN_YN', _$SortOrderEnumMap[instance.withdrawnYn]);
  writeNotNull('CLPH', _$SortOrderEnumMap[instance.clph]);
  writeNotNull('EMAIL', _$SortOrderEnumMap[instance.email]);
  writeNotNull('LST_LOGIN_DATE', _$SortOrderEnumMap[instance.lstLoginDate]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STUSERMSTWhereUniqueInput _$STUSERMSTWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    STUSERMSTWhereUniqueInput(
      userId: json['USER_ID'] as String?,
    );

Map<String, dynamic> _$STUSERMSTWhereUniqueInputToJson(
    STUSERMSTWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', instance.userId);
  return val;
}

STUSERMSTOrderByWithAggregationInput
    _$STUSERMSTOrderByWithAggregationInputFromJson(Map<String, dynamic> json) =>
        STUSERMSTOrderByWithAggregationInput(
          userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
          userNm: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_NM']),
          userPw: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_PW']),
          userDiv: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_DIV']),
          status: $enumDecodeNullable(_$SortOrderEnumMap, json['STATUS']),
          prevLoginYn:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PREV_LOGIN_YN']),
          withdrawnYn:
              $enumDecodeNullable(_$SortOrderEnumMap, json['WITHDRAWN_YN']),
          clph: $enumDecodeNullable(_$SortOrderEnumMap, json['CLPH']),
          email: $enumDecodeNullable(_$SortOrderEnumMap, json['EMAIL']),
          lstLoginDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['LST_LOGIN_DATE']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
          $count: json['_count'] == null
              ? null
              : STUSERMSTCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : STUSERMSTMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : STUSERMSTMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STUSERMSTOrderByWithAggregationInputToJson(
    STUSERMSTOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('USER_NM', _$SortOrderEnumMap[instance.userNm]);
  writeNotNull('USER_PW', _$SortOrderEnumMap[instance.userPw]);
  writeNotNull('USER_DIV', _$SortOrderEnumMap[instance.userDiv]);
  writeNotNull('STATUS', _$SortOrderEnumMap[instance.status]);
  writeNotNull('PREV_LOGIN_YN', _$SortOrderEnumMap[instance.prevLoginYn]);
  writeNotNull('WITHDRAWN_YN', _$SortOrderEnumMap[instance.withdrawnYn]);
  writeNotNull('CLPH', _$SortOrderEnumMap[instance.clph]);
  writeNotNull('EMAIL', _$SortOrderEnumMap[instance.email]);
  writeNotNull('LST_LOGIN_DATE', _$SortOrderEnumMap[instance.lstLoginDate]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  return val;
}

STUSERMSTScalarWhereWithAggregatesInput
    _$STUSERMSTScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        STUSERMSTScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              STUSERMSTScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              STUSERMSTScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              STUSERMSTScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          userId: json['USER_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['USER_ID'] as Map<String, dynamic>),
          userNm: json['USER_NM'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['USER_NM'] as Map<String, dynamic>),
          userPw: json['USER_PW'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['USER_PW'] as Map<String, dynamic>),
          userDiv: json['USER_DIV'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['USER_DIV'] as Map<String, dynamic>),
          status: json['STATUS'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['STATUS'] as Map<String, dynamic>),
          prevLoginYn: json['PREV_LOGIN_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['PREV_LOGIN_YN'] as Map<String, dynamic>),
          withdrawnYn: json['WITHDRAWN_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['WITHDRAWN_YN'] as Map<String, dynamic>),
          clph: json['CLPH'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['CLPH'] as Map<String, dynamic>),
          email: json['EMAIL'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EMAIL'] as Map<String, dynamic>),
          lstLoginDate: json['LST_LOGIN_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['LST_LOGIN_DATE'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delId: json['DEL_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_ID'] as Map<String, dynamic>),
          delDate: json['DEL_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STUSERMSTScalarWhereWithAggregatesInputToJson(
    STUSERMSTScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('USER_NM', instance.userNm?.toJson());
  writeNotNull('USER_PW', instance.userPw?.toJson());
  writeNotNull('USER_DIV', instance.userDiv?.toJson());
  writeNotNull('STATUS', instance.status?.toJson());
  writeNotNull('PREV_LOGIN_YN', instance.prevLoginYn?.toJson());
  writeNotNull('WITHDRAWN_YN', instance.withdrawnYn?.toJson());
  writeNotNull('CLPH', instance.clph?.toJson());
  writeNotNull('EMAIL', instance.email?.toJson());
  writeNotNull('LST_LOGIN_DATE', instance.lstLoginDate?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

WORKREPORTDETAILTBLWhereInput _$WORKREPORTDETAILTBLWhereInputFromJson(
        Map<String, dynamic> json) =>
    WORKREPORTDETAILTBLWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map((e) =>
          WORKREPORTDETAILTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map((e) =>
          WORKREPORTDETAILTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
          WORKREPORTDETAILTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      reportId: json['REPORT_ID'] == null
          ? null
          : StringFilter.fromJson(json['REPORT_ID'] as Map<String, dynamic>),
      seq: json['SEQ'] == null
          ? null
          : BigIntFilter.fromJson(json['SEQ'] as Map<String, dynamic>),
      projectNm: json['PROJECT_NM'] == null
          ? null
          : StringFilter.fromJson(json['PROJECT_NM'] as Map<String, dynamic>),
      projectSubNm: json['PROJECT_SUB_NM'] == null
          ? null
          : StringFilter.fromJson(
              json['PROJECT_SUB_NM'] as Map<String, dynamic>),
      detailContent: json['DETAIL_CONTENT'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DETAIL_CONTENT'] as Map<String, dynamic>),
      worker: json['WORKER'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['WORKER'] as Map<String, dynamic>),
      grade: json['GRADE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['GRADE'] as Map<String, dynamic>),
      processRate: json['PROCESS_RATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['PROCESS_RATE'] as Map<String, dynamic>),
      workDate: json['WORK_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['WORK_DATE'] as Map<String, dynamic>),
      processType: json['PROCESS_TYPE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['PROCESS_TYPE'] as Map<String, dynamic>),
      subjectYn: json['SUBJECT_YN'] == null
          ? null
          : StringFilter.fromJson(json['SUBJECT_YN'] as Map<String, dynamic>),
      regUser: json['REG_USER'] == null
          ? null
          : StringFilter.fromJson(json['REG_USER'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      completeDate: json['COMPLETE_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['COMPLETE_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$WORKREPORTDETAILTBLWhereInputToJson(
    WORKREPORTDETAILTBLWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('REPORT_ID', instance.reportId?.toJson());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('PROJECT_NM', instance.projectNm?.toJson());
  writeNotNull('PROJECT_SUB_NM', instance.projectSubNm?.toJson());
  writeNotNull('DETAIL_CONTENT', instance.detailContent?.toJson());
  writeNotNull('WORKER', instance.worker?.toJson());
  writeNotNull('GRADE', instance.grade?.toJson());
  writeNotNull('PROCESS_RATE', instance.processRate?.toJson());
  writeNotNull('WORK_DATE', instance.workDate?.toJson());
  writeNotNull('PROCESS_TYPE', instance.processType?.toJson());
  writeNotNull('SUBJECT_YN', instance.subjectYn?.toJson());
  writeNotNull('REG_USER', instance.regUser?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('COMPLETE_DATE', instance.completeDate?.toJson());
  return val;
}

WORKREPORTDETAILTBLOrderByWithRelationInput
    _$WORKREPORTDETAILTBLOrderByWithRelationInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTDETAILTBLOrderByWithRelationInput(
          reportId: $enumDecodeNullable(_$SortOrderEnumMap, json['REPORT_ID']),
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          projectNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PROJECT_NM']),
          projectSubNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PROJECT_SUB_NM']),
          detailContent:
              $enumDecodeNullable(_$SortOrderEnumMap, json['DETAIL_CONTENT']),
          worker: $enumDecodeNullable(_$SortOrderEnumMap, json['WORKER']),
          grade: $enumDecodeNullable(_$SortOrderEnumMap, json['GRADE']),
          processRate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PROCESS_RATE']),
          workDate: $enumDecodeNullable(_$SortOrderEnumMap, json['WORK_DATE']),
          processType:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PROCESS_TYPE']),
          subjectYn:
              $enumDecodeNullable(_$SortOrderEnumMap, json['SUBJECT_YN']),
          regUser: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_USER']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          completeDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['COMPLETE_DATE']),
        );

Map<String, dynamic> _$WORKREPORTDETAILTBLOrderByWithRelationInputToJson(
    WORKREPORTDETAILTBLOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', _$SortOrderEnumMap[instance.reportId]);
  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('PROJECT_NM', _$SortOrderEnumMap[instance.projectNm]);
  writeNotNull('PROJECT_SUB_NM', _$SortOrderEnumMap[instance.projectSubNm]);
  writeNotNull('DETAIL_CONTENT', _$SortOrderEnumMap[instance.detailContent]);
  writeNotNull('WORKER', _$SortOrderEnumMap[instance.worker]);
  writeNotNull('GRADE', _$SortOrderEnumMap[instance.grade]);
  writeNotNull('PROCESS_RATE', _$SortOrderEnumMap[instance.processRate]);
  writeNotNull('WORK_DATE', _$SortOrderEnumMap[instance.workDate]);
  writeNotNull('PROCESS_TYPE', _$SortOrderEnumMap[instance.processType]);
  writeNotNull('SUBJECT_YN', _$SortOrderEnumMap[instance.subjectYn]);
  writeNotNull('REG_USER', _$SortOrderEnumMap[instance.regUser]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('COMPLETE_DATE', _$SortOrderEnumMap[instance.completeDate]);
  return val;
}

WORKREPORTDETAILTBLWhereUniqueInput
    _$WORKREPORTDETAILTBLWhereUniqueInputFromJson(Map<String, dynamic> json) =>
        WORKREPORTDETAILTBLWhereUniqueInput(
          seqReportId: json['SEQ_REPORT_ID'] == null
              ? null
              : WORKREPORTDETAILTBLSEQREPORTIDCompoundUniqueInput.fromJson(
                  json['SEQ_REPORT_ID'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$WORKREPORTDETAILTBLWhereUniqueInputToJson(
    WORKREPORTDETAILTBLWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ_REPORT_ID', instance.seqReportId?.toJson());
  return val;
}

WORKREPORTDETAILTBLOrderByWithAggregationInput
    _$WORKREPORTDETAILTBLOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTDETAILTBLOrderByWithAggregationInput(
          reportId: $enumDecodeNullable(_$SortOrderEnumMap, json['REPORT_ID']),
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          projectNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PROJECT_NM']),
          projectSubNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PROJECT_SUB_NM']),
          detailContent:
              $enumDecodeNullable(_$SortOrderEnumMap, json['DETAIL_CONTENT']),
          worker: $enumDecodeNullable(_$SortOrderEnumMap, json['WORKER']),
          grade: $enumDecodeNullable(_$SortOrderEnumMap, json['GRADE']),
          processRate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PROCESS_RATE']),
          workDate: $enumDecodeNullable(_$SortOrderEnumMap, json['WORK_DATE']),
          processType:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PROCESS_TYPE']),
          subjectYn:
              $enumDecodeNullable(_$SortOrderEnumMap, json['SUBJECT_YN']),
          regUser: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_USER']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          completeDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['COMPLETE_DATE']),
          $count: json['_count'] == null
              ? null
              : WORKREPORTDETAILTBLCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : WORKREPORTDETAILTBLAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : WORKREPORTDETAILTBLMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : WORKREPORTDETAILTBLMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : WORKREPORTDETAILTBLSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$WORKREPORTDETAILTBLOrderByWithAggregationInputToJson(
    WORKREPORTDETAILTBLOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', _$SortOrderEnumMap[instance.reportId]);
  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('PROJECT_NM', _$SortOrderEnumMap[instance.projectNm]);
  writeNotNull('PROJECT_SUB_NM', _$SortOrderEnumMap[instance.projectSubNm]);
  writeNotNull('DETAIL_CONTENT', _$SortOrderEnumMap[instance.detailContent]);
  writeNotNull('WORKER', _$SortOrderEnumMap[instance.worker]);
  writeNotNull('GRADE', _$SortOrderEnumMap[instance.grade]);
  writeNotNull('PROCESS_RATE', _$SortOrderEnumMap[instance.processRate]);
  writeNotNull('WORK_DATE', _$SortOrderEnumMap[instance.workDate]);
  writeNotNull('PROCESS_TYPE', _$SortOrderEnumMap[instance.processType]);
  writeNotNull('SUBJECT_YN', _$SortOrderEnumMap[instance.subjectYn]);
  writeNotNull('REG_USER', _$SortOrderEnumMap[instance.regUser]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('COMPLETE_DATE', _$SortOrderEnumMap[instance.completeDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

WORKREPORTDETAILTBLScalarWhereWithAggregatesInput
    _$WORKREPORTDETAILTBLScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTDETAILTBLScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              WORKREPORTDETAILTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              WORKREPORTDETAILTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              WORKREPORTDETAILTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          reportId: json['REPORT_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REPORT_ID'] as Map<String, dynamic>),
          seq: json['SEQ'] == null
              ? null
              : BigIntWithAggregatesFilter.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          projectNm: json['PROJECT_NM'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['PROJECT_NM'] as Map<String, dynamic>),
          projectSubNm: json['PROJECT_SUB_NM'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['PROJECT_SUB_NM'] as Map<String, dynamic>),
          detailContent: json['DETAIL_CONTENT'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DETAIL_CONTENT'] as Map<String, dynamic>),
          worker: json['WORKER'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['WORKER'] as Map<String, dynamic>),
          grade: json['GRADE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['GRADE'] as Map<String, dynamic>),
          processRate: json['PROCESS_RATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['PROCESS_RATE'] as Map<String, dynamic>),
          workDate: json['WORK_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['WORK_DATE'] as Map<String, dynamic>),
          processType: json['PROCESS_TYPE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['PROCESS_TYPE'] as Map<String, dynamic>),
          subjectYn: json['SUBJECT_YN'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['SUBJECT_YN'] as Map<String, dynamic>),
          regUser: json['REG_USER'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_USER'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          completeDate: json['COMPLETE_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['COMPLETE_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$WORKREPORTDETAILTBLScalarWhereWithAggregatesInputToJson(
    WORKREPORTDETAILTBLScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('REPORT_ID', instance.reportId?.toJson());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('PROJECT_NM', instance.projectNm?.toJson());
  writeNotNull('PROJECT_SUB_NM', instance.projectSubNm?.toJson());
  writeNotNull('DETAIL_CONTENT', instance.detailContent?.toJson());
  writeNotNull('WORKER', instance.worker?.toJson());
  writeNotNull('GRADE', instance.grade?.toJson());
  writeNotNull('PROCESS_RATE', instance.processRate?.toJson());
  writeNotNull('WORK_DATE', instance.workDate?.toJson());
  writeNotNull('PROCESS_TYPE', instance.processType?.toJson());
  writeNotNull('SUBJECT_YN', instance.subjectYn?.toJson());
  writeNotNull('REG_USER', instance.regUser?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('COMPLETE_DATE', instance.completeDate?.toJson());
  return val;
}

WORKREPORTHTMLTBLWhereInput _$WORKREPORTHTMLTBLWhereInputFromJson(
        Map<String, dynamic> json) =>
    WORKREPORTHTMLTBLWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map((e) =>
          WORKREPORTHTMLTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map((e) =>
          WORKREPORTHTMLTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
          WORKREPORTHTMLTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      reportId: json['REPORT_ID'] == null
          ? null
          : StringFilter.fromJson(json['REPORT_ID'] as Map<String, dynamic>),
      userId: json['USER_ID'] == null
          ? null
          : StringFilter.fromJson(json['USER_ID'] as Map<String, dynamic>),
      title: json['TITLE'] == null
          ? null
          : StringFilter.fromJson(json['TITLE'] as Map<String, dynamic>),
      htmlContent: json['HTML_CONTENT'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['HTML_CONTENT'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$WORKREPORTHTMLTBLWhereInputToJson(
    WORKREPORTHTMLTBLWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('REPORT_ID', instance.reportId?.toJson());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('HTML_CONTENT', instance.htmlContent?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

WORKREPORTHTMLTBLOrderByWithRelationInput
    _$WORKREPORTHTMLTBLOrderByWithRelationInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTHTMLTBLOrderByWithRelationInput(
          reportId: $enumDecodeNullable(_$SortOrderEnumMap, json['REPORT_ID']),
          userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
          title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
          htmlContent:
              $enumDecodeNullable(_$SortOrderEnumMap, json['HTML_CONTENT']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$WORKREPORTHTMLTBLOrderByWithRelationInputToJson(
    WORKREPORTHTMLTBLOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', _$SortOrderEnumMap[instance.reportId]);
  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull('HTML_CONTENT', _$SortOrderEnumMap[instance.htmlContent]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

WORKREPORTHTMLTBLWhereUniqueInput _$WORKREPORTHTMLTBLWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    WORKREPORTHTMLTBLWhereUniqueInput(
      reportIdUserId: json['REPORT_ID_USER_ID'] == null
          ? null
          : WORKREPORTHTMLTBLREPORTIDUSERIDCompoundUniqueInput.fromJson(
              json['REPORT_ID_USER_ID'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$WORKREPORTHTMLTBLWhereUniqueInputToJson(
    WORKREPORTHTMLTBLWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID_USER_ID', instance.reportIdUserId?.toJson());
  return val;
}

WORKREPORTHTMLTBLOrderByWithAggregationInput
    _$WORKREPORTHTMLTBLOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTHTMLTBLOrderByWithAggregationInput(
          reportId: $enumDecodeNullable(_$SortOrderEnumMap, json['REPORT_ID']),
          userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
          title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
          htmlContent:
              $enumDecodeNullable(_$SortOrderEnumMap, json['HTML_CONTENT']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          $count: json['_count'] == null
              ? null
              : WORKREPORTHTMLTBLCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : WORKREPORTHTMLTBLMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : WORKREPORTHTMLTBLMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$WORKREPORTHTMLTBLOrderByWithAggregationInputToJson(
    WORKREPORTHTMLTBLOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', _$SortOrderEnumMap[instance.reportId]);
  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull('HTML_CONTENT', _$SortOrderEnumMap[instance.htmlContent]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  return val;
}

WORKREPORTHTMLTBLScalarWhereWithAggregatesInput
    _$WORKREPORTHTMLTBLScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTHTMLTBLScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              WORKREPORTHTMLTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              WORKREPORTHTMLTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              WORKREPORTHTMLTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          reportId: json['REPORT_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REPORT_ID'] as Map<String, dynamic>),
          userId: json['USER_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['USER_ID'] as Map<String, dynamic>),
          title: json['TITLE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['TITLE'] as Map<String, dynamic>),
          htmlContent: json['HTML_CONTENT'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['HTML_CONTENT'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$WORKREPORTHTMLTBLScalarWhereWithAggregatesInputToJson(
    WORKREPORTHTMLTBLScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('REPORT_ID', instance.reportId?.toJson());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('HTML_CONTENT', instance.htmlContent?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

WORKREPORTHTMLTBLBACKWhereInput _$WORKREPORTHTMLTBLBACKWhereInputFromJson(
        Map<String, dynamic> json) =>
    WORKREPORTHTMLTBLBACKWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map((e) =>
          WORKREPORTHTMLTBLBACKWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map((e) =>
          WORKREPORTHTMLTBLBACKWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
          WORKREPORTHTMLTBLBACKWhereInput.fromJson(e as Map<String, dynamic>)),
      reportId: json['REPORT_ID'] == null
          ? null
          : StringFilter.fromJson(json['REPORT_ID'] as Map<String, dynamic>),
      userId: json['USER_ID'] == null
          ? null
          : StringFilter.fromJson(json['USER_ID'] as Map<String, dynamic>),
      title: json['TITLE'] == null
          ? null
          : StringFilter.fromJson(json['TITLE'] as Map<String, dynamic>),
      htmlContent: json['HTML_CONTENT'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['HTML_CONTENT'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$WORKREPORTHTMLTBLBACKWhereInputToJson(
    WORKREPORTHTMLTBLBACKWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('REPORT_ID', instance.reportId?.toJson());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('HTML_CONTENT', instance.htmlContent?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

WORKREPORTHTMLTBLBACKOrderByWithRelationInput
    _$WORKREPORTHTMLTBLBACKOrderByWithRelationInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTHTMLTBLBACKOrderByWithRelationInput(
          reportId: $enumDecodeNullable(_$SortOrderEnumMap, json['REPORT_ID']),
          userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
          title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
          htmlContent:
              $enumDecodeNullable(_$SortOrderEnumMap, json['HTML_CONTENT']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$WORKREPORTHTMLTBLBACKOrderByWithRelationInputToJson(
    WORKREPORTHTMLTBLBACKOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', _$SortOrderEnumMap[instance.reportId]);
  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull('HTML_CONTENT', _$SortOrderEnumMap[instance.htmlContent]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

WORKREPORTHTMLTBLBACKWhereUniqueInput
    _$WORKREPORTHTMLTBLBACKWhereUniqueInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTHTMLTBLBACKWhereUniqueInput(
          reportIdUserId: json['REPORT_ID_USER_ID'] == null
              ? null
              : WORKREPORTHTMLTBLBACKREPORTIDUSERIDCompoundUniqueInput.fromJson(
                  json['REPORT_ID_USER_ID'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$WORKREPORTHTMLTBLBACKWhereUniqueInputToJson(
    WORKREPORTHTMLTBLBACKWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID_USER_ID', instance.reportIdUserId?.toJson());
  return val;
}

WORKREPORTHTMLTBLBACKOrderByWithAggregationInput
    _$WORKREPORTHTMLTBLBACKOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTHTMLTBLBACKOrderByWithAggregationInput(
          reportId: $enumDecodeNullable(_$SortOrderEnumMap, json['REPORT_ID']),
          userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
          title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
          htmlContent:
              $enumDecodeNullable(_$SortOrderEnumMap, json['HTML_CONTENT']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          $count: json['_count'] == null
              ? null
              : WORKREPORTHTMLTBLBACKCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : WORKREPORTHTMLTBLBACKMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : WORKREPORTHTMLTBLBACKMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$WORKREPORTHTMLTBLBACKOrderByWithAggregationInputToJson(
    WORKREPORTHTMLTBLBACKOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', _$SortOrderEnumMap[instance.reportId]);
  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull('HTML_CONTENT', _$SortOrderEnumMap[instance.htmlContent]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  return val;
}

WORKREPORTHTMLTBLBACKScalarWhereWithAggregatesInput
    _$WORKREPORTHTMLTBLBACKScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTHTMLTBLBACKScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              WORKREPORTHTMLTBLBACKScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              WORKREPORTHTMLTBLBACKScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              WORKREPORTHTMLTBLBACKScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          reportId: json['REPORT_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REPORT_ID'] as Map<String, dynamic>),
          userId: json['USER_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['USER_ID'] as Map<String, dynamic>),
          title: json['TITLE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['TITLE'] as Map<String, dynamic>),
          htmlContent: json['HTML_CONTENT'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['HTML_CONTENT'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic>
    _$WORKREPORTHTMLTBLBACKScalarWhereWithAggregatesInputToJson(
        WORKREPORTHTMLTBLBACKScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('REPORT_ID', instance.reportId?.toJson());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('HTML_CONTENT', instance.htmlContent?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

WORKREPORTMASTERTBLWhereInput _$WORKREPORTMASTERTBLWhereInputFromJson(
        Map<String, dynamic> json) =>
    WORKREPORTMASTERTBLWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map((e) =>
          WORKREPORTMASTERTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map((e) =>
          WORKREPORTMASTERTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
          WORKREPORTMASTERTBLWhereInput.fromJson(e as Map<String, dynamic>)),
      reportId: json['REPORT_ID'] == null
          ? null
          : StringFilter.fromJson(json['REPORT_ID'] as Map<String, dynamic>),
      title: json['TITLE'] == null
          ? null
          : StringFilter.fromJson(json['TITLE'] as Map<String, dynamic>),
      dept: json['DEPT'] == null
          ? null
          : StringFilter.fromJson(json['DEPT'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : DateTimeNullableFilter.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$WORKREPORTMASTERTBLWhereInputToJson(
    WORKREPORTMASTERTBLWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('REPORT_ID', instance.reportId?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('DEPT', instance.dept?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

WORKREPORTMASTERTBLOrderByWithRelationInput
    _$WORKREPORTMASTERTBLOrderByWithRelationInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTMASTERTBLOrderByWithRelationInput(
          reportId: $enumDecodeNullable(_$SortOrderEnumMap, json['REPORT_ID']),
          title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
          dept: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$WORKREPORTMASTERTBLOrderByWithRelationInputToJson(
    WORKREPORTMASTERTBLOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', _$SortOrderEnumMap[instance.reportId]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull('DEPT', _$SortOrderEnumMap[instance.dept]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

WORKREPORTMASTERTBLWhereUniqueInput
    _$WORKREPORTMASTERTBLWhereUniqueInputFromJson(Map<String, dynamic> json) =>
        WORKREPORTMASTERTBLWhereUniqueInput(
          reportId: json['REPORT_ID'] as String?,
        );

Map<String, dynamic> _$WORKREPORTMASTERTBLWhereUniqueInputToJson(
    WORKREPORTMASTERTBLWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', instance.reportId);
  return val;
}

WORKREPORTMASTERTBLOrderByWithAggregationInput
    _$WORKREPORTMASTERTBLOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTMASTERTBLOrderByWithAggregationInput(
          reportId: $enumDecodeNullable(_$SortOrderEnumMap, json['REPORT_ID']),
          title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
          dept: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          $count: json['_count'] == null
              ? null
              : WORKREPORTMASTERTBLCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : WORKREPORTMASTERTBLMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : WORKREPORTMASTERTBLMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$WORKREPORTMASTERTBLOrderByWithAggregationInputToJson(
    WORKREPORTMASTERTBLOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', _$SortOrderEnumMap[instance.reportId]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull('DEPT', _$SortOrderEnumMap[instance.dept]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  return val;
}

WORKREPORTMASTERTBLScalarWhereWithAggregatesInput
    _$WORKREPORTMASTERTBLScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTMASTERTBLScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              WORKREPORTMASTERTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              WORKREPORTMASTERTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              WORKREPORTMASTERTBLScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          reportId: json['REPORT_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REPORT_ID'] as Map<String, dynamic>),
          title: json['TITLE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['TITLE'] as Map<String, dynamic>),
          dept: json['DEPT'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['DEPT'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : DateTimeNullableWithAggregatesFilter.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$WORKREPORTMASTERTBLScalarWhereWithAggregatesInputToJson(
    WORKREPORTMASTERTBLScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('REPORT_ID', instance.reportId?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('DEPT', instance.dept?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

WORKREQUESTMSTWhereInput _$WORKREQUESTMSTWhereInputFromJson(
        Map<String, dynamic> json) =>
    WORKREQUESTMSTWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map(
          (e) => WORKREQUESTMSTWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map(
          (e) => WORKREQUESTMSTWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map(
          (e) => WORKREQUESTMSTWhereInput.fromJson(e as Map<String, dynamic>)),
      seq: json['SEQ'] == null
          ? null
          : IntFilter.fromJson(json['SEQ'] as Map<String, dynamic>),
      rqstrDpnm: json['RQSTR_DPNM'] == null
          ? null
          : StringFilter.fromJson(json['RQSTR_DPNM'] as Map<String, dynamic>),
      rqstrNm: json['RQSTR_NM'] == null
          ? null
          : StringFilter.fromJson(json['RQSTR_NM'] as Map<String, dynamic>),
      rqstrId: json['RQSTR_ID'] == null
          ? null
          : StringFilter.fromJson(json['RQSTR_ID'] as Map<String, dynamic>),
      rqstrDate: json['RQSTR_DATE'] == null
          ? null
          : StringFilter.fromJson(json['RQSTR_DATE'] as Map<String, dynamic>),
      hopeDate: json['HOPE_DATE'] == null
          ? null
          : StringFilter.fromJson(json['HOPE_DATE'] as Map<String, dynamic>),
      chrDprNm: json['CHR_DPR_NM'] == null
          ? null
          : StringFilter.fromJson(json['CHR_DPR_NM'] as Map<String, dynamic>),
      chrNm: json['CHR_NM'] == null
          ? null
          : StringFilter.fromJson(json['CHR_NM'] as Map<String, dynamic>),
      chrId: json['CHR_ID'] == null
          ? null
          : StringFilter.fromJson(json['CHR_ID'] as Map<String, dynamic>),
      chrChk: json['CHR_CHK'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['CHR_CHK'] as Map<String, dynamic>),
      title: json['TITLE'] == null
          ? null
          : StringFilter.fromJson(json['TITLE'] as Map<String, dynamic>),
      cn: json['CN'] == null
          ? null
          : StringFilter.fromJson(json['CN'] as Map<String, dynamic>),
      etc: json['ETC'] == null
          ? null
          : StringNullableFilter.fromJson(json['ETC'] as Map<String, dynamic>),
      doc: json['DOC'] == null
          ? null
          : StringNullableFilter.fromJson(json['DOC'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFilter.fromJson(json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$WORKREQUESTMSTWhereInputToJson(
    WORKREQUESTMSTWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('RQSTR_DPNM', instance.rqstrDpnm?.toJson());
  writeNotNull('RQSTR_NM', instance.rqstrNm?.toJson());
  writeNotNull('RQSTR_ID', instance.rqstrId?.toJson());
  writeNotNull('RQSTR_DATE', instance.rqstrDate?.toJson());
  writeNotNull('HOPE_DATE', instance.hopeDate?.toJson());
  writeNotNull('CHR_DPR_NM', instance.chrDprNm?.toJson());
  writeNotNull('CHR_NM', instance.chrNm?.toJson());
  writeNotNull('CHR_ID', instance.chrId?.toJson());
  writeNotNull('CHR_CHK', instance.chrChk?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('CN', instance.cn?.toJson());
  writeNotNull('ETC', instance.etc?.toJson());
  writeNotNull('DOC', instance.doc?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

WORKREQUESTMSTOrderByWithRelationInput
    _$WORKREQUESTMSTOrderByWithRelationInputFromJson(
            Map<String, dynamic> json) =>
        WORKREQUESTMSTOrderByWithRelationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          rqstrDpnm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['RQSTR_DPNM']),
          rqstrNm: $enumDecodeNullable(_$SortOrderEnumMap, json['RQSTR_NM']),
          rqstrId: $enumDecodeNullable(_$SortOrderEnumMap, json['RQSTR_ID']),
          rqstrDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['RQSTR_DATE']),
          hopeDate: $enumDecodeNullable(_$SortOrderEnumMap, json['HOPE_DATE']),
          chrDprNm: $enumDecodeNullable(_$SortOrderEnumMap, json['CHR_DPR_NM']),
          chrNm: $enumDecodeNullable(_$SortOrderEnumMap, json['CHR_NM']),
          chrId: $enumDecodeNullable(_$SortOrderEnumMap, json['CHR_ID']),
          chrChk: $enumDecodeNullable(_$SortOrderEnumMap, json['CHR_CHK']),
          title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
          cn: $enumDecodeNullable(_$SortOrderEnumMap, json['CN']),
          etc: $enumDecodeNullable(_$SortOrderEnumMap, json['ETC']),
          doc: $enumDecodeNullable(_$SortOrderEnumMap, json['DOC']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$WORKREQUESTMSTOrderByWithRelationInputToJson(
    WORKREQUESTMSTOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('RQSTR_DPNM', _$SortOrderEnumMap[instance.rqstrDpnm]);
  writeNotNull('RQSTR_NM', _$SortOrderEnumMap[instance.rqstrNm]);
  writeNotNull('RQSTR_ID', _$SortOrderEnumMap[instance.rqstrId]);
  writeNotNull('RQSTR_DATE', _$SortOrderEnumMap[instance.rqstrDate]);
  writeNotNull('HOPE_DATE', _$SortOrderEnumMap[instance.hopeDate]);
  writeNotNull('CHR_DPR_NM', _$SortOrderEnumMap[instance.chrDprNm]);
  writeNotNull('CHR_NM', _$SortOrderEnumMap[instance.chrNm]);
  writeNotNull('CHR_ID', _$SortOrderEnumMap[instance.chrId]);
  writeNotNull('CHR_CHK', _$SortOrderEnumMap[instance.chrChk]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull('CN', _$SortOrderEnumMap[instance.cn]);
  writeNotNull('ETC', _$SortOrderEnumMap[instance.etc]);
  writeNotNull('DOC', _$SortOrderEnumMap[instance.doc]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

WORKREQUESTMSTWhereUniqueInput _$WORKREQUESTMSTWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    WORKREQUESTMSTWhereUniqueInput(
      seq: json['SEQ'] as int?,
    );

Map<String, dynamic> _$WORKREQUESTMSTWhereUniqueInputToJson(
    WORKREQUESTMSTWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq);
  return val;
}

WORKREQUESTMSTOrderByWithAggregationInput
    _$WORKREQUESTMSTOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        WORKREQUESTMSTOrderByWithAggregationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          rqstrDpnm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['RQSTR_DPNM']),
          rqstrNm: $enumDecodeNullable(_$SortOrderEnumMap, json['RQSTR_NM']),
          rqstrId: $enumDecodeNullable(_$SortOrderEnumMap, json['RQSTR_ID']),
          rqstrDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['RQSTR_DATE']),
          hopeDate: $enumDecodeNullable(_$SortOrderEnumMap, json['HOPE_DATE']),
          chrDprNm: $enumDecodeNullable(_$SortOrderEnumMap, json['CHR_DPR_NM']),
          chrNm: $enumDecodeNullable(_$SortOrderEnumMap, json['CHR_NM']),
          chrId: $enumDecodeNullable(_$SortOrderEnumMap, json['CHR_ID']),
          chrChk: $enumDecodeNullable(_$SortOrderEnumMap, json['CHR_CHK']),
          title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
          cn: $enumDecodeNullable(_$SortOrderEnumMap, json['CN']),
          etc: $enumDecodeNullable(_$SortOrderEnumMap, json['ETC']),
          doc: $enumDecodeNullable(_$SortOrderEnumMap, json['DOC']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
          $count: json['_count'] == null
              ? null
              : WORKREQUESTMSTCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : WORKREQUESTMSTAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : WORKREQUESTMSTMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : WORKREQUESTMSTMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : WORKREQUESTMSTSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$WORKREQUESTMSTOrderByWithAggregationInputToJson(
    WORKREQUESTMSTOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('RQSTR_DPNM', _$SortOrderEnumMap[instance.rqstrDpnm]);
  writeNotNull('RQSTR_NM', _$SortOrderEnumMap[instance.rqstrNm]);
  writeNotNull('RQSTR_ID', _$SortOrderEnumMap[instance.rqstrId]);
  writeNotNull('RQSTR_DATE', _$SortOrderEnumMap[instance.rqstrDate]);
  writeNotNull('HOPE_DATE', _$SortOrderEnumMap[instance.hopeDate]);
  writeNotNull('CHR_DPR_NM', _$SortOrderEnumMap[instance.chrDprNm]);
  writeNotNull('CHR_NM', _$SortOrderEnumMap[instance.chrNm]);
  writeNotNull('CHR_ID', _$SortOrderEnumMap[instance.chrId]);
  writeNotNull('CHR_CHK', _$SortOrderEnumMap[instance.chrChk]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull('CN', _$SortOrderEnumMap[instance.cn]);
  writeNotNull('ETC', _$SortOrderEnumMap[instance.etc]);
  writeNotNull('DOC', _$SortOrderEnumMap[instance.doc]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

WORKREQUESTMSTScalarWhereWithAggregatesInput
    _$WORKREQUESTMSTScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        WORKREQUESTMSTScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              WORKREQUESTMSTScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              WORKREQUESTMSTScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              WORKREQUESTMSTScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          seq: json['SEQ'] == null
              ? null
              : IntWithAggregatesFilter.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          rqstrDpnm: json['RQSTR_DPNM'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['RQSTR_DPNM'] as Map<String, dynamic>),
          rqstrNm: json['RQSTR_NM'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['RQSTR_NM'] as Map<String, dynamic>),
          rqstrId: json['RQSTR_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['RQSTR_ID'] as Map<String, dynamic>),
          rqstrDate: json['RQSTR_DATE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['RQSTR_DATE'] as Map<String, dynamic>),
          hopeDate: json['HOPE_DATE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['HOPE_DATE'] as Map<String, dynamic>),
          chrDprNm: json['CHR_DPR_NM'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['CHR_DPR_NM'] as Map<String, dynamic>),
          chrNm: json['CHR_NM'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['CHR_NM'] as Map<String, dynamic>),
          chrId: json['CHR_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['CHR_ID'] as Map<String, dynamic>),
          chrChk: json['CHR_CHK'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['CHR_CHK'] as Map<String, dynamic>),
          title: json['TITLE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['TITLE'] as Map<String, dynamic>),
          cn: json['CN'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['CN'] as Map<String, dynamic>),
          etc: json['ETC'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['ETC'] as Map<String, dynamic>),
          doc: json['DOC'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DOC'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delId: json['DEL_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_ID'] as Map<String, dynamic>),
          delDate: json['DEL_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$WORKREQUESTMSTScalarWhereWithAggregatesInputToJson(
    WORKREQUESTMSTScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('RQSTR_DPNM', instance.rqstrDpnm?.toJson());
  writeNotNull('RQSTR_NM', instance.rqstrNm?.toJson());
  writeNotNull('RQSTR_ID', instance.rqstrId?.toJson());
  writeNotNull('RQSTR_DATE', instance.rqstrDate?.toJson());
  writeNotNull('HOPE_DATE', instance.hopeDate?.toJson());
  writeNotNull('CHR_DPR_NM', instance.chrDprNm?.toJson());
  writeNotNull('CHR_NM', instance.chrNm?.toJson());
  writeNotNull('CHR_ID', instance.chrId?.toJson());
  writeNotNull('CHR_CHK', instance.chrChk?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('CN', instance.cn?.toJson());
  writeNotNull('ETC', instance.etc?.toJson());
  writeNotNull('DOC', instance.doc?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

WORKREQUESTREFWhereInput _$WORKREQUESTREFWhereInputFromJson(
        Map<String, dynamic> json) =>
    WORKREQUESTREFWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map(
          (e) => WORKREQUESTREFWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map(
          (e) => WORKREQUESTREFWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map(
          (e) => WORKREQUESTREFWhereInput.fromJson(e as Map<String, dynamic>)),
      seq: json['SEQ'] == null
          ? null
          : IntFilter.fromJson(json['SEQ'] as Map<String, dynamic>),
      mseq: json['MSEQ'] == null
          ? null
          : IntFilter.fromJson(json['MSEQ'] as Map<String, dynamic>),
      refId: json['REF_ID'] == null
          ? null
          : StringFilter.fromJson(json['REF_ID'] as Map<String, dynamic>),
      refNm: json['REF_NM'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['REF_NM'] as Map<String, dynamic>),
      refDep: json['REF_DEP'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['REF_DEP'] as Map<String, dynamic>),
      refGrade: json['REF_GRADE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['REF_GRADE'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFilter.fromJson(json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$WORKREQUESTREFWhereInputToJson(
    WORKREQUESTREFWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('REF_ID', instance.refId?.toJson());
  writeNotNull('REF_NM', instance.refNm?.toJson());
  writeNotNull('REF_DEP', instance.refDep?.toJson());
  writeNotNull('REF_GRADE', instance.refGrade?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

WORKREQUESTREFOrderByWithRelationInput
    _$WORKREQUESTREFOrderByWithRelationInputFromJson(
            Map<String, dynamic> json) =>
        WORKREQUESTREFOrderByWithRelationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          refId: $enumDecodeNullable(_$SortOrderEnumMap, json['REF_ID']),
          refNm: $enumDecodeNullable(_$SortOrderEnumMap, json['REF_NM']),
          refDep: $enumDecodeNullable(_$SortOrderEnumMap, json['REF_DEP']),
          refGrade: $enumDecodeNullable(_$SortOrderEnumMap, json['REF_GRADE']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$WORKREQUESTREFOrderByWithRelationInputToJson(
    WORKREQUESTREFOrderByWithRelationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('REF_ID', _$SortOrderEnumMap[instance.refId]);
  writeNotNull('REF_NM', _$SortOrderEnumMap[instance.refNm]);
  writeNotNull('REF_DEP', _$SortOrderEnumMap[instance.refDep]);
  writeNotNull('REF_GRADE', _$SortOrderEnumMap[instance.refGrade]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

WORKREQUESTREFWhereUniqueInput _$WORKREQUESTREFWhereUniqueInputFromJson(
        Map<String, dynamic> json) =>
    WORKREQUESTREFWhereUniqueInput(
      seq: json['SEQ'] as int?,
    );

Map<String, dynamic> _$WORKREQUESTREFWhereUniqueInputToJson(
    WORKREQUESTREFWhereUniqueInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq);
  return val;
}

WORKREQUESTREFOrderByWithAggregationInput
    _$WORKREQUESTREFOrderByWithAggregationInputFromJson(
            Map<String, dynamic> json) =>
        WORKREQUESTREFOrderByWithAggregationInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          refId: $enumDecodeNullable(_$SortOrderEnumMap, json['REF_ID']),
          refNm: $enumDecodeNullable(_$SortOrderEnumMap, json['REF_NM']),
          refDep: $enumDecodeNullable(_$SortOrderEnumMap, json['REF_DEP']),
          refGrade: $enumDecodeNullable(_$SortOrderEnumMap, json['REF_GRADE']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
          $count: json['_count'] == null
              ? null
              : WORKREQUESTREFCountOrderByAggregateInput.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : WORKREQUESTREFAvgOrderByAggregateInput.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : WORKREQUESTREFMaxOrderByAggregateInput.fromJson(
                  json['_max'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : WORKREQUESTREFMinOrderByAggregateInput.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : WORKREQUESTREFSumOrderByAggregateInput.fromJson(
                  json['_sum'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$WORKREQUESTREFOrderByWithAggregationInputToJson(
    WORKREQUESTREFOrderByWithAggregationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('REF_ID', _$SortOrderEnumMap[instance.refId]);
  writeNotNull('REF_NM', _$SortOrderEnumMap[instance.refNm]);
  writeNotNull('REF_DEP', _$SortOrderEnumMap[instance.refDep]);
  writeNotNull('REF_GRADE', _$SortOrderEnumMap[instance.refGrade]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  return val;
}

WORKREQUESTREFScalarWhereWithAggregatesInput
    _$WORKREQUESTREFScalarWhereWithAggregatesInputFromJson(
            Map<String, dynamic> json) =>
        WORKREQUESTREFScalarWhereWithAggregatesInput(
          AND: (json['AND'] as List<dynamic>?)?.map((e) =>
              WORKREQUESTREFScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          OR: (json['OR'] as List<dynamic>?)?.map((e) =>
              WORKREQUESTREFScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          NOT: (json['NOT'] as List<dynamic>?)?.map((e) =>
              WORKREQUESTREFScalarWhereWithAggregatesInput.fromJson(
                  e as Map<String, dynamic>)),
          seq: json['SEQ'] == null
              ? null
              : IntWithAggregatesFilter.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          mseq: json['MSEQ'] == null
              ? null
              : IntWithAggregatesFilter.fromJson(
                  json['MSEQ'] as Map<String, dynamic>),
          refId: json['REF_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REF_ID'] as Map<String, dynamic>),
          refNm: json['REF_NM'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['REF_NM'] as Map<String, dynamic>),
          refDep: json['REF_DEP'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['REF_DEP'] as Map<String, dynamic>),
          refGrade: json['REF_GRADE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['REF_GRADE'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringWithAggregatesFilter.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delId: json['DEL_ID'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_ID'] as Map<String, dynamic>),
          delDate: json['DEL_DATE'] == null
              ? null
              : StringNullableWithAggregatesFilter.fromJson(
                  json['DEL_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$WORKREQUESTREFScalarWhereWithAggregatesInputToJson(
    WORKREQUESTREFScalarWhereWithAggregatesInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('REF_ID', instance.refId?.toJson());
  writeNotNull('REF_NM', instance.refNm?.toJson());
  writeNotNull('REF_DEP', instance.refDep?.toJson());
  writeNotNull('REF_GRADE', instance.refGrade?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

ALLCODETBLCreateInput _$ALLCODETBLCreateInputFromJson(
        Map<String, dynamic> json) =>
    ALLCODETBLCreateInput(
      codeType: json['CODE_TYPE'] as String,
      codeName: json['CODE_NAME'] as String?,
      unitType: json['UNIT_TYPE'] as String,
      unitName: json['UNIT_NAME'] as String?,
      sort: json['SORT'] as int?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$ALLCODETBLCreateInputToJson(
    ALLCODETBLCreateInput instance) {
  final val = <String, dynamic>{
    'CODE_TYPE': instance.codeType,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CODE_NAME', instance.codeName);
  val['UNIT_TYPE'] = instance.unitType;
  writeNotNull('UNIT_NAME', instance.unitName);
  writeNotNull('SORT', instance.sort);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

Value? _$JsonConverterFromJson<Json, Value>(
  Object? json,
  Value? Function(Json json) fromJson,
) =>
    json == null ? null : fromJson(json as Json);

Json? _$JsonConverterToJson<Json, Value>(
  Value? value,
  Json? Function(Value value) toJson,
) =>
    value == null ? null : toJson(value);

ALLCODETBLUncheckedCreateInput _$ALLCODETBLUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    ALLCODETBLUncheckedCreateInput(
      codeType: json['CODE_TYPE'] as String,
      codeName: json['CODE_NAME'] as String?,
      unitType: json['UNIT_TYPE'] as String,
      unitName: json['UNIT_NAME'] as String?,
      sort: json['SORT'] as int?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$ALLCODETBLUncheckedCreateInputToJson(
    ALLCODETBLUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'CODE_TYPE': instance.codeType,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CODE_NAME', instance.codeName);
  val['UNIT_TYPE'] = instance.unitType;
  writeNotNull('UNIT_NAME', instance.unitName);
  writeNotNull('SORT', instance.sort);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

ALLCODETBLUpdateInput _$ALLCODETBLUpdateInputFromJson(
        Map<String, dynamic> json) =>
    ALLCODETBLUpdateInput(
      codeType: json['CODE_TYPE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CODE_TYPE'] as Map<String, dynamic>),
      codeName: json['CODE_NAME'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CODE_NAME'] as Map<String, dynamic>),
      unitType: json['UNIT_TYPE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['UNIT_TYPE'] as Map<String, dynamic>),
      unitName: json['UNIT_NAME'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['UNIT_NAME'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['SORT'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$ALLCODETBLUpdateInputToJson(
    ALLCODETBLUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CODE_TYPE', instance.codeType?.toJson());
  writeNotNull('CODE_NAME', instance.codeName?.toJson());
  writeNotNull('UNIT_TYPE', instance.unitType?.toJson());
  writeNotNull('UNIT_NAME', instance.unitName?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

ALLCODETBLUncheckedUpdateInput _$ALLCODETBLUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    ALLCODETBLUncheckedUpdateInput(
      codeType: json['CODE_TYPE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CODE_TYPE'] as Map<String, dynamic>),
      codeName: json['CODE_NAME'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CODE_NAME'] as Map<String, dynamic>),
      unitType: json['UNIT_TYPE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['UNIT_TYPE'] as Map<String, dynamic>),
      unitName: json['UNIT_NAME'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['UNIT_NAME'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['SORT'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$ALLCODETBLUncheckedUpdateInputToJson(
    ALLCODETBLUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CODE_TYPE', instance.codeType?.toJson());
  writeNotNull('CODE_NAME', instance.codeName?.toJson());
  writeNotNull('UNIT_TYPE', instance.unitType?.toJson());
  writeNotNull('UNIT_NAME', instance.unitName?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

ALLCODETBLCreateManyInput _$ALLCODETBLCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    ALLCODETBLCreateManyInput(
      codeType: json['CODE_TYPE'] as String,
      codeName: json['CODE_NAME'] as String?,
      unitType: json['UNIT_TYPE'] as String,
      unitName: json['UNIT_NAME'] as String?,
      sort: json['SORT'] as int?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$ALLCODETBLCreateManyInputToJson(
    ALLCODETBLCreateManyInput instance) {
  final val = <String, dynamic>{
    'CODE_TYPE': instance.codeType,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CODE_NAME', instance.codeName);
  val['UNIT_TYPE'] = instance.unitType;
  writeNotNull('UNIT_NAME', instance.unitName);
  writeNotNull('SORT', instance.sort);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

ALLCODETBLUpdateManyMutationInput _$ALLCODETBLUpdateManyMutationInputFromJson(
        Map<String, dynamic> json) =>
    ALLCODETBLUpdateManyMutationInput(
      codeType: json['CODE_TYPE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CODE_TYPE'] as Map<String, dynamic>),
      codeName: json['CODE_NAME'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CODE_NAME'] as Map<String, dynamic>),
      unitType: json['UNIT_TYPE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['UNIT_TYPE'] as Map<String, dynamic>),
      unitName: json['UNIT_NAME'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['UNIT_NAME'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['SORT'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$ALLCODETBLUpdateManyMutationInputToJson(
    ALLCODETBLUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CODE_TYPE', instance.codeType?.toJson());
  writeNotNull('CODE_NAME', instance.codeName?.toJson());
  writeNotNull('UNIT_TYPE', instance.unitType?.toJson());
  writeNotNull('UNIT_NAME', instance.unitName?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

ALLCODETBLUncheckedUpdateManyInput _$ALLCODETBLUncheckedUpdateManyInputFromJson(
        Map<String, dynamic> json) =>
    ALLCODETBLUncheckedUpdateManyInput(
      codeType: json['CODE_TYPE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CODE_TYPE'] as Map<String, dynamic>),
      codeName: json['CODE_NAME'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CODE_NAME'] as Map<String, dynamic>),
      unitType: json['UNIT_TYPE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['UNIT_TYPE'] as Map<String, dynamic>),
      unitName: json['UNIT_NAME'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['UNIT_NAME'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['SORT'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$ALLCODETBLUncheckedUpdateManyInputToJson(
    ALLCODETBLUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CODE_TYPE', instance.codeType?.toJson());
  writeNotNull('CODE_NAME', instance.codeName?.toJson());
  writeNotNull('UNIT_TYPE', instance.unitType?.toJson());
  writeNotNull('UNIT_NAME', instance.unitName?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

APPROVALATTACHFILETBLCreateInput _$APPROVALATTACHFILETBLCreateInputFromJson(
        Map<String, dynamic> json) =>
    APPROVALATTACHFILETBLCreateInput(
      approvalId: json['APPROVAL_ID'] as String,
      seq: (json['SEQ'] as num).toDouble(),
      oriFileNm: json['ORI_FILE_NM'] as String?,
      saveFileNm: json['SAVE_FILE_NM'] as String?,
      fileSize: json['FILE_SIZE'] as int?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$APPROVALATTACHFILETBLCreateInputToJson(
    APPROVALATTACHFILETBLCreateInput instance) {
  final val = <String, dynamic>{
    'APPROVAL_ID': instance.approvalId,
    'SEQ': instance.seq,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('ORI_FILE_NM', instance.oriFileNm);
  writeNotNull('SAVE_FILE_NM', instance.saveFileNm);
  writeNotNull('FILE_SIZE', instance.fileSize);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  return val;
}

APPROVALATTACHFILETBLUncheckedCreateInput
    _$APPROVALATTACHFILETBLUncheckedCreateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALATTACHFILETBLUncheckedCreateInput(
          approvalId: json['APPROVAL_ID'] as String,
          seq: (json['SEQ'] as num).toDouble(),
          oriFileNm: json['ORI_FILE_NM'] as String?,
          saveFileNm: json['SAVE_FILE_NM'] as String?,
          fileSize: json['FILE_SIZE'] as int?,
          regDate: _$JsonConverterFromJson<String, DateTime>(
              json['REG_DATE'], const DateTimeJsonConverter().fromJson),
        );

Map<String, dynamic> _$APPROVALATTACHFILETBLUncheckedCreateInputToJson(
    APPROVALATTACHFILETBLUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'APPROVAL_ID': instance.approvalId,
    'SEQ': instance.seq,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('ORI_FILE_NM', instance.oriFileNm);
  writeNotNull('SAVE_FILE_NM', instance.saveFileNm);
  writeNotNull('FILE_SIZE', instance.fileSize);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  return val;
}

APPROVALATTACHFILETBLUpdateInput _$APPROVALATTACHFILETBLUpdateInputFromJson(
        Map<String, dynamic> json) =>
    APPROVALATTACHFILETBLUpdateInput(
      approvalId: json['APPROVAL_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['APPROVAL_ID'] as Map<String, dynamic>),
      seq: json['SEQ'] == null
          ? null
          : DecimalFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      oriFileNm: json['ORI_FILE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ORI_FILE_NM'] as Map<String, dynamic>),
      saveFileNm: json['SAVE_FILE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SAVE_FILE_NM'] as Map<String, dynamic>),
      fileSize: json['FILE_SIZE'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['FILE_SIZE'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$APPROVALATTACHFILETBLUpdateInputToJson(
    APPROVALATTACHFILETBLUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_ID', instance.approvalId?.toJson());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ORI_FILE_NM', instance.oriFileNm?.toJson());
  writeNotNull('SAVE_FILE_NM', instance.saveFileNm?.toJson());
  writeNotNull('FILE_SIZE', instance.fileSize?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

APPROVALATTACHFILETBLUncheckedUpdateInput
    _$APPROVALATTACHFILETBLUncheckedUpdateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALATTACHFILETBLUncheckedUpdateInput(
          approvalId: json['APPROVAL_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_ID'] as Map<String, dynamic>),
          seq: json['SEQ'] == null
              ? null
              : DecimalFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          oriFileNm: json['ORI_FILE_NM'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['ORI_FILE_NM'] as Map<String, dynamic>),
          saveFileNm: json['SAVE_FILE_NM'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['SAVE_FILE_NM'] as Map<String, dynamic>),
          fileSize: json['FILE_SIZE'] == null
              ? null
              : NullableIntFieldUpdateOperationsInput.fromJson(
                  json['FILE_SIZE'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALATTACHFILETBLUncheckedUpdateInputToJson(
    APPROVALATTACHFILETBLUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_ID', instance.approvalId?.toJson());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ORI_FILE_NM', instance.oriFileNm?.toJson());
  writeNotNull('SAVE_FILE_NM', instance.saveFileNm?.toJson());
  writeNotNull('FILE_SIZE', instance.fileSize?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

APPROVALATTACHFILETBLCreateManyInput
    _$APPROVALATTACHFILETBLCreateManyInputFromJson(Map<String, dynamic> json) =>
        APPROVALATTACHFILETBLCreateManyInput(
          approvalId: json['APPROVAL_ID'] as String,
          seq: (json['SEQ'] as num).toDouble(),
          oriFileNm: json['ORI_FILE_NM'] as String?,
          saveFileNm: json['SAVE_FILE_NM'] as String?,
          fileSize: json['FILE_SIZE'] as int?,
          regDate: _$JsonConverterFromJson<String, DateTime>(
              json['REG_DATE'], const DateTimeJsonConverter().fromJson),
        );

Map<String, dynamic> _$APPROVALATTACHFILETBLCreateManyInputToJson(
    APPROVALATTACHFILETBLCreateManyInput instance) {
  final val = <String, dynamic>{
    'APPROVAL_ID': instance.approvalId,
    'SEQ': instance.seq,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('ORI_FILE_NM', instance.oriFileNm);
  writeNotNull('SAVE_FILE_NM', instance.saveFileNm);
  writeNotNull('FILE_SIZE', instance.fileSize);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  return val;
}

APPROVALATTACHFILETBLUpdateManyMutationInput
    _$APPROVALATTACHFILETBLUpdateManyMutationInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALATTACHFILETBLUpdateManyMutationInput(
          approvalId: json['APPROVAL_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_ID'] as Map<String, dynamic>),
          seq: json['SEQ'] == null
              ? null
              : DecimalFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          oriFileNm: json['ORI_FILE_NM'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['ORI_FILE_NM'] as Map<String, dynamic>),
          saveFileNm: json['SAVE_FILE_NM'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['SAVE_FILE_NM'] as Map<String, dynamic>),
          fileSize: json['FILE_SIZE'] == null
              ? null
              : NullableIntFieldUpdateOperationsInput.fromJson(
                  json['FILE_SIZE'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALATTACHFILETBLUpdateManyMutationInputToJson(
    APPROVALATTACHFILETBLUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_ID', instance.approvalId?.toJson());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ORI_FILE_NM', instance.oriFileNm?.toJson());
  writeNotNull('SAVE_FILE_NM', instance.saveFileNm?.toJson());
  writeNotNull('FILE_SIZE', instance.fileSize?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

APPROVALATTACHFILETBLUncheckedUpdateManyInput
    _$APPROVALATTACHFILETBLUncheckedUpdateManyInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALATTACHFILETBLUncheckedUpdateManyInput(
          approvalId: json['APPROVAL_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_ID'] as Map<String, dynamic>),
          seq: json['SEQ'] == null
              ? null
              : DecimalFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          oriFileNm: json['ORI_FILE_NM'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['ORI_FILE_NM'] as Map<String, dynamic>),
          saveFileNm: json['SAVE_FILE_NM'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['SAVE_FILE_NM'] as Map<String, dynamic>),
          fileSize: json['FILE_SIZE'] == null
              ? null
              : NullableIntFieldUpdateOperationsInput.fromJson(
                  json['FILE_SIZE'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALATTACHFILETBLUncheckedUpdateManyInputToJson(
    APPROVALATTACHFILETBLUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_ID', instance.approvalId?.toJson());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ORI_FILE_NM', instance.oriFileNm?.toJson());
  writeNotNull('SAVE_FILE_NM', instance.saveFileNm?.toJson());
  writeNotNull('FILE_SIZE', instance.fileSize?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

APPROVALDOCINFOTBLCreateInput _$APPROVALDOCINFOTBLCreateInputFromJson(
        Map<String, dynamic> json) =>
    APPROVALDOCINFOTBLCreateInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      docType: json['DOC_TYPE'] as String?,
      docNm: json['DOC_NM'] as String?,
      title: json['TITLE'] as String,
      approvalLineType: json['APPROVAL_LINE_TYPE'] as String?,
      approvalLineContent: json['APPROVAL_LINE_CONTENT'] as String?,
      approvalLineContentBak: json['APPROVAL_LINE_CONTENT_BAK'] as String?,
      content: json['CONTENT'] as String?,
      writerId: json['WRITER_ID'] as String?,
      userNm: json['USER_NM'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$APPROVALDOCINFOTBLCreateInputToJson(
    APPROVALDOCINFOTBLCreateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  writeNotNull('DOC_TYPE', instance.docType);
  writeNotNull('DOC_NM', instance.docNm);
  val['TITLE'] = instance.title;
  writeNotNull('APPROVAL_LINE_TYPE', instance.approvalLineType);
  writeNotNull('APPROVAL_LINE_CONTENT', instance.approvalLineContent);
  writeNotNull('APPROVAL_LINE_CONTENT_BAK', instance.approvalLineContentBak);
  writeNotNull('CONTENT', instance.content);
  writeNotNull('WRITER_ID', instance.writerId);
  writeNotNull('USER_NM', instance.userNm);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

APPROVALDOCINFOTBLUncheckedCreateInput
    _$APPROVALDOCINFOTBLUncheckedCreateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALDOCINFOTBLUncheckedCreateInput(
          seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
          docType: json['DOC_TYPE'] as String?,
          docNm: json['DOC_NM'] as String?,
          title: json['TITLE'] as String,
          approvalLineType: json['APPROVAL_LINE_TYPE'] as String?,
          approvalLineContent: json['APPROVAL_LINE_CONTENT'] as String?,
          approvalLineContentBak: json['APPROVAL_LINE_CONTENT_BAK'] as String?,
          content: json['CONTENT'] as String?,
          writerId: json['WRITER_ID'] as String?,
          userNm: json['USER_NM'] as String?,
          regDate: _$JsonConverterFromJson<String, DateTime>(
              json['REG_DATE'], const DateTimeJsonConverter().fromJson),
          updDate: _$JsonConverterFromJson<String, DateTime>(
              json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
          useYn: json['USE_YN'] as String?,
          delYn: json['DEL_YN'] as String?,
        );

Map<String, dynamic> _$APPROVALDOCINFOTBLUncheckedCreateInputToJson(
    APPROVALDOCINFOTBLUncheckedCreateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  writeNotNull('DOC_TYPE', instance.docType);
  writeNotNull('DOC_NM', instance.docNm);
  val['TITLE'] = instance.title;
  writeNotNull('APPROVAL_LINE_TYPE', instance.approvalLineType);
  writeNotNull('APPROVAL_LINE_CONTENT', instance.approvalLineContent);
  writeNotNull('APPROVAL_LINE_CONTENT_BAK', instance.approvalLineContentBak);
  writeNotNull('CONTENT', instance.content);
  writeNotNull('WRITER_ID', instance.writerId);
  writeNotNull('USER_NM', instance.userNm);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

APPROVALDOCINFOTBLUpdateInput _$APPROVALDOCINFOTBLUpdateInputFromJson(
        Map<String, dynamic> json) =>
    APPROVALDOCINFOTBLUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      docType: json['DOC_TYPE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DOC_TYPE'] as Map<String, dynamic>),
      docNm: json['DOC_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DOC_NM'] as Map<String, dynamic>),
      title: json['TITLE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['TITLE'] as Map<String, dynamic>),
      approvalLineType: json['APPROVAL_LINE_TYPE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['APPROVAL_LINE_TYPE'] as Map<String, dynamic>),
      approvalLineContent: json['APPROVAL_LINE_CONTENT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['APPROVAL_LINE_CONTENT'] as Map<String, dynamic>),
      approvalLineContentBak: json['APPROVAL_LINE_CONTENT_BAK'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['APPROVAL_LINE_CONTENT_BAK'] as Map<String, dynamic>),
      content: json['CONTENT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CONTENT'] as Map<String, dynamic>),
      writerId: json['WRITER_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['WRITER_ID'] as Map<String, dynamic>),
      userNm: json['USER_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USER_NM'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : NullableDateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$APPROVALDOCINFOTBLUpdateInputToJson(
    APPROVALDOCINFOTBLUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('DOC_TYPE', instance.docType?.toJson());
  writeNotNull('DOC_NM', instance.docNm?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('APPROVAL_LINE_TYPE', instance.approvalLineType?.toJson());
  writeNotNull('APPROVAL_LINE_CONTENT', instance.approvalLineContent?.toJson());
  writeNotNull(
      'APPROVAL_LINE_CONTENT_BAK', instance.approvalLineContentBak?.toJson());
  writeNotNull('CONTENT', instance.content?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('USER_NM', instance.userNm?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALDOCINFOTBLUncheckedUpdateInput
    _$APPROVALDOCINFOTBLUncheckedUpdateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALDOCINFOTBLUncheckedUpdateInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          docType: json['DOC_TYPE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DOC_TYPE'] as Map<String, dynamic>),
          docNm: json['DOC_NM'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DOC_NM'] as Map<String, dynamic>),
          title: json['TITLE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['TITLE'] as Map<String, dynamic>),
          approvalLineType: json['APPROVAL_LINE_TYPE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_LINE_TYPE'] as Map<String, dynamic>),
          approvalLineContent: json['APPROVAL_LINE_CONTENT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_LINE_CONTENT'] as Map<String, dynamic>),
          approvalLineContentBak: json['APPROVAL_LINE_CONTENT_BAK'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_LINE_CONTENT_BAK'] as Map<String, dynamic>),
          content: json['CONTENT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CONTENT'] as Map<String, dynamic>),
          writerId: json['WRITER_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['WRITER_ID'] as Map<String, dynamic>),
          userNm: json['USER_NM'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['USER_NM'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : NullableDateTimeFieldUpdateOperationsInput.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALDOCINFOTBLUncheckedUpdateInputToJson(
    APPROVALDOCINFOTBLUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('DOC_TYPE', instance.docType?.toJson());
  writeNotNull('DOC_NM', instance.docNm?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('APPROVAL_LINE_TYPE', instance.approvalLineType?.toJson());
  writeNotNull('APPROVAL_LINE_CONTENT', instance.approvalLineContent?.toJson());
  writeNotNull(
      'APPROVAL_LINE_CONTENT_BAK', instance.approvalLineContentBak?.toJson());
  writeNotNull('CONTENT', instance.content?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('USER_NM', instance.userNm?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALDOCINFOTBLCreateManyInput _$APPROVALDOCINFOTBLCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    APPROVALDOCINFOTBLCreateManyInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      docType: json['DOC_TYPE'] as String?,
      docNm: json['DOC_NM'] as String?,
      title: json['TITLE'] as String,
      approvalLineType: json['APPROVAL_LINE_TYPE'] as String?,
      approvalLineContent: json['APPROVAL_LINE_CONTENT'] as String?,
      approvalLineContentBak: json['APPROVAL_LINE_CONTENT_BAK'] as String?,
      content: json['CONTENT'] as String?,
      writerId: json['WRITER_ID'] as String?,
      userNm: json['USER_NM'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$APPROVALDOCINFOTBLCreateManyInputToJson(
    APPROVALDOCINFOTBLCreateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  writeNotNull('DOC_TYPE', instance.docType);
  writeNotNull('DOC_NM', instance.docNm);
  val['TITLE'] = instance.title;
  writeNotNull('APPROVAL_LINE_TYPE', instance.approvalLineType);
  writeNotNull('APPROVAL_LINE_CONTENT', instance.approvalLineContent);
  writeNotNull('APPROVAL_LINE_CONTENT_BAK', instance.approvalLineContentBak);
  writeNotNull('CONTENT', instance.content);
  writeNotNull('WRITER_ID', instance.writerId);
  writeNotNull('USER_NM', instance.userNm);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

APPROVALDOCINFOTBLUpdateManyMutationInput
    _$APPROVALDOCINFOTBLUpdateManyMutationInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALDOCINFOTBLUpdateManyMutationInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          docType: json['DOC_TYPE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DOC_TYPE'] as Map<String, dynamic>),
          docNm: json['DOC_NM'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DOC_NM'] as Map<String, dynamic>),
          title: json['TITLE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['TITLE'] as Map<String, dynamic>),
          approvalLineType: json['APPROVAL_LINE_TYPE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_LINE_TYPE'] as Map<String, dynamic>),
          approvalLineContent: json['APPROVAL_LINE_CONTENT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_LINE_CONTENT'] as Map<String, dynamic>),
          approvalLineContentBak: json['APPROVAL_LINE_CONTENT_BAK'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_LINE_CONTENT_BAK'] as Map<String, dynamic>),
          content: json['CONTENT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CONTENT'] as Map<String, dynamic>),
          writerId: json['WRITER_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['WRITER_ID'] as Map<String, dynamic>),
          userNm: json['USER_NM'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['USER_NM'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : NullableDateTimeFieldUpdateOperationsInput.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALDOCINFOTBLUpdateManyMutationInputToJson(
    APPROVALDOCINFOTBLUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('DOC_TYPE', instance.docType?.toJson());
  writeNotNull('DOC_NM', instance.docNm?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('APPROVAL_LINE_TYPE', instance.approvalLineType?.toJson());
  writeNotNull('APPROVAL_LINE_CONTENT', instance.approvalLineContent?.toJson());
  writeNotNull(
      'APPROVAL_LINE_CONTENT_BAK', instance.approvalLineContentBak?.toJson());
  writeNotNull('CONTENT', instance.content?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('USER_NM', instance.userNm?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALDOCINFOTBLUncheckedUpdateManyInput
    _$APPROVALDOCINFOTBLUncheckedUpdateManyInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALDOCINFOTBLUncheckedUpdateManyInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          docType: json['DOC_TYPE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DOC_TYPE'] as Map<String, dynamic>),
          docNm: json['DOC_NM'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DOC_NM'] as Map<String, dynamic>),
          title: json['TITLE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['TITLE'] as Map<String, dynamic>),
          approvalLineType: json['APPROVAL_LINE_TYPE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_LINE_TYPE'] as Map<String, dynamic>),
          approvalLineContent: json['APPROVAL_LINE_CONTENT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_LINE_CONTENT'] as Map<String, dynamic>),
          approvalLineContentBak: json['APPROVAL_LINE_CONTENT_BAK'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_LINE_CONTENT_BAK'] as Map<String, dynamic>),
          content: json['CONTENT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CONTENT'] as Map<String, dynamic>),
          writerId: json['WRITER_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['WRITER_ID'] as Map<String, dynamic>),
          userNm: json['USER_NM'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['USER_NM'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : NullableDateTimeFieldUpdateOperationsInput.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALDOCINFOTBLUncheckedUpdateManyInputToJson(
    APPROVALDOCINFOTBLUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('DOC_TYPE', instance.docType?.toJson());
  writeNotNull('DOC_NM', instance.docNm?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('APPROVAL_LINE_TYPE', instance.approvalLineType?.toJson());
  writeNotNull('APPROVAL_LINE_CONTENT', instance.approvalLineContent?.toJson());
  writeNotNull(
      'APPROVAL_LINE_CONTENT_BAK', instance.approvalLineContentBak?.toJson());
  writeNotNull('CONTENT', instance.content?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('USER_NM', instance.userNm?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALHISTORYTBLCreateInput _$APPROVALHISTORYTBLCreateInputFromJson(
        Map<String, dynamic> json) =>
    APPROVALHISTORYTBLCreateInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      approvalId: json['APPROVAL_ID'] as String,
      writerId: json['WRITER_ID'] as String,
      writerNm: json['WRITER_NM'] as String,
      docType: json['DOC_TYPE'] as String,
      keepPriod: json['KEEP_PRIOD'] as int?,
      keepDate: _$JsonConverterFromJson<String, DateTime>(
          json['KEEP_DATE'], const DateTimeJsonConverter().fromJson),
      grade: json['GRADE'] as String?,
      status: json['STATUS'] as String?,
      content: json['CONTENT'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$APPROVALHISTORYTBLCreateInputToJson(
    APPROVALHISTORYTBLCreateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['APPROVAL_ID'] = instance.approvalId;
  val['WRITER_ID'] = instance.writerId;
  val['WRITER_NM'] = instance.writerNm;
  val['DOC_TYPE'] = instance.docType;
  writeNotNull('KEEP_PRIOD', instance.keepPriod);
  writeNotNull(
      'KEEP_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.keepDate, const DateTimeJsonConverter().toJson));
  writeNotNull('GRADE', instance.grade);
  writeNotNull('STATUS', instance.status);
  writeNotNull('CONTENT', instance.content);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

APPROVALHISTORYTBLUncheckedCreateInput
    _$APPROVALHISTORYTBLUncheckedCreateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALHISTORYTBLUncheckedCreateInput(
          seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
          approvalId: json['APPROVAL_ID'] as String,
          writerId: json['WRITER_ID'] as String,
          writerNm: json['WRITER_NM'] as String,
          docType: json['DOC_TYPE'] as String,
          keepPriod: json['KEEP_PRIOD'] as int?,
          keepDate: _$JsonConverterFromJson<String, DateTime>(
              json['KEEP_DATE'], const DateTimeJsonConverter().fromJson),
          grade: json['GRADE'] as String?,
          status: json['STATUS'] as String?,
          content: json['CONTENT'] as String?,
          regDate: _$JsonConverterFromJson<String, DateTime>(
              json['REG_DATE'], const DateTimeJsonConverter().fromJson),
          updDate: _$JsonConverterFromJson<String, DateTime>(
              json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
          delYn: json['DEL_YN'] as String?,
        );

Map<String, dynamic> _$APPROVALHISTORYTBLUncheckedCreateInputToJson(
    APPROVALHISTORYTBLUncheckedCreateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['APPROVAL_ID'] = instance.approvalId;
  val['WRITER_ID'] = instance.writerId;
  val['WRITER_NM'] = instance.writerNm;
  val['DOC_TYPE'] = instance.docType;
  writeNotNull('KEEP_PRIOD', instance.keepPriod);
  writeNotNull(
      'KEEP_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.keepDate, const DateTimeJsonConverter().toJson));
  writeNotNull('GRADE', instance.grade);
  writeNotNull('STATUS', instance.status);
  writeNotNull('CONTENT', instance.content);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

APPROVALHISTORYTBLUpdateInput _$APPROVALHISTORYTBLUpdateInputFromJson(
        Map<String, dynamic> json) =>
    APPROVALHISTORYTBLUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      approvalId: json['APPROVAL_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['APPROVAL_ID'] as Map<String, dynamic>),
      writerId: json['WRITER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['WRITER_ID'] as Map<String, dynamic>),
      writerNm: json['WRITER_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['WRITER_NM'] as Map<String, dynamic>),
      docType: json['DOC_TYPE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['DOC_TYPE'] as Map<String, dynamic>),
      keepPriod: json['KEEP_PRIOD'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['KEEP_PRIOD'] as Map<String, dynamic>),
      keepDate: json['KEEP_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['KEEP_DATE'] as Map<String, dynamic>),
      grade: json['GRADE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['GRADE'] as Map<String, dynamic>),
      status: json['STATUS'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['STATUS'] as Map<String, dynamic>),
      content: json['CONTENT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CONTENT'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : NullableDateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$APPROVALHISTORYTBLUpdateInputToJson(
    APPROVALHISTORYTBLUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('APPROVAL_ID', instance.approvalId?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('WRITER_NM', instance.writerNm?.toJson());
  writeNotNull('DOC_TYPE', instance.docType?.toJson());
  writeNotNull('KEEP_PRIOD', instance.keepPriod?.toJson());
  writeNotNull('KEEP_DATE', instance.keepDate?.toJson());
  writeNotNull('GRADE', instance.grade?.toJson());
  writeNotNull('STATUS', instance.status?.toJson());
  writeNotNull('CONTENT', instance.content?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALHISTORYTBLUncheckedUpdateInput
    _$APPROVALHISTORYTBLUncheckedUpdateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALHISTORYTBLUncheckedUpdateInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          approvalId: json['APPROVAL_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_ID'] as Map<String, dynamic>),
          writerId: json['WRITER_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['WRITER_ID'] as Map<String, dynamic>),
          writerNm: json['WRITER_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['WRITER_NM'] as Map<String, dynamic>),
          docType: json['DOC_TYPE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['DOC_TYPE'] as Map<String, dynamic>),
          keepPriod: json['KEEP_PRIOD'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['KEEP_PRIOD'] as Map<String, dynamic>),
          keepDate: json['KEEP_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['KEEP_DATE'] as Map<String, dynamic>),
          grade: json['GRADE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['GRADE'] as Map<String, dynamic>),
          status: json['STATUS'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['STATUS'] as Map<String, dynamic>),
          content: json['CONTENT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CONTENT'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : NullableDateTimeFieldUpdateOperationsInput.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALHISTORYTBLUncheckedUpdateInputToJson(
    APPROVALHISTORYTBLUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('APPROVAL_ID', instance.approvalId?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('WRITER_NM', instance.writerNm?.toJson());
  writeNotNull('DOC_TYPE', instance.docType?.toJson());
  writeNotNull('KEEP_PRIOD', instance.keepPriod?.toJson());
  writeNotNull('KEEP_DATE', instance.keepDate?.toJson());
  writeNotNull('GRADE', instance.grade?.toJson());
  writeNotNull('STATUS', instance.status?.toJson());
  writeNotNull('CONTENT', instance.content?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALHISTORYTBLCreateManyInput _$APPROVALHISTORYTBLCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    APPROVALHISTORYTBLCreateManyInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      approvalId: json['APPROVAL_ID'] as String,
      writerId: json['WRITER_ID'] as String,
      writerNm: json['WRITER_NM'] as String,
      docType: json['DOC_TYPE'] as String,
      keepPriod: json['KEEP_PRIOD'] as int?,
      keepDate: _$JsonConverterFromJson<String, DateTime>(
          json['KEEP_DATE'], const DateTimeJsonConverter().fromJson),
      grade: json['GRADE'] as String?,
      status: json['STATUS'] as String?,
      content: json['CONTENT'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$APPROVALHISTORYTBLCreateManyInputToJson(
    APPROVALHISTORYTBLCreateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['APPROVAL_ID'] = instance.approvalId;
  val['WRITER_ID'] = instance.writerId;
  val['WRITER_NM'] = instance.writerNm;
  val['DOC_TYPE'] = instance.docType;
  writeNotNull('KEEP_PRIOD', instance.keepPriod);
  writeNotNull(
      'KEEP_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.keepDate, const DateTimeJsonConverter().toJson));
  writeNotNull('GRADE', instance.grade);
  writeNotNull('STATUS', instance.status);
  writeNotNull('CONTENT', instance.content);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

APPROVALHISTORYTBLUpdateManyMutationInput
    _$APPROVALHISTORYTBLUpdateManyMutationInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALHISTORYTBLUpdateManyMutationInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          approvalId: json['APPROVAL_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_ID'] as Map<String, dynamic>),
          writerId: json['WRITER_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['WRITER_ID'] as Map<String, dynamic>),
          writerNm: json['WRITER_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['WRITER_NM'] as Map<String, dynamic>),
          docType: json['DOC_TYPE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['DOC_TYPE'] as Map<String, dynamic>),
          keepPriod: json['KEEP_PRIOD'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['KEEP_PRIOD'] as Map<String, dynamic>),
          keepDate: json['KEEP_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['KEEP_DATE'] as Map<String, dynamic>),
          grade: json['GRADE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['GRADE'] as Map<String, dynamic>),
          status: json['STATUS'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['STATUS'] as Map<String, dynamic>),
          content: json['CONTENT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CONTENT'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : NullableDateTimeFieldUpdateOperationsInput.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALHISTORYTBLUpdateManyMutationInputToJson(
    APPROVALHISTORYTBLUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('APPROVAL_ID', instance.approvalId?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('WRITER_NM', instance.writerNm?.toJson());
  writeNotNull('DOC_TYPE', instance.docType?.toJson());
  writeNotNull('KEEP_PRIOD', instance.keepPriod?.toJson());
  writeNotNull('KEEP_DATE', instance.keepDate?.toJson());
  writeNotNull('GRADE', instance.grade?.toJson());
  writeNotNull('STATUS', instance.status?.toJson());
  writeNotNull('CONTENT', instance.content?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALHISTORYTBLUncheckedUpdateManyInput
    _$APPROVALHISTORYTBLUncheckedUpdateManyInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALHISTORYTBLUncheckedUpdateManyInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          approvalId: json['APPROVAL_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_ID'] as Map<String, dynamic>),
          writerId: json['WRITER_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['WRITER_ID'] as Map<String, dynamic>),
          writerNm: json['WRITER_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['WRITER_NM'] as Map<String, dynamic>),
          docType: json['DOC_TYPE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['DOC_TYPE'] as Map<String, dynamic>),
          keepPriod: json['KEEP_PRIOD'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['KEEP_PRIOD'] as Map<String, dynamic>),
          keepDate: json['KEEP_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['KEEP_DATE'] as Map<String, dynamic>),
          grade: json['GRADE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['GRADE'] as Map<String, dynamic>),
          status: json['STATUS'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['STATUS'] as Map<String, dynamic>),
          content: json['CONTENT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CONTENT'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : NullableDateTimeFieldUpdateOperationsInput.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALHISTORYTBLUncheckedUpdateManyInputToJson(
    APPROVALHISTORYTBLUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('APPROVAL_ID', instance.approvalId?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('WRITER_NM', instance.writerNm?.toJson());
  writeNotNull('DOC_TYPE', instance.docType?.toJson());
  writeNotNull('KEEP_PRIOD', instance.keepPriod?.toJson());
  writeNotNull('KEEP_DATE', instance.keepDate?.toJson());
  writeNotNull('GRADE', instance.grade?.toJson());
  writeNotNull('STATUS', instance.status?.toJson());
  writeNotNull('CONTENT', instance.content?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALMASTERTBLCreateInput _$APPROVALMASTERTBLCreateInputFromJson(
        Map<String, dynamic> json) =>
    APPROVALMASTERTBLCreateInput(
      approvalId: json['APPROVAL_ID'] as String,
      writerId: json['WRITER_ID'] as String,
      writerNm: json['WRITER_NM'] as String,
      docType: json['DOC_TYPE'] as String,
      keepPriod: json['KEEP_PRIOD'] as int?,
      keepDate: _$JsonConverterFromJson<String, DateTime>(
          json['KEEP_DATE'], const DateTimeJsonConverter().fromJson),
      grade: json['GRADE'] as String?,
      status: json['STATUS'] as String?,
      title: json['TITLE'] as String?,
      header: json['HEADER'] as String?,
      content: json['CONTENT'] as String?,
      m1: (json['M1'] as num?)?.toDouble(),
      m2: (json['M2'] as num?)?.toDouble(),
      m3: (json['M3'] as num?)?.toDouble(),
      m4: (json['M4'] as num?)?.toDouble(),
      m5: (json['M5'] as num?)?.toDouble(),
      m6: (json['M6'] as num?)?.toDouble(),
      m7: (json['M7'] as num?)?.toDouble(),
      m8: (json['M8'] as num?)?.toDouble(),
      m9: (json['M9'] as num?)?.toDouble(),
      m10: (json['M10'] as num?)?.toDouble(),
      m11: (json['M11'] as num?)?.toDouble(),
      m12: (json['M12'] as num?)?.toDouble(),
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      completeDate: _$JsonConverterFromJson<String, DateTime>(
          json['COMPLETE_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$APPROVALMASTERTBLCreateInputToJson(
    APPROVALMASTERTBLCreateInput instance) {
  final val = <String, dynamic>{
    'APPROVAL_ID': instance.approvalId,
    'WRITER_ID': instance.writerId,
    'WRITER_NM': instance.writerNm,
    'DOC_TYPE': instance.docType,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('KEEP_PRIOD', instance.keepPriod);
  writeNotNull(
      'KEEP_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.keepDate, const DateTimeJsonConverter().toJson));
  writeNotNull('GRADE', instance.grade);
  writeNotNull('STATUS', instance.status);
  writeNotNull('TITLE', instance.title);
  writeNotNull('HEADER', instance.header);
  writeNotNull('CONTENT', instance.content);
  writeNotNull('M1', instance.m1);
  writeNotNull('M2', instance.m2);
  writeNotNull('M3', instance.m3);
  writeNotNull('M4', instance.m4);
  writeNotNull('M5', instance.m5);
  writeNotNull('M6', instance.m6);
  writeNotNull('M7', instance.m7);
  writeNotNull('M8', instance.m8);
  writeNotNull('M9', instance.m9);
  writeNotNull('M10', instance.m10);
  writeNotNull('M11', instance.m11);
  writeNotNull('M12', instance.m12);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'COMPLETE_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.completeDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

APPROVALMASTERTBLUncheckedCreateInput
    _$APPROVALMASTERTBLUncheckedCreateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALMASTERTBLUncheckedCreateInput(
          approvalId: json['APPROVAL_ID'] as String,
          writerId: json['WRITER_ID'] as String,
          writerNm: json['WRITER_NM'] as String,
          docType: json['DOC_TYPE'] as String,
          keepPriod: json['KEEP_PRIOD'] as int?,
          keepDate: _$JsonConverterFromJson<String, DateTime>(
              json['KEEP_DATE'], const DateTimeJsonConverter().fromJson),
          grade: json['GRADE'] as String?,
          status: json['STATUS'] as String?,
          title: json['TITLE'] as String?,
          header: json['HEADER'] as String?,
          content: json['CONTENT'] as String?,
          m1: (json['M1'] as num?)?.toDouble(),
          m2: (json['M2'] as num?)?.toDouble(),
          m3: (json['M3'] as num?)?.toDouble(),
          m4: (json['M4'] as num?)?.toDouble(),
          m5: (json['M5'] as num?)?.toDouble(),
          m6: (json['M6'] as num?)?.toDouble(),
          m7: (json['M7'] as num?)?.toDouble(),
          m8: (json['M8'] as num?)?.toDouble(),
          m9: (json['M9'] as num?)?.toDouble(),
          m10: (json['M10'] as num?)?.toDouble(),
          m11: (json['M11'] as num?)?.toDouble(),
          m12: (json['M12'] as num?)?.toDouble(),
          regDate: _$JsonConverterFromJson<String, DateTime>(
              json['REG_DATE'], const DateTimeJsonConverter().fromJson),
          completeDate: _$JsonConverterFromJson<String, DateTime>(
              json['COMPLETE_DATE'], const DateTimeJsonConverter().fromJson),
          updDate: _$JsonConverterFromJson<String, DateTime>(
              json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
          delYn: json['DEL_YN'] as String?,
        );

Map<String, dynamic> _$APPROVALMASTERTBLUncheckedCreateInputToJson(
    APPROVALMASTERTBLUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'APPROVAL_ID': instance.approvalId,
    'WRITER_ID': instance.writerId,
    'WRITER_NM': instance.writerNm,
    'DOC_TYPE': instance.docType,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('KEEP_PRIOD', instance.keepPriod);
  writeNotNull(
      'KEEP_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.keepDate, const DateTimeJsonConverter().toJson));
  writeNotNull('GRADE', instance.grade);
  writeNotNull('STATUS', instance.status);
  writeNotNull('TITLE', instance.title);
  writeNotNull('HEADER', instance.header);
  writeNotNull('CONTENT', instance.content);
  writeNotNull('M1', instance.m1);
  writeNotNull('M2', instance.m2);
  writeNotNull('M3', instance.m3);
  writeNotNull('M4', instance.m4);
  writeNotNull('M5', instance.m5);
  writeNotNull('M6', instance.m6);
  writeNotNull('M7', instance.m7);
  writeNotNull('M8', instance.m8);
  writeNotNull('M9', instance.m9);
  writeNotNull('M10', instance.m10);
  writeNotNull('M11', instance.m11);
  writeNotNull('M12', instance.m12);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'COMPLETE_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.completeDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

APPROVALMASTERTBLUpdateInput _$APPROVALMASTERTBLUpdateInputFromJson(
        Map<String, dynamic> json) =>
    APPROVALMASTERTBLUpdateInput(
      approvalId: json['APPROVAL_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['APPROVAL_ID'] as Map<String, dynamic>),
      writerId: json['WRITER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['WRITER_ID'] as Map<String, dynamic>),
      writerNm: json['WRITER_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['WRITER_NM'] as Map<String, dynamic>),
      docType: json['DOC_TYPE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['DOC_TYPE'] as Map<String, dynamic>),
      keepPriod: json['KEEP_PRIOD'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['KEEP_PRIOD'] as Map<String, dynamic>),
      keepDate: json['KEEP_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['KEEP_DATE'] as Map<String, dynamic>),
      grade: json['GRADE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['GRADE'] as Map<String, dynamic>),
      status: json['STATUS'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['STATUS'] as Map<String, dynamic>),
      title: json['TITLE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['TITLE'] as Map<String, dynamic>),
      header: json['HEADER'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['HEADER'] as Map<String, dynamic>),
      content: json['CONTENT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CONTENT'] as Map<String, dynamic>),
      m1: json['M1'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M1'] as Map<String, dynamic>),
      m2: json['M2'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M2'] as Map<String, dynamic>),
      m3: json['M3'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M3'] as Map<String, dynamic>),
      m4: json['M4'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M4'] as Map<String, dynamic>),
      m5: json['M5'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M5'] as Map<String, dynamic>),
      m6: json['M6'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M6'] as Map<String, dynamic>),
      m7: json['M7'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M7'] as Map<String, dynamic>),
      m8: json['M8'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M8'] as Map<String, dynamic>),
      m9: json['M9'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M9'] as Map<String, dynamic>),
      m10: json['M10'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M10'] as Map<String, dynamic>),
      m11: json['M11'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M11'] as Map<String, dynamic>),
      m12: json['M12'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M12'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      completeDate: json['COMPLETE_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['COMPLETE_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : NullableDateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$APPROVALMASTERTBLUpdateInputToJson(
    APPROVALMASTERTBLUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_ID', instance.approvalId?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('WRITER_NM', instance.writerNm?.toJson());
  writeNotNull('DOC_TYPE', instance.docType?.toJson());
  writeNotNull('KEEP_PRIOD', instance.keepPriod?.toJson());
  writeNotNull('KEEP_DATE', instance.keepDate?.toJson());
  writeNotNull('GRADE', instance.grade?.toJson());
  writeNotNull('STATUS', instance.status?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('HEADER', instance.header?.toJson());
  writeNotNull('CONTENT', instance.content?.toJson());
  writeNotNull('M1', instance.m1?.toJson());
  writeNotNull('M2', instance.m2?.toJson());
  writeNotNull('M3', instance.m3?.toJson());
  writeNotNull('M4', instance.m4?.toJson());
  writeNotNull('M5', instance.m5?.toJson());
  writeNotNull('M6', instance.m6?.toJson());
  writeNotNull('M7', instance.m7?.toJson());
  writeNotNull('M8', instance.m8?.toJson());
  writeNotNull('M9', instance.m9?.toJson());
  writeNotNull('M10', instance.m10?.toJson());
  writeNotNull('M11', instance.m11?.toJson());
  writeNotNull('M12', instance.m12?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('COMPLETE_DATE', instance.completeDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALMASTERTBLUncheckedUpdateInput
    _$APPROVALMASTERTBLUncheckedUpdateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALMASTERTBLUncheckedUpdateInput(
          approvalId: json['APPROVAL_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_ID'] as Map<String, dynamic>),
          writerId: json['WRITER_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['WRITER_ID'] as Map<String, dynamic>),
          writerNm: json['WRITER_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['WRITER_NM'] as Map<String, dynamic>),
          docType: json['DOC_TYPE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['DOC_TYPE'] as Map<String, dynamic>),
          keepPriod: json['KEEP_PRIOD'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['KEEP_PRIOD'] as Map<String, dynamic>),
          keepDate: json['KEEP_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['KEEP_DATE'] as Map<String, dynamic>),
          grade: json['GRADE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['GRADE'] as Map<String, dynamic>),
          status: json['STATUS'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['STATUS'] as Map<String, dynamic>),
          title: json['TITLE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['TITLE'] as Map<String, dynamic>),
          header: json['HEADER'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['HEADER'] as Map<String, dynamic>),
          content: json['CONTENT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CONTENT'] as Map<String, dynamic>),
          m1: json['M1'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M1'] as Map<String, dynamic>),
          m2: json['M2'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M2'] as Map<String, dynamic>),
          m3: json['M3'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M3'] as Map<String, dynamic>),
          m4: json['M4'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M4'] as Map<String, dynamic>),
          m5: json['M5'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M5'] as Map<String, dynamic>),
          m6: json['M6'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M6'] as Map<String, dynamic>),
          m7: json['M7'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M7'] as Map<String, dynamic>),
          m8: json['M8'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M8'] as Map<String, dynamic>),
          m9: json['M9'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M9'] as Map<String, dynamic>),
          m10: json['M10'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M10'] as Map<String, dynamic>),
          m11: json['M11'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M11'] as Map<String, dynamic>),
          m12: json['M12'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M12'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          completeDate: json['COMPLETE_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['COMPLETE_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : NullableDateTimeFieldUpdateOperationsInput.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALMASTERTBLUncheckedUpdateInputToJson(
    APPROVALMASTERTBLUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_ID', instance.approvalId?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('WRITER_NM', instance.writerNm?.toJson());
  writeNotNull('DOC_TYPE', instance.docType?.toJson());
  writeNotNull('KEEP_PRIOD', instance.keepPriod?.toJson());
  writeNotNull('KEEP_DATE', instance.keepDate?.toJson());
  writeNotNull('GRADE', instance.grade?.toJson());
  writeNotNull('STATUS', instance.status?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('HEADER', instance.header?.toJson());
  writeNotNull('CONTENT', instance.content?.toJson());
  writeNotNull('M1', instance.m1?.toJson());
  writeNotNull('M2', instance.m2?.toJson());
  writeNotNull('M3', instance.m3?.toJson());
  writeNotNull('M4', instance.m4?.toJson());
  writeNotNull('M5', instance.m5?.toJson());
  writeNotNull('M6', instance.m6?.toJson());
  writeNotNull('M7', instance.m7?.toJson());
  writeNotNull('M8', instance.m8?.toJson());
  writeNotNull('M9', instance.m9?.toJson());
  writeNotNull('M10', instance.m10?.toJson());
  writeNotNull('M11', instance.m11?.toJson());
  writeNotNull('M12', instance.m12?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('COMPLETE_DATE', instance.completeDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALMASTERTBLCreateManyInput _$APPROVALMASTERTBLCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    APPROVALMASTERTBLCreateManyInput(
      approvalId: json['APPROVAL_ID'] as String,
      writerId: json['WRITER_ID'] as String,
      writerNm: json['WRITER_NM'] as String,
      docType: json['DOC_TYPE'] as String,
      keepPriod: json['KEEP_PRIOD'] as int?,
      keepDate: _$JsonConverterFromJson<String, DateTime>(
          json['KEEP_DATE'], const DateTimeJsonConverter().fromJson),
      grade: json['GRADE'] as String?,
      status: json['STATUS'] as String?,
      title: json['TITLE'] as String?,
      header: json['HEADER'] as String?,
      content: json['CONTENT'] as String?,
      m1: (json['M1'] as num?)?.toDouble(),
      m2: (json['M2'] as num?)?.toDouble(),
      m3: (json['M3'] as num?)?.toDouble(),
      m4: (json['M4'] as num?)?.toDouble(),
      m5: (json['M5'] as num?)?.toDouble(),
      m6: (json['M6'] as num?)?.toDouble(),
      m7: (json['M7'] as num?)?.toDouble(),
      m8: (json['M8'] as num?)?.toDouble(),
      m9: (json['M9'] as num?)?.toDouble(),
      m10: (json['M10'] as num?)?.toDouble(),
      m11: (json['M11'] as num?)?.toDouble(),
      m12: (json['M12'] as num?)?.toDouble(),
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      completeDate: _$JsonConverterFromJson<String, DateTime>(
          json['COMPLETE_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$APPROVALMASTERTBLCreateManyInputToJson(
    APPROVALMASTERTBLCreateManyInput instance) {
  final val = <String, dynamic>{
    'APPROVAL_ID': instance.approvalId,
    'WRITER_ID': instance.writerId,
    'WRITER_NM': instance.writerNm,
    'DOC_TYPE': instance.docType,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('KEEP_PRIOD', instance.keepPriod);
  writeNotNull(
      'KEEP_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.keepDate, const DateTimeJsonConverter().toJson));
  writeNotNull('GRADE', instance.grade);
  writeNotNull('STATUS', instance.status);
  writeNotNull('TITLE', instance.title);
  writeNotNull('HEADER', instance.header);
  writeNotNull('CONTENT', instance.content);
  writeNotNull('M1', instance.m1);
  writeNotNull('M2', instance.m2);
  writeNotNull('M3', instance.m3);
  writeNotNull('M4', instance.m4);
  writeNotNull('M5', instance.m5);
  writeNotNull('M6', instance.m6);
  writeNotNull('M7', instance.m7);
  writeNotNull('M8', instance.m8);
  writeNotNull('M9', instance.m9);
  writeNotNull('M10', instance.m10);
  writeNotNull('M11', instance.m11);
  writeNotNull('M12', instance.m12);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'COMPLETE_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.completeDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

APPROVALMASTERTBLUpdateManyMutationInput
    _$APPROVALMASTERTBLUpdateManyMutationInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALMASTERTBLUpdateManyMutationInput(
          approvalId: json['APPROVAL_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_ID'] as Map<String, dynamic>),
          writerId: json['WRITER_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['WRITER_ID'] as Map<String, dynamic>),
          writerNm: json['WRITER_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['WRITER_NM'] as Map<String, dynamic>),
          docType: json['DOC_TYPE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['DOC_TYPE'] as Map<String, dynamic>),
          keepPriod: json['KEEP_PRIOD'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['KEEP_PRIOD'] as Map<String, dynamic>),
          keepDate: json['KEEP_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['KEEP_DATE'] as Map<String, dynamic>),
          grade: json['GRADE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['GRADE'] as Map<String, dynamic>),
          status: json['STATUS'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['STATUS'] as Map<String, dynamic>),
          title: json['TITLE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['TITLE'] as Map<String, dynamic>),
          header: json['HEADER'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['HEADER'] as Map<String, dynamic>),
          content: json['CONTENT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CONTENT'] as Map<String, dynamic>),
          m1: json['M1'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M1'] as Map<String, dynamic>),
          m2: json['M2'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M2'] as Map<String, dynamic>),
          m3: json['M3'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M3'] as Map<String, dynamic>),
          m4: json['M4'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M4'] as Map<String, dynamic>),
          m5: json['M5'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M5'] as Map<String, dynamic>),
          m6: json['M6'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M6'] as Map<String, dynamic>),
          m7: json['M7'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M7'] as Map<String, dynamic>),
          m8: json['M8'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M8'] as Map<String, dynamic>),
          m9: json['M9'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M9'] as Map<String, dynamic>),
          m10: json['M10'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M10'] as Map<String, dynamic>),
          m11: json['M11'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M11'] as Map<String, dynamic>),
          m12: json['M12'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M12'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          completeDate: json['COMPLETE_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['COMPLETE_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : NullableDateTimeFieldUpdateOperationsInput.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALMASTERTBLUpdateManyMutationInputToJson(
    APPROVALMASTERTBLUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_ID', instance.approvalId?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('WRITER_NM', instance.writerNm?.toJson());
  writeNotNull('DOC_TYPE', instance.docType?.toJson());
  writeNotNull('KEEP_PRIOD', instance.keepPriod?.toJson());
  writeNotNull('KEEP_DATE', instance.keepDate?.toJson());
  writeNotNull('GRADE', instance.grade?.toJson());
  writeNotNull('STATUS', instance.status?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('HEADER', instance.header?.toJson());
  writeNotNull('CONTENT', instance.content?.toJson());
  writeNotNull('M1', instance.m1?.toJson());
  writeNotNull('M2', instance.m2?.toJson());
  writeNotNull('M3', instance.m3?.toJson());
  writeNotNull('M4', instance.m4?.toJson());
  writeNotNull('M5', instance.m5?.toJson());
  writeNotNull('M6', instance.m6?.toJson());
  writeNotNull('M7', instance.m7?.toJson());
  writeNotNull('M8', instance.m8?.toJson());
  writeNotNull('M9', instance.m9?.toJson());
  writeNotNull('M10', instance.m10?.toJson());
  writeNotNull('M11', instance.m11?.toJson());
  writeNotNull('M12', instance.m12?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('COMPLETE_DATE', instance.completeDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALMASTERTBLUncheckedUpdateManyInput
    _$APPROVALMASTERTBLUncheckedUpdateManyInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALMASTERTBLUncheckedUpdateManyInput(
          approvalId: json['APPROVAL_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_ID'] as Map<String, dynamic>),
          writerId: json['WRITER_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['WRITER_ID'] as Map<String, dynamic>),
          writerNm: json['WRITER_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['WRITER_NM'] as Map<String, dynamic>),
          docType: json['DOC_TYPE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['DOC_TYPE'] as Map<String, dynamic>),
          keepPriod: json['KEEP_PRIOD'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['KEEP_PRIOD'] as Map<String, dynamic>),
          keepDate: json['KEEP_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['KEEP_DATE'] as Map<String, dynamic>),
          grade: json['GRADE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['GRADE'] as Map<String, dynamic>),
          status: json['STATUS'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['STATUS'] as Map<String, dynamic>),
          title: json['TITLE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['TITLE'] as Map<String, dynamic>),
          header: json['HEADER'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['HEADER'] as Map<String, dynamic>),
          content: json['CONTENT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CONTENT'] as Map<String, dynamic>),
          m1: json['M1'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M1'] as Map<String, dynamic>),
          m2: json['M2'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M2'] as Map<String, dynamic>),
          m3: json['M3'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M3'] as Map<String, dynamic>),
          m4: json['M4'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M4'] as Map<String, dynamic>),
          m5: json['M5'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M5'] as Map<String, dynamic>),
          m6: json['M6'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M6'] as Map<String, dynamic>),
          m7: json['M7'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M7'] as Map<String, dynamic>),
          m8: json['M8'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M8'] as Map<String, dynamic>),
          m9: json['M9'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M9'] as Map<String, dynamic>),
          m10: json['M10'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M10'] as Map<String, dynamic>),
          m11: json['M11'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M11'] as Map<String, dynamic>),
          m12: json['M12'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['M12'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          completeDate: json['COMPLETE_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['COMPLETE_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : NullableDateTimeFieldUpdateOperationsInput.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALMASTERTBLUncheckedUpdateManyInputToJson(
    APPROVALMASTERTBLUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_ID', instance.approvalId?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('WRITER_NM', instance.writerNm?.toJson());
  writeNotNull('DOC_TYPE', instance.docType?.toJson());
  writeNotNull('KEEP_PRIOD', instance.keepPriod?.toJson());
  writeNotNull('KEEP_DATE', instance.keepDate?.toJson());
  writeNotNull('GRADE', instance.grade?.toJson());
  writeNotNull('STATUS', instance.status?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('HEADER', instance.header?.toJson());
  writeNotNull('CONTENT', instance.content?.toJson());
  writeNotNull('M1', instance.m1?.toJson());
  writeNotNull('M2', instance.m2?.toJson());
  writeNotNull('M3', instance.m3?.toJson());
  writeNotNull('M4', instance.m4?.toJson());
  writeNotNull('M5', instance.m5?.toJson());
  writeNotNull('M6', instance.m6?.toJson());
  writeNotNull('M7', instance.m7?.toJson());
  writeNotNull('M8', instance.m8?.toJson());
  writeNotNull('M9', instance.m9?.toJson());
  writeNotNull('M10', instance.m10?.toJson());
  writeNotNull('M11', instance.m11?.toJson());
  writeNotNull('M12', instance.m12?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('COMPLETE_DATE', instance.completeDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALMEMOTBLCreateInput _$APPROVALMEMOTBLCreateInputFromJson(
        Map<String, dynamic> json) =>
    APPROVALMEMOTBLCreateInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      approvalId: json['APPROVAL_ID'] as String,
      writerId: json['WRITER_ID'] as String,
      writerNm: json['WRITER_NM'] as String,
      content: json['CONTENT'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$APPROVALMEMOTBLCreateInputToJson(
    APPROVALMEMOTBLCreateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['APPROVAL_ID'] = instance.approvalId;
  val['WRITER_ID'] = instance.writerId;
  val['WRITER_NM'] = instance.writerNm;
  writeNotNull('CONTENT', instance.content);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

APPROVALMEMOTBLUncheckedCreateInput
    _$APPROVALMEMOTBLUncheckedCreateInputFromJson(Map<String, dynamic> json) =>
        APPROVALMEMOTBLUncheckedCreateInput(
          seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
          approvalId: json['APPROVAL_ID'] as String,
          writerId: json['WRITER_ID'] as String,
          writerNm: json['WRITER_NM'] as String,
          content: json['CONTENT'] as String?,
          regDate: _$JsonConverterFromJson<String, DateTime>(
              json['REG_DATE'], const DateTimeJsonConverter().fromJson),
          updDate: _$JsonConverterFromJson<String, DateTime>(
              json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
          delYn: json['DEL_YN'] as String?,
        );

Map<String, dynamic> _$APPROVALMEMOTBLUncheckedCreateInputToJson(
    APPROVALMEMOTBLUncheckedCreateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['APPROVAL_ID'] = instance.approvalId;
  val['WRITER_ID'] = instance.writerId;
  val['WRITER_NM'] = instance.writerNm;
  writeNotNull('CONTENT', instance.content);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

APPROVALMEMOTBLUpdateInput _$APPROVALMEMOTBLUpdateInputFromJson(
        Map<String, dynamic> json) =>
    APPROVALMEMOTBLUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      approvalId: json['APPROVAL_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['APPROVAL_ID'] as Map<String, dynamic>),
      writerId: json['WRITER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['WRITER_ID'] as Map<String, dynamic>),
      writerNm: json['WRITER_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['WRITER_NM'] as Map<String, dynamic>),
      content: json['CONTENT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CONTENT'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : NullableDateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$APPROVALMEMOTBLUpdateInputToJson(
    APPROVALMEMOTBLUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('APPROVAL_ID', instance.approvalId?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('WRITER_NM', instance.writerNm?.toJson());
  writeNotNull('CONTENT', instance.content?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALMEMOTBLUncheckedUpdateInput
    _$APPROVALMEMOTBLUncheckedUpdateInputFromJson(Map<String, dynamic> json) =>
        APPROVALMEMOTBLUncheckedUpdateInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          approvalId: json['APPROVAL_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_ID'] as Map<String, dynamic>),
          writerId: json['WRITER_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['WRITER_ID'] as Map<String, dynamic>),
          writerNm: json['WRITER_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['WRITER_NM'] as Map<String, dynamic>),
          content: json['CONTENT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CONTENT'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : NullableDateTimeFieldUpdateOperationsInput.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALMEMOTBLUncheckedUpdateInputToJson(
    APPROVALMEMOTBLUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('APPROVAL_ID', instance.approvalId?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('WRITER_NM', instance.writerNm?.toJson());
  writeNotNull('CONTENT', instance.content?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALMEMOTBLCreateManyInput _$APPROVALMEMOTBLCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    APPROVALMEMOTBLCreateManyInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      approvalId: json['APPROVAL_ID'] as String,
      writerId: json['WRITER_ID'] as String,
      writerNm: json['WRITER_NM'] as String,
      content: json['CONTENT'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$APPROVALMEMOTBLCreateManyInputToJson(
    APPROVALMEMOTBLCreateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['APPROVAL_ID'] = instance.approvalId;
  val['WRITER_ID'] = instance.writerId;
  val['WRITER_NM'] = instance.writerNm;
  writeNotNull('CONTENT', instance.content);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

APPROVALMEMOTBLUpdateManyMutationInput
    _$APPROVALMEMOTBLUpdateManyMutationInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALMEMOTBLUpdateManyMutationInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          approvalId: json['APPROVAL_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_ID'] as Map<String, dynamic>),
          writerId: json['WRITER_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['WRITER_ID'] as Map<String, dynamic>),
          writerNm: json['WRITER_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['WRITER_NM'] as Map<String, dynamic>),
          content: json['CONTENT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CONTENT'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : NullableDateTimeFieldUpdateOperationsInput.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALMEMOTBLUpdateManyMutationInputToJson(
    APPROVALMEMOTBLUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('APPROVAL_ID', instance.approvalId?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('WRITER_NM', instance.writerNm?.toJson());
  writeNotNull('CONTENT', instance.content?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALMEMOTBLUncheckedUpdateManyInput
    _$APPROVALMEMOTBLUncheckedUpdateManyInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALMEMOTBLUncheckedUpdateManyInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          approvalId: json['APPROVAL_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_ID'] as Map<String, dynamic>),
          writerId: json['WRITER_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['WRITER_ID'] as Map<String, dynamic>),
          writerNm: json['WRITER_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['WRITER_NM'] as Map<String, dynamic>),
          content: json['CONTENT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CONTENT'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : NullableDateTimeFieldUpdateOperationsInput.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALMEMOTBLUncheckedUpdateManyInputToJson(
    APPROVALMEMOTBLUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('APPROVAL_ID', instance.approvalId?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('WRITER_NM', instance.writerNm?.toJson());
  writeNotNull('CONTENT', instance.content?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALTYPETBLCreateInput _$APPROVALTYPETBLCreateInputFromJson(
        Map<String, dynamic> json) =>
    APPROVALTYPETBLCreateInput(
      type: json['TYPE'] as String,
      content: json['CONTENT'] as String?,
      contentBak: json['CONTENT_BAK'] as String?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$APPROVALTYPETBLCreateInputToJson(
    APPROVALTYPETBLCreateInput instance) {
  final val = <String, dynamic>{
    'TYPE': instance.type,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CONTENT', instance.content);
  writeNotNull('CONTENT_BAK', instance.contentBak);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

APPROVALTYPETBLUncheckedCreateInput
    _$APPROVALTYPETBLUncheckedCreateInputFromJson(Map<String, dynamic> json) =>
        APPROVALTYPETBLUncheckedCreateInput(
          type: json['TYPE'] as String,
          content: json['CONTENT'] as String?,
          contentBak: json['CONTENT_BAK'] as String?,
          useYn: json['USE_YN'] as String?,
          delYn: json['DEL_YN'] as String?,
        );

Map<String, dynamic> _$APPROVALTYPETBLUncheckedCreateInputToJson(
    APPROVALTYPETBLUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'TYPE': instance.type,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CONTENT', instance.content);
  writeNotNull('CONTENT_BAK', instance.contentBak);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

APPROVALTYPETBLUpdateInput _$APPROVALTYPETBLUpdateInputFromJson(
        Map<String, dynamic> json) =>
    APPROVALTYPETBLUpdateInput(
      type: json['TYPE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['TYPE'] as Map<String, dynamic>),
      content: json['CONTENT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CONTENT'] as Map<String, dynamic>),
      contentBak: json['CONTENT_BAK'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CONTENT_BAK'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$APPROVALTYPETBLUpdateInputToJson(
    APPROVALTYPETBLUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('TYPE', instance.type?.toJson());
  writeNotNull('CONTENT', instance.content?.toJson());
  writeNotNull('CONTENT_BAK', instance.contentBak?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALTYPETBLUncheckedUpdateInput
    _$APPROVALTYPETBLUncheckedUpdateInputFromJson(Map<String, dynamic> json) =>
        APPROVALTYPETBLUncheckedUpdateInput(
          type: json['TYPE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['TYPE'] as Map<String, dynamic>),
          content: json['CONTENT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CONTENT'] as Map<String, dynamic>),
          contentBak: json['CONTENT_BAK'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CONTENT_BAK'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALTYPETBLUncheckedUpdateInputToJson(
    APPROVALTYPETBLUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('TYPE', instance.type?.toJson());
  writeNotNull('CONTENT', instance.content?.toJson());
  writeNotNull('CONTENT_BAK', instance.contentBak?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALTYPETBLCreateManyInput _$APPROVALTYPETBLCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    APPROVALTYPETBLCreateManyInput(
      type: json['TYPE'] as String,
      content: json['CONTENT'] as String?,
      contentBak: json['CONTENT_BAK'] as String?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$APPROVALTYPETBLCreateManyInputToJson(
    APPROVALTYPETBLCreateManyInput instance) {
  final val = <String, dynamic>{
    'TYPE': instance.type,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CONTENT', instance.content);
  writeNotNull('CONTENT_BAK', instance.contentBak);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

APPROVALTYPETBLUpdateManyMutationInput
    _$APPROVALTYPETBLUpdateManyMutationInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALTYPETBLUpdateManyMutationInput(
          type: json['TYPE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['TYPE'] as Map<String, dynamic>),
          content: json['CONTENT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CONTENT'] as Map<String, dynamic>),
          contentBak: json['CONTENT_BAK'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CONTENT_BAK'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALTYPETBLUpdateManyMutationInputToJson(
    APPROVALTYPETBLUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('TYPE', instance.type?.toJson());
  writeNotNull('CONTENT', instance.content?.toJson());
  writeNotNull('CONTENT_BAK', instance.contentBak?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALTYPETBLUncheckedUpdateManyInput
    _$APPROVALTYPETBLUncheckedUpdateManyInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALTYPETBLUncheckedUpdateManyInput(
          type: json['TYPE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['TYPE'] as Map<String, dynamic>),
          content: json['CONTENT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CONTENT'] as Map<String, dynamic>),
          contentBak: json['CONTENT_BAK'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CONTENT_BAK'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALTYPETBLUncheckedUpdateManyInputToJson(
    APPROVALTYPETBLUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('TYPE', instance.type?.toJson());
  writeNotNull('CONTENT', instance.content?.toJson());
  writeNotNull('CONTENT_BAK', instance.contentBak?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALUSERTBLCreateInput _$APPROVALUSERTBLCreateInputFromJson(
        Map<String, dynamic> json) =>
    APPROVALUSERTBLCreateInput(
      approvalId: json['APPROVAL_ID'] as String,
      approvalUsrId: json['APPROVAL_USR_ID'] as String,
      approvalUsrGradeCd: json['APPROVAL_USR_GRADE_CD'] as String?,
      approvalUsrType: json['APPROVAL_USR_TYPE'] as String?,
      approvalUsrSort: json['APPROVAL_USR_SORT'] as int,
      approvalProcUserYn: json['APPROVAL_PROC_USER_YN'] as String?,
      approvalProcYn: json['APPROVAL_PROC_YN'] as String?,
      approvalProcDate: _$JsonConverterFromJson<String, DateTime>(
          json['APPROVAL_PROC_DATE'], const DateTimeJsonConverter().fromJson),
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$APPROVALUSERTBLCreateInputToJson(
    APPROVALUSERTBLCreateInput instance) {
  final val = <String, dynamic>{
    'APPROVAL_ID': instance.approvalId,
    'APPROVAL_USR_ID': instance.approvalUsrId,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_USR_GRADE_CD', instance.approvalUsrGradeCd);
  writeNotNull('APPROVAL_USR_TYPE', instance.approvalUsrType);
  val['APPROVAL_USR_SORT'] = instance.approvalUsrSort;
  writeNotNull('APPROVAL_PROC_USER_YN', instance.approvalProcUserYn);
  writeNotNull('APPROVAL_PROC_YN', instance.approvalProcYn);
  writeNotNull(
      'APPROVAL_PROC_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.approvalProcDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

APPROVALUSERTBLUncheckedCreateInput
    _$APPROVALUSERTBLUncheckedCreateInputFromJson(Map<String, dynamic> json) =>
        APPROVALUSERTBLUncheckedCreateInput(
          approvalId: json['APPROVAL_ID'] as String,
          approvalUsrId: json['APPROVAL_USR_ID'] as String,
          approvalUsrGradeCd: json['APPROVAL_USR_GRADE_CD'] as String?,
          approvalUsrType: json['APPROVAL_USR_TYPE'] as String?,
          approvalUsrSort: json['APPROVAL_USR_SORT'] as int,
          approvalProcUserYn: json['APPROVAL_PROC_USER_YN'] as String?,
          approvalProcYn: json['APPROVAL_PROC_YN'] as String?,
          approvalProcDate: _$JsonConverterFromJson<String, DateTime>(
              json['APPROVAL_PROC_DATE'],
              const DateTimeJsonConverter().fromJson),
          regDate: _$JsonConverterFromJson<String, DateTime>(
              json['REG_DATE'], const DateTimeJsonConverter().fromJson),
          updDate: _$JsonConverterFromJson<String, DateTime>(
              json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
          delYn: json['DEL_YN'] as String?,
        );

Map<String, dynamic> _$APPROVALUSERTBLUncheckedCreateInputToJson(
    APPROVALUSERTBLUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'APPROVAL_ID': instance.approvalId,
    'APPROVAL_USR_ID': instance.approvalUsrId,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_USR_GRADE_CD', instance.approvalUsrGradeCd);
  writeNotNull('APPROVAL_USR_TYPE', instance.approvalUsrType);
  val['APPROVAL_USR_SORT'] = instance.approvalUsrSort;
  writeNotNull('APPROVAL_PROC_USER_YN', instance.approvalProcUserYn);
  writeNotNull('APPROVAL_PROC_YN', instance.approvalProcYn);
  writeNotNull(
      'APPROVAL_PROC_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.approvalProcDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

APPROVALUSERTBLUpdateInput _$APPROVALUSERTBLUpdateInputFromJson(
        Map<String, dynamic> json) =>
    APPROVALUSERTBLUpdateInput(
      approvalId: json['APPROVAL_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['APPROVAL_ID'] as Map<String, dynamic>),
      approvalUsrId: json['APPROVAL_USR_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['APPROVAL_USR_ID'] as Map<String, dynamic>),
      approvalUsrGradeCd: json['APPROVAL_USR_GRADE_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['APPROVAL_USR_GRADE_CD'] as Map<String, dynamic>),
      approvalUsrType: json['APPROVAL_USR_TYPE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['APPROVAL_USR_TYPE'] as Map<String, dynamic>),
      approvalUsrSort: json['APPROVAL_USR_SORT'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['APPROVAL_USR_SORT'] as Map<String, dynamic>),
      approvalProcUserYn: json['APPROVAL_PROC_USER_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['APPROVAL_PROC_USER_YN'] as Map<String, dynamic>),
      approvalProcYn: json['APPROVAL_PROC_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['APPROVAL_PROC_YN'] as Map<String, dynamic>),
      approvalProcDate: json['APPROVAL_PROC_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['APPROVAL_PROC_DATE'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : NullableDateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$APPROVALUSERTBLUpdateInputToJson(
    APPROVALUSERTBLUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_ID', instance.approvalId?.toJson());
  writeNotNull('APPROVAL_USR_ID', instance.approvalUsrId?.toJson());
  writeNotNull('APPROVAL_USR_GRADE_CD', instance.approvalUsrGradeCd?.toJson());
  writeNotNull('APPROVAL_USR_TYPE', instance.approvalUsrType?.toJson());
  writeNotNull('APPROVAL_USR_SORT', instance.approvalUsrSort?.toJson());
  writeNotNull('APPROVAL_PROC_USER_YN', instance.approvalProcUserYn?.toJson());
  writeNotNull('APPROVAL_PROC_YN', instance.approvalProcYn?.toJson());
  writeNotNull('APPROVAL_PROC_DATE', instance.approvalProcDate?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALUSERTBLUncheckedUpdateInput
    _$APPROVALUSERTBLUncheckedUpdateInputFromJson(Map<String, dynamic> json) =>
        APPROVALUSERTBLUncheckedUpdateInput(
          approvalId: json['APPROVAL_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_ID'] as Map<String, dynamic>),
          approvalUsrId: json['APPROVAL_USR_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_USR_ID'] as Map<String, dynamic>),
          approvalUsrGradeCd: json['APPROVAL_USR_GRADE_CD'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_USR_GRADE_CD'] as Map<String, dynamic>),
          approvalUsrType: json['APPROVAL_USR_TYPE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_USR_TYPE'] as Map<String, dynamic>),
          approvalUsrSort: json['APPROVAL_USR_SORT'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_USR_SORT'] as Map<String, dynamic>),
          approvalProcUserYn: json['APPROVAL_PROC_USER_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_PROC_USER_YN'] as Map<String, dynamic>),
          approvalProcYn: json['APPROVAL_PROC_YN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_PROC_YN'] as Map<String, dynamic>),
          approvalProcDate: json['APPROVAL_PROC_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_PROC_DATE'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : NullableDateTimeFieldUpdateOperationsInput.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALUSERTBLUncheckedUpdateInputToJson(
    APPROVALUSERTBLUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_ID', instance.approvalId?.toJson());
  writeNotNull('APPROVAL_USR_ID', instance.approvalUsrId?.toJson());
  writeNotNull('APPROVAL_USR_GRADE_CD', instance.approvalUsrGradeCd?.toJson());
  writeNotNull('APPROVAL_USR_TYPE', instance.approvalUsrType?.toJson());
  writeNotNull('APPROVAL_USR_SORT', instance.approvalUsrSort?.toJson());
  writeNotNull('APPROVAL_PROC_USER_YN', instance.approvalProcUserYn?.toJson());
  writeNotNull('APPROVAL_PROC_YN', instance.approvalProcYn?.toJson());
  writeNotNull('APPROVAL_PROC_DATE', instance.approvalProcDate?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALUSERTBLCreateManyInput _$APPROVALUSERTBLCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    APPROVALUSERTBLCreateManyInput(
      approvalId: json['APPROVAL_ID'] as String,
      approvalUsrId: json['APPROVAL_USR_ID'] as String,
      approvalUsrGradeCd: json['APPROVAL_USR_GRADE_CD'] as String?,
      approvalUsrType: json['APPROVAL_USR_TYPE'] as String?,
      approvalUsrSort: json['APPROVAL_USR_SORT'] as int,
      approvalProcUserYn: json['APPROVAL_PROC_USER_YN'] as String?,
      approvalProcYn: json['APPROVAL_PROC_YN'] as String?,
      approvalProcDate: _$JsonConverterFromJson<String, DateTime>(
          json['APPROVAL_PROC_DATE'], const DateTimeJsonConverter().fromJson),
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$APPROVALUSERTBLCreateManyInputToJson(
    APPROVALUSERTBLCreateManyInput instance) {
  final val = <String, dynamic>{
    'APPROVAL_ID': instance.approvalId,
    'APPROVAL_USR_ID': instance.approvalUsrId,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_USR_GRADE_CD', instance.approvalUsrGradeCd);
  writeNotNull('APPROVAL_USR_TYPE', instance.approvalUsrType);
  val['APPROVAL_USR_SORT'] = instance.approvalUsrSort;
  writeNotNull('APPROVAL_PROC_USER_YN', instance.approvalProcUserYn);
  writeNotNull('APPROVAL_PROC_YN', instance.approvalProcYn);
  writeNotNull(
      'APPROVAL_PROC_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.approvalProcDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

APPROVALUSERTBLUpdateManyMutationInput
    _$APPROVALUSERTBLUpdateManyMutationInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALUSERTBLUpdateManyMutationInput(
          approvalId: json['APPROVAL_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_ID'] as Map<String, dynamic>),
          approvalUsrId: json['APPROVAL_USR_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_USR_ID'] as Map<String, dynamic>),
          approvalUsrGradeCd: json['APPROVAL_USR_GRADE_CD'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_USR_GRADE_CD'] as Map<String, dynamic>),
          approvalUsrType: json['APPROVAL_USR_TYPE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_USR_TYPE'] as Map<String, dynamic>),
          approvalUsrSort: json['APPROVAL_USR_SORT'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_USR_SORT'] as Map<String, dynamic>),
          approvalProcUserYn: json['APPROVAL_PROC_USER_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_PROC_USER_YN'] as Map<String, dynamic>),
          approvalProcYn: json['APPROVAL_PROC_YN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_PROC_YN'] as Map<String, dynamic>),
          approvalProcDate: json['APPROVAL_PROC_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_PROC_DATE'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : NullableDateTimeFieldUpdateOperationsInput.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALUSERTBLUpdateManyMutationInputToJson(
    APPROVALUSERTBLUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_ID', instance.approvalId?.toJson());
  writeNotNull('APPROVAL_USR_ID', instance.approvalUsrId?.toJson());
  writeNotNull('APPROVAL_USR_GRADE_CD', instance.approvalUsrGradeCd?.toJson());
  writeNotNull('APPROVAL_USR_TYPE', instance.approvalUsrType?.toJson());
  writeNotNull('APPROVAL_USR_SORT', instance.approvalUsrSort?.toJson());
  writeNotNull('APPROVAL_PROC_USER_YN', instance.approvalProcUserYn?.toJson());
  writeNotNull('APPROVAL_PROC_YN', instance.approvalProcYn?.toJson());
  writeNotNull('APPROVAL_PROC_DATE', instance.approvalProcDate?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

APPROVALUSERTBLUncheckedUpdateManyInput
    _$APPROVALUSERTBLUncheckedUpdateManyInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALUSERTBLUncheckedUpdateManyInput(
          approvalId: json['APPROVAL_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_ID'] as Map<String, dynamic>),
          approvalUsrId: json['APPROVAL_USR_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_USR_ID'] as Map<String, dynamic>),
          approvalUsrGradeCd: json['APPROVAL_USR_GRADE_CD'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_USR_GRADE_CD'] as Map<String, dynamic>),
          approvalUsrType: json['APPROVAL_USR_TYPE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_USR_TYPE'] as Map<String, dynamic>),
          approvalUsrSort: json['APPROVAL_USR_SORT'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_USR_SORT'] as Map<String, dynamic>),
          approvalProcUserYn: json['APPROVAL_PROC_USER_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_PROC_USER_YN'] as Map<String, dynamic>),
          approvalProcYn: json['APPROVAL_PROC_YN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_PROC_YN'] as Map<String, dynamic>),
          approvalProcDate: json['APPROVAL_PROC_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['APPROVAL_PROC_DATE'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : NullableDateTimeFieldUpdateOperationsInput.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$APPROVALUSERTBLUncheckedUpdateManyInputToJson(
    APPROVALUSERTBLUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_ID', instance.approvalId?.toJson());
  writeNotNull('APPROVAL_USR_ID', instance.approvalUsrId?.toJson());
  writeNotNull('APPROVAL_USR_GRADE_CD', instance.approvalUsrGradeCd?.toJson());
  writeNotNull('APPROVAL_USR_TYPE', instance.approvalUsrType?.toJson());
  writeNotNull('APPROVAL_USR_SORT', instance.approvalUsrSort?.toJson());
  writeNotNull('APPROVAL_PROC_USER_YN', instance.approvalProcUserYn?.toJson());
  writeNotNull('APPROVAL_PROC_YN', instance.approvalProcYn?.toJson());
  writeNotNull('APPROVAL_PROC_DATE', instance.approvalProcDate?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

BOOKASSETTBLCreateInput _$BOOKASSETTBLCreateInputFromJson(
        Map<String, dynamic> json) =>
    BOOKASSETTBLCreateInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      assetNo: json['ASSET_NO'] as String,
      bookNm: json['BOOK_NM'] as String?,
      cnt: json['CNT'] as int?,
      publisher: json['PUBLISHER'] as String?,
      amount: json['AMOUNT'] as int?,
      buyDate: json['BUY_DATE'] as String?,
      mngDept: json['MNG_DEPT'] as String?,
      rentYn: json['RENT_YN'] as String?,
      rentUser: json['RENT_USER'] as String?,
      remarks: json['REMARKS'] as String?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$BOOKASSETTBLCreateInputToJson(
    BOOKASSETTBLCreateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['ASSET_NO'] = instance.assetNo;
  writeNotNull('BOOK_NM', instance.bookNm);
  writeNotNull('CNT', instance.cnt);
  writeNotNull('PUBLISHER', instance.publisher);
  writeNotNull('AMOUNT', instance.amount);
  writeNotNull('BUY_DATE', instance.buyDate);
  writeNotNull('MNG_DEPT', instance.mngDept);
  writeNotNull('RENT_YN', instance.rentYn);
  writeNotNull('RENT_USER', instance.rentUser);
  writeNotNull('REMARKS', instance.remarks);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

BOOKASSETTBLUncheckedCreateInput _$BOOKASSETTBLUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    BOOKASSETTBLUncheckedCreateInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      assetNo: json['ASSET_NO'] as String,
      bookNm: json['BOOK_NM'] as String?,
      cnt: json['CNT'] as int?,
      publisher: json['PUBLISHER'] as String?,
      amount: json['AMOUNT'] as int?,
      buyDate: json['BUY_DATE'] as String?,
      mngDept: json['MNG_DEPT'] as String?,
      rentYn: json['RENT_YN'] as String?,
      rentUser: json['RENT_USER'] as String?,
      remarks: json['REMARKS'] as String?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$BOOKASSETTBLUncheckedCreateInputToJson(
    BOOKASSETTBLUncheckedCreateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['ASSET_NO'] = instance.assetNo;
  writeNotNull('BOOK_NM', instance.bookNm);
  writeNotNull('CNT', instance.cnt);
  writeNotNull('PUBLISHER', instance.publisher);
  writeNotNull('AMOUNT', instance.amount);
  writeNotNull('BUY_DATE', instance.buyDate);
  writeNotNull('MNG_DEPT', instance.mngDept);
  writeNotNull('RENT_YN', instance.rentYn);
  writeNotNull('RENT_USER', instance.rentUser);
  writeNotNull('REMARKS', instance.remarks);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

BOOKASSETTBLUpdateInput _$BOOKASSETTBLUpdateInputFromJson(
        Map<String, dynamic> json) =>
    BOOKASSETTBLUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      assetNo: json['ASSET_NO'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['ASSET_NO'] as Map<String, dynamic>),
      bookNm: json['BOOK_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['BOOK_NM'] as Map<String, dynamic>),
      cnt: json['CNT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['CNT'] as Map<String, dynamic>),
      publisher: json['PUBLISHER'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['PUBLISHER'] as Map<String, dynamic>),
      amount: json['AMOUNT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['AMOUNT'] as Map<String, dynamic>),
      buyDate: json['BUY_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['BUY_DATE'] as Map<String, dynamic>),
      mngDept: json['MNG_DEPT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MNG_DEPT'] as Map<String, dynamic>),
      rentYn: json['RENT_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['RENT_YN'] as Map<String, dynamic>),
      rentUser: json['RENT_USER'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['RENT_USER'] as Map<String, dynamic>),
      remarks: json['REMARKS'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REMARKS'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : NullableDateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$BOOKASSETTBLUpdateInputToJson(
    BOOKASSETTBLUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('BOOK_NM', instance.bookNm?.toJson());
  writeNotNull('CNT', instance.cnt?.toJson());
  writeNotNull('PUBLISHER', instance.publisher?.toJson());
  writeNotNull('AMOUNT', instance.amount?.toJson());
  writeNotNull('BUY_DATE', instance.buyDate?.toJson());
  writeNotNull('MNG_DEPT', instance.mngDept?.toJson());
  writeNotNull('RENT_YN', instance.rentYn?.toJson());
  writeNotNull('RENT_USER', instance.rentUser?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

BOOKASSETTBLUncheckedUpdateInput _$BOOKASSETTBLUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    BOOKASSETTBLUncheckedUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      assetNo: json['ASSET_NO'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['ASSET_NO'] as Map<String, dynamic>),
      bookNm: json['BOOK_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['BOOK_NM'] as Map<String, dynamic>),
      cnt: json['CNT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['CNT'] as Map<String, dynamic>),
      publisher: json['PUBLISHER'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['PUBLISHER'] as Map<String, dynamic>),
      amount: json['AMOUNT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['AMOUNT'] as Map<String, dynamic>),
      buyDate: json['BUY_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['BUY_DATE'] as Map<String, dynamic>),
      mngDept: json['MNG_DEPT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MNG_DEPT'] as Map<String, dynamic>),
      rentYn: json['RENT_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['RENT_YN'] as Map<String, dynamic>),
      rentUser: json['RENT_USER'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['RENT_USER'] as Map<String, dynamic>),
      remarks: json['REMARKS'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REMARKS'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : NullableDateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$BOOKASSETTBLUncheckedUpdateInputToJson(
    BOOKASSETTBLUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('BOOK_NM', instance.bookNm?.toJson());
  writeNotNull('CNT', instance.cnt?.toJson());
  writeNotNull('PUBLISHER', instance.publisher?.toJson());
  writeNotNull('AMOUNT', instance.amount?.toJson());
  writeNotNull('BUY_DATE', instance.buyDate?.toJson());
  writeNotNull('MNG_DEPT', instance.mngDept?.toJson());
  writeNotNull('RENT_YN', instance.rentYn?.toJson());
  writeNotNull('RENT_USER', instance.rentUser?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

BOOKASSETTBLCreateManyInput _$BOOKASSETTBLCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    BOOKASSETTBLCreateManyInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      assetNo: json['ASSET_NO'] as String,
      bookNm: json['BOOK_NM'] as String?,
      cnt: json['CNT'] as int?,
      publisher: json['PUBLISHER'] as String?,
      amount: json['AMOUNT'] as int?,
      buyDate: json['BUY_DATE'] as String?,
      mngDept: json['MNG_DEPT'] as String?,
      rentYn: json['RENT_YN'] as String?,
      rentUser: json['RENT_USER'] as String?,
      remarks: json['REMARKS'] as String?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$BOOKASSETTBLCreateManyInputToJson(
    BOOKASSETTBLCreateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['ASSET_NO'] = instance.assetNo;
  writeNotNull('BOOK_NM', instance.bookNm);
  writeNotNull('CNT', instance.cnt);
  writeNotNull('PUBLISHER', instance.publisher);
  writeNotNull('AMOUNT', instance.amount);
  writeNotNull('BUY_DATE', instance.buyDate);
  writeNotNull('MNG_DEPT', instance.mngDept);
  writeNotNull('RENT_YN', instance.rentYn);
  writeNotNull('RENT_USER', instance.rentUser);
  writeNotNull('REMARKS', instance.remarks);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

BOOKASSETTBLUpdateManyMutationInput
    _$BOOKASSETTBLUpdateManyMutationInputFromJson(Map<String, dynamic> json) =>
        BOOKASSETTBLUpdateManyMutationInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          assetNo: json['ASSET_NO'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['ASSET_NO'] as Map<String, dynamic>),
          bookNm: json['BOOK_NM'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['BOOK_NM'] as Map<String, dynamic>),
          cnt: json['CNT'] == null
              ? null
              : NullableIntFieldUpdateOperationsInput.fromJson(
                  json['CNT'] as Map<String, dynamic>),
          publisher: json['PUBLISHER'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['PUBLISHER'] as Map<String, dynamic>),
          amount: json['AMOUNT'] == null
              ? null
              : NullableIntFieldUpdateOperationsInput.fromJson(
                  json['AMOUNT'] as Map<String, dynamic>),
          buyDate: json['BUY_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['BUY_DATE'] as Map<String, dynamic>),
          mngDept: json['MNG_DEPT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['MNG_DEPT'] as Map<String, dynamic>),
          rentYn: json['RENT_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['RENT_YN'] as Map<String, dynamic>),
          rentUser: json['RENT_USER'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['RENT_USER'] as Map<String, dynamic>),
          remarks: json['REMARKS'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REMARKS'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : NullableDateTimeFieldUpdateOperationsInput.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$BOOKASSETTBLUpdateManyMutationInputToJson(
    BOOKASSETTBLUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('BOOK_NM', instance.bookNm?.toJson());
  writeNotNull('CNT', instance.cnt?.toJson());
  writeNotNull('PUBLISHER', instance.publisher?.toJson());
  writeNotNull('AMOUNT', instance.amount?.toJson());
  writeNotNull('BUY_DATE', instance.buyDate?.toJson());
  writeNotNull('MNG_DEPT', instance.mngDept?.toJson());
  writeNotNull('RENT_YN', instance.rentYn?.toJson());
  writeNotNull('RENT_USER', instance.rentUser?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

BOOKASSETTBLUncheckedUpdateManyInput
    _$BOOKASSETTBLUncheckedUpdateManyInputFromJson(Map<String, dynamic> json) =>
        BOOKASSETTBLUncheckedUpdateManyInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          assetNo: json['ASSET_NO'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['ASSET_NO'] as Map<String, dynamic>),
          bookNm: json['BOOK_NM'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['BOOK_NM'] as Map<String, dynamic>),
          cnt: json['CNT'] == null
              ? null
              : NullableIntFieldUpdateOperationsInput.fromJson(
                  json['CNT'] as Map<String, dynamic>),
          publisher: json['PUBLISHER'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['PUBLISHER'] as Map<String, dynamic>),
          amount: json['AMOUNT'] == null
              ? null
              : NullableIntFieldUpdateOperationsInput.fromJson(
                  json['AMOUNT'] as Map<String, dynamic>),
          buyDate: json['BUY_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['BUY_DATE'] as Map<String, dynamic>),
          mngDept: json['MNG_DEPT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['MNG_DEPT'] as Map<String, dynamic>),
          rentYn: json['RENT_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['RENT_YN'] as Map<String, dynamic>),
          rentUser: json['RENT_USER'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['RENT_USER'] as Map<String, dynamic>),
          remarks: json['REMARKS'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REMARKS'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : NullableDateTimeFieldUpdateOperationsInput.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$BOOKASSETTBLUncheckedUpdateManyInputToJson(
    BOOKASSETTBLUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('BOOK_NM', instance.bookNm?.toJson());
  writeNotNull('CNT', instance.cnt?.toJson());
  writeNotNull('PUBLISHER', instance.publisher?.toJson());
  writeNotNull('AMOUNT', instance.amount?.toJson());
  writeNotNull('BUY_DATE', instance.buyDate?.toJson());
  writeNotNull('MNG_DEPT', instance.mngDept?.toJson());
  writeNotNull('RENT_YN', instance.rentYn?.toJson());
  writeNotNull('RENT_USER', instance.rentUser?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

CARASSETINSURTBLCreateInput _$CARASSETINSURTBLCreateInputFromJson(
        Map<String, dynamic> json) =>
    CARASSETINSURTBLCreateInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      mseq: BigInt.parse(json['MSEQ'] as String),
      guarantee: json['GUARANTEE'] as String,
    );

Map<String, dynamic> _$CARASSETINSURTBLCreateInputToJson(
    CARASSETINSURTBLCreateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['MSEQ'] = instance.mseq.toString();
  val['GUARANTEE'] = instance.guarantee;
  return val;
}

CARASSETINSURTBLUncheckedCreateInput
    _$CARASSETINSURTBLUncheckedCreateInputFromJson(Map<String, dynamic> json) =>
        CARASSETINSURTBLUncheckedCreateInput(
          seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
          mseq: BigInt.parse(json['MSEQ'] as String),
          guarantee: json['GUARANTEE'] as String,
        );

Map<String, dynamic> _$CARASSETINSURTBLUncheckedCreateInputToJson(
    CARASSETINSURTBLUncheckedCreateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['MSEQ'] = instance.mseq.toString();
  val['GUARANTEE'] = instance.guarantee;
  return val;
}

CARASSETINSURTBLUpdateInput _$CARASSETINSURTBLUpdateInputFromJson(
        Map<String, dynamic> json) =>
    CARASSETINSURTBLUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      mseq: json['MSEQ'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['MSEQ'] as Map<String, dynamic>),
      guarantee: json['GUARANTEE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['GUARANTEE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$CARASSETINSURTBLUpdateInputToJson(
    CARASSETINSURTBLUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('GUARANTEE', instance.guarantee?.toJson());
  return val;
}

CARASSETINSURTBLUncheckedUpdateInput
    _$CARASSETINSURTBLUncheckedUpdateInputFromJson(Map<String, dynamic> json) =>
        CARASSETINSURTBLUncheckedUpdateInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          mseq: json['MSEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['MSEQ'] as Map<String, dynamic>),
          guarantee: json['GUARANTEE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['GUARANTEE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$CARASSETINSURTBLUncheckedUpdateInputToJson(
    CARASSETINSURTBLUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('GUARANTEE', instance.guarantee?.toJson());
  return val;
}

CARASSETINSURTBLCreateManyInput _$CARASSETINSURTBLCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    CARASSETINSURTBLCreateManyInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      mseq: BigInt.parse(json['MSEQ'] as String),
      guarantee: json['GUARANTEE'] as String,
    );

Map<String, dynamic> _$CARASSETINSURTBLCreateManyInputToJson(
    CARASSETINSURTBLCreateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['MSEQ'] = instance.mseq.toString();
  val['GUARANTEE'] = instance.guarantee;
  return val;
}

CARASSETINSURTBLUpdateManyMutationInput
    _$CARASSETINSURTBLUpdateManyMutationInputFromJson(
            Map<String, dynamic> json) =>
        CARASSETINSURTBLUpdateManyMutationInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          mseq: json['MSEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['MSEQ'] as Map<String, dynamic>),
          guarantee: json['GUARANTEE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['GUARANTEE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$CARASSETINSURTBLUpdateManyMutationInputToJson(
    CARASSETINSURTBLUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('GUARANTEE', instance.guarantee?.toJson());
  return val;
}

CARASSETINSURTBLUncheckedUpdateManyInput
    _$CARASSETINSURTBLUncheckedUpdateManyInputFromJson(
            Map<String, dynamic> json) =>
        CARASSETINSURTBLUncheckedUpdateManyInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          mseq: json['MSEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['MSEQ'] as Map<String, dynamic>),
          guarantee: json['GUARANTEE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['GUARANTEE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$CARASSETINSURTBLUncheckedUpdateManyInputToJson(
    CARASSETINSURTBLUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('GUARANTEE', instance.guarantee?.toJson());
  return val;
}

CARASSETTBLCreateInput _$CARASSETTBLCreateInputFromJson(
        Map<String, dynamic> json) =>
    CARASSETTBLCreateInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      assetNo: json['ASSET_NO'] as String,
      modelNo: json['MODEL_NO'] as String?,
      carNo: json['CAR_NO'] as String?,
      owner: json['OWNER'] as String?,
      ownerType: json['OWNER_TYPE'] as String?,
      amount: json['AMOUNT'] as int?,
      buyDate: json['BUY_DATE'] as String?,
      seller: json['SELLER'] as String?,
      remarks: json['REMARKS'] as String?,
      mngrNm: json['MNGR_NM'] as String?,
      fuel: json['FUEL'] as String?,
      manuDt: json['MANU_DT'] as String?,
      effic: json['EFFIC'] as String?,
      insur: json['INSUR'] as String?,
      insurMngr: json['INSUR_MNGR'] as String?,
      emgTel: json['EMG_TEL'] as String?,
      storeNm: json['STORE_NM'] as String?,
      storeTel: json['STORE_TEL'] as String?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$CARASSETTBLCreateInputToJson(
    CARASSETTBLCreateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['ASSET_NO'] = instance.assetNo;
  writeNotNull('MODEL_NO', instance.modelNo);
  writeNotNull('CAR_NO', instance.carNo);
  writeNotNull('OWNER', instance.owner);
  writeNotNull('OWNER_TYPE', instance.ownerType);
  writeNotNull('AMOUNT', instance.amount);
  writeNotNull('BUY_DATE', instance.buyDate);
  writeNotNull('SELLER', instance.seller);
  writeNotNull('REMARKS', instance.remarks);
  writeNotNull('MNGR_NM', instance.mngrNm);
  writeNotNull('FUEL', instance.fuel);
  writeNotNull('MANU_DT', instance.manuDt);
  writeNotNull('EFFIC', instance.effic);
  writeNotNull('INSUR', instance.insur);
  writeNotNull('INSUR_MNGR', instance.insurMngr);
  writeNotNull('EMG_TEL', instance.emgTel);
  writeNotNull('STORE_NM', instance.storeNm);
  writeNotNull('STORE_TEL', instance.storeTel);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

CARASSETTBLUncheckedCreateInput _$CARASSETTBLUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    CARASSETTBLUncheckedCreateInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      assetNo: json['ASSET_NO'] as String,
      modelNo: json['MODEL_NO'] as String?,
      carNo: json['CAR_NO'] as String?,
      owner: json['OWNER'] as String?,
      ownerType: json['OWNER_TYPE'] as String?,
      amount: json['AMOUNT'] as int?,
      buyDate: json['BUY_DATE'] as String?,
      seller: json['SELLER'] as String?,
      remarks: json['REMARKS'] as String?,
      mngrNm: json['MNGR_NM'] as String?,
      fuel: json['FUEL'] as String?,
      manuDt: json['MANU_DT'] as String?,
      effic: json['EFFIC'] as String?,
      insur: json['INSUR'] as String?,
      insurMngr: json['INSUR_MNGR'] as String?,
      emgTel: json['EMG_TEL'] as String?,
      storeNm: json['STORE_NM'] as String?,
      storeTel: json['STORE_TEL'] as String?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$CARASSETTBLUncheckedCreateInputToJson(
    CARASSETTBLUncheckedCreateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['ASSET_NO'] = instance.assetNo;
  writeNotNull('MODEL_NO', instance.modelNo);
  writeNotNull('CAR_NO', instance.carNo);
  writeNotNull('OWNER', instance.owner);
  writeNotNull('OWNER_TYPE', instance.ownerType);
  writeNotNull('AMOUNT', instance.amount);
  writeNotNull('BUY_DATE', instance.buyDate);
  writeNotNull('SELLER', instance.seller);
  writeNotNull('REMARKS', instance.remarks);
  writeNotNull('MNGR_NM', instance.mngrNm);
  writeNotNull('FUEL', instance.fuel);
  writeNotNull('MANU_DT', instance.manuDt);
  writeNotNull('EFFIC', instance.effic);
  writeNotNull('INSUR', instance.insur);
  writeNotNull('INSUR_MNGR', instance.insurMngr);
  writeNotNull('EMG_TEL', instance.emgTel);
  writeNotNull('STORE_NM', instance.storeNm);
  writeNotNull('STORE_TEL', instance.storeTel);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

CARASSETTBLUpdateInput _$CARASSETTBLUpdateInputFromJson(
        Map<String, dynamic> json) =>
    CARASSETTBLUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      assetNo: json['ASSET_NO'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['ASSET_NO'] as Map<String, dynamic>),
      modelNo: json['MODEL_NO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MODEL_NO'] as Map<String, dynamic>),
      carNo: json['CAR_NO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CAR_NO'] as Map<String, dynamic>),
      owner: json['OWNER'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['OWNER'] as Map<String, dynamic>),
      ownerType: json['OWNER_TYPE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['OWNER_TYPE'] as Map<String, dynamic>),
      amount: json['AMOUNT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['AMOUNT'] as Map<String, dynamic>),
      buyDate: json['BUY_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['BUY_DATE'] as Map<String, dynamic>),
      seller: json['SELLER'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SELLER'] as Map<String, dynamic>),
      remarks: json['REMARKS'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REMARKS'] as Map<String, dynamic>),
      mngrNm: json['MNGR_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MNGR_NM'] as Map<String, dynamic>),
      fuel: json['FUEL'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FUEL'] as Map<String, dynamic>),
      manuDt: json['MANU_DT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MANU_DT'] as Map<String, dynamic>),
      effic: json['EFFIC'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EFFIC'] as Map<String, dynamic>),
      insur: json['INSUR'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['INSUR'] as Map<String, dynamic>),
      insurMngr: json['INSUR_MNGR'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['INSUR_MNGR'] as Map<String, dynamic>),
      emgTel: json['EMG_TEL'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EMG_TEL'] as Map<String, dynamic>),
      storeNm: json['STORE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['STORE_NM'] as Map<String, dynamic>),
      storeTel: json['STORE_TEL'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['STORE_TEL'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : NullableDateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$CARASSETTBLUpdateInputToJson(
    CARASSETTBLUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('MODEL_NO', instance.modelNo?.toJson());
  writeNotNull('CAR_NO', instance.carNo?.toJson());
  writeNotNull('OWNER', instance.owner?.toJson());
  writeNotNull('OWNER_TYPE', instance.ownerType?.toJson());
  writeNotNull('AMOUNT', instance.amount?.toJson());
  writeNotNull('BUY_DATE', instance.buyDate?.toJson());
  writeNotNull('SELLER', instance.seller?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('MNGR_NM', instance.mngrNm?.toJson());
  writeNotNull('FUEL', instance.fuel?.toJson());
  writeNotNull('MANU_DT', instance.manuDt?.toJson());
  writeNotNull('EFFIC', instance.effic?.toJson());
  writeNotNull('INSUR', instance.insur?.toJson());
  writeNotNull('INSUR_MNGR', instance.insurMngr?.toJson());
  writeNotNull('EMG_TEL', instance.emgTel?.toJson());
  writeNotNull('STORE_NM', instance.storeNm?.toJson());
  writeNotNull('STORE_TEL', instance.storeTel?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

CARASSETTBLUncheckedUpdateInput _$CARASSETTBLUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    CARASSETTBLUncheckedUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      assetNo: json['ASSET_NO'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['ASSET_NO'] as Map<String, dynamic>),
      modelNo: json['MODEL_NO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MODEL_NO'] as Map<String, dynamic>),
      carNo: json['CAR_NO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CAR_NO'] as Map<String, dynamic>),
      owner: json['OWNER'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['OWNER'] as Map<String, dynamic>),
      ownerType: json['OWNER_TYPE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['OWNER_TYPE'] as Map<String, dynamic>),
      amount: json['AMOUNT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['AMOUNT'] as Map<String, dynamic>),
      buyDate: json['BUY_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['BUY_DATE'] as Map<String, dynamic>),
      seller: json['SELLER'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SELLER'] as Map<String, dynamic>),
      remarks: json['REMARKS'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REMARKS'] as Map<String, dynamic>),
      mngrNm: json['MNGR_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MNGR_NM'] as Map<String, dynamic>),
      fuel: json['FUEL'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FUEL'] as Map<String, dynamic>),
      manuDt: json['MANU_DT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MANU_DT'] as Map<String, dynamic>),
      effic: json['EFFIC'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EFFIC'] as Map<String, dynamic>),
      insur: json['INSUR'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['INSUR'] as Map<String, dynamic>),
      insurMngr: json['INSUR_MNGR'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['INSUR_MNGR'] as Map<String, dynamic>),
      emgTel: json['EMG_TEL'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EMG_TEL'] as Map<String, dynamic>),
      storeNm: json['STORE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['STORE_NM'] as Map<String, dynamic>),
      storeTel: json['STORE_TEL'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['STORE_TEL'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : NullableDateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$CARASSETTBLUncheckedUpdateInputToJson(
    CARASSETTBLUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('MODEL_NO', instance.modelNo?.toJson());
  writeNotNull('CAR_NO', instance.carNo?.toJson());
  writeNotNull('OWNER', instance.owner?.toJson());
  writeNotNull('OWNER_TYPE', instance.ownerType?.toJson());
  writeNotNull('AMOUNT', instance.amount?.toJson());
  writeNotNull('BUY_DATE', instance.buyDate?.toJson());
  writeNotNull('SELLER', instance.seller?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('MNGR_NM', instance.mngrNm?.toJson());
  writeNotNull('FUEL', instance.fuel?.toJson());
  writeNotNull('MANU_DT', instance.manuDt?.toJson());
  writeNotNull('EFFIC', instance.effic?.toJson());
  writeNotNull('INSUR', instance.insur?.toJson());
  writeNotNull('INSUR_MNGR', instance.insurMngr?.toJson());
  writeNotNull('EMG_TEL', instance.emgTel?.toJson());
  writeNotNull('STORE_NM', instance.storeNm?.toJson());
  writeNotNull('STORE_TEL', instance.storeTel?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

CARASSETTBLCreateManyInput _$CARASSETTBLCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    CARASSETTBLCreateManyInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      assetNo: json['ASSET_NO'] as String,
      modelNo: json['MODEL_NO'] as String?,
      carNo: json['CAR_NO'] as String?,
      owner: json['OWNER'] as String?,
      ownerType: json['OWNER_TYPE'] as String?,
      amount: json['AMOUNT'] as int?,
      buyDate: json['BUY_DATE'] as String?,
      seller: json['SELLER'] as String?,
      remarks: json['REMARKS'] as String?,
      mngrNm: json['MNGR_NM'] as String?,
      fuel: json['FUEL'] as String?,
      manuDt: json['MANU_DT'] as String?,
      effic: json['EFFIC'] as String?,
      insur: json['INSUR'] as String?,
      insurMngr: json['INSUR_MNGR'] as String?,
      emgTel: json['EMG_TEL'] as String?,
      storeNm: json['STORE_NM'] as String?,
      storeTel: json['STORE_TEL'] as String?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$CARASSETTBLCreateManyInputToJson(
    CARASSETTBLCreateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['ASSET_NO'] = instance.assetNo;
  writeNotNull('MODEL_NO', instance.modelNo);
  writeNotNull('CAR_NO', instance.carNo);
  writeNotNull('OWNER', instance.owner);
  writeNotNull('OWNER_TYPE', instance.ownerType);
  writeNotNull('AMOUNT', instance.amount);
  writeNotNull('BUY_DATE', instance.buyDate);
  writeNotNull('SELLER', instance.seller);
  writeNotNull('REMARKS', instance.remarks);
  writeNotNull('MNGR_NM', instance.mngrNm);
  writeNotNull('FUEL', instance.fuel);
  writeNotNull('MANU_DT', instance.manuDt);
  writeNotNull('EFFIC', instance.effic);
  writeNotNull('INSUR', instance.insur);
  writeNotNull('INSUR_MNGR', instance.insurMngr);
  writeNotNull('EMG_TEL', instance.emgTel);
  writeNotNull('STORE_NM', instance.storeNm);
  writeNotNull('STORE_TEL', instance.storeTel);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

CARASSETTBLUpdateManyMutationInput _$CARASSETTBLUpdateManyMutationInputFromJson(
        Map<String, dynamic> json) =>
    CARASSETTBLUpdateManyMutationInput(
      seq: json['SEQ'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      assetNo: json['ASSET_NO'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['ASSET_NO'] as Map<String, dynamic>),
      modelNo: json['MODEL_NO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MODEL_NO'] as Map<String, dynamic>),
      carNo: json['CAR_NO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CAR_NO'] as Map<String, dynamic>),
      owner: json['OWNER'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['OWNER'] as Map<String, dynamic>),
      ownerType: json['OWNER_TYPE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['OWNER_TYPE'] as Map<String, dynamic>),
      amount: json['AMOUNT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['AMOUNT'] as Map<String, dynamic>),
      buyDate: json['BUY_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['BUY_DATE'] as Map<String, dynamic>),
      seller: json['SELLER'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SELLER'] as Map<String, dynamic>),
      remarks: json['REMARKS'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REMARKS'] as Map<String, dynamic>),
      mngrNm: json['MNGR_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MNGR_NM'] as Map<String, dynamic>),
      fuel: json['FUEL'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FUEL'] as Map<String, dynamic>),
      manuDt: json['MANU_DT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MANU_DT'] as Map<String, dynamic>),
      effic: json['EFFIC'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EFFIC'] as Map<String, dynamic>),
      insur: json['INSUR'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['INSUR'] as Map<String, dynamic>),
      insurMngr: json['INSUR_MNGR'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['INSUR_MNGR'] as Map<String, dynamic>),
      emgTel: json['EMG_TEL'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EMG_TEL'] as Map<String, dynamic>),
      storeNm: json['STORE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['STORE_NM'] as Map<String, dynamic>),
      storeTel: json['STORE_TEL'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['STORE_TEL'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : NullableDateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$CARASSETTBLUpdateManyMutationInputToJson(
    CARASSETTBLUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('MODEL_NO', instance.modelNo?.toJson());
  writeNotNull('CAR_NO', instance.carNo?.toJson());
  writeNotNull('OWNER', instance.owner?.toJson());
  writeNotNull('OWNER_TYPE', instance.ownerType?.toJson());
  writeNotNull('AMOUNT', instance.amount?.toJson());
  writeNotNull('BUY_DATE', instance.buyDate?.toJson());
  writeNotNull('SELLER', instance.seller?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('MNGR_NM', instance.mngrNm?.toJson());
  writeNotNull('FUEL', instance.fuel?.toJson());
  writeNotNull('MANU_DT', instance.manuDt?.toJson());
  writeNotNull('EFFIC', instance.effic?.toJson());
  writeNotNull('INSUR', instance.insur?.toJson());
  writeNotNull('INSUR_MNGR', instance.insurMngr?.toJson());
  writeNotNull('EMG_TEL', instance.emgTel?.toJson());
  writeNotNull('STORE_NM', instance.storeNm?.toJson());
  writeNotNull('STORE_TEL', instance.storeTel?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

CARASSETTBLUncheckedUpdateManyInput
    _$CARASSETTBLUncheckedUpdateManyInputFromJson(Map<String, dynamic> json) =>
        CARASSETTBLUncheckedUpdateManyInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          assetNo: json['ASSET_NO'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['ASSET_NO'] as Map<String, dynamic>),
          modelNo: json['MODEL_NO'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['MODEL_NO'] as Map<String, dynamic>),
          carNo: json['CAR_NO'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CAR_NO'] as Map<String, dynamic>),
          owner: json['OWNER'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['OWNER'] as Map<String, dynamic>),
          ownerType: json['OWNER_TYPE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['OWNER_TYPE'] as Map<String, dynamic>),
          amount: json['AMOUNT'] == null
              ? null
              : NullableIntFieldUpdateOperationsInput.fromJson(
                  json['AMOUNT'] as Map<String, dynamic>),
          buyDate: json['BUY_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['BUY_DATE'] as Map<String, dynamic>),
          seller: json['SELLER'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['SELLER'] as Map<String, dynamic>),
          remarks: json['REMARKS'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REMARKS'] as Map<String, dynamic>),
          mngrNm: json['MNGR_NM'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['MNGR_NM'] as Map<String, dynamic>),
          fuel: json['FUEL'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['FUEL'] as Map<String, dynamic>),
          manuDt: json['MANU_DT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['MANU_DT'] as Map<String, dynamic>),
          effic: json['EFFIC'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EFFIC'] as Map<String, dynamic>),
          insur: json['INSUR'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['INSUR'] as Map<String, dynamic>),
          insurMngr: json['INSUR_MNGR'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['INSUR_MNGR'] as Map<String, dynamic>),
          emgTel: json['EMG_TEL'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EMG_TEL'] as Map<String, dynamic>),
          storeNm: json['STORE_NM'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['STORE_NM'] as Map<String, dynamic>),
          storeTel: json['STORE_TEL'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['STORE_TEL'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : NullableDateTimeFieldUpdateOperationsInput.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$CARASSETTBLUncheckedUpdateManyInputToJson(
    CARASSETTBLUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('MODEL_NO', instance.modelNo?.toJson());
  writeNotNull('CAR_NO', instance.carNo?.toJson());
  writeNotNull('OWNER', instance.owner?.toJson());
  writeNotNull('OWNER_TYPE', instance.ownerType?.toJson());
  writeNotNull('AMOUNT', instance.amount?.toJson());
  writeNotNull('BUY_DATE', instance.buyDate?.toJson());
  writeNotNull('SELLER', instance.seller?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('MNGR_NM', instance.mngrNm?.toJson());
  writeNotNull('FUEL', instance.fuel?.toJson());
  writeNotNull('MANU_DT', instance.manuDt?.toJson());
  writeNotNull('EFFIC', instance.effic?.toJson());
  writeNotNull('INSUR', instance.insur?.toJson());
  writeNotNull('INSUR_MNGR', instance.insurMngr?.toJson());
  writeNotNull('EMG_TEL', instance.emgTel?.toJson());
  writeNotNull('STORE_NM', instance.storeNm?.toJson());
  writeNotNull('STORE_TEL', instance.storeTel?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

CARCHARGETBLCreateInput _$CARCHARGETBLCreateInputFromJson(
        Map<String, dynamic> json) =>
    CARCHARGETBLCreateInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      item: json['ITEM'] as String,
      charge: BigInt.parse(json['CHARGE'] as String),
      writerId: json['WRITER_ID'] as String,
      memo: json['MEMO'] as String,
      regDate: json['REG_DATE'] as String,
    );

Map<String, dynamic> _$CARCHARGETBLCreateInputToJson(
    CARCHARGETBLCreateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['ITEM'] = instance.item;
  val['CHARGE'] = instance.charge.toString();
  val['WRITER_ID'] = instance.writerId;
  val['MEMO'] = instance.memo;
  val['REG_DATE'] = instance.regDate;
  return val;
}

CARCHARGETBLUncheckedCreateInput _$CARCHARGETBLUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    CARCHARGETBLUncheckedCreateInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      item: json['ITEM'] as String,
      charge: BigInt.parse(json['CHARGE'] as String),
      writerId: json['WRITER_ID'] as String,
      memo: json['MEMO'] as String,
      regDate: json['REG_DATE'] as String,
    );

Map<String, dynamic> _$CARCHARGETBLUncheckedCreateInputToJson(
    CARCHARGETBLUncheckedCreateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['ITEM'] = instance.item;
  val['CHARGE'] = instance.charge.toString();
  val['WRITER_ID'] = instance.writerId;
  val['MEMO'] = instance.memo;
  val['REG_DATE'] = instance.regDate;
  return val;
}

CARCHARGETBLUpdateInput _$CARCHARGETBLUpdateInputFromJson(
        Map<String, dynamic> json) =>
    CARCHARGETBLUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      item: json['ITEM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['ITEM'] as Map<String, dynamic>),
      charge: json['CHARGE'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['CHARGE'] as Map<String, dynamic>),
      writerId: json['WRITER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['WRITER_ID'] as Map<String, dynamic>),
      memo: json['MEMO'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MEMO'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$CARCHARGETBLUpdateInputToJson(
    CARCHARGETBLUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ITEM', instance.item?.toJson());
  writeNotNull('CHARGE', instance.charge?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('MEMO', instance.memo?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

CARCHARGETBLUncheckedUpdateInput _$CARCHARGETBLUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    CARCHARGETBLUncheckedUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      item: json['ITEM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['ITEM'] as Map<String, dynamic>),
      charge: json['CHARGE'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['CHARGE'] as Map<String, dynamic>),
      writerId: json['WRITER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['WRITER_ID'] as Map<String, dynamic>),
      memo: json['MEMO'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MEMO'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$CARCHARGETBLUncheckedUpdateInputToJson(
    CARCHARGETBLUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ITEM', instance.item?.toJson());
  writeNotNull('CHARGE', instance.charge?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('MEMO', instance.memo?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

CARCHARGETBLCreateManyInput _$CARCHARGETBLCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    CARCHARGETBLCreateManyInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      item: json['ITEM'] as String,
      charge: BigInt.parse(json['CHARGE'] as String),
      writerId: json['WRITER_ID'] as String,
      memo: json['MEMO'] as String,
      regDate: json['REG_DATE'] as String,
    );

Map<String, dynamic> _$CARCHARGETBLCreateManyInputToJson(
    CARCHARGETBLCreateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['ITEM'] = instance.item;
  val['CHARGE'] = instance.charge.toString();
  val['WRITER_ID'] = instance.writerId;
  val['MEMO'] = instance.memo;
  val['REG_DATE'] = instance.regDate;
  return val;
}

CARCHARGETBLUpdateManyMutationInput
    _$CARCHARGETBLUpdateManyMutationInputFromJson(Map<String, dynamic> json) =>
        CARCHARGETBLUpdateManyMutationInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          item: json['ITEM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['ITEM'] as Map<String, dynamic>),
          charge: json['CHARGE'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['CHARGE'] as Map<String, dynamic>),
          writerId: json['WRITER_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['WRITER_ID'] as Map<String, dynamic>),
          memo: json['MEMO'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['MEMO'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$CARCHARGETBLUpdateManyMutationInputToJson(
    CARCHARGETBLUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ITEM', instance.item?.toJson());
  writeNotNull('CHARGE', instance.charge?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('MEMO', instance.memo?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

CARCHARGETBLUncheckedUpdateManyInput
    _$CARCHARGETBLUncheckedUpdateManyInputFromJson(Map<String, dynamic> json) =>
        CARCHARGETBLUncheckedUpdateManyInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          item: json['ITEM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['ITEM'] as Map<String, dynamic>),
          charge: json['CHARGE'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['CHARGE'] as Map<String, dynamic>),
          writerId: json['WRITER_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['WRITER_ID'] as Map<String, dynamic>),
          memo: json['MEMO'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['MEMO'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$CARCHARGETBLUncheckedUpdateManyInputToJson(
    CARCHARGETBLUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ITEM', instance.item?.toJson());
  writeNotNull('CHARGE', instance.charge?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('MEMO', instance.memo?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

CARINFOTBLCreateInput _$CARINFOTBLCreateInputFromJson(
        Map<String, dynamic> json) =>
    CARINFOTBLCreateInput(
      sort: json['SORT'] == null ? null : BigInt.parse(json['SORT'] as String),
      carManageNo: json['CAR_MANAGE_NO'] as String,
      model: json['MODEL'] as String,
      userId: json['USER_ID'] as String,
      regDate: json['REG_DATE'] as String,
      disusedYn: json['DISUSED_YN'] as String?,
    );

Map<String, dynamic> _$CARINFOTBLCreateInputToJson(
    CARINFOTBLCreateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SORT', instance.sort?.toString());
  val['CAR_MANAGE_NO'] = instance.carManageNo;
  val['MODEL'] = instance.model;
  val['USER_ID'] = instance.userId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('DISUSED_YN', instance.disusedYn);
  return val;
}

CARINFOTBLUncheckedCreateInput _$CARINFOTBLUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    CARINFOTBLUncheckedCreateInput(
      sort: json['SORT'] == null ? null : BigInt.parse(json['SORT'] as String),
      carManageNo: json['CAR_MANAGE_NO'] as String,
      model: json['MODEL'] as String,
      userId: json['USER_ID'] as String,
      regDate: json['REG_DATE'] as String,
      disusedYn: json['DISUSED_YN'] as String?,
    );

Map<String, dynamic> _$CARINFOTBLUncheckedCreateInputToJson(
    CARINFOTBLUncheckedCreateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SORT', instance.sort?.toString());
  val['CAR_MANAGE_NO'] = instance.carManageNo;
  val['MODEL'] = instance.model;
  val['USER_ID'] = instance.userId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('DISUSED_YN', instance.disusedYn);
  return val;
}

CARINFOTBLUpdateInput _$CARINFOTBLUpdateInputFromJson(
        Map<String, dynamic> json) =>
    CARINFOTBLUpdateInput(
      sort: json['SORT'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['SORT'] as Map<String, dynamic>),
      carManageNo: json['CAR_MANAGE_NO'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CAR_MANAGE_NO'] as Map<String, dynamic>),
      model: json['MODEL'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MODEL'] as Map<String, dynamic>),
      userId: json['USER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      disusedYn: json['DISUSED_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['DISUSED_YN'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$CARINFOTBLUpdateInputToJson(
    CARINFOTBLUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('CAR_MANAGE_NO', instance.carManageNo?.toJson());
  writeNotNull('MODEL', instance.model?.toJson());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('DISUSED_YN', instance.disusedYn?.toJson());
  return val;
}

CARINFOTBLUncheckedUpdateInput _$CARINFOTBLUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    CARINFOTBLUncheckedUpdateInput(
      sort: json['SORT'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['SORT'] as Map<String, dynamic>),
      carManageNo: json['CAR_MANAGE_NO'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CAR_MANAGE_NO'] as Map<String, dynamic>),
      model: json['MODEL'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MODEL'] as Map<String, dynamic>),
      userId: json['USER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      disusedYn: json['DISUSED_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['DISUSED_YN'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$CARINFOTBLUncheckedUpdateInputToJson(
    CARINFOTBLUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('CAR_MANAGE_NO', instance.carManageNo?.toJson());
  writeNotNull('MODEL', instance.model?.toJson());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('DISUSED_YN', instance.disusedYn?.toJson());
  return val;
}

CARINFOTBLCreateManyInput _$CARINFOTBLCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    CARINFOTBLCreateManyInput(
      sort: json['SORT'] == null ? null : BigInt.parse(json['SORT'] as String),
      carManageNo: json['CAR_MANAGE_NO'] as String,
      model: json['MODEL'] as String,
      userId: json['USER_ID'] as String,
      regDate: json['REG_DATE'] as String,
      disusedYn: json['DISUSED_YN'] as String?,
    );

Map<String, dynamic> _$CARINFOTBLCreateManyInputToJson(
    CARINFOTBLCreateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SORT', instance.sort?.toString());
  val['CAR_MANAGE_NO'] = instance.carManageNo;
  val['MODEL'] = instance.model;
  val['USER_ID'] = instance.userId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('DISUSED_YN', instance.disusedYn);
  return val;
}

CARINFOTBLUpdateManyMutationInput _$CARINFOTBLUpdateManyMutationInputFromJson(
        Map<String, dynamic> json) =>
    CARINFOTBLUpdateManyMutationInput(
      sort: json['SORT'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['SORT'] as Map<String, dynamic>),
      carManageNo: json['CAR_MANAGE_NO'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CAR_MANAGE_NO'] as Map<String, dynamic>),
      model: json['MODEL'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MODEL'] as Map<String, dynamic>),
      userId: json['USER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      disusedYn: json['DISUSED_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['DISUSED_YN'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$CARINFOTBLUpdateManyMutationInputToJson(
    CARINFOTBLUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('CAR_MANAGE_NO', instance.carManageNo?.toJson());
  writeNotNull('MODEL', instance.model?.toJson());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('DISUSED_YN', instance.disusedYn?.toJson());
  return val;
}

CARINFOTBLUncheckedUpdateManyInput _$CARINFOTBLUncheckedUpdateManyInputFromJson(
        Map<String, dynamic> json) =>
    CARINFOTBLUncheckedUpdateManyInput(
      sort: json['SORT'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['SORT'] as Map<String, dynamic>),
      carManageNo: json['CAR_MANAGE_NO'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CAR_MANAGE_NO'] as Map<String, dynamic>),
      model: json['MODEL'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MODEL'] as Map<String, dynamic>),
      userId: json['USER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      disusedYn: json['DISUSED_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['DISUSED_YN'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$CARINFOTBLUncheckedUpdateManyInputToJson(
    CARINFOTBLUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('CAR_MANAGE_NO', instance.carManageNo?.toJson());
  writeNotNull('MODEL', instance.model?.toJson());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('DISUSED_YN', instance.disusedYn?.toJson());
  return val;
}

CARMILEAGETBLCreateInput _$CARMILEAGETBLCreateInputFromJson(
        Map<String, dynamic> json) =>
    CARMILEAGETBLCreateInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      carManageNo: json['CAR_MANAGE_NO'] as String,
      forUse: json['FOR_USE'] as String,
      stPoint: json['ST_POINT'] as String,
      destination: json['DESTINATION'] as String,
      mileage: BigInt.parse(json['MILEAGE'] as String),
      totalMileage: BigInt.parse(json['TOTAL_MILEAGE'] as String),
      recordDate: json['RECORD_DATE'] as String,
      writerId: json['WRITER_ID'] as String,
      editorId: json['EDITOR_ID'] as String,
      regDate: json['REG_DATE'] as String,
      apprYn: json['APPR_YN'] as String,
    );

Map<String, dynamic> _$CARMILEAGETBLCreateInputToJson(
    CARMILEAGETBLCreateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['CAR_MANAGE_NO'] = instance.carManageNo;
  val['FOR_USE'] = instance.forUse;
  val['ST_POINT'] = instance.stPoint;
  val['DESTINATION'] = instance.destination;
  val['MILEAGE'] = instance.mileage.toString();
  val['TOTAL_MILEAGE'] = instance.totalMileage.toString();
  val['RECORD_DATE'] = instance.recordDate;
  val['WRITER_ID'] = instance.writerId;
  val['EDITOR_ID'] = instance.editorId;
  val['REG_DATE'] = instance.regDate;
  val['APPR_YN'] = instance.apprYn;
  return val;
}

CARMILEAGETBLUncheckedCreateInput _$CARMILEAGETBLUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    CARMILEAGETBLUncheckedCreateInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      carManageNo: json['CAR_MANAGE_NO'] as String,
      forUse: json['FOR_USE'] as String,
      stPoint: json['ST_POINT'] as String,
      destination: json['DESTINATION'] as String,
      mileage: BigInt.parse(json['MILEAGE'] as String),
      totalMileage: BigInt.parse(json['TOTAL_MILEAGE'] as String),
      recordDate: json['RECORD_DATE'] as String,
      writerId: json['WRITER_ID'] as String,
      editorId: json['EDITOR_ID'] as String,
      regDate: json['REG_DATE'] as String,
      apprYn: json['APPR_YN'] as String,
    );

Map<String, dynamic> _$CARMILEAGETBLUncheckedCreateInputToJson(
    CARMILEAGETBLUncheckedCreateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['CAR_MANAGE_NO'] = instance.carManageNo;
  val['FOR_USE'] = instance.forUse;
  val['ST_POINT'] = instance.stPoint;
  val['DESTINATION'] = instance.destination;
  val['MILEAGE'] = instance.mileage.toString();
  val['TOTAL_MILEAGE'] = instance.totalMileage.toString();
  val['RECORD_DATE'] = instance.recordDate;
  val['WRITER_ID'] = instance.writerId;
  val['EDITOR_ID'] = instance.editorId;
  val['REG_DATE'] = instance.regDate;
  val['APPR_YN'] = instance.apprYn;
  return val;
}

CARMILEAGETBLUpdateInput _$CARMILEAGETBLUpdateInputFromJson(
        Map<String, dynamic> json) =>
    CARMILEAGETBLUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      carManageNo: json['CAR_MANAGE_NO'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CAR_MANAGE_NO'] as Map<String, dynamic>),
      forUse: json['FOR_USE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['FOR_USE'] as Map<String, dynamic>),
      stPoint: json['ST_POINT'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['ST_POINT'] as Map<String, dynamic>),
      destination: json['DESTINATION'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['DESTINATION'] as Map<String, dynamic>),
      mileage: json['MILEAGE'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['MILEAGE'] as Map<String, dynamic>),
      totalMileage: json['TOTAL_MILEAGE'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['TOTAL_MILEAGE'] as Map<String, dynamic>),
      recordDate: json['RECORD_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['RECORD_DATE'] as Map<String, dynamic>),
      writerId: json['WRITER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['WRITER_ID'] as Map<String, dynamic>),
      editorId: json['EDITOR_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['EDITOR_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      apprYn: json['APPR_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['APPR_YN'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$CARMILEAGETBLUpdateInputToJson(
    CARMILEAGETBLUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('CAR_MANAGE_NO', instance.carManageNo?.toJson());
  writeNotNull('FOR_USE', instance.forUse?.toJson());
  writeNotNull('ST_POINT', instance.stPoint?.toJson());
  writeNotNull('DESTINATION', instance.destination?.toJson());
  writeNotNull('MILEAGE', instance.mileage?.toJson());
  writeNotNull('TOTAL_MILEAGE', instance.totalMileage?.toJson());
  writeNotNull('RECORD_DATE', instance.recordDate?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('EDITOR_ID', instance.editorId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('APPR_YN', instance.apprYn?.toJson());
  return val;
}

CARMILEAGETBLUncheckedUpdateInput _$CARMILEAGETBLUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    CARMILEAGETBLUncheckedUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      carManageNo: json['CAR_MANAGE_NO'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CAR_MANAGE_NO'] as Map<String, dynamic>),
      forUse: json['FOR_USE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['FOR_USE'] as Map<String, dynamic>),
      stPoint: json['ST_POINT'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['ST_POINT'] as Map<String, dynamic>),
      destination: json['DESTINATION'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['DESTINATION'] as Map<String, dynamic>),
      mileage: json['MILEAGE'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['MILEAGE'] as Map<String, dynamic>),
      totalMileage: json['TOTAL_MILEAGE'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['TOTAL_MILEAGE'] as Map<String, dynamic>),
      recordDate: json['RECORD_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['RECORD_DATE'] as Map<String, dynamic>),
      writerId: json['WRITER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['WRITER_ID'] as Map<String, dynamic>),
      editorId: json['EDITOR_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['EDITOR_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      apprYn: json['APPR_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['APPR_YN'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$CARMILEAGETBLUncheckedUpdateInputToJson(
    CARMILEAGETBLUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('CAR_MANAGE_NO', instance.carManageNo?.toJson());
  writeNotNull('FOR_USE', instance.forUse?.toJson());
  writeNotNull('ST_POINT', instance.stPoint?.toJson());
  writeNotNull('DESTINATION', instance.destination?.toJson());
  writeNotNull('MILEAGE', instance.mileage?.toJson());
  writeNotNull('TOTAL_MILEAGE', instance.totalMileage?.toJson());
  writeNotNull('RECORD_DATE', instance.recordDate?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('EDITOR_ID', instance.editorId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('APPR_YN', instance.apprYn?.toJson());
  return val;
}

CARMILEAGETBLCreateManyInput _$CARMILEAGETBLCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    CARMILEAGETBLCreateManyInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      carManageNo: json['CAR_MANAGE_NO'] as String,
      forUse: json['FOR_USE'] as String,
      stPoint: json['ST_POINT'] as String,
      destination: json['DESTINATION'] as String,
      mileage: BigInt.parse(json['MILEAGE'] as String),
      totalMileage: BigInt.parse(json['TOTAL_MILEAGE'] as String),
      recordDate: json['RECORD_DATE'] as String,
      writerId: json['WRITER_ID'] as String,
      editorId: json['EDITOR_ID'] as String,
      regDate: json['REG_DATE'] as String,
      apprYn: json['APPR_YN'] as String,
    );

Map<String, dynamic> _$CARMILEAGETBLCreateManyInputToJson(
    CARMILEAGETBLCreateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['CAR_MANAGE_NO'] = instance.carManageNo;
  val['FOR_USE'] = instance.forUse;
  val['ST_POINT'] = instance.stPoint;
  val['DESTINATION'] = instance.destination;
  val['MILEAGE'] = instance.mileage.toString();
  val['TOTAL_MILEAGE'] = instance.totalMileage.toString();
  val['RECORD_DATE'] = instance.recordDate;
  val['WRITER_ID'] = instance.writerId;
  val['EDITOR_ID'] = instance.editorId;
  val['REG_DATE'] = instance.regDate;
  val['APPR_YN'] = instance.apprYn;
  return val;
}

CARMILEAGETBLUpdateManyMutationInput
    _$CARMILEAGETBLUpdateManyMutationInputFromJson(Map<String, dynamic> json) =>
        CARMILEAGETBLUpdateManyMutationInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          carManageNo: json['CAR_MANAGE_NO'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['CAR_MANAGE_NO'] as Map<String, dynamic>),
          forUse: json['FOR_USE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['FOR_USE'] as Map<String, dynamic>),
          stPoint: json['ST_POINT'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['ST_POINT'] as Map<String, dynamic>),
          destination: json['DESTINATION'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['DESTINATION'] as Map<String, dynamic>),
          mileage: json['MILEAGE'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['MILEAGE'] as Map<String, dynamic>),
          totalMileage: json['TOTAL_MILEAGE'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['TOTAL_MILEAGE'] as Map<String, dynamic>),
          recordDate: json['RECORD_DATE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['RECORD_DATE'] as Map<String, dynamic>),
          writerId: json['WRITER_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['WRITER_ID'] as Map<String, dynamic>),
          editorId: json['EDITOR_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['EDITOR_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          apprYn: json['APPR_YN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['APPR_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$CARMILEAGETBLUpdateManyMutationInputToJson(
    CARMILEAGETBLUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('CAR_MANAGE_NO', instance.carManageNo?.toJson());
  writeNotNull('FOR_USE', instance.forUse?.toJson());
  writeNotNull('ST_POINT', instance.stPoint?.toJson());
  writeNotNull('DESTINATION', instance.destination?.toJson());
  writeNotNull('MILEAGE', instance.mileage?.toJson());
  writeNotNull('TOTAL_MILEAGE', instance.totalMileage?.toJson());
  writeNotNull('RECORD_DATE', instance.recordDate?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('EDITOR_ID', instance.editorId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('APPR_YN', instance.apprYn?.toJson());
  return val;
}

CARMILEAGETBLUncheckedUpdateManyInput
    _$CARMILEAGETBLUncheckedUpdateManyInputFromJson(
            Map<String, dynamic> json) =>
        CARMILEAGETBLUncheckedUpdateManyInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          carManageNo: json['CAR_MANAGE_NO'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['CAR_MANAGE_NO'] as Map<String, dynamic>),
          forUse: json['FOR_USE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['FOR_USE'] as Map<String, dynamic>),
          stPoint: json['ST_POINT'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['ST_POINT'] as Map<String, dynamic>),
          destination: json['DESTINATION'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['DESTINATION'] as Map<String, dynamic>),
          mileage: json['MILEAGE'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['MILEAGE'] as Map<String, dynamic>),
          totalMileage: json['TOTAL_MILEAGE'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['TOTAL_MILEAGE'] as Map<String, dynamic>),
          recordDate: json['RECORD_DATE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['RECORD_DATE'] as Map<String, dynamic>),
          writerId: json['WRITER_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['WRITER_ID'] as Map<String, dynamic>),
          editorId: json['EDITOR_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['EDITOR_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          apprYn: json['APPR_YN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['APPR_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$CARMILEAGETBLUncheckedUpdateManyInputToJson(
    CARMILEAGETBLUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('CAR_MANAGE_NO', instance.carManageNo?.toJson());
  writeNotNull('FOR_USE', instance.forUse?.toJson());
  writeNotNull('ST_POINT', instance.stPoint?.toJson());
  writeNotNull('DESTINATION', instance.destination?.toJson());
  writeNotNull('MILEAGE', instance.mileage?.toJson());
  writeNotNull('TOTAL_MILEAGE', instance.totalMileage?.toJson());
  writeNotNull('RECORD_DATE', instance.recordDate?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('EDITOR_ID', instance.editorId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('APPR_YN', instance.apprYn?.toJson());
  return val;
}

CARPARTREPLACETBLCreateInput _$CARPARTREPLACETBLCreateInputFromJson(
        Map<String, dynamic> json) =>
    CARPARTREPLACETBLCreateInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      partNm: json['PART_NM'] as String,
      replacePeriod: BigInt.parse(json['REPLACE_PERIOD'] as String),
      reTotalMileage: BigInt.parse(json['RE_TOTAL_MILEAGE'] as String),
      nowTotalMileage: BigInt.parse(json['NOW_TOTAL_MILEAGE'] as String),
      remainMileage: BigInt.parse(json['REMAIN_MILEAGE'] as String),
      replaceCount: BigInt.parse(json['REPLACE_COUNT'] as String),
      partReDate: json['PART_RE_DATE'] as String,
      writerId: json['WRITER_ID'] as String,
      regDate: json['REG_DATE'] as String,
    );

Map<String, dynamic> _$CARPARTREPLACETBLCreateInputToJson(
    CARPARTREPLACETBLCreateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['PART_NM'] = instance.partNm;
  val['REPLACE_PERIOD'] = instance.replacePeriod.toString();
  val['RE_TOTAL_MILEAGE'] = instance.reTotalMileage.toString();
  val['NOW_TOTAL_MILEAGE'] = instance.nowTotalMileage.toString();
  val['REMAIN_MILEAGE'] = instance.remainMileage.toString();
  val['REPLACE_COUNT'] = instance.replaceCount.toString();
  val['PART_RE_DATE'] = instance.partReDate;
  val['WRITER_ID'] = instance.writerId;
  val['REG_DATE'] = instance.regDate;
  return val;
}

CARPARTREPLACETBLUncheckedCreateInput
    _$CARPARTREPLACETBLUncheckedCreateInputFromJson(
            Map<String, dynamic> json) =>
        CARPARTREPLACETBLUncheckedCreateInput(
          seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
          partNm: json['PART_NM'] as String,
          replacePeriod: BigInt.parse(json['REPLACE_PERIOD'] as String),
          reTotalMileage: BigInt.parse(json['RE_TOTAL_MILEAGE'] as String),
          nowTotalMileage: BigInt.parse(json['NOW_TOTAL_MILEAGE'] as String),
          remainMileage: BigInt.parse(json['REMAIN_MILEAGE'] as String),
          replaceCount: BigInt.parse(json['REPLACE_COUNT'] as String),
          partReDate: json['PART_RE_DATE'] as String,
          writerId: json['WRITER_ID'] as String,
          regDate: json['REG_DATE'] as String,
        );

Map<String, dynamic> _$CARPARTREPLACETBLUncheckedCreateInputToJson(
    CARPARTREPLACETBLUncheckedCreateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['PART_NM'] = instance.partNm;
  val['REPLACE_PERIOD'] = instance.replacePeriod.toString();
  val['RE_TOTAL_MILEAGE'] = instance.reTotalMileage.toString();
  val['NOW_TOTAL_MILEAGE'] = instance.nowTotalMileage.toString();
  val['REMAIN_MILEAGE'] = instance.remainMileage.toString();
  val['REPLACE_COUNT'] = instance.replaceCount.toString();
  val['PART_RE_DATE'] = instance.partReDate;
  val['WRITER_ID'] = instance.writerId;
  val['REG_DATE'] = instance.regDate;
  return val;
}

CARPARTREPLACETBLUpdateInput _$CARPARTREPLACETBLUpdateInputFromJson(
        Map<String, dynamic> json) =>
    CARPARTREPLACETBLUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      partNm: json['PART_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['PART_NM'] as Map<String, dynamic>),
      replacePeriod: json['REPLACE_PERIOD'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['REPLACE_PERIOD'] as Map<String, dynamic>),
      reTotalMileage: json['RE_TOTAL_MILEAGE'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['RE_TOTAL_MILEAGE'] as Map<String, dynamic>),
      nowTotalMileage: json['NOW_TOTAL_MILEAGE'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['NOW_TOTAL_MILEAGE'] as Map<String, dynamic>),
      remainMileage: json['REMAIN_MILEAGE'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['REMAIN_MILEAGE'] as Map<String, dynamic>),
      replaceCount: json['REPLACE_COUNT'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['REPLACE_COUNT'] as Map<String, dynamic>),
      partReDate: json['PART_RE_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['PART_RE_DATE'] as Map<String, dynamic>),
      writerId: json['WRITER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['WRITER_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$CARPARTREPLACETBLUpdateInputToJson(
    CARPARTREPLACETBLUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('PART_NM', instance.partNm?.toJson());
  writeNotNull('REPLACE_PERIOD', instance.replacePeriod?.toJson());
  writeNotNull('RE_TOTAL_MILEAGE', instance.reTotalMileage?.toJson());
  writeNotNull('NOW_TOTAL_MILEAGE', instance.nowTotalMileage?.toJson());
  writeNotNull('REMAIN_MILEAGE', instance.remainMileage?.toJson());
  writeNotNull('REPLACE_COUNT', instance.replaceCount?.toJson());
  writeNotNull('PART_RE_DATE', instance.partReDate?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

CARPARTREPLACETBLUncheckedUpdateInput
    _$CARPARTREPLACETBLUncheckedUpdateInputFromJson(
            Map<String, dynamic> json) =>
        CARPARTREPLACETBLUncheckedUpdateInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          partNm: json['PART_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['PART_NM'] as Map<String, dynamic>),
          replacePeriod: json['REPLACE_PERIOD'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['REPLACE_PERIOD'] as Map<String, dynamic>),
          reTotalMileage: json['RE_TOTAL_MILEAGE'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['RE_TOTAL_MILEAGE'] as Map<String, dynamic>),
          nowTotalMileage: json['NOW_TOTAL_MILEAGE'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['NOW_TOTAL_MILEAGE'] as Map<String, dynamic>),
          remainMileage: json['REMAIN_MILEAGE'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['REMAIN_MILEAGE'] as Map<String, dynamic>),
          replaceCount: json['REPLACE_COUNT'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['REPLACE_COUNT'] as Map<String, dynamic>),
          partReDate: json['PART_RE_DATE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['PART_RE_DATE'] as Map<String, dynamic>),
          writerId: json['WRITER_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['WRITER_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$CARPARTREPLACETBLUncheckedUpdateInputToJson(
    CARPARTREPLACETBLUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('PART_NM', instance.partNm?.toJson());
  writeNotNull('REPLACE_PERIOD', instance.replacePeriod?.toJson());
  writeNotNull('RE_TOTAL_MILEAGE', instance.reTotalMileage?.toJson());
  writeNotNull('NOW_TOTAL_MILEAGE', instance.nowTotalMileage?.toJson());
  writeNotNull('REMAIN_MILEAGE', instance.remainMileage?.toJson());
  writeNotNull('REPLACE_COUNT', instance.replaceCount?.toJson());
  writeNotNull('PART_RE_DATE', instance.partReDate?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

CARPARTREPLACETBLCreateManyInput _$CARPARTREPLACETBLCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    CARPARTREPLACETBLCreateManyInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      partNm: json['PART_NM'] as String,
      replacePeriod: BigInt.parse(json['REPLACE_PERIOD'] as String),
      reTotalMileage: BigInt.parse(json['RE_TOTAL_MILEAGE'] as String),
      nowTotalMileage: BigInt.parse(json['NOW_TOTAL_MILEAGE'] as String),
      remainMileage: BigInt.parse(json['REMAIN_MILEAGE'] as String),
      replaceCount: BigInt.parse(json['REPLACE_COUNT'] as String),
      partReDate: json['PART_RE_DATE'] as String,
      writerId: json['WRITER_ID'] as String,
      regDate: json['REG_DATE'] as String,
    );

Map<String, dynamic> _$CARPARTREPLACETBLCreateManyInputToJson(
    CARPARTREPLACETBLCreateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['PART_NM'] = instance.partNm;
  val['REPLACE_PERIOD'] = instance.replacePeriod.toString();
  val['RE_TOTAL_MILEAGE'] = instance.reTotalMileage.toString();
  val['NOW_TOTAL_MILEAGE'] = instance.nowTotalMileage.toString();
  val['REMAIN_MILEAGE'] = instance.remainMileage.toString();
  val['REPLACE_COUNT'] = instance.replaceCount.toString();
  val['PART_RE_DATE'] = instance.partReDate;
  val['WRITER_ID'] = instance.writerId;
  val['REG_DATE'] = instance.regDate;
  return val;
}

CARPARTREPLACETBLUpdateManyMutationInput
    _$CARPARTREPLACETBLUpdateManyMutationInputFromJson(
            Map<String, dynamic> json) =>
        CARPARTREPLACETBLUpdateManyMutationInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          partNm: json['PART_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['PART_NM'] as Map<String, dynamic>),
          replacePeriod: json['REPLACE_PERIOD'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['REPLACE_PERIOD'] as Map<String, dynamic>),
          reTotalMileage: json['RE_TOTAL_MILEAGE'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['RE_TOTAL_MILEAGE'] as Map<String, dynamic>),
          nowTotalMileage: json['NOW_TOTAL_MILEAGE'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['NOW_TOTAL_MILEAGE'] as Map<String, dynamic>),
          remainMileage: json['REMAIN_MILEAGE'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['REMAIN_MILEAGE'] as Map<String, dynamic>),
          replaceCount: json['REPLACE_COUNT'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['REPLACE_COUNT'] as Map<String, dynamic>),
          partReDate: json['PART_RE_DATE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['PART_RE_DATE'] as Map<String, dynamic>),
          writerId: json['WRITER_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['WRITER_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$CARPARTREPLACETBLUpdateManyMutationInputToJson(
    CARPARTREPLACETBLUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('PART_NM', instance.partNm?.toJson());
  writeNotNull('REPLACE_PERIOD', instance.replacePeriod?.toJson());
  writeNotNull('RE_TOTAL_MILEAGE', instance.reTotalMileage?.toJson());
  writeNotNull('NOW_TOTAL_MILEAGE', instance.nowTotalMileage?.toJson());
  writeNotNull('REMAIN_MILEAGE', instance.remainMileage?.toJson());
  writeNotNull('REPLACE_COUNT', instance.replaceCount?.toJson());
  writeNotNull('PART_RE_DATE', instance.partReDate?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

CARPARTREPLACETBLUncheckedUpdateManyInput
    _$CARPARTREPLACETBLUncheckedUpdateManyInputFromJson(
            Map<String, dynamic> json) =>
        CARPARTREPLACETBLUncheckedUpdateManyInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          partNm: json['PART_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['PART_NM'] as Map<String, dynamic>),
          replacePeriod: json['REPLACE_PERIOD'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['REPLACE_PERIOD'] as Map<String, dynamic>),
          reTotalMileage: json['RE_TOTAL_MILEAGE'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['RE_TOTAL_MILEAGE'] as Map<String, dynamic>),
          nowTotalMileage: json['NOW_TOTAL_MILEAGE'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['NOW_TOTAL_MILEAGE'] as Map<String, dynamic>),
          remainMileage: json['REMAIN_MILEAGE'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['REMAIN_MILEAGE'] as Map<String, dynamic>),
          replaceCount: json['REPLACE_COUNT'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['REPLACE_COUNT'] as Map<String, dynamic>),
          partReDate: json['PART_RE_DATE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['PART_RE_DATE'] as Map<String, dynamic>),
          writerId: json['WRITER_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['WRITER_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$CARPARTREPLACETBLUncheckedUpdateManyInputToJson(
    CARPARTREPLACETBLUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('PART_NM', instance.partNm?.toJson());
  writeNotNull('REPLACE_PERIOD', instance.replacePeriod?.toJson());
  writeNotNull('RE_TOTAL_MILEAGE', instance.reTotalMileage?.toJson());
  writeNotNull('NOW_TOTAL_MILEAGE', instance.nowTotalMileage?.toJson());
  writeNotNull('REMAIN_MILEAGE', instance.remainMileage?.toJson());
  writeNotNull('REPLACE_COUNT', instance.replaceCount?.toJson());
  writeNotNull('PART_RE_DATE', instance.partReDate?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

CARREPAIRLOGCreateInput _$CARREPAIRLOGCreateInputFromJson(
        Map<String, dynamic> json) =>
    CARREPAIRLOGCreateInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      mseq: json['MSEQ'] == null ? null : BigInt.parse(json['MSEQ'] as String),
      assetNo: json['ASSET_NO'] as String?,
      repairDe: json['REPAIR_DE'] as String?,
      repairAmount: json['REPAIR_AMOUNT'] as String?,
      repairStore: json['REPAIR_STORE'] as String?,
      repairLog: json['REPAIR_LOG'] as String?,
      repairOwner: json['REPAIR_OWNER'] as String?,
      fileTp: json['FILE_TP'] as String?,
      flpth: json['FLPTH'] as String?,
      orginalFileNm: json['ORGINAL_FILE_NM'] as String?,
      streFileNm: json['STRE_FILE_NM'] as String?,
      regId: json['REG_ID'] as String?,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$CARREPAIRLOGCreateInputToJson(
    CARREPAIRLOGCreateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  writeNotNull('MSEQ', instance.mseq?.toString());
  writeNotNull('ASSET_NO', instance.assetNo);
  writeNotNull('REPAIR_DE', instance.repairDe);
  writeNotNull('REPAIR_AMOUNT', instance.repairAmount);
  writeNotNull('REPAIR_STORE', instance.repairStore);
  writeNotNull('REPAIR_LOG', instance.repairLog);
  writeNotNull('REPAIR_OWNER', instance.repairOwner);
  writeNotNull('FILE_TP', instance.fileTp);
  writeNotNull('FLPTH', instance.flpth);
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm);
  writeNotNull('STRE_FILE_NM', instance.streFileNm);
  writeNotNull('REG_ID', instance.regId);
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

CARREPAIRLOGUncheckedCreateInput _$CARREPAIRLOGUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    CARREPAIRLOGUncheckedCreateInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      mseq: json['MSEQ'] == null ? null : BigInt.parse(json['MSEQ'] as String),
      assetNo: json['ASSET_NO'] as String?,
      repairDe: json['REPAIR_DE'] as String?,
      repairAmount: json['REPAIR_AMOUNT'] as String?,
      repairStore: json['REPAIR_STORE'] as String?,
      repairLog: json['REPAIR_LOG'] as String?,
      repairOwner: json['REPAIR_OWNER'] as String?,
      fileTp: json['FILE_TP'] as String?,
      flpth: json['FLPTH'] as String?,
      orginalFileNm: json['ORGINAL_FILE_NM'] as String?,
      streFileNm: json['STRE_FILE_NM'] as String?,
      regId: json['REG_ID'] as String?,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$CARREPAIRLOGUncheckedCreateInputToJson(
    CARREPAIRLOGUncheckedCreateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  writeNotNull('MSEQ', instance.mseq?.toString());
  writeNotNull('ASSET_NO', instance.assetNo);
  writeNotNull('REPAIR_DE', instance.repairDe);
  writeNotNull('REPAIR_AMOUNT', instance.repairAmount);
  writeNotNull('REPAIR_STORE', instance.repairStore);
  writeNotNull('REPAIR_LOG', instance.repairLog);
  writeNotNull('REPAIR_OWNER', instance.repairOwner);
  writeNotNull('FILE_TP', instance.fileTp);
  writeNotNull('FLPTH', instance.flpth);
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm);
  writeNotNull('STRE_FILE_NM', instance.streFileNm);
  writeNotNull('REG_ID', instance.regId);
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

CARREPAIRLOGUpdateInput _$CARREPAIRLOGUpdateInputFromJson(
        Map<String, dynamic> json) =>
    CARREPAIRLOGUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      mseq: json['MSEQ'] == null
          ? null
          : NullableBigIntFieldUpdateOperationsInput.fromJson(
              json['MSEQ'] as Map<String, dynamic>),
      assetNo: json['ASSET_NO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ASSET_NO'] as Map<String, dynamic>),
      repairDe: json['REPAIR_DE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REPAIR_DE'] as Map<String, dynamic>),
      repairAmount: json['REPAIR_AMOUNT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REPAIR_AMOUNT'] as Map<String, dynamic>),
      repairStore: json['REPAIR_STORE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REPAIR_STORE'] as Map<String, dynamic>),
      repairLog: json['REPAIR_LOG'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REPAIR_LOG'] as Map<String, dynamic>),
      repairOwner: json['REPAIR_OWNER'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REPAIR_OWNER'] as Map<String, dynamic>),
      fileTp: json['FILE_TP'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FILE_TP'] as Map<String, dynamic>),
      flpth: json['FLPTH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FLPTH'] as Map<String, dynamic>),
      orginalFileNm: json['ORGINAL_FILE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ORGINAL_FILE_NM'] as Map<String, dynamic>),
      streFileNm: json['STRE_FILE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['STRE_FILE_NM'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$CARREPAIRLOGUpdateInputToJson(
    CARREPAIRLOGUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('REPAIR_DE', instance.repairDe?.toJson());
  writeNotNull('REPAIR_AMOUNT', instance.repairAmount?.toJson());
  writeNotNull('REPAIR_STORE', instance.repairStore?.toJson());
  writeNotNull('REPAIR_LOG', instance.repairLog?.toJson());
  writeNotNull('REPAIR_OWNER', instance.repairOwner?.toJson());
  writeNotNull('FILE_TP', instance.fileTp?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm?.toJson());
  writeNotNull('STRE_FILE_NM', instance.streFileNm?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

CARREPAIRLOGUncheckedUpdateInput _$CARREPAIRLOGUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    CARREPAIRLOGUncheckedUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      mseq: json['MSEQ'] == null
          ? null
          : NullableBigIntFieldUpdateOperationsInput.fromJson(
              json['MSEQ'] as Map<String, dynamic>),
      assetNo: json['ASSET_NO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ASSET_NO'] as Map<String, dynamic>),
      repairDe: json['REPAIR_DE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REPAIR_DE'] as Map<String, dynamic>),
      repairAmount: json['REPAIR_AMOUNT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REPAIR_AMOUNT'] as Map<String, dynamic>),
      repairStore: json['REPAIR_STORE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REPAIR_STORE'] as Map<String, dynamic>),
      repairLog: json['REPAIR_LOG'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REPAIR_LOG'] as Map<String, dynamic>),
      repairOwner: json['REPAIR_OWNER'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REPAIR_OWNER'] as Map<String, dynamic>),
      fileTp: json['FILE_TP'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FILE_TP'] as Map<String, dynamic>),
      flpth: json['FLPTH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FLPTH'] as Map<String, dynamic>),
      orginalFileNm: json['ORGINAL_FILE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ORGINAL_FILE_NM'] as Map<String, dynamic>),
      streFileNm: json['STRE_FILE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['STRE_FILE_NM'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$CARREPAIRLOGUncheckedUpdateInputToJson(
    CARREPAIRLOGUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('REPAIR_DE', instance.repairDe?.toJson());
  writeNotNull('REPAIR_AMOUNT', instance.repairAmount?.toJson());
  writeNotNull('REPAIR_STORE', instance.repairStore?.toJson());
  writeNotNull('REPAIR_LOG', instance.repairLog?.toJson());
  writeNotNull('REPAIR_OWNER', instance.repairOwner?.toJson());
  writeNotNull('FILE_TP', instance.fileTp?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm?.toJson());
  writeNotNull('STRE_FILE_NM', instance.streFileNm?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

CARREPAIRLOGCreateManyInput _$CARREPAIRLOGCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    CARREPAIRLOGCreateManyInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      mseq: json['MSEQ'] == null ? null : BigInt.parse(json['MSEQ'] as String),
      assetNo: json['ASSET_NO'] as String?,
      repairDe: json['REPAIR_DE'] as String?,
      repairAmount: json['REPAIR_AMOUNT'] as String?,
      repairStore: json['REPAIR_STORE'] as String?,
      repairLog: json['REPAIR_LOG'] as String?,
      repairOwner: json['REPAIR_OWNER'] as String?,
      fileTp: json['FILE_TP'] as String?,
      flpth: json['FLPTH'] as String?,
      orginalFileNm: json['ORGINAL_FILE_NM'] as String?,
      streFileNm: json['STRE_FILE_NM'] as String?,
      regId: json['REG_ID'] as String?,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$CARREPAIRLOGCreateManyInputToJson(
    CARREPAIRLOGCreateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  writeNotNull('MSEQ', instance.mseq?.toString());
  writeNotNull('ASSET_NO', instance.assetNo);
  writeNotNull('REPAIR_DE', instance.repairDe);
  writeNotNull('REPAIR_AMOUNT', instance.repairAmount);
  writeNotNull('REPAIR_STORE', instance.repairStore);
  writeNotNull('REPAIR_LOG', instance.repairLog);
  writeNotNull('REPAIR_OWNER', instance.repairOwner);
  writeNotNull('FILE_TP', instance.fileTp);
  writeNotNull('FLPTH', instance.flpth);
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm);
  writeNotNull('STRE_FILE_NM', instance.streFileNm);
  writeNotNull('REG_ID', instance.regId);
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

CARREPAIRLOGUpdateManyMutationInput
    _$CARREPAIRLOGUpdateManyMutationInputFromJson(Map<String, dynamic> json) =>
        CARREPAIRLOGUpdateManyMutationInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          mseq: json['MSEQ'] == null
              ? null
              : NullableBigIntFieldUpdateOperationsInput.fromJson(
                  json['MSEQ'] as Map<String, dynamic>),
          assetNo: json['ASSET_NO'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['ASSET_NO'] as Map<String, dynamic>),
          repairDe: json['REPAIR_DE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REPAIR_DE'] as Map<String, dynamic>),
          repairAmount: json['REPAIR_AMOUNT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REPAIR_AMOUNT'] as Map<String, dynamic>),
          repairStore: json['REPAIR_STORE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REPAIR_STORE'] as Map<String, dynamic>),
          repairLog: json['REPAIR_LOG'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REPAIR_LOG'] as Map<String, dynamic>),
          repairOwner: json['REPAIR_OWNER'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REPAIR_OWNER'] as Map<String, dynamic>),
          fileTp: json['FILE_TP'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['FILE_TP'] as Map<String, dynamic>),
          flpth: json['FLPTH'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['FLPTH'] as Map<String, dynamic>),
          orginalFileNm: json['ORGINAL_FILE_NM'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['ORGINAL_FILE_NM'] as Map<String, dynamic>),
          streFileNm: json['STRE_FILE_NM'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['STRE_FILE_NM'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delId: json['DEL_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_ID'] as Map<String, dynamic>),
          delDate: json['DEL_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$CARREPAIRLOGUpdateManyMutationInputToJson(
    CARREPAIRLOGUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('REPAIR_DE', instance.repairDe?.toJson());
  writeNotNull('REPAIR_AMOUNT', instance.repairAmount?.toJson());
  writeNotNull('REPAIR_STORE', instance.repairStore?.toJson());
  writeNotNull('REPAIR_LOG', instance.repairLog?.toJson());
  writeNotNull('REPAIR_OWNER', instance.repairOwner?.toJson());
  writeNotNull('FILE_TP', instance.fileTp?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm?.toJson());
  writeNotNull('STRE_FILE_NM', instance.streFileNm?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

CARREPAIRLOGUncheckedUpdateManyInput
    _$CARREPAIRLOGUncheckedUpdateManyInputFromJson(Map<String, dynamic> json) =>
        CARREPAIRLOGUncheckedUpdateManyInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          mseq: json['MSEQ'] == null
              ? null
              : NullableBigIntFieldUpdateOperationsInput.fromJson(
                  json['MSEQ'] as Map<String, dynamic>),
          assetNo: json['ASSET_NO'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['ASSET_NO'] as Map<String, dynamic>),
          repairDe: json['REPAIR_DE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REPAIR_DE'] as Map<String, dynamic>),
          repairAmount: json['REPAIR_AMOUNT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REPAIR_AMOUNT'] as Map<String, dynamic>),
          repairStore: json['REPAIR_STORE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REPAIR_STORE'] as Map<String, dynamic>),
          repairLog: json['REPAIR_LOG'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REPAIR_LOG'] as Map<String, dynamic>),
          repairOwner: json['REPAIR_OWNER'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REPAIR_OWNER'] as Map<String, dynamic>),
          fileTp: json['FILE_TP'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['FILE_TP'] as Map<String, dynamic>),
          flpth: json['FLPTH'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['FLPTH'] as Map<String, dynamic>),
          orginalFileNm: json['ORGINAL_FILE_NM'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['ORGINAL_FILE_NM'] as Map<String, dynamic>),
          streFileNm: json['STRE_FILE_NM'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['STRE_FILE_NM'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delId: json['DEL_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_ID'] as Map<String, dynamic>),
          delDate: json['DEL_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$CARREPAIRLOGUncheckedUpdateManyInputToJson(
    CARREPAIRLOGUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('REPAIR_DE', instance.repairDe?.toJson());
  writeNotNull('REPAIR_AMOUNT', instance.repairAmount?.toJson());
  writeNotNull('REPAIR_STORE', instance.repairStore?.toJson());
  writeNotNull('REPAIR_LOG', instance.repairLog?.toJson());
  writeNotNull('REPAIR_OWNER', instance.repairOwner?.toJson());
  writeNotNull('FILE_TP', instance.fileTp?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm?.toJson());
  writeNotNull('STRE_FILE_NM', instance.streFileNm?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

CARUSEMANAGETBLCreateInput _$CARUSEMANAGETBLCreateInputFromJson(
        Map<String, dynamic> json) =>
    CARUSEMANAGETBLCreateInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      carNo: json['CAR_NO'] as String,
      carType: json['CAR_TYPE'] as String,
      destination: json['DESTINATION'] as String,
      purpose: json['PURPOSE'] as String?,
      users: json['USERS'] as String,
      useStartDate: _$JsonConverterFromJson<String, DateTime>(
          json['USE_START_DATE'], const DateTimeJsonConverter().fromJson),
      useEndDate: _$JsonConverterFromJson<String, DateTime>(
          json['USE_END_DATE'], const DateTimeJsonConverter().fromJson),
      useBeforeDistance: (json['USE_BEFORE_DISTANCE'] as num?)?.toDouble(),
      useAfterDistance: (json['USE_AFTER_DISTANCE'] as num?)?.toDouble(),
      remarks: json['REMARKS'] as String?,
      acceptYn: json['ACCEPT_YN'] as String?,
      regUser: json['REG_USER'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      useStartHour: json['USE_START_HOUR'] as String?,
      useEndHour: json['USE_END_HOUR'] as String?,
      cardApply: json['CARD_APPLY'] as String?,
    );

Map<String, dynamic> _$CARUSEMANAGETBLCreateInputToJson(
    CARUSEMANAGETBLCreateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['CAR_NO'] = instance.carNo;
  val['CAR_TYPE'] = instance.carType;
  val['DESTINATION'] = instance.destination;
  writeNotNull('PURPOSE', instance.purpose);
  val['USERS'] = instance.users;
  writeNotNull(
      'USE_START_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.useStartDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'USE_END_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.useEndDate, const DateTimeJsonConverter().toJson));
  writeNotNull('USE_BEFORE_DISTANCE', instance.useBeforeDistance);
  writeNotNull('USE_AFTER_DISTANCE', instance.useAfterDistance);
  writeNotNull('REMARKS', instance.remarks);
  writeNotNull('ACCEPT_YN', instance.acceptYn);
  writeNotNull('REG_USER', instance.regUser);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull('USE_START_HOUR', instance.useStartHour);
  writeNotNull('USE_END_HOUR', instance.useEndHour);
  writeNotNull('CARD_APPLY', instance.cardApply);
  return val;
}

CARUSEMANAGETBLUncheckedCreateInput
    _$CARUSEMANAGETBLUncheckedCreateInputFromJson(Map<String, dynamic> json) =>
        CARUSEMANAGETBLUncheckedCreateInput(
          seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
          carNo: json['CAR_NO'] as String,
          carType: json['CAR_TYPE'] as String,
          destination: json['DESTINATION'] as String,
          purpose: json['PURPOSE'] as String?,
          users: json['USERS'] as String,
          useStartDate: _$JsonConverterFromJson<String, DateTime>(
              json['USE_START_DATE'], const DateTimeJsonConverter().fromJson),
          useEndDate: _$JsonConverterFromJson<String, DateTime>(
              json['USE_END_DATE'], const DateTimeJsonConverter().fromJson),
          useBeforeDistance: (json['USE_BEFORE_DISTANCE'] as num?)?.toDouble(),
          useAfterDistance: (json['USE_AFTER_DISTANCE'] as num?)?.toDouble(),
          remarks: json['REMARKS'] as String?,
          acceptYn: json['ACCEPT_YN'] as String?,
          regUser: json['REG_USER'] as String?,
          regDate: _$JsonConverterFromJson<String, DateTime>(
              json['REG_DATE'], const DateTimeJsonConverter().fromJson),
          useStartHour: json['USE_START_HOUR'] as String?,
          useEndHour: json['USE_END_HOUR'] as String?,
          cardApply: json['CARD_APPLY'] as String?,
        );

Map<String, dynamic> _$CARUSEMANAGETBLUncheckedCreateInputToJson(
    CARUSEMANAGETBLUncheckedCreateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['CAR_NO'] = instance.carNo;
  val['CAR_TYPE'] = instance.carType;
  val['DESTINATION'] = instance.destination;
  writeNotNull('PURPOSE', instance.purpose);
  val['USERS'] = instance.users;
  writeNotNull(
      'USE_START_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.useStartDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'USE_END_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.useEndDate, const DateTimeJsonConverter().toJson));
  writeNotNull('USE_BEFORE_DISTANCE', instance.useBeforeDistance);
  writeNotNull('USE_AFTER_DISTANCE', instance.useAfterDistance);
  writeNotNull('REMARKS', instance.remarks);
  writeNotNull('ACCEPT_YN', instance.acceptYn);
  writeNotNull('REG_USER', instance.regUser);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull('USE_START_HOUR', instance.useStartHour);
  writeNotNull('USE_END_HOUR', instance.useEndHour);
  writeNotNull('CARD_APPLY', instance.cardApply);
  return val;
}

CARUSEMANAGETBLUpdateInput _$CARUSEMANAGETBLUpdateInputFromJson(
        Map<String, dynamic> json) =>
    CARUSEMANAGETBLUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      carNo: json['CAR_NO'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CAR_NO'] as Map<String, dynamic>),
      carType: json['CAR_TYPE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CAR_TYPE'] as Map<String, dynamic>),
      destination: json['DESTINATION'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['DESTINATION'] as Map<String, dynamic>),
      purpose: json['PURPOSE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['PURPOSE'] as Map<String, dynamic>),
      users: json['USERS'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USERS'] as Map<String, dynamic>),
      useStartDate: json['USE_START_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['USE_START_DATE'] as Map<String, dynamic>),
      useEndDate: json['USE_END_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['USE_END_DATE'] as Map<String, dynamic>),
      useBeforeDistance: json['USE_BEFORE_DISTANCE'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['USE_BEFORE_DISTANCE'] as Map<String, dynamic>),
      useAfterDistance: json['USE_AFTER_DISTANCE'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['USE_AFTER_DISTANCE'] as Map<String, dynamic>),
      remarks: json['REMARKS'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REMARKS'] as Map<String, dynamic>),
      acceptYn: json['ACCEPT_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ACCEPT_YN'] as Map<String, dynamic>),
      regUser: json['REG_USER'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_USER'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      useStartHour: json['USE_START_HOUR'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USE_START_HOUR'] as Map<String, dynamic>),
      useEndHour: json['USE_END_HOUR'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USE_END_HOUR'] as Map<String, dynamic>),
      cardApply: json['CARD_APPLY'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CARD_APPLY'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$CARUSEMANAGETBLUpdateInputToJson(
    CARUSEMANAGETBLUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('CAR_NO', instance.carNo?.toJson());
  writeNotNull('CAR_TYPE', instance.carType?.toJson());
  writeNotNull('DESTINATION', instance.destination?.toJson());
  writeNotNull('PURPOSE', instance.purpose?.toJson());
  writeNotNull('USERS', instance.users?.toJson());
  writeNotNull('USE_START_DATE', instance.useStartDate?.toJson());
  writeNotNull('USE_END_DATE', instance.useEndDate?.toJson());
  writeNotNull('USE_BEFORE_DISTANCE', instance.useBeforeDistance?.toJson());
  writeNotNull('USE_AFTER_DISTANCE', instance.useAfterDistance?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('ACCEPT_YN', instance.acceptYn?.toJson());
  writeNotNull('REG_USER', instance.regUser?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('USE_START_HOUR', instance.useStartHour?.toJson());
  writeNotNull('USE_END_HOUR', instance.useEndHour?.toJson());
  writeNotNull('CARD_APPLY', instance.cardApply?.toJson());
  return val;
}

CARUSEMANAGETBLUncheckedUpdateInput
    _$CARUSEMANAGETBLUncheckedUpdateInputFromJson(Map<String, dynamic> json) =>
        CARUSEMANAGETBLUncheckedUpdateInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          carNo: json['CAR_NO'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['CAR_NO'] as Map<String, dynamic>),
          carType: json['CAR_TYPE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['CAR_TYPE'] as Map<String, dynamic>),
          destination: json['DESTINATION'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['DESTINATION'] as Map<String, dynamic>),
          purpose: json['PURPOSE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['PURPOSE'] as Map<String, dynamic>),
          users: json['USERS'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['USERS'] as Map<String, dynamic>),
          useStartDate: json['USE_START_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['USE_START_DATE'] as Map<String, dynamic>),
          useEndDate: json['USE_END_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['USE_END_DATE'] as Map<String, dynamic>),
          useBeforeDistance: json['USE_BEFORE_DISTANCE'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['USE_BEFORE_DISTANCE'] as Map<String, dynamic>),
          useAfterDistance: json['USE_AFTER_DISTANCE'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['USE_AFTER_DISTANCE'] as Map<String, dynamic>),
          remarks: json['REMARKS'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REMARKS'] as Map<String, dynamic>),
          acceptYn: json['ACCEPT_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['ACCEPT_YN'] as Map<String, dynamic>),
          regUser: json['REG_USER'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REG_USER'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          useStartHour: json['USE_START_HOUR'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['USE_START_HOUR'] as Map<String, dynamic>),
          useEndHour: json['USE_END_HOUR'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['USE_END_HOUR'] as Map<String, dynamic>),
          cardApply: json['CARD_APPLY'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['CARD_APPLY'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$CARUSEMANAGETBLUncheckedUpdateInputToJson(
    CARUSEMANAGETBLUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('CAR_NO', instance.carNo?.toJson());
  writeNotNull('CAR_TYPE', instance.carType?.toJson());
  writeNotNull('DESTINATION', instance.destination?.toJson());
  writeNotNull('PURPOSE', instance.purpose?.toJson());
  writeNotNull('USERS', instance.users?.toJson());
  writeNotNull('USE_START_DATE', instance.useStartDate?.toJson());
  writeNotNull('USE_END_DATE', instance.useEndDate?.toJson());
  writeNotNull('USE_BEFORE_DISTANCE', instance.useBeforeDistance?.toJson());
  writeNotNull('USE_AFTER_DISTANCE', instance.useAfterDistance?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('ACCEPT_YN', instance.acceptYn?.toJson());
  writeNotNull('REG_USER', instance.regUser?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('USE_START_HOUR', instance.useStartHour?.toJson());
  writeNotNull('USE_END_HOUR', instance.useEndHour?.toJson());
  writeNotNull('CARD_APPLY', instance.cardApply?.toJson());
  return val;
}

CARUSEMANAGETBLCreateManyInput _$CARUSEMANAGETBLCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    CARUSEMANAGETBLCreateManyInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      carNo: json['CAR_NO'] as String,
      carType: json['CAR_TYPE'] as String,
      destination: json['DESTINATION'] as String,
      purpose: json['PURPOSE'] as String?,
      users: json['USERS'] as String,
      useStartDate: _$JsonConverterFromJson<String, DateTime>(
          json['USE_START_DATE'], const DateTimeJsonConverter().fromJson),
      useEndDate: _$JsonConverterFromJson<String, DateTime>(
          json['USE_END_DATE'], const DateTimeJsonConverter().fromJson),
      useBeforeDistance: (json['USE_BEFORE_DISTANCE'] as num?)?.toDouble(),
      useAfterDistance: (json['USE_AFTER_DISTANCE'] as num?)?.toDouble(),
      remarks: json['REMARKS'] as String?,
      acceptYn: json['ACCEPT_YN'] as String?,
      regUser: json['REG_USER'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      useStartHour: json['USE_START_HOUR'] as String?,
      useEndHour: json['USE_END_HOUR'] as String?,
      cardApply: json['CARD_APPLY'] as String?,
    );

Map<String, dynamic> _$CARUSEMANAGETBLCreateManyInputToJson(
    CARUSEMANAGETBLCreateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['CAR_NO'] = instance.carNo;
  val['CAR_TYPE'] = instance.carType;
  val['DESTINATION'] = instance.destination;
  writeNotNull('PURPOSE', instance.purpose);
  val['USERS'] = instance.users;
  writeNotNull(
      'USE_START_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.useStartDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'USE_END_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.useEndDate, const DateTimeJsonConverter().toJson));
  writeNotNull('USE_BEFORE_DISTANCE', instance.useBeforeDistance);
  writeNotNull('USE_AFTER_DISTANCE', instance.useAfterDistance);
  writeNotNull('REMARKS', instance.remarks);
  writeNotNull('ACCEPT_YN', instance.acceptYn);
  writeNotNull('REG_USER', instance.regUser);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull('USE_START_HOUR', instance.useStartHour);
  writeNotNull('USE_END_HOUR', instance.useEndHour);
  writeNotNull('CARD_APPLY', instance.cardApply);
  return val;
}

CARUSEMANAGETBLUpdateManyMutationInput
    _$CARUSEMANAGETBLUpdateManyMutationInputFromJson(
            Map<String, dynamic> json) =>
        CARUSEMANAGETBLUpdateManyMutationInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          carNo: json['CAR_NO'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['CAR_NO'] as Map<String, dynamic>),
          carType: json['CAR_TYPE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['CAR_TYPE'] as Map<String, dynamic>),
          destination: json['DESTINATION'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['DESTINATION'] as Map<String, dynamic>),
          purpose: json['PURPOSE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['PURPOSE'] as Map<String, dynamic>),
          users: json['USERS'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['USERS'] as Map<String, dynamic>),
          useStartDate: json['USE_START_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['USE_START_DATE'] as Map<String, dynamic>),
          useEndDate: json['USE_END_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['USE_END_DATE'] as Map<String, dynamic>),
          useBeforeDistance: json['USE_BEFORE_DISTANCE'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['USE_BEFORE_DISTANCE'] as Map<String, dynamic>),
          useAfterDistance: json['USE_AFTER_DISTANCE'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['USE_AFTER_DISTANCE'] as Map<String, dynamic>),
          remarks: json['REMARKS'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REMARKS'] as Map<String, dynamic>),
          acceptYn: json['ACCEPT_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['ACCEPT_YN'] as Map<String, dynamic>),
          regUser: json['REG_USER'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REG_USER'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          useStartHour: json['USE_START_HOUR'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['USE_START_HOUR'] as Map<String, dynamic>),
          useEndHour: json['USE_END_HOUR'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['USE_END_HOUR'] as Map<String, dynamic>),
          cardApply: json['CARD_APPLY'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['CARD_APPLY'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$CARUSEMANAGETBLUpdateManyMutationInputToJson(
    CARUSEMANAGETBLUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('CAR_NO', instance.carNo?.toJson());
  writeNotNull('CAR_TYPE', instance.carType?.toJson());
  writeNotNull('DESTINATION', instance.destination?.toJson());
  writeNotNull('PURPOSE', instance.purpose?.toJson());
  writeNotNull('USERS', instance.users?.toJson());
  writeNotNull('USE_START_DATE', instance.useStartDate?.toJson());
  writeNotNull('USE_END_DATE', instance.useEndDate?.toJson());
  writeNotNull('USE_BEFORE_DISTANCE', instance.useBeforeDistance?.toJson());
  writeNotNull('USE_AFTER_DISTANCE', instance.useAfterDistance?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('ACCEPT_YN', instance.acceptYn?.toJson());
  writeNotNull('REG_USER', instance.regUser?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('USE_START_HOUR', instance.useStartHour?.toJson());
  writeNotNull('USE_END_HOUR', instance.useEndHour?.toJson());
  writeNotNull('CARD_APPLY', instance.cardApply?.toJson());
  return val;
}

CARUSEMANAGETBLUncheckedUpdateManyInput
    _$CARUSEMANAGETBLUncheckedUpdateManyInputFromJson(
            Map<String, dynamic> json) =>
        CARUSEMANAGETBLUncheckedUpdateManyInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          carNo: json['CAR_NO'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['CAR_NO'] as Map<String, dynamic>),
          carType: json['CAR_TYPE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['CAR_TYPE'] as Map<String, dynamic>),
          destination: json['DESTINATION'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['DESTINATION'] as Map<String, dynamic>),
          purpose: json['PURPOSE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['PURPOSE'] as Map<String, dynamic>),
          users: json['USERS'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['USERS'] as Map<String, dynamic>),
          useStartDate: json['USE_START_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['USE_START_DATE'] as Map<String, dynamic>),
          useEndDate: json['USE_END_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['USE_END_DATE'] as Map<String, dynamic>),
          useBeforeDistance: json['USE_BEFORE_DISTANCE'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['USE_BEFORE_DISTANCE'] as Map<String, dynamic>),
          useAfterDistance: json['USE_AFTER_DISTANCE'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['USE_AFTER_DISTANCE'] as Map<String, dynamic>),
          remarks: json['REMARKS'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REMARKS'] as Map<String, dynamic>),
          acceptYn: json['ACCEPT_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['ACCEPT_YN'] as Map<String, dynamic>),
          regUser: json['REG_USER'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REG_USER'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          useStartHour: json['USE_START_HOUR'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['USE_START_HOUR'] as Map<String, dynamic>),
          useEndHour: json['USE_END_HOUR'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['USE_END_HOUR'] as Map<String, dynamic>),
          cardApply: json['CARD_APPLY'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['CARD_APPLY'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$CARUSEMANAGETBLUncheckedUpdateManyInputToJson(
    CARUSEMANAGETBLUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('CAR_NO', instance.carNo?.toJson());
  writeNotNull('CAR_TYPE', instance.carType?.toJson());
  writeNotNull('DESTINATION', instance.destination?.toJson());
  writeNotNull('PURPOSE', instance.purpose?.toJson());
  writeNotNull('USERS', instance.users?.toJson());
  writeNotNull('USE_START_DATE', instance.useStartDate?.toJson());
  writeNotNull('USE_END_DATE', instance.useEndDate?.toJson());
  writeNotNull('USE_BEFORE_DISTANCE', instance.useBeforeDistance?.toJson());
  writeNotNull('USE_AFTER_DISTANCE', instance.useAfterDistance?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('ACCEPT_YN', instance.acceptYn?.toJson());
  writeNotNull('REG_USER', instance.regUser?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('USE_START_HOUR', instance.useStartHour?.toJson());
  writeNotNull('USE_END_HOUR', instance.useEndHour?.toJson());
  writeNotNull('CARD_APPLY', instance.cardApply?.toJson());
  return val;
}

HOLIDAYTBLCreateInput _$HOLIDAYTBLCreateInputFromJson(
        Map<String, dynamic> json) =>
    HOLIDAYTBLCreateInput(
      userId: json['USER_ID'] as String,
      stdYear: json['STD_YEAR'] as String,
      m1: (json['M1'] as num?)?.toDouble(),
      m2: (json['M2'] as num?)?.toDouble(),
      m3: (json['M3'] as num?)?.toDouble(),
      m4: (json['M4'] as num?)?.toDouble(),
      m5: (json['M5'] as num?)?.toDouble(),
      m6: (json['M6'] as num?)?.toDouble(),
      m7: (json['M7'] as num?)?.toDouble(),
      m8: (json['M8'] as num?)?.toDouble(),
      m9: (json['M9'] as num?)?.toDouble(),
      m10: (json['M10'] as num?)?.toDouble(),
      m11: (json['M11'] as num?)?.toDouble(),
      m12: (json['M12'] as num?)?.toDouble(),
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$HOLIDAYTBLCreateInputToJson(
    HOLIDAYTBLCreateInput instance) {
  final val = <String, dynamic>{
    'USER_ID': instance.userId,
    'STD_YEAR': instance.stdYear,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('M1', instance.m1);
  writeNotNull('M2', instance.m2);
  writeNotNull('M3', instance.m3);
  writeNotNull('M4', instance.m4);
  writeNotNull('M5', instance.m5);
  writeNotNull('M6', instance.m6);
  writeNotNull('M7', instance.m7);
  writeNotNull('M8', instance.m8);
  writeNotNull('M9', instance.m9);
  writeNotNull('M10', instance.m10);
  writeNotNull('M11', instance.m11);
  writeNotNull('M12', instance.m12);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

HOLIDAYTBLUncheckedCreateInput _$HOLIDAYTBLUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    HOLIDAYTBLUncheckedCreateInput(
      userId: json['USER_ID'] as String,
      stdYear: json['STD_YEAR'] as String,
      m1: (json['M1'] as num?)?.toDouble(),
      m2: (json['M2'] as num?)?.toDouble(),
      m3: (json['M3'] as num?)?.toDouble(),
      m4: (json['M4'] as num?)?.toDouble(),
      m5: (json['M5'] as num?)?.toDouble(),
      m6: (json['M6'] as num?)?.toDouble(),
      m7: (json['M7'] as num?)?.toDouble(),
      m8: (json['M8'] as num?)?.toDouble(),
      m9: (json['M9'] as num?)?.toDouble(),
      m10: (json['M10'] as num?)?.toDouble(),
      m11: (json['M11'] as num?)?.toDouble(),
      m12: (json['M12'] as num?)?.toDouble(),
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$HOLIDAYTBLUncheckedCreateInputToJson(
    HOLIDAYTBLUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'USER_ID': instance.userId,
    'STD_YEAR': instance.stdYear,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('M1', instance.m1);
  writeNotNull('M2', instance.m2);
  writeNotNull('M3', instance.m3);
  writeNotNull('M4', instance.m4);
  writeNotNull('M5', instance.m5);
  writeNotNull('M6', instance.m6);
  writeNotNull('M7', instance.m7);
  writeNotNull('M8', instance.m8);
  writeNotNull('M9', instance.m9);
  writeNotNull('M10', instance.m10);
  writeNotNull('M11', instance.m11);
  writeNotNull('M12', instance.m12);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

HOLIDAYTBLUpdateInput _$HOLIDAYTBLUpdateInputFromJson(
        Map<String, dynamic> json) =>
    HOLIDAYTBLUpdateInput(
      userId: json['USER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_ID'] as Map<String, dynamic>),
      stdYear: json['STD_YEAR'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['STD_YEAR'] as Map<String, dynamic>),
      m1: json['M1'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M1'] as Map<String, dynamic>),
      m2: json['M2'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M2'] as Map<String, dynamic>),
      m3: json['M3'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M3'] as Map<String, dynamic>),
      m4: json['M4'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M4'] as Map<String, dynamic>),
      m5: json['M5'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M5'] as Map<String, dynamic>),
      m6: json['M6'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M6'] as Map<String, dynamic>),
      m7: json['M7'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M7'] as Map<String, dynamic>),
      m8: json['M8'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M8'] as Map<String, dynamic>),
      m9: json['M9'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M9'] as Map<String, dynamic>),
      m10: json['M10'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M10'] as Map<String, dynamic>),
      m11: json['M11'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M11'] as Map<String, dynamic>),
      m12: json['M12'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M12'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : NullableDateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$HOLIDAYTBLUpdateInputToJson(
    HOLIDAYTBLUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('STD_YEAR', instance.stdYear?.toJson());
  writeNotNull('M1', instance.m1?.toJson());
  writeNotNull('M2', instance.m2?.toJson());
  writeNotNull('M3', instance.m3?.toJson());
  writeNotNull('M4', instance.m4?.toJson());
  writeNotNull('M5', instance.m5?.toJson());
  writeNotNull('M6', instance.m6?.toJson());
  writeNotNull('M7', instance.m7?.toJson());
  writeNotNull('M8', instance.m8?.toJson());
  writeNotNull('M9', instance.m9?.toJson());
  writeNotNull('M10', instance.m10?.toJson());
  writeNotNull('M11', instance.m11?.toJson());
  writeNotNull('M12', instance.m12?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

HOLIDAYTBLUncheckedUpdateInput _$HOLIDAYTBLUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    HOLIDAYTBLUncheckedUpdateInput(
      userId: json['USER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_ID'] as Map<String, dynamic>),
      stdYear: json['STD_YEAR'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['STD_YEAR'] as Map<String, dynamic>),
      m1: json['M1'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M1'] as Map<String, dynamic>),
      m2: json['M2'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M2'] as Map<String, dynamic>),
      m3: json['M3'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M3'] as Map<String, dynamic>),
      m4: json['M4'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M4'] as Map<String, dynamic>),
      m5: json['M5'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M5'] as Map<String, dynamic>),
      m6: json['M6'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M6'] as Map<String, dynamic>),
      m7: json['M7'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M7'] as Map<String, dynamic>),
      m8: json['M8'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M8'] as Map<String, dynamic>),
      m9: json['M9'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M9'] as Map<String, dynamic>),
      m10: json['M10'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M10'] as Map<String, dynamic>),
      m11: json['M11'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M11'] as Map<String, dynamic>),
      m12: json['M12'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M12'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : NullableDateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$HOLIDAYTBLUncheckedUpdateInputToJson(
    HOLIDAYTBLUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('STD_YEAR', instance.stdYear?.toJson());
  writeNotNull('M1', instance.m1?.toJson());
  writeNotNull('M2', instance.m2?.toJson());
  writeNotNull('M3', instance.m3?.toJson());
  writeNotNull('M4', instance.m4?.toJson());
  writeNotNull('M5', instance.m5?.toJson());
  writeNotNull('M6', instance.m6?.toJson());
  writeNotNull('M7', instance.m7?.toJson());
  writeNotNull('M8', instance.m8?.toJson());
  writeNotNull('M9', instance.m9?.toJson());
  writeNotNull('M10', instance.m10?.toJson());
  writeNotNull('M11', instance.m11?.toJson());
  writeNotNull('M12', instance.m12?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

HOLIDAYTBLCreateManyInput _$HOLIDAYTBLCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    HOLIDAYTBLCreateManyInput(
      userId: json['USER_ID'] as String,
      stdYear: json['STD_YEAR'] as String,
      m1: (json['M1'] as num?)?.toDouble(),
      m2: (json['M2'] as num?)?.toDouble(),
      m3: (json['M3'] as num?)?.toDouble(),
      m4: (json['M4'] as num?)?.toDouble(),
      m5: (json['M5'] as num?)?.toDouble(),
      m6: (json['M6'] as num?)?.toDouble(),
      m7: (json['M7'] as num?)?.toDouble(),
      m8: (json['M8'] as num?)?.toDouble(),
      m9: (json['M9'] as num?)?.toDouble(),
      m10: (json['M10'] as num?)?.toDouble(),
      m11: (json['M11'] as num?)?.toDouble(),
      m12: (json['M12'] as num?)?.toDouble(),
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$HOLIDAYTBLCreateManyInputToJson(
    HOLIDAYTBLCreateManyInput instance) {
  final val = <String, dynamic>{
    'USER_ID': instance.userId,
    'STD_YEAR': instance.stdYear,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('M1', instance.m1);
  writeNotNull('M2', instance.m2);
  writeNotNull('M3', instance.m3);
  writeNotNull('M4', instance.m4);
  writeNotNull('M5', instance.m5);
  writeNotNull('M6', instance.m6);
  writeNotNull('M7', instance.m7);
  writeNotNull('M8', instance.m8);
  writeNotNull('M9', instance.m9);
  writeNotNull('M10', instance.m10);
  writeNotNull('M11', instance.m11);
  writeNotNull('M12', instance.m12);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

HOLIDAYTBLUpdateManyMutationInput _$HOLIDAYTBLUpdateManyMutationInputFromJson(
        Map<String, dynamic> json) =>
    HOLIDAYTBLUpdateManyMutationInput(
      userId: json['USER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_ID'] as Map<String, dynamic>),
      stdYear: json['STD_YEAR'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['STD_YEAR'] as Map<String, dynamic>),
      m1: json['M1'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M1'] as Map<String, dynamic>),
      m2: json['M2'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M2'] as Map<String, dynamic>),
      m3: json['M3'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M3'] as Map<String, dynamic>),
      m4: json['M4'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M4'] as Map<String, dynamic>),
      m5: json['M5'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M5'] as Map<String, dynamic>),
      m6: json['M6'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M6'] as Map<String, dynamic>),
      m7: json['M7'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M7'] as Map<String, dynamic>),
      m8: json['M8'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M8'] as Map<String, dynamic>),
      m9: json['M9'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M9'] as Map<String, dynamic>),
      m10: json['M10'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M10'] as Map<String, dynamic>),
      m11: json['M11'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M11'] as Map<String, dynamic>),
      m12: json['M12'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M12'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : NullableDateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$HOLIDAYTBLUpdateManyMutationInputToJson(
    HOLIDAYTBLUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('STD_YEAR', instance.stdYear?.toJson());
  writeNotNull('M1', instance.m1?.toJson());
  writeNotNull('M2', instance.m2?.toJson());
  writeNotNull('M3', instance.m3?.toJson());
  writeNotNull('M4', instance.m4?.toJson());
  writeNotNull('M5', instance.m5?.toJson());
  writeNotNull('M6', instance.m6?.toJson());
  writeNotNull('M7', instance.m7?.toJson());
  writeNotNull('M8', instance.m8?.toJson());
  writeNotNull('M9', instance.m9?.toJson());
  writeNotNull('M10', instance.m10?.toJson());
  writeNotNull('M11', instance.m11?.toJson());
  writeNotNull('M12', instance.m12?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

HOLIDAYTBLUncheckedUpdateManyInput _$HOLIDAYTBLUncheckedUpdateManyInputFromJson(
        Map<String, dynamic> json) =>
    HOLIDAYTBLUncheckedUpdateManyInput(
      userId: json['USER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_ID'] as Map<String, dynamic>),
      stdYear: json['STD_YEAR'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['STD_YEAR'] as Map<String, dynamic>),
      m1: json['M1'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M1'] as Map<String, dynamic>),
      m2: json['M2'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M2'] as Map<String, dynamic>),
      m3: json['M3'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M3'] as Map<String, dynamic>),
      m4: json['M4'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M4'] as Map<String, dynamic>),
      m5: json['M5'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M5'] as Map<String, dynamic>),
      m6: json['M6'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M6'] as Map<String, dynamic>),
      m7: json['M7'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M7'] as Map<String, dynamic>),
      m8: json['M8'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M8'] as Map<String, dynamic>),
      m9: json['M9'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M9'] as Map<String, dynamic>),
      m10: json['M10'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M10'] as Map<String, dynamic>),
      m11: json['M11'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M11'] as Map<String, dynamic>),
      m12: json['M12'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['M12'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : NullableDateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$HOLIDAYTBLUncheckedUpdateManyInputToJson(
    HOLIDAYTBLUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('STD_YEAR', instance.stdYear?.toJson());
  writeNotNull('M1', instance.m1?.toJson());
  writeNotNull('M2', instance.m2?.toJson());
  writeNotNull('M3', instance.m3?.toJson());
  writeNotNull('M4', instance.m4?.toJson());
  writeNotNull('M5', instance.m5?.toJson());
  writeNotNull('M6', instance.m6?.toJson());
  writeNotNull('M7', instance.m7?.toJson());
  writeNotNull('M8', instance.m8?.toJson());
  writeNotNull('M9', instance.m9?.toJson());
  writeNotNull('M10', instance.m10?.toJson());
  writeNotNull('M11', instance.m11?.toJson());
  writeNotNull('M12', instance.m12?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

MEMBERTBLCreateInput _$MEMBERTBLCreateInputFromJson(
        Map<String, dynamic> json) =>
    MEMBERTBLCreateInput(
      userId: json['USER_ID'] as String,
      passwd: json['PASSWD'] as String,
      userNm: json['USER_NM'] as String,
      dept: json['DEPT'] as String?,
      grade: json['GRADE'] as String?,
      joinDate: _$JsonConverterFromJson<String, DateTime>(
          json['JOIN_DATE'], const DateTimeJsonConverter().fromJson),
      retireDate: _$JsonConverterFromJson<String, DateTime>(
          json['RETIRE_DATE'], const DateTimeJsonConverter().fromJson),
      pwdChgDate: _$JsonConverterFromJson<String, DateTime>(
          json['PWD_CHG_DATE'], const DateTimeJsonConverter().fromJson),
      pwdWrongCnt: json['PWD_WRONG_CNT'] as int?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      lastLoginDate: _$JsonConverterFromJson<String, DateTime>(
          json['LAST_LOGIN_DATE'], const DateTimeJsonConverter().fromJson),
      memo: json['MEMO'] as String?,
      menuTbl: json['MENU_TBL'] == null
          ? null
          : MENUTBLCreateNestedManyWithoutMEMBERTBLInput.fromJson(
              json['MENU_TBL'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$MEMBERTBLCreateInputToJson(
    MEMBERTBLCreateInput instance) {
  final val = <String, dynamic>{
    'USER_ID': instance.userId,
    'PASSWD': instance.passwd,
    'USER_NM': instance.userNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('DEPT', instance.dept);
  writeNotNull('GRADE', instance.grade);
  writeNotNull(
      'JOIN_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.joinDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'RETIRE_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.retireDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'PWD_CHG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.pwdChgDate, const DateTimeJsonConverter().toJson));
  writeNotNull('PWD_WRONG_CNT', instance.pwdWrongCnt);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'LAST_LOGIN_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.lastLoginDate, const DateTimeJsonConverter().toJson));
  writeNotNull('MEMO', instance.memo);
  writeNotNull('MENU_TBL', instance.menuTbl?.toJson());
  return val;
}

MEMBERTBLUncheckedCreateInput _$MEMBERTBLUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    MEMBERTBLUncheckedCreateInput(
      userId: json['USER_ID'] as String,
      passwd: json['PASSWD'] as String,
      userNm: json['USER_NM'] as String,
      dept: json['DEPT'] as String?,
      grade: json['GRADE'] as String?,
      joinDate: _$JsonConverterFromJson<String, DateTime>(
          json['JOIN_DATE'], const DateTimeJsonConverter().fromJson),
      retireDate: _$JsonConverterFromJson<String, DateTime>(
          json['RETIRE_DATE'], const DateTimeJsonConverter().fromJson),
      pwdChgDate: _$JsonConverterFromJson<String, DateTime>(
          json['PWD_CHG_DATE'], const DateTimeJsonConverter().fromJson),
      pwdWrongCnt: json['PWD_WRONG_CNT'] as int?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      lastLoginDate: _$JsonConverterFromJson<String, DateTime>(
          json['LAST_LOGIN_DATE'], const DateTimeJsonConverter().fromJson),
      memo: json['MEMO'] as String?,
      menuTbl: json['MENU_TBL'] == null
          ? null
          : MENUTBLUncheckedCreateNestedManyWithoutMEMBERTBLInput.fromJson(
              json['MENU_TBL'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$MEMBERTBLUncheckedCreateInputToJson(
    MEMBERTBLUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'USER_ID': instance.userId,
    'PASSWD': instance.passwd,
    'USER_NM': instance.userNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('DEPT', instance.dept);
  writeNotNull('GRADE', instance.grade);
  writeNotNull(
      'JOIN_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.joinDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'RETIRE_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.retireDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'PWD_CHG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.pwdChgDate, const DateTimeJsonConverter().toJson));
  writeNotNull('PWD_WRONG_CNT', instance.pwdWrongCnt);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'LAST_LOGIN_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.lastLoginDate, const DateTimeJsonConverter().toJson));
  writeNotNull('MEMO', instance.memo);
  writeNotNull('MENU_TBL', instance.menuTbl?.toJson());
  return val;
}

MEMBERTBLUpdateInput _$MEMBERTBLUpdateInputFromJson(
        Map<String, dynamic> json) =>
    MEMBERTBLUpdateInput(
      userId: json['USER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_ID'] as Map<String, dynamic>),
      passwd: json['PASSWD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['PASSWD'] as Map<String, dynamic>),
      userNm: json['USER_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_NM'] as Map<String, dynamic>),
      dept: json['DEPT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEPT'] as Map<String, dynamic>),
      grade: json['GRADE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['GRADE'] as Map<String, dynamic>),
      joinDate: json['JOIN_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['JOIN_DATE'] as Map<String, dynamic>),
      retireDate: json['RETIRE_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['RETIRE_DATE'] as Map<String, dynamic>),
      pwdChgDate: json['PWD_CHG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['PWD_CHG_DATE'] as Map<String, dynamic>),
      pwdWrongCnt: json['PWD_WRONG_CNT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['PWD_WRONG_CNT'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : NullableDateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
      lastLoginDate: json['LAST_LOGIN_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['LAST_LOGIN_DATE'] as Map<String, dynamic>),
      memo: json['MEMO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MEMO'] as Map<String, dynamic>),
      menuTbl: json['MENU_TBL'] == null
          ? null
          : MENUTBLUpdateManyWithoutMEMBERTBLNestedInput.fromJson(
              json['MENU_TBL'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$MEMBERTBLUpdateInputToJson(
    MEMBERTBLUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('PASSWD', instance.passwd?.toJson());
  writeNotNull('USER_NM', instance.userNm?.toJson());
  writeNotNull('DEPT', instance.dept?.toJson());
  writeNotNull('GRADE', instance.grade?.toJson());
  writeNotNull('JOIN_DATE', instance.joinDate?.toJson());
  writeNotNull('RETIRE_DATE', instance.retireDate?.toJson());
  writeNotNull('PWD_CHG_DATE', instance.pwdChgDate?.toJson());
  writeNotNull('PWD_WRONG_CNT', instance.pwdWrongCnt?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('LAST_LOGIN_DATE', instance.lastLoginDate?.toJson());
  writeNotNull('MEMO', instance.memo?.toJson());
  writeNotNull('MENU_TBL', instance.menuTbl?.toJson());
  return val;
}

MEMBERTBLUncheckedUpdateInput _$MEMBERTBLUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    MEMBERTBLUncheckedUpdateInput(
      userId: json['USER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_ID'] as Map<String, dynamic>),
      passwd: json['PASSWD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['PASSWD'] as Map<String, dynamic>),
      userNm: json['USER_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_NM'] as Map<String, dynamic>),
      dept: json['DEPT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEPT'] as Map<String, dynamic>),
      grade: json['GRADE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['GRADE'] as Map<String, dynamic>),
      joinDate: json['JOIN_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['JOIN_DATE'] as Map<String, dynamic>),
      retireDate: json['RETIRE_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['RETIRE_DATE'] as Map<String, dynamic>),
      pwdChgDate: json['PWD_CHG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['PWD_CHG_DATE'] as Map<String, dynamic>),
      pwdWrongCnt: json['PWD_WRONG_CNT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['PWD_WRONG_CNT'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : NullableDateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
      lastLoginDate: json['LAST_LOGIN_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['LAST_LOGIN_DATE'] as Map<String, dynamic>),
      memo: json['MEMO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MEMO'] as Map<String, dynamic>),
      menuTbl: json['MENU_TBL'] == null
          ? null
          : MENUTBLUncheckedUpdateManyWithoutMEMBERTBLNestedInput.fromJson(
              json['MENU_TBL'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$MEMBERTBLUncheckedUpdateInputToJson(
    MEMBERTBLUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('PASSWD', instance.passwd?.toJson());
  writeNotNull('USER_NM', instance.userNm?.toJson());
  writeNotNull('DEPT', instance.dept?.toJson());
  writeNotNull('GRADE', instance.grade?.toJson());
  writeNotNull('JOIN_DATE', instance.joinDate?.toJson());
  writeNotNull('RETIRE_DATE', instance.retireDate?.toJson());
  writeNotNull('PWD_CHG_DATE', instance.pwdChgDate?.toJson());
  writeNotNull('PWD_WRONG_CNT', instance.pwdWrongCnt?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('LAST_LOGIN_DATE', instance.lastLoginDate?.toJson());
  writeNotNull('MEMO', instance.memo?.toJson());
  writeNotNull('MENU_TBL', instance.menuTbl?.toJson());
  return val;
}

MEMBERTBLCreateManyInput _$MEMBERTBLCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    MEMBERTBLCreateManyInput(
      userId: json['USER_ID'] as String,
      passwd: json['PASSWD'] as String,
      userNm: json['USER_NM'] as String,
      dept: json['DEPT'] as String?,
      grade: json['GRADE'] as String?,
      joinDate: _$JsonConverterFromJson<String, DateTime>(
          json['JOIN_DATE'], const DateTimeJsonConverter().fromJson),
      retireDate: _$JsonConverterFromJson<String, DateTime>(
          json['RETIRE_DATE'], const DateTimeJsonConverter().fromJson),
      pwdChgDate: _$JsonConverterFromJson<String, DateTime>(
          json['PWD_CHG_DATE'], const DateTimeJsonConverter().fromJson),
      pwdWrongCnt: json['PWD_WRONG_CNT'] as int?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      lastLoginDate: _$JsonConverterFromJson<String, DateTime>(
          json['LAST_LOGIN_DATE'], const DateTimeJsonConverter().fromJson),
      memo: json['MEMO'] as String?,
    );

Map<String, dynamic> _$MEMBERTBLCreateManyInputToJson(
    MEMBERTBLCreateManyInput instance) {
  final val = <String, dynamic>{
    'USER_ID': instance.userId,
    'PASSWD': instance.passwd,
    'USER_NM': instance.userNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('DEPT', instance.dept);
  writeNotNull('GRADE', instance.grade);
  writeNotNull(
      'JOIN_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.joinDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'RETIRE_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.retireDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'PWD_CHG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.pwdChgDate, const DateTimeJsonConverter().toJson));
  writeNotNull('PWD_WRONG_CNT', instance.pwdWrongCnt);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'LAST_LOGIN_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.lastLoginDate, const DateTimeJsonConverter().toJson));
  writeNotNull('MEMO', instance.memo);
  return val;
}

MEMBERTBLUpdateManyMutationInput _$MEMBERTBLUpdateManyMutationInputFromJson(
        Map<String, dynamic> json) =>
    MEMBERTBLUpdateManyMutationInput(
      userId: json['USER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_ID'] as Map<String, dynamic>),
      passwd: json['PASSWD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['PASSWD'] as Map<String, dynamic>),
      userNm: json['USER_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_NM'] as Map<String, dynamic>),
      dept: json['DEPT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEPT'] as Map<String, dynamic>),
      grade: json['GRADE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['GRADE'] as Map<String, dynamic>),
      joinDate: json['JOIN_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['JOIN_DATE'] as Map<String, dynamic>),
      retireDate: json['RETIRE_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['RETIRE_DATE'] as Map<String, dynamic>),
      pwdChgDate: json['PWD_CHG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['PWD_CHG_DATE'] as Map<String, dynamic>),
      pwdWrongCnt: json['PWD_WRONG_CNT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['PWD_WRONG_CNT'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : NullableDateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
      lastLoginDate: json['LAST_LOGIN_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['LAST_LOGIN_DATE'] as Map<String, dynamic>),
      memo: json['MEMO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MEMO'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$MEMBERTBLUpdateManyMutationInputToJson(
    MEMBERTBLUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('PASSWD', instance.passwd?.toJson());
  writeNotNull('USER_NM', instance.userNm?.toJson());
  writeNotNull('DEPT', instance.dept?.toJson());
  writeNotNull('GRADE', instance.grade?.toJson());
  writeNotNull('JOIN_DATE', instance.joinDate?.toJson());
  writeNotNull('RETIRE_DATE', instance.retireDate?.toJson());
  writeNotNull('PWD_CHG_DATE', instance.pwdChgDate?.toJson());
  writeNotNull('PWD_WRONG_CNT', instance.pwdWrongCnt?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('LAST_LOGIN_DATE', instance.lastLoginDate?.toJson());
  writeNotNull('MEMO', instance.memo?.toJson());
  return val;
}

MEMBERTBLUncheckedUpdateManyInput _$MEMBERTBLUncheckedUpdateManyInputFromJson(
        Map<String, dynamic> json) =>
    MEMBERTBLUncheckedUpdateManyInput(
      userId: json['USER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_ID'] as Map<String, dynamic>),
      passwd: json['PASSWD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['PASSWD'] as Map<String, dynamic>),
      userNm: json['USER_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_NM'] as Map<String, dynamic>),
      dept: json['DEPT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEPT'] as Map<String, dynamic>),
      grade: json['GRADE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['GRADE'] as Map<String, dynamic>),
      joinDate: json['JOIN_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['JOIN_DATE'] as Map<String, dynamic>),
      retireDate: json['RETIRE_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['RETIRE_DATE'] as Map<String, dynamic>),
      pwdChgDate: json['PWD_CHG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['PWD_CHG_DATE'] as Map<String, dynamic>),
      pwdWrongCnt: json['PWD_WRONG_CNT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['PWD_WRONG_CNT'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : NullableDateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
      lastLoginDate: json['LAST_LOGIN_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['LAST_LOGIN_DATE'] as Map<String, dynamic>),
      memo: json['MEMO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MEMO'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$MEMBERTBLUncheckedUpdateManyInputToJson(
    MEMBERTBLUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('PASSWD', instance.passwd?.toJson());
  writeNotNull('USER_NM', instance.userNm?.toJson());
  writeNotNull('DEPT', instance.dept?.toJson());
  writeNotNull('GRADE', instance.grade?.toJson());
  writeNotNull('JOIN_DATE', instance.joinDate?.toJson());
  writeNotNull('RETIRE_DATE', instance.retireDate?.toJson());
  writeNotNull('PWD_CHG_DATE', instance.pwdChgDate?.toJson());
  writeNotNull('PWD_WRONG_CNT', instance.pwdWrongCnt?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('LAST_LOGIN_DATE', instance.lastLoginDate?.toJson());
  writeNotNull('MEMO', instance.memo?.toJson());
  return val;
}

MENUAUTHTBLCreateInput _$MENUAUTHTBLCreateInputFromJson(
        Map<String, dynamic> json) =>
    MENUAUTHTBLCreateInput(
      userId: json['USER_ID'] as String,
      menuId: json['MENU_ID'] as String,
      readYn: json['READ_YN'] as String?,
      writeYn: json['WRITE_YN'] as String?,
      regId: json['REG_ID'] as String?,
      updId: json['UPD_ID'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$MENUAUTHTBLCreateInputToJson(
    MENUAUTHTBLCreateInput instance) {
  final val = <String, dynamic>{
    'USER_ID': instance.userId,
    'MENU_ID': instance.menuId,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('READ_YN', instance.readYn);
  writeNotNull('WRITE_YN', instance.writeYn);
  writeNotNull('REG_ID', instance.regId);
  writeNotNull('UPD_ID', instance.updId);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

MENUAUTHTBLUncheckedCreateInput _$MENUAUTHTBLUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    MENUAUTHTBLUncheckedCreateInput(
      userId: json['USER_ID'] as String,
      menuId: json['MENU_ID'] as String,
      readYn: json['READ_YN'] as String?,
      writeYn: json['WRITE_YN'] as String?,
      regId: json['REG_ID'] as String?,
      updId: json['UPD_ID'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$MENUAUTHTBLUncheckedCreateInputToJson(
    MENUAUTHTBLUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'USER_ID': instance.userId,
    'MENU_ID': instance.menuId,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('READ_YN', instance.readYn);
  writeNotNull('WRITE_YN', instance.writeYn);
  writeNotNull('REG_ID', instance.regId);
  writeNotNull('UPD_ID', instance.updId);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

MENUAUTHTBLUpdateInput _$MENUAUTHTBLUpdateInputFromJson(
        Map<String, dynamic> json) =>
    MENUAUTHTBLUpdateInput(
      userId: json['USER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_ID'] as Map<String, dynamic>),
      menuId: json['MENU_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_ID'] as Map<String, dynamic>),
      readYn: json['READ_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['READ_YN'] as Map<String, dynamic>),
      writeYn: json['WRITE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['WRITE_YN'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      updId: json['UPD_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['UPD_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : NullableDateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$MENUAUTHTBLUpdateInputToJson(
    MENUAUTHTBLUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('MENU_ID', instance.menuId?.toJson());
  writeNotNull('READ_YN', instance.readYn?.toJson());
  writeNotNull('WRITE_YN', instance.writeYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('UPD_ID', instance.updId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

MENUAUTHTBLUncheckedUpdateInput _$MENUAUTHTBLUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    MENUAUTHTBLUncheckedUpdateInput(
      userId: json['USER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_ID'] as Map<String, dynamic>),
      menuId: json['MENU_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_ID'] as Map<String, dynamic>),
      readYn: json['READ_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['READ_YN'] as Map<String, dynamic>),
      writeYn: json['WRITE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['WRITE_YN'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      updId: json['UPD_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['UPD_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : NullableDateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$MENUAUTHTBLUncheckedUpdateInputToJson(
    MENUAUTHTBLUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('MENU_ID', instance.menuId?.toJson());
  writeNotNull('READ_YN', instance.readYn?.toJson());
  writeNotNull('WRITE_YN', instance.writeYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('UPD_ID', instance.updId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

MENUAUTHTBLCreateManyInput _$MENUAUTHTBLCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    MENUAUTHTBLCreateManyInput(
      userId: json['USER_ID'] as String,
      menuId: json['MENU_ID'] as String,
      readYn: json['READ_YN'] as String?,
      writeYn: json['WRITE_YN'] as String?,
      regId: json['REG_ID'] as String?,
      updId: json['UPD_ID'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$MENUAUTHTBLCreateManyInputToJson(
    MENUAUTHTBLCreateManyInput instance) {
  final val = <String, dynamic>{
    'USER_ID': instance.userId,
    'MENU_ID': instance.menuId,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('READ_YN', instance.readYn);
  writeNotNull('WRITE_YN', instance.writeYn);
  writeNotNull('REG_ID', instance.regId);
  writeNotNull('UPD_ID', instance.updId);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

MENUAUTHTBLUpdateManyMutationInput _$MENUAUTHTBLUpdateManyMutationInputFromJson(
        Map<String, dynamic> json) =>
    MENUAUTHTBLUpdateManyMutationInput(
      userId: json['USER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_ID'] as Map<String, dynamic>),
      menuId: json['MENU_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_ID'] as Map<String, dynamic>),
      readYn: json['READ_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['READ_YN'] as Map<String, dynamic>),
      writeYn: json['WRITE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['WRITE_YN'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      updId: json['UPD_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['UPD_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : NullableDateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$MENUAUTHTBLUpdateManyMutationInputToJson(
    MENUAUTHTBLUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('MENU_ID', instance.menuId?.toJson());
  writeNotNull('READ_YN', instance.readYn?.toJson());
  writeNotNull('WRITE_YN', instance.writeYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('UPD_ID', instance.updId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

MENUAUTHTBLUncheckedUpdateManyInput
    _$MENUAUTHTBLUncheckedUpdateManyInputFromJson(Map<String, dynamic> json) =>
        MENUAUTHTBLUncheckedUpdateManyInput(
          userId: json['USER_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['USER_ID'] as Map<String, dynamic>),
          menuId: json['MENU_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['MENU_ID'] as Map<String, dynamic>),
          readYn: json['READ_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['READ_YN'] as Map<String, dynamic>),
          writeYn: json['WRITE_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['WRITE_YN'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          updId: json['UPD_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['UPD_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : NullableDateTimeFieldUpdateOperationsInput.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$MENUAUTHTBLUncheckedUpdateManyInputToJson(
    MENUAUTHTBLUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('MENU_ID', instance.menuId?.toJson());
  writeNotNull('READ_YN', instance.readYn?.toJson());
  writeNotNull('WRITE_YN', instance.writeYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('UPD_ID', instance.updId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

MENUTBLCreateInput _$MENUTBLCreateInputFromJson(Map<String, dynamic> json) =>
    MENUTBLCreateInput(
      menuId: json['MENU_ID'] as String,
      menuNm: json['MENU_NM'] as String,
      depth: json['DEPTH'] as int,
      sort: json['SORT'] as int,
      ownerId: json['OWNER_ID'] as String?,
      url: json['URL'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      dispYn: json['DISP_YN'] as String?,
      menuIcon: json['MENU_ICON'] as String?,
      memberTbl: json['MEMBER_TBL'] == null
          ? null
          : MEMBERTBLCreateNestedOneWithoutMENUTBLInput.fromJson(
              json['MEMBER_TBL'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$MENUTBLCreateInputToJson(MENUTBLCreateInput instance) {
  final val = <String, dynamic>{
    'MENU_ID': instance.menuId,
    'MENU_NM': instance.menuNm,
    'DEPTH': instance.depth,
    'SORT': instance.sort,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('OWNER_ID', instance.ownerId);
  writeNotNull('URL', instance.url);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull('DISP_YN', instance.dispYn);
  writeNotNull('MENU_ICON', instance.menuIcon);
  writeNotNull('MEMBER_TBL', instance.memberTbl?.toJson());
  return val;
}

MENUTBLUncheckedCreateInput _$MENUTBLUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    MENUTBLUncheckedCreateInput(
      menuId: json['MENU_ID'] as String,
      menuNm: json['MENU_NM'] as String,
      depth: json['DEPTH'] as int,
      sort: json['SORT'] as int,
      ownerId: json['OWNER_ID'] as String?,
      url: json['URL'] as String?,
      writerId: json['WRITER_ID'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      dispYn: json['DISP_YN'] as String?,
      menuIcon: json['MENU_ICON'] as String?,
    );

Map<String, dynamic> _$MENUTBLUncheckedCreateInputToJson(
    MENUTBLUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'MENU_ID': instance.menuId,
    'MENU_NM': instance.menuNm,
    'DEPTH': instance.depth,
    'SORT': instance.sort,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('OWNER_ID', instance.ownerId);
  writeNotNull('URL', instance.url);
  writeNotNull('WRITER_ID', instance.writerId);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull('DISP_YN', instance.dispYn);
  writeNotNull('MENU_ICON', instance.menuIcon);
  return val;
}

MENUTBLUpdateInput _$MENUTBLUpdateInputFromJson(Map<String, dynamic> json) =>
    MENUTBLUpdateInput(
      menuId: json['MENU_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_ID'] as Map<String, dynamic>),
      menuNm: json['MENU_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_NM'] as Map<String, dynamic>),
      depth: json['DEPTH'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['DEPTH'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SORT'] as Map<String, dynamic>),
      ownerId: json['OWNER_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['OWNER_ID'] as Map<String, dynamic>),
      url: json['URL'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['URL'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : NullableDateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      dispYn: json['DISP_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DISP_YN'] as Map<String, dynamic>),
      menuIcon: json['MENU_ICON'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MENU_ICON'] as Map<String, dynamic>),
      memberTbl: json['MEMBER_TBL'] == null
          ? null
          : MEMBERTBLUpdateOneWithoutMENUTBLNestedInput.fromJson(
              json['MEMBER_TBL'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$MENUTBLUpdateInputToJson(MENUTBLUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_ID', instance.menuId?.toJson());
  writeNotNull('MENU_NM', instance.menuNm?.toJson());
  writeNotNull('DEPTH', instance.depth?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('OWNER_ID', instance.ownerId?.toJson());
  writeNotNull('URL', instance.url?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('DISP_YN', instance.dispYn?.toJson());
  writeNotNull('MENU_ICON', instance.menuIcon?.toJson());
  writeNotNull('MEMBER_TBL', instance.memberTbl?.toJson());
  return val;
}

MENUTBLUncheckedUpdateInput _$MENUTBLUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    MENUTBLUncheckedUpdateInput(
      menuId: json['MENU_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_ID'] as Map<String, dynamic>),
      menuNm: json['MENU_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_NM'] as Map<String, dynamic>),
      depth: json['DEPTH'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['DEPTH'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SORT'] as Map<String, dynamic>),
      ownerId: json['OWNER_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['OWNER_ID'] as Map<String, dynamic>),
      url: json['URL'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['URL'] as Map<String, dynamic>),
      writerId: json['WRITER_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['WRITER_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : NullableDateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      dispYn: json['DISP_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DISP_YN'] as Map<String, dynamic>),
      menuIcon: json['MENU_ICON'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MENU_ICON'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$MENUTBLUncheckedUpdateInputToJson(
    MENUTBLUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_ID', instance.menuId?.toJson());
  writeNotNull('MENU_NM', instance.menuNm?.toJson());
  writeNotNull('DEPTH', instance.depth?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('OWNER_ID', instance.ownerId?.toJson());
  writeNotNull('URL', instance.url?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('DISP_YN', instance.dispYn?.toJson());
  writeNotNull('MENU_ICON', instance.menuIcon?.toJson());
  return val;
}

MENUTBLCreateManyInput _$MENUTBLCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    MENUTBLCreateManyInput(
      menuId: json['MENU_ID'] as String,
      menuNm: json['MENU_NM'] as String,
      depth: json['DEPTH'] as int,
      sort: json['SORT'] as int,
      ownerId: json['OWNER_ID'] as String?,
      url: json['URL'] as String?,
      writerId: json['WRITER_ID'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      dispYn: json['DISP_YN'] as String?,
      menuIcon: json['MENU_ICON'] as String?,
    );

Map<String, dynamic> _$MENUTBLCreateManyInputToJson(
    MENUTBLCreateManyInput instance) {
  final val = <String, dynamic>{
    'MENU_ID': instance.menuId,
    'MENU_NM': instance.menuNm,
    'DEPTH': instance.depth,
    'SORT': instance.sort,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('OWNER_ID', instance.ownerId);
  writeNotNull('URL', instance.url);
  writeNotNull('WRITER_ID', instance.writerId);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull('DISP_YN', instance.dispYn);
  writeNotNull('MENU_ICON', instance.menuIcon);
  return val;
}

MENUTBLUpdateManyMutationInput _$MENUTBLUpdateManyMutationInputFromJson(
        Map<String, dynamic> json) =>
    MENUTBLUpdateManyMutationInput(
      menuId: json['MENU_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_ID'] as Map<String, dynamic>),
      menuNm: json['MENU_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_NM'] as Map<String, dynamic>),
      depth: json['DEPTH'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['DEPTH'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SORT'] as Map<String, dynamic>),
      ownerId: json['OWNER_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['OWNER_ID'] as Map<String, dynamic>),
      url: json['URL'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['URL'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : NullableDateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      dispYn: json['DISP_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DISP_YN'] as Map<String, dynamic>),
      menuIcon: json['MENU_ICON'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MENU_ICON'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$MENUTBLUpdateManyMutationInputToJson(
    MENUTBLUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_ID', instance.menuId?.toJson());
  writeNotNull('MENU_NM', instance.menuNm?.toJson());
  writeNotNull('DEPTH', instance.depth?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('OWNER_ID', instance.ownerId?.toJson());
  writeNotNull('URL', instance.url?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('DISP_YN', instance.dispYn?.toJson());
  writeNotNull('MENU_ICON', instance.menuIcon?.toJson());
  return val;
}

MENUTBLUncheckedUpdateManyInput _$MENUTBLUncheckedUpdateManyInputFromJson(
        Map<String, dynamic> json) =>
    MENUTBLUncheckedUpdateManyInput(
      menuId: json['MENU_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_ID'] as Map<String, dynamic>),
      menuNm: json['MENU_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_NM'] as Map<String, dynamic>),
      depth: json['DEPTH'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['DEPTH'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SORT'] as Map<String, dynamic>),
      ownerId: json['OWNER_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['OWNER_ID'] as Map<String, dynamic>),
      url: json['URL'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['URL'] as Map<String, dynamic>),
      writerId: json['WRITER_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['WRITER_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : NullableDateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      dispYn: json['DISP_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DISP_YN'] as Map<String, dynamic>),
      menuIcon: json['MENU_ICON'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MENU_ICON'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$MENUTBLUncheckedUpdateManyInputToJson(
    MENUTBLUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_ID', instance.menuId?.toJson());
  writeNotNull('MENU_NM', instance.menuNm?.toJson());
  writeNotNull('DEPTH', instance.depth?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('OWNER_ID', instance.ownerId?.toJson());
  writeNotNull('URL', instance.url?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('DISP_YN', instance.dispYn?.toJson());
  writeNotNull('MENU_ICON', instance.menuIcon?.toJson());
  return val;
}

OFFICEASSETTBLCreateInput _$OFFICEASSETTBLCreateInputFromJson(
        Map<String, dynamic> json) =>
    OFFICEASSETTBLCreateInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      assetNo: json['ASSET_NO'] as String,
      assetType: json['ASSET_TYPE'] as String,
      seller: json['SELLER'] as String?,
      buyDate: json['BUY_DATE'] as String?,
      modelNo: json['MODEL_NO'] as String?,
      serialNo: json['SERIAL_NO'] as String?,
      amount: json['AMOUNT'] as int?,
      keepYear: (json['KEEP_YEAR'] as num?)?.toDouble(),
      mngDept: json['MNG_DEPT'] as String?,
      assetAccount: json['ASSET_ACCOUNT'] as String?,
      remarks: json['REMARKS'] as String?,
      carryOut: json['CARRY_OUT'] as String?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$OFFICEASSETTBLCreateInputToJson(
    OFFICEASSETTBLCreateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['ASSET_NO'] = instance.assetNo;
  val['ASSET_TYPE'] = instance.assetType;
  writeNotNull('SELLER', instance.seller);
  writeNotNull('BUY_DATE', instance.buyDate);
  writeNotNull('MODEL_NO', instance.modelNo);
  writeNotNull('SERIAL_NO', instance.serialNo);
  writeNotNull('AMOUNT', instance.amount);
  writeNotNull('KEEP_YEAR', instance.keepYear);
  writeNotNull('MNG_DEPT', instance.mngDept);
  writeNotNull('ASSET_ACCOUNT', instance.assetAccount);
  writeNotNull('REMARKS', instance.remarks);
  writeNotNull('CARRY_OUT', instance.carryOut);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

OFFICEASSETTBLUncheckedCreateInput _$OFFICEASSETTBLUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    OFFICEASSETTBLUncheckedCreateInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      assetNo: json['ASSET_NO'] as String,
      assetType: json['ASSET_TYPE'] as String,
      seller: json['SELLER'] as String?,
      buyDate: json['BUY_DATE'] as String?,
      modelNo: json['MODEL_NO'] as String?,
      serialNo: json['SERIAL_NO'] as String?,
      amount: json['AMOUNT'] as int?,
      keepYear: (json['KEEP_YEAR'] as num?)?.toDouble(),
      mngDept: json['MNG_DEPT'] as String?,
      assetAccount: json['ASSET_ACCOUNT'] as String?,
      remarks: json['REMARKS'] as String?,
      carryOut: json['CARRY_OUT'] as String?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$OFFICEASSETTBLUncheckedCreateInputToJson(
    OFFICEASSETTBLUncheckedCreateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['ASSET_NO'] = instance.assetNo;
  val['ASSET_TYPE'] = instance.assetType;
  writeNotNull('SELLER', instance.seller);
  writeNotNull('BUY_DATE', instance.buyDate);
  writeNotNull('MODEL_NO', instance.modelNo);
  writeNotNull('SERIAL_NO', instance.serialNo);
  writeNotNull('AMOUNT', instance.amount);
  writeNotNull('KEEP_YEAR', instance.keepYear);
  writeNotNull('MNG_DEPT', instance.mngDept);
  writeNotNull('ASSET_ACCOUNT', instance.assetAccount);
  writeNotNull('REMARKS', instance.remarks);
  writeNotNull('CARRY_OUT', instance.carryOut);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

OFFICEASSETTBLUpdateInput _$OFFICEASSETTBLUpdateInputFromJson(
        Map<String, dynamic> json) =>
    OFFICEASSETTBLUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      assetNo: json['ASSET_NO'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['ASSET_NO'] as Map<String, dynamic>),
      assetType: json['ASSET_TYPE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['ASSET_TYPE'] as Map<String, dynamic>),
      seller: json['SELLER'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SELLER'] as Map<String, dynamic>),
      buyDate: json['BUY_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['BUY_DATE'] as Map<String, dynamic>),
      modelNo: json['MODEL_NO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MODEL_NO'] as Map<String, dynamic>),
      serialNo: json['SERIAL_NO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SERIAL_NO'] as Map<String, dynamic>),
      amount: json['AMOUNT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['AMOUNT'] as Map<String, dynamic>),
      keepYear: json['KEEP_YEAR'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['KEEP_YEAR'] as Map<String, dynamic>),
      mngDept: json['MNG_DEPT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MNG_DEPT'] as Map<String, dynamic>),
      assetAccount: json['ASSET_ACCOUNT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ASSET_ACCOUNT'] as Map<String, dynamic>),
      remarks: json['REMARKS'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REMARKS'] as Map<String, dynamic>),
      carryOut: json['CARRY_OUT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CARRY_OUT'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : NullableDateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$OFFICEASSETTBLUpdateInputToJson(
    OFFICEASSETTBLUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('ASSET_TYPE', instance.assetType?.toJson());
  writeNotNull('SELLER', instance.seller?.toJson());
  writeNotNull('BUY_DATE', instance.buyDate?.toJson());
  writeNotNull('MODEL_NO', instance.modelNo?.toJson());
  writeNotNull('SERIAL_NO', instance.serialNo?.toJson());
  writeNotNull('AMOUNT', instance.amount?.toJson());
  writeNotNull('KEEP_YEAR', instance.keepYear?.toJson());
  writeNotNull('MNG_DEPT', instance.mngDept?.toJson());
  writeNotNull('ASSET_ACCOUNT', instance.assetAccount?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('CARRY_OUT', instance.carryOut?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

OFFICEASSETTBLUncheckedUpdateInput _$OFFICEASSETTBLUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    OFFICEASSETTBLUncheckedUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      assetNo: json['ASSET_NO'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['ASSET_NO'] as Map<String, dynamic>),
      assetType: json['ASSET_TYPE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['ASSET_TYPE'] as Map<String, dynamic>),
      seller: json['SELLER'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SELLER'] as Map<String, dynamic>),
      buyDate: json['BUY_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['BUY_DATE'] as Map<String, dynamic>),
      modelNo: json['MODEL_NO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MODEL_NO'] as Map<String, dynamic>),
      serialNo: json['SERIAL_NO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SERIAL_NO'] as Map<String, dynamic>),
      amount: json['AMOUNT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['AMOUNT'] as Map<String, dynamic>),
      keepYear: json['KEEP_YEAR'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['KEEP_YEAR'] as Map<String, dynamic>),
      mngDept: json['MNG_DEPT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MNG_DEPT'] as Map<String, dynamic>),
      assetAccount: json['ASSET_ACCOUNT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ASSET_ACCOUNT'] as Map<String, dynamic>),
      remarks: json['REMARKS'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REMARKS'] as Map<String, dynamic>),
      carryOut: json['CARRY_OUT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CARRY_OUT'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : NullableDateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$OFFICEASSETTBLUncheckedUpdateInputToJson(
    OFFICEASSETTBLUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('ASSET_TYPE', instance.assetType?.toJson());
  writeNotNull('SELLER', instance.seller?.toJson());
  writeNotNull('BUY_DATE', instance.buyDate?.toJson());
  writeNotNull('MODEL_NO', instance.modelNo?.toJson());
  writeNotNull('SERIAL_NO', instance.serialNo?.toJson());
  writeNotNull('AMOUNT', instance.amount?.toJson());
  writeNotNull('KEEP_YEAR', instance.keepYear?.toJson());
  writeNotNull('MNG_DEPT', instance.mngDept?.toJson());
  writeNotNull('ASSET_ACCOUNT', instance.assetAccount?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('CARRY_OUT', instance.carryOut?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

OFFICEASSETTBLCreateManyInput _$OFFICEASSETTBLCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    OFFICEASSETTBLCreateManyInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      assetNo: json['ASSET_NO'] as String,
      assetType: json['ASSET_TYPE'] as String,
      seller: json['SELLER'] as String?,
      buyDate: json['BUY_DATE'] as String?,
      modelNo: json['MODEL_NO'] as String?,
      serialNo: json['SERIAL_NO'] as String?,
      amount: json['AMOUNT'] as int?,
      keepYear: (json['KEEP_YEAR'] as num?)?.toDouble(),
      mngDept: json['MNG_DEPT'] as String?,
      assetAccount: json['ASSET_ACCOUNT'] as String?,
      remarks: json['REMARKS'] as String?,
      carryOut: json['CARRY_OUT'] as String?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$OFFICEASSETTBLCreateManyInputToJson(
    OFFICEASSETTBLCreateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['ASSET_NO'] = instance.assetNo;
  val['ASSET_TYPE'] = instance.assetType;
  writeNotNull('SELLER', instance.seller);
  writeNotNull('BUY_DATE', instance.buyDate);
  writeNotNull('MODEL_NO', instance.modelNo);
  writeNotNull('SERIAL_NO', instance.serialNo);
  writeNotNull('AMOUNT', instance.amount);
  writeNotNull('KEEP_YEAR', instance.keepYear);
  writeNotNull('MNG_DEPT', instance.mngDept);
  writeNotNull('ASSET_ACCOUNT', instance.assetAccount);
  writeNotNull('REMARKS', instance.remarks);
  writeNotNull('CARRY_OUT', instance.carryOut);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

OFFICEASSETTBLUpdateManyMutationInput
    _$OFFICEASSETTBLUpdateManyMutationInputFromJson(
            Map<String, dynamic> json) =>
        OFFICEASSETTBLUpdateManyMutationInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          assetNo: json['ASSET_NO'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['ASSET_NO'] as Map<String, dynamic>),
          assetType: json['ASSET_TYPE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['ASSET_TYPE'] as Map<String, dynamic>),
          seller: json['SELLER'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['SELLER'] as Map<String, dynamic>),
          buyDate: json['BUY_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['BUY_DATE'] as Map<String, dynamic>),
          modelNo: json['MODEL_NO'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['MODEL_NO'] as Map<String, dynamic>),
          serialNo: json['SERIAL_NO'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['SERIAL_NO'] as Map<String, dynamic>),
          amount: json['AMOUNT'] == null
              ? null
              : NullableIntFieldUpdateOperationsInput.fromJson(
                  json['AMOUNT'] as Map<String, dynamic>),
          keepYear: json['KEEP_YEAR'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['KEEP_YEAR'] as Map<String, dynamic>),
          mngDept: json['MNG_DEPT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['MNG_DEPT'] as Map<String, dynamic>),
          assetAccount: json['ASSET_ACCOUNT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['ASSET_ACCOUNT'] as Map<String, dynamic>),
          remarks: json['REMARKS'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REMARKS'] as Map<String, dynamic>),
          carryOut: json['CARRY_OUT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CARRY_OUT'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : NullableDateTimeFieldUpdateOperationsInput.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$OFFICEASSETTBLUpdateManyMutationInputToJson(
    OFFICEASSETTBLUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('ASSET_TYPE', instance.assetType?.toJson());
  writeNotNull('SELLER', instance.seller?.toJson());
  writeNotNull('BUY_DATE', instance.buyDate?.toJson());
  writeNotNull('MODEL_NO', instance.modelNo?.toJson());
  writeNotNull('SERIAL_NO', instance.serialNo?.toJson());
  writeNotNull('AMOUNT', instance.amount?.toJson());
  writeNotNull('KEEP_YEAR', instance.keepYear?.toJson());
  writeNotNull('MNG_DEPT', instance.mngDept?.toJson());
  writeNotNull('ASSET_ACCOUNT', instance.assetAccount?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('CARRY_OUT', instance.carryOut?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

OFFICEASSETTBLUncheckedUpdateManyInput
    _$OFFICEASSETTBLUncheckedUpdateManyInputFromJson(
            Map<String, dynamic> json) =>
        OFFICEASSETTBLUncheckedUpdateManyInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          assetNo: json['ASSET_NO'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['ASSET_NO'] as Map<String, dynamic>),
          assetType: json['ASSET_TYPE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['ASSET_TYPE'] as Map<String, dynamic>),
          seller: json['SELLER'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['SELLER'] as Map<String, dynamic>),
          buyDate: json['BUY_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['BUY_DATE'] as Map<String, dynamic>),
          modelNo: json['MODEL_NO'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['MODEL_NO'] as Map<String, dynamic>),
          serialNo: json['SERIAL_NO'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['SERIAL_NO'] as Map<String, dynamic>),
          amount: json['AMOUNT'] == null
              ? null
              : NullableIntFieldUpdateOperationsInput.fromJson(
                  json['AMOUNT'] as Map<String, dynamic>),
          keepYear: json['KEEP_YEAR'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['KEEP_YEAR'] as Map<String, dynamic>),
          mngDept: json['MNG_DEPT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['MNG_DEPT'] as Map<String, dynamic>),
          assetAccount: json['ASSET_ACCOUNT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['ASSET_ACCOUNT'] as Map<String, dynamic>),
          remarks: json['REMARKS'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REMARKS'] as Map<String, dynamic>),
          carryOut: json['CARRY_OUT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CARRY_OUT'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : NullableDateTimeFieldUpdateOperationsInput.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$OFFICEASSETTBLUncheckedUpdateManyInputToJson(
    OFFICEASSETTBLUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('ASSET_TYPE', instance.assetType?.toJson());
  writeNotNull('SELLER', instance.seller?.toJson());
  writeNotNull('BUY_DATE', instance.buyDate?.toJson());
  writeNotNull('MODEL_NO', instance.modelNo?.toJson());
  writeNotNull('SERIAL_NO', instance.serialNo?.toJson());
  writeNotNull('AMOUNT', instance.amount?.toJson());
  writeNotNull('KEEP_YEAR', instance.keepYear?.toJson());
  writeNotNull('MNG_DEPT', instance.mngDept?.toJson());
  writeNotNull('ASSET_ACCOUNT', instance.assetAccount?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('CARRY_OUT', instance.carryOut?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

SERVERASSETTBLCreateInput _$SERVERASSETTBLCreateInputFromJson(
        Map<String, dynamic> json) =>
    SERVERASSETTBLCreateInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      assetNo: json['ASSET_NO'] as String,
      assetType: json['ASSET_TYPE'] as String,
      maker: json['MAKER'] as String?,
      cnt: (json['CNT'] as num?)?.toDouble(),
      amount: json['AMOUNT'] as int?,
      buyDate: json['BUY_DATE'] as String?,
      seller: json['SELLER'] as String?,
      modelNo: json['MODEL_NO'] as String?,
      serialNo: json['SERIAL_NO'] as String?,
      hostname: json['HOSTNAME'] as String?,
      builtLoc: json['BUILT_LOC'] as String?,
      useDesc: json['USE_DESC'] as String?,
      osInfo: json['OS_INFO'] as String?,
      cpuInfo: json['CPU_INFO'] as String?,
      ramInfo: json['RAM_INFO'] as String?,
      hddInfo: json['HDD_INFO'] as String?,
      ssdInfo: json['SSD_INFO'] as String?,
      odd: json['ODD'] as String?,
      remarks: json['REMARKS'] as String?,
      carryOut: json['CARRY_OUT'] as String?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$SERVERASSETTBLCreateInputToJson(
    SERVERASSETTBLCreateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['ASSET_NO'] = instance.assetNo;
  val['ASSET_TYPE'] = instance.assetType;
  writeNotNull('MAKER', instance.maker);
  writeNotNull('CNT', instance.cnt);
  writeNotNull('AMOUNT', instance.amount);
  writeNotNull('BUY_DATE', instance.buyDate);
  writeNotNull('SELLER', instance.seller);
  writeNotNull('MODEL_NO', instance.modelNo);
  writeNotNull('SERIAL_NO', instance.serialNo);
  writeNotNull('HOSTNAME', instance.hostname);
  writeNotNull('BUILT_LOC', instance.builtLoc);
  writeNotNull('USE_DESC', instance.useDesc);
  writeNotNull('OS_INFO', instance.osInfo);
  writeNotNull('CPU_INFO', instance.cpuInfo);
  writeNotNull('RAM_INFO', instance.ramInfo);
  writeNotNull('HDD_INFO', instance.hddInfo);
  writeNotNull('SSD_INFO', instance.ssdInfo);
  writeNotNull('ODD', instance.odd);
  writeNotNull('REMARKS', instance.remarks);
  writeNotNull('CARRY_OUT', instance.carryOut);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

SERVERASSETTBLUncheckedCreateInput _$SERVERASSETTBLUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    SERVERASSETTBLUncheckedCreateInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      assetNo: json['ASSET_NO'] as String,
      assetType: json['ASSET_TYPE'] as String,
      maker: json['MAKER'] as String?,
      cnt: (json['CNT'] as num?)?.toDouble(),
      amount: json['AMOUNT'] as int?,
      buyDate: json['BUY_DATE'] as String?,
      seller: json['SELLER'] as String?,
      modelNo: json['MODEL_NO'] as String?,
      serialNo: json['SERIAL_NO'] as String?,
      hostname: json['HOSTNAME'] as String?,
      builtLoc: json['BUILT_LOC'] as String?,
      useDesc: json['USE_DESC'] as String?,
      osInfo: json['OS_INFO'] as String?,
      cpuInfo: json['CPU_INFO'] as String?,
      ramInfo: json['RAM_INFO'] as String?,
      hddInfo: json['HDD_INFO'] as String?,
      ssdInfo: json['SSD_INFO'] as String?,
      odd: json['ODD'] as String?,
      remarks: json['REMARKS'] as String?,
      carryOut: json['CARRY_OUT'] as String?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$SERVERASSETTBLUncheckedCreateInputToJson(
    SERVERASSETTBLUncheckedCreateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['ASSET_NO'] = instance.assetNo;
  val['ASSET_TYPE'] = instance.assetType;
  writeNotNull('MAKER', instance.maker);
  writeNotNull('CNT', instance.cnt);
  writeNotNull('AMOUNT', instance.amount);
  writeNotNull('BUY_DATE', instance.buyDate);
  writeNotNull('SELLER', instance.seller);
  writeNotNull('MODEL_NO', instance.modelNo);
  writeNotNull('SERIAL_NO', instance.serialNo);
  writeNotNull('HOSTNAME', instance.hostname);
  writeNotNull('BUILT_LOC', instance.builtLoc);
  writeNotNull('USE_DESC', instance.useDesc);
  writeNotNull('OS_INFO', instance.osInfo);
  writeNotNull('CPU_INFO', instance.cpuInfo);
  writeNotNull('RAM_INFO', instance.ramInfo);
  writeNotNull('HDD_INFO', instance.hddInfo);
  writeNotNull('SSD_INFO', instance.ssdInfo);
  writeNotNull('ODD', instance.odd);
  writeNotNull('REMARKS', instance.remarks);
  writeNotNull('CARRY_OUT', instance.carryOut);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

SERVERASSETTBLUpdateInput _$SERVERASSETTBLUpdateInputFromJson(
        Map<String, dynamic> json) =>
    SERVERASSETTBLUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      assetNo: json['ASSET_NO'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['ASSET_NO'] as Map<String, dynamic>),
      assetType: json['ASSET_TYPE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['ASSET_TYPE'] as Map<String, dynamic>),
      maker: json['MAKER'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MAKER'] as Map<String, dynamic>),
      cnt: json['CNT'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['CNT'] as Map<String, dynamic>),
      amount: json['AMOUNT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['AMOUNT'] as Map<String, dynamic>),
      buyDate: json['BUY_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['BUY_DATE'] as Map<String, dynamic>),
      seller: json['SELLER'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SELLER'] as Map<String, dynamic>),
      modelNo: json['MODEL_NO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MODEL_NO'] as Map<String, dynamic>),
      serialNo: json['SERIAL_NO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SERIAL_NO'] as Map<String, dynamic>),
      hostname: json['HOSTNAME'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['HOSTNAME'] as Map<String, dynamic>),
      builtLoc: json['BUILT_LOC'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['BUILT_LOC'] as Map<String, dynamic>),
      useDesc: json['USE_DESC'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USE_DESC'] as Map<String, dynamic>),
      osInfo: json['OS_INFO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['OS_INFO'] as Map<String, dynamic>),
      cpuInfo: json['CPU_INFO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CPU_INFO'] as Map<String, dynamic>),
      ramInfo: json['RAM_INFO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['RAM_INFO'] as Map<String, dynamic>),
      hddInfo: json['HDD_INFO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['HDD_INFO'] as Map<String, dynamic>),
      ssdInfo: json['SSD_INFO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SSD_INFO'] as Map<String, dynamic>),
      odd: json['ODD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ODD'] as Map<String, dynamic>),
      remarks: json['REMARKS'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REMARKS'] as Map<String, dynamic>),
      carryOut: json['CARRY_OUT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CARRY_OUT'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : NullableDateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$SERVERASSETTBLUpdateInputToJson(
    SERVERASSETTBLUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('ASSET_TYPE', instance.assetType?.toJson());
  writeNotNull('MAKER', instance.maker?.toJson());
  writeNotNull('CNT', instance.cnt?.toJson());
  writeNotNull('AMOUNT', instance.amount?.toJson());
  writeNotNull('BUY_DATE', instance.buyDate?.toJson());
  writeNotNull('SELLER', instance.seller?.toJson());
  writeNotNull('MODEL_NO', instance.modelNo?.toJson());
  writeNotNull('SERIAL_NO', instance.serialNo?.toJson());
  writeNotNull('HOSTNAME', instance.hostname?.toJson());
  writeNotNull('BUILT_LOC', instance.builtLoc?.toJson());
  writeNotNull('USE_DESC', instance.useDesc?.toJson());
  writeNotNull('OS_INFO', instance.osInfo?.toJson());
  writeNotNull('CPU_INFO', instance.cpuInfo?.toJson());
  writeNotNull('RAM_INFO', instance.ramInfo?.toJson());
  writeNotNull('HDD_INFO', instance.hddInfo?.toJson());
  writeNotNull('SSD_INFO', instance.ssdInfo?.toJson());
  writeNotNull('ODD', instance.odd?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('CARRY_OUT', instance.carryOut?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

SERVERASSETTBLUncheckedUpdateInput _$SERVERASSETTBLUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    SERVERASSETTBLUncheckedUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      assetNo: json['ASSET_NO'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['ASSET_NO'] as Map<String, dynamic>),
      assetType: json['ASSET_TYPE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['ASSET_TYPE'] as Map<String, dynamic>),
      maker: json['MAKER'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MAKER'] as Map<String, dynamic>),
      cnt: json['CNT'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['CNT'] as Map<String, dynamic>),
      amount: json['AMOUNT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['AMOUNT'] as Map<String, dynamic>),
      buyDate: json['BUY_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['BUY_DATE'] as Map<String, dynamic>),
      seller: json['SELLER'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SELLER'] as Map<String, dynamic>),
      modelNo: json['MODEL_NO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MODEL_NO'] as Map<String, dynamic>),
      serialNo: json['SERIAL_NO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SERIAL_NO'] as Map<String, dynamic>),
      hostname: json['HOSTNAME'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['HOSTNAME'] as Map<String, dynamic>),
      builtLoc: json['BUILT_LOC'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['BUILT_LOC'] as Map<String, dynamic>),
      useDesc: json['USE_DESC'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USE_DESC'] as Map<String, dynamic>),
      osInfo: json['OS_INFO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['OS_INFO'] as Map<String, dynamic>),
      cpuInfo: json['CPU_INFO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CPU_INFO'] as Map<String, dynamic>),
      ramInfo: json['RAM_INFO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['RAM_INFO'] as Map<String, dynamic>),
      hddInfo: json['HDD_INFO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['HDD_INFO'] as Map<String, dynamic>),
      ssdInfo: json['SSD_INFO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SSD_INFO'] as Map<String, dynamic>),
      odd: json['ODD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ODD'] as Map<String, dynamic>),
      remarks: json['REMARKS'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REMARKS'] as Map<String, dynamic>),
      carryOut: json['CARRY_OUT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CARRY_OUT'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : NullableDateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$SERVERASSETTBLUncheckedUpdateInputToJson(
    SERVERASSETTBLUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('ASSET_TYPE', instance.assetType?.toJson());
  writeNotNull('MAKER', instance.maker?.toJson());
  writeNotNull('CNT', instance.cnt?.toJson());
  writeNotNull('AMOUNT', instance.amount?.toJson());
  writeNotNull('BUY_DATE', instance.buyDate?.toJson());
  writeNotNull('SELLER', instance.seller?.toJson());
  writeNotNull('MODEL_NO', instance.modelNo?.toJson());
  writeNotNull('SERIAL_NO', instance.serialNo?.toJson());
  writeNotNull('HOSTNAME', instance.hostname?.toJson());
  writeNotNull('BUILT_LOC', instance.builtLoc?.toJson());
  writeNotNull('USE_DESC', instance.useDesc?.toJson());
  writeNotNull('OS_INFO', instance.osInfo?.toJson());
  writeNotNull('CPU_INFO', instance.cpuInfo?.toJson());
  writeNotNull('RAM_INFO', instance.ramInfo?.toJson());
  writeNotNull('HDD_INFO', instance.hddInfo?.toJson());
  writeNotNull('SSD_INFO', instance.ssdInfo?.toJson());
  writeNotNull('ODD', instance.odd?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('CARRY_OUT', instance.carryOut?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

SERVERASSETTBLCreateManyInput _$SERVERASSETTBLCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    SERVERASSETTBLCreateManyInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      assetNo: json['ASSET_NO'] as String,
      assetType: json['ASSET_TYPE'] as String,
      maker: json['MAKER'] as String?,
      cnt: (json['CNT'] as num?)?.toDouble(),
      amount: json['AMOUNT'] as int?,
      buyDate: json['BUY_DATE'] as String?,
      seller: json['SELLER'] as String?,
      modelNo: json['MODEL_NO'] as String?,
      serialNo: json['SERIAL_NO'] as String?,
      hostname: json['HOSTNAME'] as String?,
      builtLoc: json['BUILT_LOC'] as String?,
      useDesc: json['USE_DESC'] as String?,
      osInfo: json['OS_INFO'] as String?,
      cpuInfo: json['CPU_INFO'] as String?,
      ramInfo: json['RAM_INFO'] as String?,
      hddInfo: json['HDD_INFO'] as String?,
      ssdInfo: json['SSD_INFO'] as String?,
      odd: json['ODD'] as String?,
      remarks: json['REMARKS'] as String?,
      carryOut: json['CARRY_OUT'] as String?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$SERVERASSETTBLCreateManyInputToJson(
    SERVERASSETTBLCreateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['ASSET_NO'] = instance.assetNo;
  val['ASSET_TYPE'] = instance.assetType;
  writeNotNull('MAKER', instance.maker);
  writeNotNull('CNT', instance.cnt);
  writeNotNull('AMOUNT', instance.amount);
  writeNotNull('BUY_DATE', instance.buyDate);
  writeNotNull('SELLER', instance.seller);
  writeNotNull('MODEL_NO', instance.modelNo);
  writeNotNull('SERIAL_NO', instance.serialNo);
  writeNotNull('HOSTNAME', instance.hostname);
  writeNotNull('BUILT_LOC', instance.builtLoc);
  writeNotNull('USE_DESC', instance.useDesc);
  writeNotNull('OS_INFO', instance.osInfo);
  writeNotNull('CPU_INFO', instance.cpuInfo);
  writeNotNull('RAM_INFO', instance.ramInfo);
  writeNotNull('HDD_INFO', instance.hddInfo);
  writeNotNull('SSD_INFO', instance.ssdInfo);
  writeNotNull('ODD', instance.odd);
  writeNotNull('REMARKS', instance.remarks);
  writeNotNull('CARRY_OUT', instance.carryOut);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

SERVERASSETTBLUpdateManyMutationInput
    _$SERVERASSETTBLUpdateManyMutationInputFromJson(
            Map<String, dynamic> json) =>
        SERVERASSETTBLUpdateManyMutationInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          assetNo: json['ASSET_NO'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['ASSET_NO'] as Map<String, dynamic>),
          assetType: json['ASSET_TYPE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['ASSET_TYPE'] as Map<String, dynamic>),
          maker: json['MAKER'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['MAKER'] as Map<String, dynamic>),
          cnt: json['CNT'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['CNT'] as Map<String, dynamic>),
          amount: json['AMOUNT'] == null
              ? null
              : NullableIntFieldUpdateOperationsInput.fromJson(
                  json['AMOUNT'] as Map<String, dynamic>),
          buyDate: json['BUY_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['BUY_DATE'] as Map<String, dynamic>),
          seller: json['SELLER'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['SELLER'] as Map<String, dynamic>),
          modelNo: json['MODEL_NO'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['MODEL_NO'] as Map<String, dynamic>),
          serialNo: json['SERIAL_NO'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['SERIAL_NO'] as Map<String, dynamic>),
          hostname: json['HOSTNAME'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['HOSTNAME'] as Map<String, dynamic>),
          builtLoc: json['BUILT_LOC'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['BUILT_LOC'] as Map<String, dynamic>),
          useDesc: json['USE_DESC'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['USE_DESC'] as Map<String, dynamic>),
          osInfo: json['OS_INFO'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['OS_INFO'] as Map<String, dynamic>),
          cpuInfo: json['CPU_INFO'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CPU_INFO'] as Map<String, dynamic>),
          ramInfo: json['RAM_INFO'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['RAM_INFO'] as Map<String, dynamic>),
          hddInfo: json['HDD_INFO'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['HDD_INFO'] as Map<String, dynamic>),
          ssdInfo: json['SSD_INFO'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['SSD_INFO'] as Map<String, dynamic>),
          odd: json['ODD'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['ODD'] as Map<String, dynamic>),
          remarks: json['REMARKS'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REMARKS'] as Map<String, dynamic>),
          carryOut: json['CARRY_OUT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CARRY_OUT'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : NullableDateTimeFieldUpdateOperationsInput.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$SERVERASSETTBLUpdateManyMutationInputToJson(
    SERVERASSETTBLUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('ASSET_TYPE', instance.assetType?.toJson());
  writeNotNull('MAKER', instance.maker?.toJson());
  writeNotNull('CNT', instance.cnt?.toJson());
  writeNotNull('AMOUNT', instance.amount?.toJson());
  writeNotNull('BUY_DATE', instance.buyDate?.toJson());
  writeNotNull('SELLER', instance.seller?.toJson());
  writeNotNull('MODEL_NO', instance.modelNo?.toJson());
  writeNotNull('SERIAL_NO', instance.serialNo?.toJson());
  writeNotNull('HOSTNAME', instance.hostname?.toJson());
  writeNotNull('BUILT_LOC', instance.builtLoc?.toJson());
  writeNotNull('USE_DESC', instance.useDesc?.toJson());
  writeNotNull('OS_INFO', instance.osInfo?.toJson());
  writeNotNull('CPU_INFO', instance.cpuInfo?.toJson());
  writeNotNull('RAM_INFO', instance.ramInfo?.toJson());
  writeNotNull('HDD_INFO', instance.hddInfo?.toJson());
  writeNotNull('SSD_INFO', instance.ssdInfo?.toJson());
  writeNotNull('ODD', instance.odd?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('CARRY_OUT', instance.carryOut?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

SERVERASSETTBLUncheckedUpdateManyInput
    _$SERVERASSETTBLUncheckedUpdateManyInputFromJson(
            Map<String, dynamic> json) =>
        SERVERASSETTBLUncheckedUpdateManyInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          assetNo: json['ASSET_NO'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['ASSET_NO'] as Map<String, dynamic>),
          assetType: json['ASSET_TYPE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['ASSET_TYPE'] as Map<String, dynamic>),
          maker: json['MAKER'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['MAKER'] as Map<String, dynamic>),
          cnt: json['CNT'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['CNT'] as Map<String, dynamic>),
          amount: json['AMOUNT'] == null
              ? null
              : NullableIntFieldUpdateOperationsInput.fromJson(
                  json['AMOUNT'] as Map<String, dynamic>),
          buyDate: json['BUY_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['BUY_DATE'] as Map<String, dynamic>),
          seller: json['SELLER'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['SELLER'] as Map<String, dynamic>),
          modelNo: json['MODEL_NO'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['MODEL_NO'] as Map<String, dynamic>),
          serialNo: json['SERIAL_NO'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['SERIAL_NO'] as Map<String, dynamic>),
          hostname: json['HOSTNAME'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['HOSTNAME'] as Map<String, dynamic>),
          builtLoc: json['BUILT_LOC'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['BUILT_LOC'] as Map<String, dynamic>),
          useDesc: json['USE_DESC'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['USE_DESC'] as Map<String, dynamic>),
          osInfo: json['OS_INFO'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['OS_INFO'] as Map<String, dynamic>),
          cpuInfo: json['CPU_INFO'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CPU_INFO'] as Map<String, dynamic>),
          ramInfo: json['RAM_INFO'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['RAM_INFO'] as Map<String, dynamic>),
          hddInfo: json['HDD_INFO'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['HDD_INFO'] as Map<String, dynamic>),
          ssdInfo: json['SSD_INFO'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['SSD_INFO'] as Map<String, dynamic>),
          odd: json['ODD'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['ODD'] as Map<String, dynamic>),
          remarks: json['REMARKS'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REMARKS'] as Map<String, dynamic>),
          carryOut: json['CARRY_OUT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CARRY_OUT'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : NullableDateTimeFieldUpdateOperationsInput.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$SERVERASSETTBLUncheckedUpdateManyInputToJson(
    SERVERASSETTBLUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('ASSET_TYPE', instance.assetType?.toJson());
  writeNotNull('MAKER', instance.maker?.toJson());
  writeNotNull('CNT', instance.cnt?.toJson());
  writeNotNull('AMOUNT', instance.amount?.toJson());
  writeNotNull('BUY_DATE', instance.buyDate?.toJson());
  writeNotNull('SELLER', instance.seller?.toJson());
  writeNotNull('MODEL_NO', instance.modelNo?.toJson());
  writeNotNull('SERIAL_NO', instance.serialNo?.toJson());
  writeNotNull('HOSTNAME', instance.hostname?.toJson());
  writeNotNull('BUILT_LOC', instance.builtLoc?.toJson());
  writeNotNull('USE_DESC', instance.useDesc?.toJson());
  writeNotNull('OS_INFO', instance.osInfo?.toJson());
  writeNotNull('CPU_INFO', instance.cpuInfo?.toJson());
  writeNotNull('RAM_INFO', instance.ramInfo?.toJson());
  writeNotNull('HDD_INFO', instance.hddInfo?.toJson());
  writeNotNull('SSD_INFO', instance.ssdInfo?.toJson());
  writeNotNull('ODD', instance.odd?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('CARRY_OUT', instance.carryOut?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

SOFTWAREASSETTBLCreateInput _$SOFTWAREASSETTBLCreateInputFromJson(
        Map<String, dynamic> json) =>
    SOFTWAREASSETTBLCreateInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      assetNo: json['ASSET_NO'] as String,
      softwareNm: json['SOFTWARE_NM'] as String,
      versionNm: json['VERSION_NM'] as String?,
      cnt: (json['CNT'] as num?)?.toDouble(),
      amount: json['AMOUNT'] as int?,
      buyDate: json['BUY_DATE'] as String?,
      serialNo: json['SERIAL_NO'] as String?,
      licenseNo: json['LICENSE_NO'] as String?,
      userNm: json['USER_NM'] as String?,
      remarks: json['REMARKS'] as String?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$SOFTWAREASSETTBLCreateInputToJson(
    SOFTWAREASSETTBLCreateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['ASSET_NO'] = instance.assetNo;
  val['SOFTWARE_NM'] = instance.softwareNm;
  writeNotNull('VERSION_NM', instance.versionNm);
  writeNotNull('CNT', instance.cnt);
  writeNotNull('AMOUNT', instance.amount);
  writeNotNull('BUY_DATE', instance.buyDate);
  writeNotNull('SERIAL_NO', instance.serialNo);
  writeNotNull('LICENSE_NO', instance.licenseNo);
  writeNotNull('USER_NM', instance.userNm);
  writeNotNull('REMARKS', instance.remarks);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

SOFTWAREASSETTBLUncheckedCreateInput
    _$SOFTWAREASSETTBLUncheckedCreateInputFromJson(Map<String, dynamic> json) =>
        SOFTWAREASSETTBLUncheckedCreateInput(
          seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
          assetNo: json['ASSET_NO'] as String,
          softwareNm: json['SOFTWARE_NM'] as String,
          versionNm: json['VERSION_NM'] as String?,
          cnt: (json['CNT'] as num?)?.toDouble(),
          amount: json['AMOUNT'] as int?,
          buyDate: json['BUY_DATE'] as String?,
          serialNo: json['SERIAL_NO'] as String?,
          licenseNo: json['LICENSE_NO'] as String?,
          userNm: json['USER_NM'] as String?,
          remarks: json['REMARKS'] as String?,
          useYn: json['USE_YN'] as String?,
          delYn: json['DEL_YN'] as String?,
          regDate: _$JsonConverterFromJson<String, DateTime>(
              json['REG_DATE'], const DateTimeJsonConverter().fromJson),
          updDate: _$JsonConverterFromJson<String, DateTime>(
              json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
        );

Map<String, dynamic> _$SOFTWAREASSETTBLUncheckedCreateInputToJson(
    SOFTWAREASSETTBLUncheckedCreateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['ASSET_NO'] = instance.assetNo;
  val['SOFTWARE_NM'] = instance.softwareNm;
  writeNotNull('VERSION_NM', instance.versionNm);
  writeNotNull('CNT', instance.cnt);
  writeNotNull('AMOUNT', instance.amount);
  writeNotNull('BUY_DATE', instance.buyDate);
  writeNotNull('SERIAL_NO', instance.serialNo);
  writeNotNull('LICENSE_NO', instance.licenseNo);
  writeNotNull('USER_NM', instance.userNm);
  writeNotNull('REMARKS', instance.remarks);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

SOFTWAREASSETTBLUpdateInput _$SOFTWAREASSETTBLUpdateInputFromJson(
        Map<String, dynamic> json) =>
    SOFTWAREASSETTBLUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      assetNo: json['ASSET_NO'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['ASSET_NO'] as Map<String, dynamic>),
      softwareNm: json['SOFTWARE_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['SOFTWARE_NM'] as Map<String, dynamic>),
      versionNm: json['VERSION_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['VERSION_NM'] as Map<String, dynamic>),
      cnt: json['CNT'] == null
          ? null
          : NullableDecimalFieldUpdateOperationsInput.fromJson(
              json['CNT'] as Map<String, dynamic>),
      amount: json['AMOUNT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['AMOUNT'] as Map<String, dynamic>),
      buyDate: json['BUY_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['BUY_DATE'] as Map<String, dynamic>),
      serialNo: json['SERIAL_NO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SERIAL_NO'] as Map<String, dynamic>),
      licenseNo: json['LICENSE_NO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['LICENSE_NO'] as Map<String, dynamic>),
      userNm: json['USER_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USER_NM'] as Map<String, dynamic>),
      remarks: json['REMARKS'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REMARKS'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : NullableDateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$SOFTWAREASSETTBLUpdateInputToJson(
    SOFTWAREASSETTBLUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('SOFTWARE_NM', instance.softwareNm?.toJson());
  writeNotNull('VERSION_NM', instance.versionNm?.toJson());
  writeNotNull('CNT', instance.cnt?.toJson());
  writeNotNull('AMOUNT', instance.amount?.toJson());
  writeNotNull('BUY_DATE', instance.buyDate?.toJson());
  writeNotNull('SERIAL_NO', instance.serialNo?.toJson());
  writeNotNull('LICENSE_NO', instance.licenseNo?.toJson());
  writeNotNull('USER_NM', instance.userNm?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

SOFTWAREASSETTBLUncheckedUpdateInput
    _$SOFTWAREASSETTBLUncheckedUpdateInputFromJson(Map<String, dynamic> json) =>
        SOFTWAREASSETTBLUncheckedUpdateInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          assetNo: json['ASSET_NO'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['ASSET_NO'] as Map<String, dynamic>),
          softwareNm: json['SOFTWARE_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['SOFTWARE_NM'] as Map<String, dynamic>),
          versionNm: json['VERSION_NM'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['VERSION_NM'] as Map<String, dynamic>),
          cnt: json['CNT'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['CNT'] as Map<String, dynamic>),
          amount: json['AMOUNT'] == null
              ? null
              : NullableIntFieldUpdateOperationsInput.fromJson(
                  json['AMOUNT'] as Map<String, dynamic>),
          buyDate: json['BUY_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['BUY_DATE'] as Map<String, dynamic>),
          serialNo: json['SERIAL_NO'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['SERIAL_NO'] as Map<String, dynamic>),
          licenseNo: json['LICENSE_NO'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['LICENSE_NO'] as Map<String, dynamic>),
          userNm: json['USER_NM'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['USER_NM'] as Map<String, dynamic>),
          remarks: json['REMARKS'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REMARKS'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : NullableDateTimeFieldUpdateOperationsInput.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$SOFTWAREASSETTBLUncheckedUpdateInputToJson(
    SOFTWAREASSETTBLUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('SOFTWARE_NM', instance.softwareNm?.toJson());
  writeNotNull('VERSION_NM', instance.versionNm?.toJson());
  writeNotNull('CNT', instance.cnt?.toJson());
  writeNotNull('AMOUNT', instance.amount?.toJson());
  writeNotNull('BUY_DATE', instance.buyDate?.toJson());
  writeNotNull('SERIAL_NO', instance.serialNo?.toJson());
  writeNotNull('LICENSE_NO', instance.licenseNo?.toJson());
  writeNotNull('USER_NM', instance.userNm?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

SOFTWAREASSETTBLCreateManyInput _$SOFTWAREASSETTBLCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    SOFTWAREASSETTBLCreateManyInput(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      assetNo: json['ASSET_NO'] as String,
      softwareNm: json['SOFTWARE_NM'] as String,
      versionNm: json['VERSION_NM'] as String?,
      cnt: (json['CNT'] as num?)?.toDouble(),
      amount: json['AMOUNT'] as int?,
      buyDate: json['BUY_DATE'] as String?,
      serialNo: json['SERIAL_NO'] as String?,
      licenseNo: json['LICENSE_NO'] as String?,
      userNm: json['USER_NM'] as String?,
      remarks: json['REMARKS'] as String?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$SOFTWAREASSETTBLCreateManyInputToJson(
    SOFTWAREASSETTBLCreateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['ASSET_NO'] = instance.assetNo;
  val['SOFTWARE_NM'] = instance.softwareNm;
  writeNotNull('VERSION_NM', instance.versionNm);
  writeNotNull('CNT', instance.cnt);
  writeNotNull('AMOUNT', instance.amount);
  writeNotNull('BUY_DATE', instance.buyDate);
  writeNotNull('SERIAL_NO', instance.serialNo);
  writeNotNull('LICENSE_NO', instance.licenseNo);
  writeNotNull('USER_NM', instance.userNm);
  writeNotNull('REMARKS', instance.remarks);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

SOFTWAREASSETTBLUpdateManyMutationInput
    _$SOFTWAREASSETTBLUpdateManyMutationInputFromJson(
            Map<String, dynamic> json) =>
        SOFTWAREASSETTBLUpdateManyMutationInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          assetNo: json['ASSET_NO'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['ASSET_NO'] as Map<String, dynamic>),
          softwareNm: json['SOFTWARE_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['SOFTWARE_NM'] as Map<String, dynamic>),
          versionNm: json['VERSION_NM'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['VERSION_NM'] as Map<String, dynamic>),
          cnt: json['CNT'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['CNT'] as Map<String, dynamic>),
          amount: json['AMOUNT'] == null
              ? null
              : NullableIntFieldUpdateOperationsInput.fromJson(
                  json['AMOUNT'] as Map<String, dynamic>),
          buyDate: json['BUY_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['BUY_DATE'] as Map<String, dynamic>),
          serialNo: json['SERIAL_NO'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['SERIAL_NO'] as Map<String, dynamic>),
          licenseNo: json['LICENSE_NO'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['LICENSE_NO'] as Map<String, dynamic>),
          userNm: json['USER_NM'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['USER_NM'] as Map<String, dynamic>),
          remarks: json['REMARKS'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REMARKS'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : NullableDateTimeFieldUpdateOperationsInput.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$SOFTWAREASSETTBLUpdateManyMutationInputToJson(
    SOFTWAREASSETTBLUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('SOFTWARE_NM', instance.softwareNm?.toJson());
  writeNotNull('VERSION_NM', instance.versionNm?.toJson());
  writeNotNull('CNT', instance.cnt?.toJson());
  writeNotNull('AMOUNT', instance.amount?.toJson());
  writeNotNull('BUY_DATE', instance.buyDate?.toJson());
  writeNotNull('SERIAL_NO', instance.serialNo?.toJson());
  writeNotNull('LICENSE_NO', instance.licenseNo?.toJson());
  writeNotNull('USER_NM', instance.userNm?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

SOFTWAREASSETTBLUncheckedUpdateManyInput
    _$SOFTWAREASSETTBLUncheckedUpdateManyInputFromJson(
            Map<String, dynamic> json) =>
        SOFTWAREASSETTBLUncheckedUpdateManyInput(
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          assetNo: json['ASSET_NO'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['ASSET_NO'] as Map<String, dynamic>),
          softwareNm: json['SOFTWARE_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['SOFTWARE_NM'] as Map<String, dynamic>),
          versionNm: json['VERSION_NM'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['VERSION_NM'] as Map<String, dynamic>),
          cnt: json['CNT'] == null
              ? null
              : NullableDecimalFieldUpdateOperationsInput.fromJson(
                  json['CNT'] as Map<String, dynamic>),
          amount: json['AMOUNT'] == null
              ? null
              : NullableIntFieldUpdateOperationsInput.fromJson(
                  json['AMOUNT'] as Map<String, dynamic>),
          buyDate: json['BUY_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['BUY_DATE'] as Map<String, dynamic>),
          serialNo: json['SERIAL_NO'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['SERIAL_NO'] as Map<String, dynamic>),
          licenseNo: json['LICENSE_NO'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['LICENSE_NO'] as Map<String, dynamic>),
          userNm: json['USER_NM'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['USER_NM'] as Map<String, dynamic>),
          remarks: json['REMARKS'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REMARKS'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : NullableDateTimeFieldUpdateOperationsInput.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$SOFTWAREASSETTBLUncheckedUpdateManyInputToJson(
    SOFTWAREASSETTBLUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('ASSET_NO', instance.assetNo?.toJson());
  writeNotNull('SOFTWARE_NM', instance.softwareNm?.toJson());
  writeNotNull('VERSION_NM', instance.versionNm?.toJson());
  writeNotNull('CNT', instance.cnt?.toJson());
  writeNotNull('AMOUNT', instance.amount?.toJson());
  writeNotNull('BUY_DATE', instance.buyDate?.toJson());
  writeNotNull('SERIAL_NO', instance.serialNo?.toJson());
  writeNotNull('LICENSE_NO', instance.licenseNo?.toJson());
  writeNotNull('USER_NM', instance.userNm?.toJson());
  writeNotNull('REMARKS', instance.remarks?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  return val;
}

STADMINMENUCreateInput _$STADMINMENUCreateInputFromJson(
        Map<String, dynamic> json) =>
    STADMINMENUCreateInput(
      menuCd: json['MENU_CD'] as String,
      menuNm: json['MENU_NM'] as String,
      menuPath: json['MENU_PATH'] as String?,
      menuSrt: json['MENU_SRT'] as int,
      menuDeps: json['MENU_DEPS'] as int,
      menuIcon: json['MENU_ICON'] as String?,
      menuTp: json['MENU_TP'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STADMINMENUCreateInputToJson(
    STADMINMENUCreateInput instance) {
  final val = <String, dynamic>{
    'MENU_CD': instance.menuCd,
    'MENU_NM': instance.menuNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_PATH', instance.menuPath);
  val['MENU_SRT'] = instance.menuSrt;
  val['MENU_DEPS'] = instance.menuDeps;
  writeNotNull('MENU_ICON', instance.menuIcon);
  writeNotNull('MENU_TP', instance.menuTp);
  val['REG_ID'] = instance.regId;
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STADMINMENUUncheckedCreateInput _$STADMINMENUUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    STADMINMENUUncheckedCreateInput(
      menuCd: json['MENU_CD'] as String,
      menuNm: json['MENU_NM'] as String,
      menuPath: json['MENU_PATH'] as String?,
      menuSrt: json['MENU_SRT'] as int,
      menuDeps: json['MENU_DEPS'] as int,
      menuIcon: json['MENU_ICON'] as String?,
      menuTp: json['MENU_TP'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STADMINMENUUncheckedCreateInputToJson(
    STADMINMENUUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'MENU_CD': instance.menuCd,
    'MENU_NM': instance.menuNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_PATH', instance.menuPath);
  val['MENU_SRT'] = instance.menuSrt;
  val['MENU_DEPS'] = instance.menuDeps;
  writeNotNull('MENU_ICON', instance.menuIcon);
  writeNotNull('MENU_TP', instance.menuTp);
  val['REG_ID'] = instance.regId;
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STADMINMENUUpdateInput _$STADMINMENUUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STADMINMENUUpdateInput(
      menuCd: json['MENU_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_CD'] as Map<String, dynamic>),
      menuNm: json['MENU_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_NM'] as Map<String, dynamic>),
      menuPath: json['MENU_PATH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MENU_PATH'] as Map<String, dynamic>),
      menuSrt: json['MENU_SRT'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['MENU_SRT'] as Map<String, dynamic>),
      menuDeps: json['MENU_DEPS'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['MENU_DEPS'] as Map<String, dynamic>),
      menuIcon: json['MENU_ICON'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MENU_ICON'] as Map<String, dynamic>),
      menuTp: json['MENU_TP'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_TP'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STADMINMENUUpdateInputToJson(
    STADMINMENUUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_CD', instance.menuCd?.toJson());
  writeNotNull('MENU_NM', instance.menuNm?.toJson());
  writeNotNull('MENU_PATH', instance.menuPath?.toJson());
  writeNotNull('MENU_SRT', instance.menuSrt?.toJson());
  writeNotNull('MENU_DEPS', instance.menuDeps?.toJson());
  writeNotNull('MENU_ICON', instance.menuIcon?.toJson());
  writeNotNull('MENU_TP', instance.menuTp?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STADMINMENUUncheckedUpdateInput _$STADMINMENUUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STADMINMENUUncheckedUpdateInput(
      menuCd: json['MENU_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_CD'] as Map<String, dynamic>),
      menuNm: json['MENU_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_NM'] as Map<String, dynamic>),
      menuPath: json['MENU_PATH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MENU_PATH'] as Map<String, dynamic>),
      menuSrt: json['MENU_SRT'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['MENU_SRT'] as Map<String, dynamic>),
      menuDeps: json['MENU_DEPS'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['MENU_DEPS'] as Map<String, dynamic>),
      menuIcon: json['MENU_ICON'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MENU_ICON'] as Map<String, dynamic>),
      menuTp: json['MENU_TP'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_TP'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STADMINMENUUncheckedUpdateInputToJson(
    STADMINMENUUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_CD', instance.menuCd?.toJson());
  writeNotNull('MENU_NM', instance.menuNm?.toJson());
  writeNotNull('MENU_PATH', instance.menuPath?.toJson());
  writeNotNull('MENU_SRT', instance.menuSrt?.toJson());
  writeNotNull('MENU_DEPS', instance.menuDeps?.toJson());
  writeNotNull('MENU_ICON', instance.menuIcon?.toJson());
  writeNotNull('MENU_TP', instance.menuTp?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STADMINMENUCreateManyInput _$STADMINMENUCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    STADMINMENUCreateManyInput(
      menuCd: json['MENU_CD'] as String,
      menuNm: json['MENU_NM'] as String,
      menuPath: json['MENU_PATH'] as String?,
      menuSrt: json['MENU_SRT'] as int,
      menuDeps: json['MENU_DEPS'] as int,
      menuIcon: json['MENU_ICON'] as String?,
      menuTp: json['MENU_TP'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STADMINMENUCreateManyInputToJson(
    STADMINMENUCreateManyInput instance) {
  final val = <String, dynamic>{
    'MENU_CD': instance.menuCd,
    'MENU_NM': instance.menuNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_PATH', instance.menuPath);
  val['MENU_SRT'] = instance.menuSrt;
  val['MENU_DEPS'] = instance.menuDeps;
  writeNotNull('MENU_ICON', instance.menuIcon);
  writeNotNull('MENU_TP', instance.menuTp);
  val['REG_ID'] = instance.regId;
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STADMINMENUUpdateManyMutationInput _$STADMINMENUUpdateManyMutationInputFromJson(
        Map<String, dynamic> json) =>
    STADMINMENUUpdateManyMutationInput(
      menuCd: json['MENU_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_CD'] as Map<String, dynamic>),
      menuNm: json['MENU_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_NM'] as Map<String, dynamic>),
      menuPath: json['MENU_PATH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MENU_PATH'] as Map<String, dynamic>),
      menuSrt: json['MENU_SRT'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['MENU_SRT'] as Map<String, dynamic>),
      menuDeps: json['MENU_DEPS'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['MENU_DEPS'] as Map<String, dynamic>),
      menuIcon: json['MENU_ICON'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MENU_ICON'] as Map<String, dynamic>),
      menuTp: json['MENU_TP'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_TP'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STADMINMENUUpdateManyMutationInputToJson(
    STADMINMENUUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_CD', instance.menuCd?.toJson());
  writeNotNull('MENU_NM', instance.menuNm?.toJson());
  writeNotNull('MENU_PATH', instance.menuPath?.toJson());
  writeNotNull('MENU_SRT', instance.menuSrt?.toJson());
  writeNotNull('MENU_DEPS', instance.menuDeps?.toJson());
  writeNotNull('MENU_ICON', instance.menuIcon?.toJson());
  writeNotNull('MENU_TP', instance.menuTp?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STADMINMENUUncheckedUpdateManyInput
    _$STADMINMENUUncheckedUpdateManyInputFromJson(Map<String, dynamic> json) =>
        STADMINMENUUncheckedUpdateManyInput(
          menuCd: json['MENU_CD'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['MENU_CD'] as Map<String, dynamic>),
          menuNm: json['MENU_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['MENU_NM'] as Map<String, dynamic>),
          menuPath: json['MENU_PATH'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['MENU_PATH'] as Map<String, dynamic>),
          menuSrt: json['MENU_SRT'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['MENU_SRT'] as Map<String, dynamic>),
          menuDeps: json['MENU_DEPS'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['MENU_DEPS'] as Map<String, dynamic>),
          menuIcon: json['MENU_ICON'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['MENU_ICON'] as Map<String, dynamic>),
          menuTp: json['MENU_TP'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['MENU_TP'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delId: json['DEL_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_ID'] as Map<String, dynamic>),
          delDate: json['DEL_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STADMINMENUUncheckedUpdateManyInputToJson(
    STADMINMENUUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_CD', instance.menuCd?.toJson());
  writeNotNull('MENU_NM', instance.menuNm?.toJson());
  writeNotNull('MENU_PATH', instance.menuPath?.toJson());
  writeNotNull('MENU_SRT', instance.menuSrt?.toJson());
  writeNotNull('MENU_DEPS', instance.menuDeps?.toJson());
  writeNotNull('MENU_ICON', instance.menuIcon?.toJson());
  writeNotNull('MENU_TP', instance.menuTp?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STALARMCreateInput _$STALARMCreateInputFromJson(Map<String, dynamic> json) =>
    STALARMCreateInput(
      seq: json['SEQ'] as int,
      msgCd: json['MSG_CD'] as String?,
      msgCnts: json['MSG_CNTS'] as String?,
      sendDate: json['SEND_DATE'] as String?,
      sendDiv: json['SEND_DIV'] as String?,
      sendDeptCd: json['SEND_DEPT_CD'] as String?,
      sendId: json['SEND_ID'] as String?,
      recvId: json['RECV_ID'] as String?,
      popYn: json['POP_YN'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
    );

Map<String, dynamic> _$STALARMCreateInputToJson(STALARMCreateInput instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MSG_CD', instance.msgCd);
  writeNotNull('MSG_CNTS', instance.msgCnts);
  writeNotNull('SEND_DATE', instance.sendDate);
  writeNotNull('SEND_DIV', instance.sendDiv);
  writeNotNull('SEND_DEPT_CD', instance.sendDeptCd);
  writeNotNull('SEND_ID', instance.sendId);
  writeNotNull('RECV_ID', instance.recvId);
  writeNotNull('POP_YN', instance.popYn);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  return val;
}

STALARMUncheckedCreateInput _$STALARMUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    STALARMUncheckedCreateInput(
      seq: json['SEQ'] as int,
      msgCd: json['MSG_CD'] as String?,
      msgCnts: json['MSG_CNTS'] as String?,
      sendDate: json['SEND_DATE'] as String?,
      sendDiv: json['SEND_DIV'] as String?,
      sendDeptCd: json['SEND_DEPT_CD'] as String?,
      sendId: json['SEND_ID'] as String?,
      recvId: json['RECV_ID'] as String?,
      popYn: json['POP_YN'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
    );

Map<String, dynamic> _$STALARMUncheckedCreateInputToJson(
    STALARMUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MSG_CD', instance.msgCd);
  writeNotNull('MSG_CNTS', instance.msgCnts);
  writeNotNull('SEND_DATE', instance.sendDate);
  writeNotNull('SEND_DIV', instance.sendDiv);
  writeNotNull('SEND_DEPT_CD', instance.sendDeptCd);
  writeNotNull('SEND_ID', instance.sendId);
  writeNotNull('RECV_ID', instance.recvId);
  writeNotNull('POP_YN', instance.popYn);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  return val;
}

STALARMUpdateInput _$STALARMUpdateInputFromJson(Map<String, dynamic> json) =>
    STALARMUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      msgCd: json['MSG_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MSG_CD'] as Map<String, dynamic>),
      msgCnts: json['MSG_CNTS'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MSG_CNTS'] as Map<String, dynamic>),
      sendDate: json['SEND_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SEND_DATE'] as Map<String, dynamic>),
      sendDiv: json['SEND_DIV'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SEND_DIV'] as Map<String, dynamic>),
      sendDeptCd: json['SEND_DEPT_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SEND_DEPT_CD'] as Map<String, dynamic>),
      sendId: json['SEND_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SEND_ID'] as Map<String, dynamic>),
      recvId: json['RECV_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['RECV_ID'] as Map<String, dynamic>),
      popYn: json['POP_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['POP_YN'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STALARMUpdateInputToJson(STALARMUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSG_CD', instance.msgCd?.toJson());
  writeNotNull('MSG_CNTS', instance.msgCnts?.toJson());
  writeNotNull('SEND_DATE', instance.sendDate?.toJson());
  writeNotNull('SEND_DIV', instance.sendDiv?.toJson());
  writeNotNull('SEND_DEPT_CD', instance.sendDeptCd?.toJson());
  writeNotNull('SEND_ID', instance.sendId?.toJson());
  writeNotNull('RECV_ID', instance.recvId?.toJson());
  writeNotNull('POP_YN', instance.popYn?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  return val;
}

STALARMUncheckedUpdateInput _$STALARMUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STALARMUncheckedUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      msgCd: json['MSG_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MSG_CD'] as Map<String, dynamic>),
      msgCnts: json['MSG_CNTS'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MSG_CNTS'] as Map<String, dynamic>),
      sendDate: json['SEND_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SEND_DATE'] as Map<String, dynamic>),
      sendDiv: json['SEND_DIV'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SEND_DIV'] as Map<String, dynamic>),
      sendDeptCd: json['SEND_DEPT_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SEND_DEPT_CD'] as Map<String, dynamic>),
      sendId: json['SEND_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SEND_ID'] as Map<String, dynamic>),
      recvId: json['RECV_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['RECV_ID'] as Map<String, dynamic>),
      popYn: json['POP_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['POP_YN'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STALARMUncheckedUpdateInputToJson(
    STALARMUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSG_CD', instance.msgCd?.toJson());
  writeNotNull('MSG_CNTS', instance.msgCnts?.toJson());
  writeNotNull('SEND_DATE', instance.sendDate?.toJson());
  writeNotNull('SEND_DIV', instance.sendDiv?.toJson());
  writeNotNull('SEND_DEPT_CD', instance.sendDeptCd?.toJson());
  writeNotNull('SEND_ID', instance.sendId?.toJson());
  writeNotNull('RECV_ID', instance.recvId?.toJson());
  writeNotNull('POP_YN', instance.popYn?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  return val;
}

STALARMCreateManyInput _$STALARMCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    STALARMCreateManyInput(
      seq: json['SEQ'] as int,
      msgCd: json['MSG_CD'] as String?,
      msgCnts: json['MSG_CNTS'] as String?,
      sendDate: json['SEND_DATE'] as String?,
      sendDiv: json['SEND_DIV'] as String?,
      sendDeptCd: json['SEND_DEPT_CD'] as String?,
      sendId: json['SEND_ID'] as String?,
      recvId: json['RECV_ID'] as String?,
      popYn: json['POP_YN'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
    );

Map<String, dynamic> _$STALARMCreateManyInputToJson(
    STALARMCreateManyInput instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MSG_CD', instance.msgCd);
  writeNotNull('MSG_CNTS', instance.msgCnts);
  writeNotNull('SEND_DATE', instance.sendDate);
  writeNotNull('SEND_DIV', instance.sendDiv);
  writeNotNull('SEND_DEPT_CD', instance.sendDeptCd);
  writeNotNull('SEND_ID', instance.sendId);
  writeNotNull('RECV_ID', instance.recvId);
  writeNotNull('POP_YN', instance.popYn);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  return val;
}

STALARMUpdateManyMutationInput _$STALARMUpdateManyMutationInputFromJson(
        Map<String, dynamic> json) =>
    STALARMUpdateManyMutationInput(
      seq: json['SEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      msgCd: json['MSG_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MSG_CD'] as Map<String, dynamic>),
      msgCnts: json['MSG_CNTS'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MSG_CNTS'] as Map<String, dynamic>),
      sendDate: json['SEND_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SEND_DATE'] as Map<String, dynamic>),
      sendDiv: json['SEND_DIV'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SEND_DIV'] as Map<String, dynamic>),
      sendDeptCd: json['SEND_DEPT_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SEND_DEPT_CD'] as Map<String, dynamic>),
      sendId: json['SEND_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SEND_ID'] as Map<String, dynamic>),
      recvId: json['RECV_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['RECV_ID'] as Map<String, dynamic>),
      popYn: json['POP_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['POP_YN'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STALARMUpdateManyMutationInputToJson(
    STALARMUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSG_CD', instance.msgCd?.toJson());
  writeNotNull('MSG_CNTS', instance.msgCnts?.toJson());
  writeNotNull('SEND_DATE', instance.sendDate?.toJson());
  writeNotNull('SEND_DIV', instance.sendDiv?.toJson());
  writeNotNull('SEND_DEPT_CD', instance.sendDeptCd?.toJson());
  writeNotNull('SEND_ID', instance.sendId?.toJson());
  writeNotNull('RECV_ID', instance.recvId?.toJson());
  writeNotNull('POP_YN', instance.popYn?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  return val;
}

STALARMUncheckedUpdateManyInput _$STALARMUncheckedUpdateManyInputFromJson(
        Map<String, dynamic> json) =>
    STALARMUncheckedUpdateManyInput(
      seq: json['SEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      msgCd: json['MSG_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MSG_CD'] as Map<String, dynamic>),
      msgCnts: json['MSG_CNTS'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MSG_CNTS'] as Map<String, dynamic>),
      sendDate: json['SEND_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SEND_DATE'] as Map<String, dynamic>),
      sendDiv: json['SEND_DIV'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SEND_DIV'] as Map<String, dynamic>),
      sendDeptCd: json['SEND_DEPT_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SEND_DEPT_CD'] as Map<String, dynamic>),
      sendId: json['SEND_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SEND_ID'] as Map<String, dynamic>),
      recvId: json['RECV_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['RECV_ID'] as Map<String, dynamic>),
      popYn: json['POP_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['POP_YN'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STALARMUncheckedUpdateManyInputToJson(
    STALARMUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSG_CD', instance.msgCd?.toJson());
  writeNotNull('MSG_CNTS', instance.msgCnts?.toJson());
  writeNotNull('SEND_DATE', instance.sendDate?.toJson());
  writeNotNull('SEND_DIV', instance.sendDiv?.toJson());
  writeNotNull('SEND_DEPT_CD', instance.sendDeptCd?.toJson());
  writeNotNull('SEND_ID', instance.sendId?.toJson());
  writeNotNull('RECV_ID', instance.recvId?.toJson());
  writeNotNull('POP_YN', instance.popYn?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  return val;
}

STAUDITLOGCreateInput _$STAUDITLOGCreateInputFromJson(
        Map<String, dynamic> json) =>
    STAUDITLOGCreateInput(
      seq: json['SEQ'] as int,
      logCode: json['LOG_CODE'] as String,
      logCnts: json['LOG_CNTS'] as String,
      errCode: json['ERR_CODE'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STAUDITLOGCreateInputToJson(
    STAUDITLOGCreateInput instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'LOG_CODE': instance.logCode,
    'LOG_CNTS': instance.logCnts,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('ERR_CODE', instance.errCode);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STAUDITLOGUncheckedCreateInput _$STAUDITLOGUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    STAUDITLOGUncheckedCreateInput(
      seq: json['SEQ'] as int,
      logCode: json['LOG_CODE'] as String,
      logCnts: json['LOG_CNTS'] as String,
      errCode: json['ERR_CODE'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STAUDITLOGUncheckedCreateInputToJson(
    STAUDITLOGUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'LOG_CODE': instance.logCode,
    'LOG_CNTS': instance.logCnts,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('ERR_CODE', instance.errCode);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STAUDITLOGUpdateInput _$STAUDITLOGUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STAUDITLOGUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      logCode: json['LOG_CODE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['LOG_CODE'] as Map<String, dynamic>),
      logCnts: json['LOG_CNTS'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['LOG_CNTS'] as Map<String, dynamic>),
      errCode: json['ERR_CODE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ERR_CODE'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STAUDITLOGUpdateInputToJson(
    STAUDITLOGUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('LOG_CODE', instance.logCode?.toJson());
  writeNotNull('LOG_CNTS', instance.logCnts?.toJson());
  writeNotNull('ERR_CODE', instance.errCode?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STAUDITLOGUncheckedUpdateInput _$STAUDITLOGUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STAUDITLOGUncheckedUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      logCode: json['LOG_CODE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['LOG_CODE'] as Map<String, dynamic>),
      logCnts: json['LOG_CNTS'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['LOG_CNTS'] as Map<String, dynamic>),
      errCode: json['ERR_CODE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ERR_CODE'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STAUDITLOGUncheckedUpdateInputToJson(
    STAUDITLOGUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('LOG_CODE', instance.logCode?.toJson());
  writeNotNull('LOG_CNTS', instance.logCnts?.toJson());
  writeNotNull('ERR_CODE', instance.errCode?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STAUDITLOGCreateManyInput _$STAUDITLOGCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    STAUDITLOGCreateManyInput(
      seq: json['SEQ'] as int,
      logCode: json['LOG_CODE'] as String,
      logCnts: json['LOG_CNTS'] as String,
      errCode: json['ERR_CODE'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STAUDITLOGCreateManyInputToJson(
    STAUDITLOGCreateManyInput instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'LOG_CODE': instance.logCode,
    'LOG_CNTS': instance.logCnts,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('ERR_CODE', instance.errCode);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STAUDITLOGUpdateManyMutationInput _$STAUDITLOGUpdateManyMutationInputFromJson(
        Map<String, dynamic> json) =>
    STAUDITLOGUpdateManyMutationInput(
      seq: json['SEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      logCode: json['LOG_CODE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['LOG_CODE'] as Map<String, dynamic>),
      logCnts: json['LOG_CNTS'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['LOG_CNTS'] as Map<String, dynamic>),
      errCode: json['ERR_CODE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ERR_CODE'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STAUDITLOGUpdateManyMutationInputToJson(
    STAUDITLOGUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('LOG_CODE', instance.logCode?.toJson());
  writeNotNull('LOG_CNTS', instance.logCnts?.toJson());
  writeNotNull('ERR_CODE', instance.errCode?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STAUDITLOGUncheckedUpdateManyInput _$STAUDITLOGUncheckedUpdateManyInputFromJson(
        Map<String, dynamic> json) =>
    STAUDITLOGUncheckedUpdateManyInput(
      seq: json['SEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      logCode: json['LOG_CODE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['LOG_CODE'] as Map<String, dynamic>),
      logCnts: json['LOG_CNTS'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['LOG_CNTS'] as Map<String, dynamic>),
      errCode: json['ERR_CODE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ERR_CODE'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STAUDITLOGUncheckedUpdateManyInputToJson(
    STAUDITLOGUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('LOG_CODE', instance.logCode?.toJson());
  writeNotNull('LOG_CNTS', instance.logCnts?.toJson());
  writeNotNull('ERR_CODE', instance.errCode?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STBANNERCreateInput _$STBANNERCreateInputFromJson(Map<String, dynamic> json) =>
    STBANNERCreateInput(
      bannerCd: json['BANNER_CD'] as String,
      lkUrl: json['LK_URL'] as String?,
      lkTarget: json['LK_TARGET'] as String?,
      flpth: json['FLPTH'] as String?,
      fileNm: json['FILE_NM'] as String?,
      useYn: json['USE_YN'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STBANNERCreateInputToJson(STBANNERCreateInput instance) {
  final val = <String, dynamic>{
    'BANNER_CD': instance.bannerCd,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('LK_URL', instance.lkUrl);
  writeNotNull('LK_TARGET', instance.lkTarget);
  writeNotNull('FLPTH', instance.flpth);
  writeNotNull('FILE_NM', instance.fileNm);
  writeNotNull('USE_YN', instance.useYn);
  val['REG_ID'] = instance.regId;
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STBANNERUncheckedCreateInput _$STBANNERUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    STBANNERUncheckedCreateInput(
      bannerCd: json['BANNER_CD'] as String,
      lkUrl: json['LK_URL'] as String?,
      lkTarget: json['LK_TARGET'] as String?,
      flpth: json['FLPTH'] as String?,
      fileNm: json['FILE_NM'] as String?,
      useYn: json['USE_YN'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STBANNERUncheckedCreateInputToJson(
    STBANNERUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'BANNER_CD': instance.bannerCd,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('LK_URL', instance.lkUrl);
  writeNotNull('LK_TARGET', instance.lkTarget);
  writeNotNull('FLPTH', instance.flpth);
  writeNotNull('FILE_NM', instance.fileNm);
  writeNotNull('USE_YN', instance.useYn);
  val['REG_ID'] = instance.regId;
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STBANNERUpdateInput _$STBANNERUpdateInputFromJson(Map<String, dynamic> json) =>
    STBANNERUpdateInput(
      bannerCd: json['BANNER_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['BANNER_CD'] as Map<String, dynamic>),
      lkUrl: json['LK_URL'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['LK_URL'] as Map<String, dynamic>),
      lkTarget: json['LK_TARGET'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['LK_TARGET'] as Map<String, dynamic>),
      flpth: json['FLPTH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FLPTH'] as Map<String, dynamic>),
      fileNm: json['FILE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FILE_NM'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STBANNERUpdateInputToJson(STBANNERUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BANNER_CD', instance.bannerCd?.toJson());
  writeNotNull('LK_URL', instance.lkUrl?.toJson());
  writeNotNull('LK_TARGET', instance.lkTarget?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('FILE_NM', instance.fileNm?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STBANNERUncheckedUpdateInput _$STBANNERUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STBANNERUncheckedUpdateInput(
      bannerCd: json['BANNER_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['BANNER_CD'] as Map<String, dynamic>),
      lkUrl: json['LK_URL'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['LK_URL'] as Map<String, dynamic>),
      lkTarget: json['LK_TARGET'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['LK_TARGET'] as Map<String, dynamic>),
      flpth: json['FLPTH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FLPTH'] as Map<String, dynamic>),
      fileNm: json['FILE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FILE_NM'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STBANNERUncheckedUpdateInputToJson(
    STBANNERUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BANNER_CD', instance.bannerCd?.toJson());
  writeNotNull('LK_URL', instance.lkUrl?.toJson());
  writeNotNull('LK_TARGET', instance.lkTarget?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('FILE_NM', instance.fileNm?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STBANNERCreateManyInput _$STBANNERCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    STBANNERCreateManyInput(
      bannerCd: json['BANNER_CD'] as String,
      lkUrl: json['LK_URL'] as String?,
      lkTarget: json['LK_TARGET'] as String?,
      flpth: json['FLPTH'] as String?,
      fileNm: json['FILE_NM'] as String?,
      useYn: json['USE_YN'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STBANNERCreateManyInputToJson(
    STBANNERCreateManyInput instance) {
  final val = <String, dynamic>{
    'BANNER_CD': instance.bannerCd,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('LK_URL', instance.lkUrl);
  writeNotNull('LK_TARGET', instance.lkTarget);
  writeNotNull('FLPTH', instance.flpth);
  writeNotNull('FILE_NM', instance.fileNm);
  writeNotNull('USE_YN', instance.useYn);
  val['REG_ID'] = instance.regId;
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STBANNERUpdateManyMutationInput _$STBANNERUpdateManyMutationInputFromJson(
        Map<String, dynamic> json) =>
    STBANNERUpdateManyMutationInput(
      bannerCd: json['BANNER_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['BANNER_CD'] as Map<String, dynamic>),
      lkUrl: json['LK_URL'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['LK_URL'] as Map<String, dynamic>),
      lkTarget: json['LK_TARGET'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['LK_TARGET'] as Map<String, dynamic>),
      flpth: json['FLPTH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FLPTH'] as Map<String, dynamic>),
      fileNm: json['FILE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FILE_NM'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STBANNERUpdateManyMutationInputToJson(
    STBANNERUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BANNER_CD', instance.bannerCd?.toJson());
  writeNotNull('LK_URL', instance.lkUrl?.toJson());
  writeNotNull('LK_TARGET', instance.lkTarget?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('FILE_NM', instance.fileNm?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STBANNERUncheckedUpdateManyInput _$STBANNERUncheckedUpdateManyInputFromJson(
        Map<String, dynamic> json) =>
    STBANNERUncheckedUpdateManyInput(
      bannerCd: json['BANNER_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['BANNER_CD'] as Map<String, dynamic>),
      lkUrl: json['LK_URL'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['LK_URL'] as Map<String, dynamic>),
      lkTarget: json['LK_TARGET'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['LK_TARGET'] as Map<String, dynamic>),
      flpth: json['FLPTH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FLPTH'] as Map<String, dynamic>),
      fileNm: json['FILE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FILE_NM'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STBANNERUncheckedUpdateManyInputToJson(
    STBANNERUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BANNER_CD', instance.bannerCd?.toJson());
  writeNotNull('LK_URL', instance.lkUrl?.toJson());
  writeNotNull('LK_TARGET', instance.lkTarget?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('FILE_NM', instance.fileNm?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STBOARDCOLUMNCreateInput _$STBOARDCOLUMNCreateInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDCOLUMNCreateInput(
      boardCd: json['BOARD_CD'] as String,
      sort: json['SORT'] as int,
      colCd: json['COL_CD'] as String,
      colNm: json['COL_NM'] as String,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
    );

Map<String, dynamic> _$STBOARDCOLUMNCreateInputToJson(
        STBOARDCOLUMNCreateInput instance) =>
    <String, dynamic>{
      'BOARD_CD': instance.boardCd,
      'SORT': instance.sort,
      'COL_CD': instance.colCd,
      'COL_NM': instance.colNm,
      'REG_ID': instance.regId,
      'REG_DATE': instance.regDate,
    };

STBOARDCOLUMNUncheckedCreateInput _$STBOARDCOLUMNUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDCOLUMNUncheckedCreateInput(
      boardCd: json['BOARD_CD'] as String,
      sort: json['SORT'] as int,
      colCd: json['COL_CD'] as String,
      colNm: json['COL_NM'] as String,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
    );

Map<String, dynamic> _$STBOARDCOLUMNUncheckedCreateInputToJson(
        STBOARDCOLUMNUncheckedCreateInput instance) =>
    <String, dynamic>{
      'BOARD_CD': instance.boardCd,
      'SORT': instance.sort,
      'COL_CD': instance.colCd,
      'COL_NM': instance.colNm,
      'REG_ID': instance.regId,
      'REG_DATE': instance.regDate,
    };

STBOARDCOLUMNUpdateInput _$STBOARDCOLUMNUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDCOLUMNUpdateInput(
      boardCd: json['BOARD_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['BOARD_CD'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SORT'] as Map<String, dynamic>),
      colCd: json['COL_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['COL_CD'] as Map<String, dynamic>),
      colNm: json['COL_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['COL_NM'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STBOARDCOLUMNUpdateInputToJson(
    STBOARDCOLUMNUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_CD', instance.boardCd?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('COL_CD', instance.colCd?.toJson());
  writeNotNull('COL_NM', instance.colNm?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

STBOARDCOLUMNUncheckedUpdateInput _$STBOARDCOLUMNUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDCOLUMNUncheckedUpdateInput(
      boardCd: json['BOARD_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['BOARD_CD'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SORT'] as Map<String, dynamic>),
      colCd: json['COL_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['COL_CD'] as Map<String, dynamic>),
      colNm: json['COL_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['COL_NM'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STBOARDCOLUMNUncheckedUpdateInputToJson(
    STBOARDCOLUMNUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_CD', instance.boardCd?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('COL_CD', instance.colCd?.toJson());
  writeNotNull('COL_NM', instance.colNm?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

STBOARDCOLUMNCreateManyInput _$STBOARDCOLUMNCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDCOLUMNCreateManyInput(
      boardCd: json['BOARD_CD'] as String,
      sort: json['SORT'] as int,
      colCd: json['COL_CD'] as String,
      colNm: json['COL_NM'] as String,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
    );

Map<String, dynamic> _$STBOARDCOLUMNCreateManyInputToJson(
        STBOARDCOLUMNCreateManyInput instance) =>
    <String, dynamic>{
      'BOARD_CD': instance.boardCd,
      'SORT': instance.sort,
      'COL_CD': instance.colCd,
      'COL_NM': instance.colNm,
      'REG_ID': instance.regId,
      'REG_DATE': instance.regDate,
    };

STBOARDCOLUMNUpdateManyMutationInput
    _$STBOARDCOLUMNUpdateManyMutationInputFromJson(Map<String, dynamic> json) =>
        STBOARDCOLUMNUpdateManyMutationInput(
          boardCd: json['BOARD_CD'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['BOARD_CD'] as Map<String, dynamic>),
          sort: json['SORT'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['SORT'] as Map<String, dynamic>),
          colCd: json['COL_CD'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['COL_CD'] as Map<String, dynamic>),
          colNm: json['COL_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['COL_NM'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STBOARDCOLUMNUpdateManyMutationInputToJson(
    STBOARDCOLUMNUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_CD', instance.boardCd?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('COL_CD', instance.colCd?.toJson());
  writeNotNull('COL_NM', instance.colNm?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

STBOARDCOLUMNUncheckedUpdateManyInput
    _$STBOARDCOLUMNUncheckedUpdateManyInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDCOLUMNUncheckedUpdateManyInput(
          boardCd: json['BOARD_CD'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['BOARD_CD'] as Map<String, dynamic>),
          sort: json['SORT'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['SORT'] as Map<String, dynamic>),
          colCd: json['COL_CD'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['COL_CD'] as Map<String, dynamic>),
          colNm: json['COL_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['COL_NM'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STBOARDCOLUMNUncheckedUpdateManyInputToJson(
    STBOARDCOLUMNUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_CD', instance.boardCd?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('COL_CD', instance.colCd?.toJson());
  writeNotNull('COL_NM', instance.colNm?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

STBOARDCOLUMNDFTCreateInput _$STBOARDCOLUMNDFTCreateInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDCOLUMNDFTCreateInput(
      boardTy: json['BOARD_TY'] as String,
      sort: json['SORT'] as int,
      colCd: json['COL_CD'] as String,
      colNm: json['COL_NM'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$STBOARDCOLUMNDFTCreateInputToJson(
    STBOARDCOLUMNDFTCreateInput instance) {
  final val = <String, dynamic>{
    'BOARD_TY': instance.boardTy,
    'SORT': instance.sort,
    'COL_CD': instance.colCd,
    'COL_NM': instance.colNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

STBOARDCOLUMNDFTUncheckedCreateInput
    _$STBOARDCOLUMNDFTUncheckedCreateInputFromJson(Map<String, dynamic> json) =>
        STBOARDCOLUMNDFTUncheckedCreateInput(
          boardTy: json['BOARD_TY'] as String,
          sort: json['SORT'] as int,
          colCd: json['COL_CD'] as String,
          colNm: json['COL_NM'] as String,
          editId: json['EDIT_ID'] as String?,
          editDate: json['EDIT_DATE'] as String?,
          delYn: json['DEL_YN'] as String?,
        );

Map<String, dynamic> _$STBOARDCOLUMNDFTUncheckedCreateInputToJson(
    STBOARDCOLUMNDFTUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'BOARD_TY': instance.boardTy,
    'SORT': instance.sort,
    'COL_CD': instance.colCd,
    'COL_NM': instance.colNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

STBOARDCOLUMNDFTUpdateInput _$STBOARDCOLUMNDFTUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDCOLUMNDFTUpdateInput(
      boardTy: json['BOARD_TY'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['BOARD_TY'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SORT'] as Map<String, dynamic>),
      colCd: json['COL_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['COL_CD'] as Map<String, dynamic>),
      colNm: json['COL_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['COL_NM'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STBOARDCOLUMNDFTUpdateInputToJson(
    STBOARDCOLUMNDFTUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_TY', instance.boardTy?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('COL_CD', instance.colCd?.toJson());
  writeNotNull('COL_NM', instance.colNm?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

STBOARDCOLUMNDFTUncheckedUpdateInput
    _$STBOARDCOLUMNDFTUncheckedUpdateInputFromJson(Map<String, dynamic> json) =>
        STBOARDCOLUMNDFTUncheckedUpdateInput(
          boardTy: json['BOARD_TY'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['BOARD_TY'] as Map<String, dynamic>),
          sort: json['SORT'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['SORT'] as Map<String, dynamic>),
          colCd: json['COL_CD'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['COL_CD'] as Map<String, dynamic>),
          colNm: json['COL_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['COL_NM'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STBOARDCOLUMNDFTUncheckedUpdateInputToJson(
    STBOARDCOLUMNDFTUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_TY', instance.boardTy?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('COL_CD', instance.colCd?.toJson());
  writeNotNull('COL_NM', instance.colNm?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

STBOARDCOLUMNDFTCreateManyInput _$STBOARDCOLUMNDFTCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDCOLUMNDFTCreateManyInput(
      boardTy: json['BOARD_TY'] as String,
      sort: json['SORT'] as int,
      colCd: json['COL_CD'] as String,
      colNm: json['COL_NM'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$STBOARDCOLUMNDFTCreateManyInputToJson(
    STBOARDCOLUMNDFTCreateManyInput instance) {
  final val = <String, dynamic>{
    'BOARD_TY': instance.boardTy,
    'SORT': instance.sort,
    'COL_CD': instance.colCd,
    'COL_NM': instance.colNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

STBOARDCOLUMNDFTUpdateManyMutationInput
    _$STBOARDCOLUMNDFTUpdateManyMutationInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDCOLUMNDFTUpdateManyMutationInput(
          boardTy: json['BOARD_TY'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['BOARD_TY'] as Map<String, dynamic>),
          sort: json['SORT'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['SORT'] as Map<String, dynamic>),
          colCd: json['COL_CD'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['COL_CD'] as Map<String, dynamic>),
          colNm: json['COL_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['COL_NM'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STBOARDCOLUMNDFTUpdateManyMutationInputToJson(
    STBOARDCOLUMNDFTUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_TY', instance.boardTy?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('COL_CD', instance.colCd?.toJson());
  writeNotNull('COL_NM', instance.colNm?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

STBOARDCOLUMNDFTUncheckedUpdateManyInput
    _$STBOARDCOLUMNDFTUncheckedUpdateManyInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDCOLUMNDFTUncheckedUpdateManyInput(
          boardTy: json['BOARD_TY'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['BOARD_TY'] as Map<String, dynamic>),
          sort: json['SORT'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['SORT'] as Map<String, dynamic>),
          colCd: json['COL_CD'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['COL_CD'] as Map<String, dynamic>),
          colNm: json['COL_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['COL_NM'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STBOARDCOLUMNDFTUncheckedUpdateManyInputToJson(
    STBOARDCOLUMNDFTUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_TY', instance.boardTy?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('COL_CD', instance.colCd?.toJson());
  writeNotNull('COL_NM', instance.colNm?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

STBOARDCOMMENTCreateInput _$STBOARDCOMMENTCreateInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDCOMMENTCreateInput(
      seq: json['SEQ'] as int,
      mseq: json['MSEQ'] as int,
      boardCd: json['BOARD_CD'] as String,
      cnts: json['CNTS'] as String?,
      upperSeq: json['UPPER_SEQ'] as int?,
      replyYn: json['REPLY_YN'] as String?,
      regAdminYn: json['REG_ADMIN_YN'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STBOARDCOMMENTCreateInputToJson(
    STBOARDCOMMENTCreateInput instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'MSEQ': instance.mseq,
    'BOARD_CD': instance.boardCd,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CNTS', instance.cnts);
  writeNotNull('UPPER_SEQ', instance.upperSeq);
  writeNotNull('REPLY_YN', instance.replyYn);
  writeNotNull('REG_ADMIN_YN', instance.regAdminYn);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STBOARDCOMMENTUncheckedCreateInput _$STBOARDCOMMENTUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDCOMMENTUncheckedCreateInput(
      seq: json['SEQ'] as int,
      mseq: json['MSEQ'] as int,
      boardCd: json['BOARD_CD'] as String,
      cnts: json['CNTS'] as String?,
      upperSeq: json['UPPER_SEQ'] as int?,
      replyYn: json['REPLY_YN'] as String?,
      regAdminYn: json['REG_ADMIN_YN'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STBOARDCOMMENTUncheckedCreateInputToJson(
    STBOARDCOMMENTUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'MSEQ': instance.mseq,
    'BOARD_CD': instance.boardCd,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CNTS', instance.cnts);
  writeNotNull('UPPER_SEQ', instance.upperSeq);
  writeNotNull('REPLY_YN', instance.replyYn);
  writeNotNull('REG_ADMIN_YN', instance.regAdminYn);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STBOARDCOMMENTUpdateInput _$STBOARDCOMMENTUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDCOMMENTUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      mseq: json['MSEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['MSEQ'] as Map<String, dynamic>),
      boardCd: json['BOARD_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['BOARD_CD'] as Map<String, dynamic>),
      cnts: json['CNTS'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CNTS'] as Map<String, dynamic>),
      upperSeq: json['UPPER_SEQ'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['UPPER_SEQ'] as Map<String, dynamic>),
      replyYn: json['REPLY_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REPLY_YN'] as Map<String, dynamic>),
      regAdminYn: json['REG_ADMIN_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_ADMIN_YN'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STBOARDCOMMENTUpdateInputToJson(
    STBOARDCOMMENTUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('BOARD_CD', instance.boardCd?.toJson());
  writeNotNull('CNTS', instance.cnts?.toJson());
  writeNotNull('UPPER_SEQ', instance.upperSeq?.toJson());
  writeNotNull('REPLY_YN', instance.replyYn?.toJson());
  writeNotNull('REG_ADMIN_YN', instance.regAdminYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STBOARDCOMMENTUncheckedUpdateInput _$STBOARDCOMMENTUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDCOMMENTUncheckedUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      mseq: json['MSEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['MSEQ'] as Map<String, dynamic>),
      boardCd: json['BOARD_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['BOARD_CD'] as Map<String, dynamic>),
      cnts: json['CNTS'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CNTS'] as Map<String, dynamic>),
      upperSeq: json['UPPER_SEQ'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['UPPER_SEQ'] as Map<String, dynamic>),
      replyYn: json['REPLY_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REPLY_YN'] as Map<String, dynamic>),
      regAdminYn: json['REG_ADMIN_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_ADMIN_YN'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STBOARDCOMMENTUncheckedUpdateInputToJson(
    STBOARDCOMMENTUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('BOARD_CD', instance.boardCd?.toJson());
  writeNotNull('CNTS', instance.cnts?.toJson());
  writeNotNull('UPPER_SEQ', instance.upperSeq?.toJson());
  writeNotNull('REPLY_YN', instance.replyYn?.toJson());
  writeNotNull('REG_ADMIN_YN', instance.regAdminYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STBOARDCOMMENTCreateManyInput _$STBOARDCOMMENTCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDCOMMENTCreateManyInput(
      seq: json['SEQ'] as int,
      mseq: json['MSEQ'] as int,
      boardCd: json['BOARD_CD'] as String,
      cnts: json['CNTS'] as String?,
      upperSeq: json['UPPER_SEQ'] as int?,
      replyYn: json['REPLY_YN'] as String?,
      regAdminYn: json['REG_ADMIN_YN'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STBOARDCOMMENTCreateManyInputToJson(
    STBOARDCOMMENTCreateManyInput instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'MSEQ': instance.mseq,
    'BOARD_CD': instance.boardCd,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CNTS', instance.cnts);
  writeNotNull('UPPER_SEQ', instance.upperSeq);
  writeNotNull('REPLY_YN', instance.replyYn);
  writeNotNull('REG_ADMIN_YN', instance.regAdminYn);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STBOARDCOMMENTUpdateManyMutationInput
    _$STBOARDCOMMENTUpdateManyMutationInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDCOMMENTUpdateManyMutationInput(
          seq: json['SEQ'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          mseq: json['MSEQ'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['MSEQ'] as Map<String, dynamic>),
          boardCd: json['BOARD_CD'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['BOARD_CD'] as Map<String, dynamic>),
          cnts: json['CNTS'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CNTS'] as Map<String, dynamic>),
          upperSeq: json['UPPER_SEQ'] == null
              ? null
              : NullableIntFieldUpdateOperationsInput.fromJson(
                  json['UPPER_SEQ'] as Map<String, dynamic>),
          replyYn: json['REPLY_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REPLY_YN'] as Map<String, dynamic>),
          regAdminYn: json['REG_ADMIN_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REG_ADMIN_YN'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delId: json['DEL_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_ID'] as Map<String, dynamic>),
          delDate: json['DEL_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STBOARDCOMMENTUpdateManyMutationInputToJson(
    STBOARDCOMMENTUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('BOARD_CD', instance.boardCd?.toJson());
  writeNotNull('CNTS', instance.cnts?.toJson());
  writeNotNull('UPPER_SEQ', instance.upperSeq?.toJson());
  writeNotNull('REPLY_YN', instance.replyYn?.toJson());
  writeNotNull('REG_ADMIN_YN', instance.regAdminYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STBOARDCOMMENTUncheckedUpdateManyInput
    _$STBOARDCOMMENTUncheckedUpdateManyInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDCOMMENTUncheckedUpdateManyInput(
          seq: json['SEQ'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          mseq: json['MSEQ'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['MSEQ'] as Map<String, dynamic>),
          boardCd: json['BOARD_CD'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['BOARD_CD'] as Map<String, dynamic>),
          cnts: json['CNTS'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CNTS'] as Map<String, dynamic>),
          upperSeq: json['UPPER_SEQ'] == null
              ? null
              : NullableIntFieldUpdateOperationsInput.fromJson(
                  json['UPPER_SEQ'] as Map<String, dynamic>),
          replyYn: json['REPLY_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REPLY_YN'] as Map<String, dynamic>),
          regAdminYn: json['REG_ADMIN_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REG_ADMIN_YN'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delId: json['DEL_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_ID'] as Map<String, dynamic>),
          delDate: json['DEL_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STBOARDCOMMENTUncheckedUpdateManyInputToJson(
    STBOARDCOMMENTUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('BOARD_CD', instance.boardCd?.toJson());
  writeNotNull('CNTS', instance.cnts?.toJson());
  writeNotNull('UPPER_SEQ', instance.upperSeq?.toJson());
  writeNotNull('REPLY_YN', instance.replyYn?.toJson());
  writeNotNull('REG_ADMIN_YN', instance.regAdminYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STBOARDFILECreateInput _$STBOARDFILECreateInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDFILECreateInput(
      seq: json['SEQ'] as int,
      mseq: json['MSEQ'] as int,
      boardCd: json['BOARD_CD'] as String,
      fileTp: json['FILE_TP'] as String?,
      flpth: json['FLPTH'] as String?,
      orginalFileNm: json['ORGINAL_FILE_NM'] as String?,
      streFileNm: json['STRE_FILE_NM'] as String?,
      fileSize: json['FILE_SIZE'] as int?,
      repreYn: json['REPRE_YN'] as String?,
      dwldCo: json['DWLD_CO'] as int?,
    );

Map<String, dynamic> _$STBOARDFILECreateInputToJson(
    STBOARDFILECreateInput instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'MSEQ': instance.mseq,
    'BOARD_CD': instance.boardCd,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('FILE_TP', instance.fileTp);
  writeNotNull('FLPTH', instance.flpth);
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm);
  writeNotNull('STRE_FILE_NM', instance.streFileNm);
  writeNotNull('FILE_SIZE', instance.fileSize);
  writeNotNull('REPRE_YN', instance.repreYn);
  writeNotNull('DWLD_CO', instance.dwldCo);
  return val;
}

STBOARDFILEUncheckedCreateInput _$STBOARDFILEUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDFILEUncheckedCreateInput(
      seq: json['SEQ'] as int,
      mseq: json['MSEQ'] as int,
      boardCd: json['BOARD_CD'] as String,
      fileTp: json['FILE_TP'] as String?,
      flpth: json['FLPTH'] as String?,
      orginalFileNm: json['ORGINAL_FILE_NM'] as String?,
      streFileNm: json['STRE_FILE_NM'] as String?,
      fileSize: json['FILE_SIZE'] as int?,
      repreYn: json['REPRE_YN'] as String?,
      dwldCo: json['DWLD_CO'] as int?,
    );

Map<String, dynamic> _$STBOARDFILEUncheckedCreateInputToJson(
    STBOARDFILEUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'MSEQ': instance.mseq,
    'BOARD_CD': instance.boardCd,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('FILE_TP', instance.fileTp);
  writeNotNull('FLPTH', instance.flpth);
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm);
  writeNotNull('STRE_FILE_NM', instance.streFileNm);
  writeNotNull('FILE_SIZE', instance.fileSize);
  writeNotNull('REPRE_YN', instance.repreYn);
  writeNotNull('DWLD_CO', instance.dwldCo);
  return val;
}

STBOARDFILEUpdateInput _$STBOARDFILEUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDFILEUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      mseq: json['MSEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['MSEQ'] as Map<String, dynamic>),
      boardCd: json['BOARD_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['BOARD_CD'] as Map<String, dynamic>),
      fileTp: json['FILE_TP'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FILE_TP'] as Map<String, dynamic>),
      flpth: json['FLPTH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FLPTH'] as Map<String, dynamic>),
      orginalFileNm: json['ORGINAL_FILE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ORGINAL_FILE_NM'] as Map<String, dynamic>),
      streFileNm: json['STRE_FILE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['STRE_FILE_NM'] as Map<String, dynamic>),
      fileSize: json['FILE_SIZE'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['FILE_SIZE'] as Map<String, dynamic>),
      repreYn: json['REPRE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REPRE_YN'] as Map<String, dynamic>),
      dwldCo: json['DWLD_CO'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['DWLD_CO'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STBOARDFILEUpdateInputToJson(
    STBOARDFILEUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('BOARD_CD', instance.boardCd?.toJson());
  writeNotNull('FILE_TP', instance.fileTp?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm?.toJson());
  writeNotNull('STRE_FILE_NM', instance.streFileNm?.toJson());
  writeNotNull('FILE_SIZE', instance.fileSize?.toJson());
  writeNotNull('REPRE_YN', instance.repreYn?.toJson());
  writeNotNull('DWLD_CO', instance.dwldCo?.toJson());
  return val;
}

STBOARDFILEUncheckedUpdateInput _$STBOARDFILEUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDFILEUncheckedUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      mseq: json['MSEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['MSEQ'] as Map<String, dynamic>),
      boardCd: json['BOARD_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['BOARD_CD'] as Map<String, dynamic>),
      fileTp: json['FILE_TP'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FILE_TP'] as Map<String, dynamic>),
      flpth: json['FLPTH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FLPTH'] as Map<String, dynamic>),
      orginalFileNm: json['ORGINAL_FILE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ORGINAL_FILE_NM'] as Map<String, dynamic>),
      streFileNm: json['STRE_FILE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['STRE_FILE_NM'] as Map<String, dynamic>),
      fileSize: json['FILE_SIZE'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['FILE_SIZE'] as Map<String, dynamic>),
      repreYn: json['REPRE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REPRE_YN'] as Map<String, dynamic>),
      dwldCo: json['DWLD_CO'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['DWLD_CO'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STBOARDFILEUncheckedUpdateInputToJson(
    STBOARDFILEUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('BOARD_CD', instance.boardCd?.toJson());
  writeNotNull('FILE_TP', instance.fileTp?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm?.toJson());
  writeNotNull('STRE_FILE_NM', instance.streFileNm?.toJson());
  writeNotNull('FILE_SIZE', instance.fileSize?.toJson());
  writeNotNull('REPRE_YN', instance.repreYn?.toJson());
  writeNotNull('DWLD_CO', instance.dwldCo?.toJson());
  return val;
}

STBOARDFILECreateManyInput _$STBOARDFILECreateManyInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDFILECreateManyInput(
      seq: json['SEQ'] as int,
      mseq: json['MSEQ'] as int,
      boardCd: json['BOARD_CD'] as String,
      fileTp: json['FILE_TP'] as String?,
      flpth: json['FLPTH'] as String?,
      orginalFileNm: json['ORGINAL_FILE_NM'] as String?,
      streFileNm: json['STRE_FILE_NM'] as String?,
      fileSize: json['FILE_SIZE'] as int?,
      repreYn: json['REPRE_YN'] as String?,
      dwldCo: json['DWLD_CO'] as int?,
    );

Map<String, dynamic> _$STBOARDFILECreateManyInputToJson(
    STBOARDFILECreateManyInput instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'MSEQ': instance.mseq,
    'BOARD_CD': instance.boardCd,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('FILE_TP', instance.fileTp);
  writeNotNull('FLPTH', instance.flpth);
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm);
  writeNotNull('STRE_FILE_NM', instance.streFileNm);
  writeNotNull('FILE_SIZE', instance.fileSize);
  writeNotNull('REPRE_YN', instance.repreYn);
  writeNotNull('DWLD_CO', instance.dwldCo);
  return val;
}

STBOARDFILEUpdateManyMutationInput _$STBOARDFILEUpdateManyMutationInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDFILEUpdateManyMutationInput(
      seq: json['SEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      mseq: json['MSEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['MSEQ'] as Map<String, dynamic>),
      boardCd: json['BOARD_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['BOARD_CD'] as Map<String, dynamic>),
      fileTp: json['FILE_TP'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FILE_TP'] as Map<String, dynamic>),
      flpth: json['FLPTH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FLPTH'] as Map<String, dynamic>),
      orginalFileNm: json['ORGINAL_FILE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ORGINAL_FILE_NM'] as Map<String, dynamic>),
      streFileNm: json['STRE_FILE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['STRE_FILE_NM'] as Map<String, dynamic>),
      fileSize: json['FILE_SIZE'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['FILE_SIZE'] as Map<String, dynamic>),
      repreYn: json['REPRE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REPRE_YN'] as Map<String, dynamic>),
      dwldCo: json['DWLD_CO'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['DWLD_CO'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STBOARDFILEUpdateManyMutationInputToJson(
    STBOARDFILEUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('BOARD_CD', instance.boardCd?.toJson());
  writeNotNull('FILE_TP', instance.fileTp?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm?.toJson());
  writeNotNull('STRE_FILE_NM', instance.streFileNm?.toJson());
  writeNotNull('FILE_SIZE', instance.fileSize?.toJson());
  writeNotNull('REPRE_YN', instance.repreYn?.toJson());
  writeNotNull('DWLD_CO', instance.dwldCo?.toJson());
  return val;
}

STBOARDFILEUncheckedUpdateManyInput
    _$STBOARDFILEUncheckedUpdateManyInputFromJson(Map<String, dynamic> json) =>
        STBOARDFILEUncheckedUpdateManyInput(
          seq: json['SEQ'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          mseq: json['MSEQ'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['MSEQ'] as Map<String, dynamic>),
          boardCd: json['BOARD_CD'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['BOARD_CD'] as Map<String, dynamic>),
          fileTp: json['FILE_TP'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['FILE_TP'] as Map<String, dynamic>),
          flpth: json['FLPTH'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['FLPTH'] as Map<String, dynamic>),
          orginalFileNm: json['ORGINAL_FILE_NM'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['ORGINAL_FILE_NM'] as Map<String, dynamic>),
          streFileNm: json['STRE_FILE_NM'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['STRE_FILE_NM'] as Map<String, dynamic>),
          fileSize: json['FILE_SIZE'] == null
              ? null
              : NullableIntFieldUpdateOperationsInput.fromJson(
                  json['FILE_SIZE'] as Map<String, dynamic>),
          repreYn: json['REPRE_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REPRE_YN'] as Map<String, dynamic>),
          dwldCo: json['DWLD_CO'] == null
              ? null
              : NullableIntFieldUpdateOperationsInput.fromJson(
                  json['DWLD_CO'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STBOARDFILEUncheckedUpdateManyInputToJson(
    STBOARDFILEUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('BOARD_CD', instance.boardCd?.toJson());
  writeNotNull('FILE_TP', instance.fileTp?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm?.toJson());
  writeNotNull('STRE_FILE_NM', instance.streFileNm?.toJson());
  writeNotNull('FILE_SIZE', instance.fileSize?.toJson());
  writeNotNull('REPRE_YN', instance.repreYn?.toJson());
  writeNotNull('DWLD_CO', instance.dwldCo?.toJson());
  return val;
}

STBOARDMSTCreateInput _$STBOARDMSTCreateInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDMSTCreateInput(
      seq: json['SEQ'] as int,
      boardCd: json['BOARD_CD'] as String,
      clsCd: json['CLS_CD'] as String?,
      ttl: json['TTL'] as String,
      cnts: json['CNTS'] as String,
      fileYn: json['FILE_YN'] as String?,
      imageYn: json['IMAGE_YN'] as String?,
      noticeYn: json['NOTICE_YN'] as String?,
      lkUrl: json['LK_URL'] as String?,
      lkTarget: json['LK_TARGET'] as String?,
      readCnt: json['READ_CNT'] as int?,
      regAdminYn: json['REG_ADMIN_YN'] as String?,
      replyYn: json['REPLY_YN'] as String?,
      upperSeq: json['UPPER_SEQ'] as int?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STBOARDMSTCreateInputToJson(
    STBOARDMSTCreateInput instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'BOARD_CD': instance.boardCd,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CLS_CD', instance.clsCd);
  val['TTL'] = instance.ttl;
  val['CNTS'] = instance.cnts;
  writeNotNull('FILE_YN', instance.fileYn);
  writeNotNull('IMAGE_YN', instance.imageYn);
  writeNotNull('NOTICE_YN', instance.noticeYn);
  writeNotNull('LK_URL', instance.lkUrl);
  writeNotNull('LK_TARGET', instance.lkTarget);
  writeNotNull('READ_CNT', instance.readCnt);
  writeNotNull('REG_ADMIN_YN', instance.regAdminYn);
  writeNotNull('REPLY_YN', instance.replyYn);
  writeNotNull('UPPER_SEQ', instance.upperSeq);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STBOARDMSTUncheckedCreateInput _$STBOARDMSTUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDMSTUncheckedCreateInput(
      seq: json['SEQ'] as int,
      boardCd: json['BOARD_CD'] as String,
      clsCd: json['CLS_CD'] as String?,
      ttl: json['TTL'] as String,
      cnts: json['CNTS'] as String,
      fileYn: json['FILE_YN'] as String?,
      imageYn: json['IMAGE_YN'] as String?,
      noticeYn: json['NOTICE_YN'] as String?,
      lkUrl: json['LK_URL'] as String?,
      lkTarget: json['LK_TARGET'] as String?,
      readCnt: json['READ_CNT'] as int?,
      regAdminYn: json['REG_ADMIN_YN'] as String?,
      replyYn: json['REPLY_YN'] as String?,
      upperSeq: json['UPPER_SEQ'] as int?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STBOARDMSTUncheckedCreateInputToJson(
    STBOARDMSTUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'BOARD_CD': instance.boardCd,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CLS_CD', instance.clsCd);
  val['TTL'] = instance.ttl;
  val['CNTS'] = instance.cnts;
  writeNotNull('FILE_YN', instance.fileYn);
  writeNotNull('IMAGE_YN', instance.imageYn);
  writeNotNull('NOTICE_YN', instance.noticeYn);
  writeNotNull('LK_URL', instance.lkUrl);
  writeNotNull('LK_TARGET', instance.lkTarget);
  writeNotNull('READ_CNT', instance.readCnt);
  writeNotNull('REG_ADMIN_YN', instance.regAdminYn);
  writeNotNull('REPLY_YN', instance.replyYn);
  writeNotNull('UPPER_SEQ', instance.upperSeq);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STBOARDMSTUpdateInput _$STBOARDMSTUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDMSTUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      boardCd: json['BOARD_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['BOARD_CD'] as Map<String, dynamic>),
      clsCd: json['CLS_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CLS_CD'] as Map<String, dynamic>),
      ttl: json['TTL'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['TTL'] as Map<String, dynamic>),
      cnts: json['CNTS'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CNTS'] as Map<String, dynamic>),
      fileYn: json['FILE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FILE_YN'] as Map<String, dynamic>),
      imageYn: json['IMAGE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['IMAGE_YN'] as Map<String, dynamic>),
      noticeYn: json['NOTICE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['NOTICE_YN'] as Map<String, dynamic>),
      lkUrl: json['LK_URL'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['LK_URL'] as Map<String, dynamic>),
      lkTarget: json['LK_TARGET'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['LK_TARGET'] as Map<String, dynamic>),
      readCnt: json['READ_CNT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['READ_CNT'] as Map<String, dynamic>),
      regAdminYn: json['REG_ADMIN_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_ADMIN_YN'] as Map<String, dynamic>),
      replyYn: json['REPLY_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REPLY_YN'] as Map<String, dynamic>),
      upperSeq: json['UPPER_SEQ'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['UPPER_SEQ'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STBOARDMSTUpdateInputToJson(
    STBOARDMSTUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('BOARD_CD', instance.boardCd?.toJson());
  writeNotNull('CLS_CD', instance.clsCd?.toJson());
  writeNotNull('TTL', instance.ttl?.toJson());
  writeNotNull('CNTS', instance.cnts?.toJson());
  writeNotNull('FILE_YN', instance.fileYn?.toJson());
  writeNotNull('IMAGE_YN', instance.imageYn?.toJson());
  writeNotNull('NOTICE_YN', instance.noticeYn?.toJson());
  writeNotNull('LK_URL', instance.lkUrl?.toJson());
  writeNotNull('LK_TARGET', instance.lkTarget?.toJson());
  writeNotNull('READ_CNT', instance.readCnt?.toJson());
  writeNotNull('REG_ADMIN_YN', instance.regAdminYn?.toJson());
  writeNotNull('REPLY_YN', instance.replyYn?.toJson());
  writeNotNull('UPPER_SEQ', instance.upperSeq?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STBOARDMSTUncheckedUpdateInput _$STBOARDMSTUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDMSTUncheckedUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      boardCd: json['BOARD_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['BOARD_CD'] as Map<String, dynamic>),
      clsCd: json['CLS_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CLS_CD'] as Map<String, dynamic>),
      ttl: json['TTL'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['TTL'] as Map<String, dynamic>),
      cnts: json['CNTS'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CNTS'] as Map<String, dynamic>),
      fileYn: json['FILE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FILE_YN'] as Map<String, dynamic>),
      imageYn: json['IMAGE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['IMAGE_YN'] as Map<String, dynamic>),
      noticeYn: json['NOTICE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['NOTICE_YN'] as Map<String, dynamic>),
      lkUrl: json['LK_URL'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['LK_URL'] as Map<String, dynamic>),
      lkTarget: json['LK_TARGET'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['LK_TARGET'] as Map<String, dynamic>),
      readCnt: json['READ_CNT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['READ_CNT'] as Map<String, dynamic>),
      regAdminYn: json['REG_ADMIN_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_ADMIN_YN'] as Map<String, dynamic>),
      replyYn: json['REPLY_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REPLY_YN'] as Map<String, dynamic>),
      upperSeq: json['UPPER_SEQ'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['UPPER_SEQ'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STBOARDMSTUncheckedUpdateInputToJson(
    STBOARDMSTUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('BOARD_CD', instance.boardCd?.toJson());
  writeNotNull('CLS_CD', instance.clsCd?.toJson());
  writeNotNull('TTL', instance.ttl?.toJson());
  writeNotNull('CNTS', instance.cnts?.toJson());
  writeNotNull('FILE_YN', instance.fileYn?.toJson());
  writeNotNull('IMAGE_YN', instance.imageYn?.toJson());
  writeNotNull('NOTICE_YN', instance.noticeYn?.toJson());
  writeNotNull('LK_URL', instance.lkUrl?.toJson());
  writeNotNull('LK_TARGET', instance.lkTarget?.toJson());
  writeNotNull('READ_CNT', instance.readCnt?.toJson());
  writeNotNull('REG_ADMIN_YN', instance.regAdminYn?.toJson());
  writeNotNull('REPLY_YN', instance.replyYn?.toJson());
  writeNotNull('UPPER_SEQ', instance.upperSeq?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STBOARDMSTCreateManyInput _$STBOARDMSTCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDMSTCreateManyInput(
      seq: json['SEQ'] as int,
      boardCd: json['BOARD_CD'] as String,
      clsCd: json['CLS_CD'] as String?,
      ttl: json['TTL'] as String,
      cnts: json['CNTS'] as String,
      fileYn: json['FILE_YN'] as String?,
      imageYn: json['IMAGE_YN'] as String?,
      noticeYn: json['NOTICE_YN'] as String?,
      lkUrl: json['LK_URL'] as String?,
      lkTarget: json['LK_TARGET'] as String?,
      readCnt: json['READ_CNT'] as int?,
      regAdminYn: json['REG_ADMIN_YN'] as String?,
      replyYn: json['REPLY_YN'] as String?,
      upperSeq: json['UPPER_SEQ'] as int?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STBOARDMSTCreateManyInputToJson(
    STBOARDMSTCreateManyInput instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'BOARD_CD': instance.boardCd,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CLS_CD', instance.clsCd);
  val['TTL'] = instance.ttl;
  val['CNTS'] = instance.cnts;
  writeNotNull('FILE_YN', instance.fileYn);
  writeNotNull('IMAGE_YN', instance.imageYn);
  writeNotNull('NOTICE_YN', instance.noticeYn);
  writeNotNull('LK_URL', instance.lkUrl);
  writeNotNull('LK_TARGET', instance.lkTarget);
  writeNotNull('READ_CNT', instance.readCnt);
  writeNotNull('REG_ADMIN_YN', instance.regAdminYn);
  writeNotNull('REPLY_YN', instance.replyYn);
  writeNotNull('UPPER_SEQ', instance.upperSeq);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STBOARDMSTUpdateManyMutationInput _$STBOARDMSTUpdateManyMutationInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDMSTUpdateManyMutationInput(
      seq: json['SEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      boardCd: json['BOARD_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['BOARD_CD'] as Map<String, dynamic>),
      clsCd: json['CLS_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CLS_CD'] as Map<String, dynamic>),
      ttl: json['TTL'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['TTL'] as Map<String, dynamic>),
      cnts: json['CNTS'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CNTS'] as Map<String, dynamic>),
      fileYn: json['FILE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FILE_YN'] as Map<String, dynamic>),
      imageYn: json['IMAGE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['IMAGE_YN'] as Map<String, dynamic>),
      noticeYn: json['NOTICE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['NOTICE_YN'] as Map<String, dynamic>),
      lkUrl: json['LK_URL'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['LK_URL'] as Map<String, dynamic>),
      lkTarget: json['LK_TARGET'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['LK_TARGET'] as Map<String, dynamic>),
      readCnt: json['READ_CNT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['READ_CNT'] as Map<String, dynamic>),
      regAdminYn: json['REG_ADMIN_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_ADMIN_YN'] as Map<String, dynamic>),
      replyYn: json['REPLY_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REPLY_YN'] as Map<String, dynamic>),
      upperSeq: json['UPPER_SEQ'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['UPPER_SEQ'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STBOARDMSTUpdateManyMutationInputToJson(
    STBOARDMSTUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('BOARD_CD', instance.boardCd?.toJson());
  writeNotNull('CLS_CD', instance.clsCd?.toJson());
  writeNotNull('TTL', instance.ttl?.toJson());
  writeNotNull('CNTS', instance.cnts?.toJson());
  writeNotNull('FILE_YN', instance.fileYn?.toJson());
  writeNotNull('IMAGE_YN', instance.imageYn?.toJson());
  writeNotNull('NOTICE_YN', instance.noticeYn?.toJson());
  writeNotNull('LK_URL', instance.lkUrl?.toJson());
  writeNotNull('LK_TARGET', instance.lkTarget?.toJson());
  writeNotNull('READ_CNT', instance.readCnt?.toJson());
  writeNotNull('REG_ADMIN_YN', instance.regAdminYn?.toJson());
  writeNotNull('REPLY_YN', instance.replyYn?.toJson());
  writeNotNull('UPPER_SEQ', instance.upperSeq?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STBOARDMSTUncheckedUpdateManyInput _$STBOARDMSTUncheckedUpdateManyInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDMSTUncheckedUpdateManyInput(
      seq: json['SEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      boardCd: json['BOARD_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['BOARD_CD'] as Map<String, dynamic>),
      clsCd: json['CLS_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CLS_CD'] as Map<String, dynamic>),
      ttl: json['TTL'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['TTL'] as Map<String, dynamic>),
      cnts: json['CNTS'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CNTS'] as Map<String, dynamic>),
      fileYn: json['FILE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FILE_YN'] as Map<String, dynamic>),
      imageYn: json['IMAGE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['IMAGE_YN'] as Map<String, dynamic>),
      noticeYn: json['NOTICE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['NOTICE_YN'] as Map<String, dynamic>),
      lkUrl: json['LK_URL'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['LK_URL'] as Map<String, dynamic>),
      lkTarget: json['LK_TARGET'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['LK_TARGET'] as Map<String, dynamic>),
      readCnt: json['READ_CNT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['READ_CNT'] as Map<String, dynamic>),
      regAdminYn: json['REG_ADMIN_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_ADMIN_YN'] as Map<String, dynamic>),
      replyYn: json['REPLY_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REPLY_YN'] as Map<String, dynamic>),
      upperSeq: json['UPPER_SEQ'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['UPPER_SEQ'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STBOARDMSTUncheckedUpdateManyInputToJson(
    STBOARDMSTUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('BOARD_CD', instance.boardCd?.toJson());
  writeNotNull('CLS_CD', instance.clsCd?.toJson());
  writeNotNull('TTL', instance.ttl?.toJson());
  writeNotNull('CNTS', instance.cnts?.toJson());
  writeNotNull('FILE_YN', instance.fileYn?.toJson());
  writeNotNull('IMAGE_YN', instance.imageYn?.toJson());
  writeNotNull('NOTICE_YN', instance.noticeYn?.toJson());
  writeNotNull('LK_URL', instance.lkUrl?.toJson());
  writeNotNull('LK_TARGET', instance.lkTarget?.toJson());
  writeNotNull('READ_CNT', instance.readCnt?.toJson());
  writeNotNull('REG_ADMIN_YN', instance.regAdminYn?.toJson());
  writeNotNull('REPLY_YN', instance.replyYn?.toJson());
  writeNotNull('UPPER_SEQ', instance.upperSeq?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STBOARDSTNGCreateInput _$STBOARDSTNGCreateInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDSTNGCreateInput(
      boardCd: json['BOARD_CD'] as String,
      boardNm: json['BOARD_NM'] as String,
      boardTy: json['BOARD_TY'] as String?,
      editorYn: json['EDITOR_YN'] as String?,
      rlsYn: json['RLS_YN'] as String?,
      cclSeq: json['CCL_SEQ'] as int?,
      listCnt: json['LIST_CNT'] as int?,
      writeYn: json['WRITE_YN'] as String?,
      commentYn: json['COMMENT_YN'] as String?,
      replyYn: json['REPLY_YN'] as String?,
      attachYn: json['ATTACH_YN'] as String?,
      attachSize: json['ATTACH_SIZE'] as String?,
      attachCnt: json['ATTACH_CNT'] as String?,
      attachExt: json['ATTACH_EXT'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STBOARDSTNGCreateInputToJson(
    STBOARDSTNGCreateInput instance) {
  final val = <String, dynamic>{
    'BOARD_CD': instance.boardCd,
    'BOARD_NM': instance.boardNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_TY', instance.boardTy);
  writeNotNull('EDITOR_YN', instance.editorYn);
  writeNotNull('RLS_YN', instance.rlsYn);
  writeNotNull('CCL_SEQ', instance.cclSeq);
  writeNotNull('LIST_CNT', instance.listCnt);
  writeNotNull('WRITE_YN', instance.writeYn);
  writeNotNull('COMMENT_YN', instance.commentYn);
  writeNotNull('REPLY_YN', instance.replyYn);
  writeNotNull('ATTACH_YN', instance.attachYn);
  writeNotNull('ATTACH_SIZE', instance.attachSize);
  writeNotNull('ATTACH_CNT', instance.attachCnt);
  writeNotNull('ATTACH_EXT', instance.attachExt);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STBOARDSTNGUncheckedCreateInput _$STBOARDSTNGUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDSTNGUncheckedCreateInput(
      boardCd: json['BOARD_CD'] as String,
      boardNm: json['BOARD_NM'] as String,
      boardTy: json['BOARD_TY'] as String?,
      editorYn: json['EDITOR_YN'] as String?,
      rlsYn: json['RLS_YN'] as String?,
      cclSeq: json['CCL_SEQ'] as int?,
      listCnt: json['LIST_CNT'] as int?,
      writeYn: json['WRITE_YN'] as String?,
      commentYn: json['COMMENT_YN'] as String?,
      replyYn: json['REPLY_YN'] as String?,
      attachYn: json['ATTACH_YN'] as String?,
      attachSize: json['ATTACH_SIZE'] as String?,
      attachCnt: json['ATTACH_CNT'] as String?,
      attachExt: json['ATTACH_EXT'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STBOARDSTNGUncheckedCreateInputToJson(
    STBOARDSTNGUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'BOARD_CD': instance.boardCd,
    'BOARD_NM': instance.boardNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_TY', instance.boardTy);
  writeNotNull('EDITOR_YN', instance.editorYn);
  writeNotNull('RLS_YN', instance.rlsYn);
  writeNotNull('CCL_SEQ', instance.cclSeq);
  writeNotNull('LIST_CNT', instance.listCnt);
  writeNotNull('WRITE_YN', instance.writeYn);
  writeNotNull('COMMENT_YN', instance.commentYn);
  writeNotNull('REPLY_YN', instance.replyYn);
  writeNotNull('ATTACH_YN', instance.attachYn);
  writeNotNull('ATTACH_SIZE', instance.attachSize);
  writeNotNull('ATTACH_CNT', instance.attachCnt);
  writeNotNull('ATTACH_EXT', instance.attachExt);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STBOARDSTNGUpdateInput _$STBOARDSTNGUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDSTNGUpdateInput(
      boardCd: json['BOARD_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['BOARD_CD'] as Map<String, dynamic>),
      boardNm: json['BOARD_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['BOARD_NM'] as Map<String, dynamic>),
      boardTy: json['BOARD_TY'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['BOARD_TY'] as Map<String, dynamic>),
      editorYn: json['EDITOR_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['EDITOR_YN'] as Map<String, dynamic>),
      rlsYn: json['RLS_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['RLS_YN'] as Map<String, dynamic>),
      cclSeq: json['CCL_SEQ'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['CCL_SEQ'] as Map<String, dynamic>),
      listCnt: json['LIST_CNT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['LIST_CNT'] as Map<String, dynamic>),
      writeYn: json['WRITE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['WRITE_YN'] as Map<String, dynamic>),
      commentYn: json['COMMENT_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['COMMENT_YN'] as Map<String, dynamic>),
      replyYn: json['REPLY_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REPLY_YN'] as Map<String, dynamic>),
      attachYn: json['ATTACH_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ATTACH_YN'] as Map<String, dynamic>),
      attachSize: json['ATTACH_SIZE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ATTACH_SIZE'] as Map<String, dynamic>),
      attachCnt: json['ATTACH_CNT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ATTACH_CNT'] as Map<String, dynamic>),
      attachExt: json['ATTACH_EXT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ATTACH_EXT'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STBOARDSTNGUpdateInputToJson(
    STBOARDSTNGUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_CD', instance.boardCd?.toJson());
  writeNotNull('BOARD_NM', instance.boardNm?.toJson());
  writeNotNull('BOARD_TY', instance.boardTy?.toJson());
  writeNotNull('EDITOR_YN', instance.editorYn?.toJson());
  writeNotNull('RLS_YN', instance.rlsYn?.toJson());
  writeNotNull('CCL_SEQ', instance.cclSeq?.toJson());
  writeNotNull('LIST_CNT', instance.listCnt?.toJson());
  writeNotNull('WRITE_YN', instance.writeYn?.toJson());
  writeNotNull('COMMENT_YN', instance.commentYn?.toJson());
  writeNotNull('REPLY_YN', instance.replyYn?.toJson());
  writeNotNull('ATTACH_YN', instance.attachYn?.toJson());
  writeNotNull('ATTACH_SIZE', instance.attachSize?.toJson());
  writeNotNull('ATTACH_CNT', instance.attachCnt?.toJson());
  writeNotNull('ATTACH_EXT', instance.attachExt?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STBOARDSTNGUncheckedUpdateInput _$STBOARDSTNGUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDSTNGUncheckedUpdateInput(
      boardCd: json['BOARD_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['BOARD_CD'] as Map<String, dynamic>),
      boardNm: json['BOARD_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['BOARD_NM'] as Map<String, dynamic>),
      boardTy: json['BOARD_TY'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['BOARD_TY'] as Map<String, dynamic>),
      editorYn: json['EDITOR_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['EDITOR_YN'] as Map<String, dynamic>),
      rlsYn: json['RLS_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['RLS_YN'] as Map<String, dynamic>),
      cclSeq: json['CCL_SEQ'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['CCL_SEQ'] as Map<String, dynamic>),
      listCnt: json['LIST_CNT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['LIST_CNT'] as Map<String, dynamic>),
      writeYn: json['WRITE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['WRITE_YN'] as Map<String, dynamic>),
      commentYn: json['COMMENT_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['COMMENT_YN'] as Map<String, dynamic>),
      replyYn: json['REPLY_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REPLY_YN'] as Map<String, dynamic>),
      attachYn: json['ATTACH_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ATTACH_YN'] as Map<String, dynamic>),
      attachSize: json['ATTACH_SIZE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ATTACH_SIZE'] as Map<String, dynamic>),
      attachCnt: json['ATTACH_CNT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ATTACH_CNT'] as Map<String, dynamic>),
      attachExt: json['ATTACH_EXT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ATTACH_EXT'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STBOARDSTNGUncheckedUpdateInputToJson(
    STBOARDSTNGUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_CD', instance.boardCd?.toJson());
  writeNotNull('BOARD_NM', instance.boardNm?.toJson());
  writeNotNull('BOARD_TY', instance.boardTy?.toJson());
  writeNotNull('EDITOR_YN', instance.editorYn?.toJson());
  writeNotNull('RLS_YN', instance.rlsYn?.toJson());
  writeNotNull('CCL_SEQ', instance.cclSeq?.toJson());
  writeNotNull('LIST_CNT', instance.listCnt?.toJson());
  writeNotNull('WRITE_YN', instance.writeYn?.toJson());
  writeNotNull('COMMENT_YN', instance.commentYn?.toJson());
  writeNotNull('REPLY_YN', instance.replyYn?.toJson());
  writeNotNull('ATTACH_YN', instance.attachYn?.toJson());
  writeNotNull('ATTACH_SIZE', instance.attachSize?.toJson());
  writeNotNull('ATTACH_CNT', instance.attachCnt?.toJson());
  writeNotNull('ATTACH_EXT', instance.attachExt?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STBOARDSTNGCreateManyInput _$STBOARDSTNGCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDSTNGCreateManyInput(
      boardCd: json['BOARD_CD'] as String,
      boardNm: json['BOARD_NM'] as String,
      boardTy: json['BOARD_TY'] as String?,
      editorYn: json['EDITOR_YN'] as String?,
      rlsYn: json['RLS_YN'] as String?,
      cclSeq: json['CCL_SEQ'] as int?,
      listCnt: json['LIST_CNT'] as int?,
      writeYn: json['WRITE_YN'] as String?,
      commentYn: json['COMMENT_YN'] as String?,
      replyYn: json['REPLY_YN'] as String?,
      attachYn: json['ATTACH_YN'] as String?,
      attachSize: json['ATTACH_SIZE'] as String?,
      attachCnt: json['ATTACH_CNT'] as String?,
      attachExt: json['ATTACH_EXT'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STBOARDSTNGCreateManyInputToJson(
    STBOARDSTNGCreateManyInput instance) {
  final val = <String, dynamic>{
    'BOARD_CD': instance.boardCd,
    'BOARD_NM': instance.boardNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_TY', instance.boardTy);
  writeNotNull('EDITOR_YN', instance.editorYn);
  writeNotNull('RLS_YN', instance.rlsYn);
  writeNotNull('CCL_SEQ', instance.cclSeq);
  writeNotNull('LIST_CNT', instance.listCnt);
  writeNotNull('WRITE_YN', instance.writeYn);
  writeNotNull('COMMENT_YN', instance.commentYn);
  writeNotNull('REPLY_YN', instance.replyYn);
  writeNotNull('ATTACH_YN', instance.attachYn);
  writeNotNull('ATTACH_SIZE', instance.attachSize);
  writeNotNull('ATTACH_CNT', instance.attachCnt);
  writeNotNull('ATTACH_EXT', instance.attachExt);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STBOARDSTNGUpdateManyMutationInput _$STBOARDSTNGUpdateManyMutationInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDSTNGUpdateManyMutationInput(
      boardCd: json['BOARD_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['BOARD_CD'] as Map<String, dynamic>),
      boardNm: json['BOARD_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['BOARD_NM'] as Map<String, dynamic>),
      boardTy: json['BOARD_TY'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['BOARD_TY'] as Map<String, dynamic>),
      editorYn: json['EDITOR_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['EDITOR_YN'] as Map<String, dynamic>),
      rlsYn: json['RLS_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['RLS_YN'] as Map<String, dynamic>),
      cclSeq: json['CCL_SEQ'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['CCL_SEQ'] as Map<String, dynamic>),
      listCnt: json['LIST_CNT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['LIST_CNT'] as Map<String, dynamic>),
      writeYn: json['WRITE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['WRITE_YN'] as Map<String, dynamic>),
      commentYn: json['COMMENT_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['COMMENT_YN'] as Map<String, dynamic>),
      replyYn: json['REPLY_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REPLY_YN'] as Map<String, dynamic>),
      attachYn: json['ATTACH_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ATTACH_YN'] as Map<String, dynamic>),
      attachSize: json['ATTACH_SIZE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ATTACH_SIZE'] as Map<String, dynamic>),
      attachCnt: json['ATTACH_CNT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ATTACH_CNT'] as Map<String, dynamic>),
      attachExt: json['ATTACH_EXT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ATTACH_EXT'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STBOARDSTNGUpdateManyMutationInputToJson(
    STBOARDSTNGUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_CD', instance.boardCd?.toJson());
  writeNotNull('BOARD_NM', instance.boardNm?.toJson());
  writeNotNull('BOARD_TY', instance.boardTy?.toJson());
  writeNotNull('EDITOR_YN', instance.editorYn?.toJson());
  writeNotNull('RLS_YN', instance.rlsYn?.toJson());
  writeNotNull('CCL_SEQ', instance.cclSeq?.toJson());
  writeNotNull('LIST_CNT', instance.listCnt?.toJson());
  writeNotNull('WRITE_YN', instance.writeYn?.toJson());
  writeNotNull('COMMENT_YN', instance.commentYn?.toJson());
  writeNotNull('REPLY_YN', instance.replyYn?.toJson());
  writeNotNull('ATTACH_YN', instance.attachYn?.toJson());
  writeNotNull('ATTACH_SIZE', instance.attachSize?.toJson());
  writeNotNull('ATTACH_CNT', instance.attachCnt?.toJson());
  writeNotNull('ATTACH_EXT', instance.attachExt?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STBOARDSTNGUncheckedUpdateManyInput
    _$STBOARDSTNGUncheckedUpdateManyInputFromJson(Map<String, dynamic> json) =>
        STBOARDSTNGUncheckedUpdateManyInput(
          boardCd: json['BOARD_CD'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['BOARD_CD'] as Map<String, dynamic>),
          boardNm: json['BOARD_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['BOARD_NM'] as Map<String, dynamic>),
          boardTy: json['BOARD_TY'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['BOARD_TY'] as Map<String, dynamic>),
          editorYn: json['EDITOR_YN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['EDITOR_YN'] as Map<String, dynamic>),
          rlsYn: json['RLS_YN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['RLS_YN'] as Map<String, dynamic>),
          cclSeq: json['CCL_SEQ'] == null
              ? null
              : NullableIntFieldUpdateOperationsInput.fromJson(
                  json['CCL_SEQ'] as Map<String, dynamic>),
          listCnt: json['LIST_CNT'] == null
              ? null
              : NullableIntFieldUpdateOperationsInput.fromJson(
                  json['LIST_CNT'] as Map<String, dynamic>),
          writeYn: json['WRITE_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['WRITE_YN'] as Map<String, dynamic>),
          commentYn: json['COMMENT_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['COMMENT_YN'] as Map<String, dynamic>),
          replyYn: json['REPLY_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REPLY_YN'] as Map<String, dynamic>),
          attachYn: json['ATTACH_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['ATTACH_YN'] as Map<String, dynamic>),
          attachSize: json['ATTACH_SIZE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['ATTACH_SIZE'] as Map<String, dynamic>),
          attachCnt: json['ATTACH_CNT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['ATTACH_CNT'] as Map<String, dynamic>),
          attachExt: json['ATTACH_EXT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['ATTACH_EXT'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delId: json['DEL_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_ID'] as Map<String, dynamic>),
          delDate: json['DEL_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STBOARDSTNGUncheckedUpdateManyInputToJson(
    STBOARDSTNGUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_CD', instance.boardCd?.toJson());
  writeNotNull('BOARD_NM', instance.boardNm?.toJson());
  writeNotNull('BOARD_TY', instance.boardTy?.toJson());
  writeNotNull('EDITOR_YN', instance.editorYn?.toJson());
  writeNotNull('RLS_YN', instance.rlsYn?.toJson());
  writeNotNull('CCL_SEQ', instance.cclSeq?.toJson());
  writeNotNull('LIST_CNT', instance.listCnt?.toJson());
  writeNotNull('WRITE_YN', instance.writeYn?.toJson());
  writeNotNull('COMMENT_YN', instance.commentYn?.toJson());
  writeNotNull('REPLY_YN', instance.replyYn?.toJson());
  writeNotNull('ATTACH_YN', instance.attachYn?.toJson());
  writeNotNull('ATTACH_SIZE', instance.attachSize?.toJson());
  writeNotNull('ATTACH_CNT', instance.attachCnt?.toJson());
  writeNotNull('ATTACH_EXT', instance.attachExt?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STCCLCreateInput _$STCCLCreateInputFromJson(Map<String, dynamic> json) =>
    STCCLCreateInput(
      seq: json['SEQ'] as int,
      cclType: json['CCL_TYPE'] as String,
      cclNm: json['CCL_NM'] as String,
      flpth: json['FLPTH'] as String?,
      orginalFileNm: json['ORGINAL_FILE_NM'] as String?,
      streFileNm: json['STRE_FILE_NM'] as String?,
      fileExtsn: json['FILE_EXTSN'] as String?,
      fileSize: json['FILE_SIZE'] as int?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STCCLCreateInputToJson(STCCLCreateInput instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'CCL_TYPE': instance.cclType,
    'CCL_NM': instance.cclNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('FLPTH', instance.flpth);
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm);
  writeNotNull('STRE_FILE_NM', instance.streFileNm);
  writeNotNull('FILE_EXTSN', instance.fileExtsn);
  writeNotNull('FILE_SIZE', instance.fileSize);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STCCLUncheckedCreateInput _$STCCLUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    STCCLUncheckedCreateInput(
      seq: json['SEQ'] as int,
      cclType: json['CCL_TYPE'] as String,
      cclNm: json['CCL_NM'] as String,
      flpth: json['FLPTH'] as String?,
      orginalFileNm: json['ORGINAL_FILE_NM'] as String?,
      streFileNm: json['STRE_FILE_NM'] as String?,
      fileExtsn: json['FILE_EXTSN'] as String?,
      fileSize: json['FILE_SIZE'] as int?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STCCLUncheckedCreateInputToJson(
    STCCLUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'CCL_TYPE': instance.cclType,
    'CCL_NM': instance.cclNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('FLPTH', instance.flpth);
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm);
  writeNotNull('STRE_FILE_NM', instance.streFileNm);
  writeNotNull('FILE_EXTSN', instance.fileExtsn);
  writeNotNull('FILE_SIZE', instance.fileSize);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STCCLUpdateInput _$STCCLUpdateInputFromJson(Map<String, dynamic> json) =>
    STCCLUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      cclType: json['CCL_TYPE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CCL_TYPE'] as Map<String, dynamic>),
      cclNm: json['CCL_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CCL_NM'] as Map<String, dynamic>),
      flpth: json['FLPTH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FLPTH'] as Map<String, dynamic>),
      orginalFileNm: json['ORGINAL_FILE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ORGINAL_FILE_NM'] as Map<String, dynamic>),
      streFileNm: json['STRE_FILE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['STRE_FILE_NM'] as Map<String, dynamic>),
      fileExtsn: json['FILE_EXTSN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FILE_EXTSN'] as Map<String, dynamic>),
      fileSize: json['FILE_SIZE'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['FILE_SIZE'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STCCLUpdateInputToJson(STCCLUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('CCL_TYPE', instance.cclType?.toJson());
  writeNotNull('CCL_NM', instance.cclNm?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm?.toJson());
  writeNotNull('STRE_FILE_NM', instance.streFileNm?.toJson());
  writeNotNull('FILE_EXTSN', instance.fileExtsn?.toJson());
  writeNotNull('FILE_SIZE', instance.fileSize?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STCCLUncheckedUpdateInput _$STCCLUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STCCLUncheckedUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      cclType: json['CCL_TYPE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CCL_TYPE'] as Map<String, dynamic>),
      cclNm: json['CCL_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CCL_NM'] as Map<String, dynamic>),
      flpth: json['FLPTH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FLPTH'] as Map<String, dynamic>),
      orginalFileNm: json['ORGINAL_FILE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ORGINAL_FILE_NM'] as Map<String, dynamic>),
      streFileNm: json['STRE_FILE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['STRE_FILE_NM'] as Map<String, dynamic>),
      fileExtsn: json['FILE_EXTSN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FILE_EXTSN'] as Map<String, dynamic>),
      fileSize: json['FILE_SIZE'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['FILE_SIZE'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STCCLUncheckedUpdateInputToJson(
    STCCLUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('CCL_TYPE', instance.cclType?.toJson());
  writeNotNull('CCL_NM', instance.cclNm?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm?.toJson());
  writeNotNull('STRE_FILE_NM', instance.streFileNm?.toJson());
  writeNotNull('FILE_EXTSN', instance.fileExtsn?.toJson());
  writeNotNull('FILE_SIZE', instance.fileSize?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STCCLCreateManyInput _$STCCLCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    STCCLCreateManyInput(
      seq: json['SEQ'] as int,
      cclType: json['CCL_TYPE'] as String,
      cclNm: json['CCL_NM'] as String,
      flpth: json['FLPTH'] as String?,
      orginalFileNm: json['ORGINAL_FILE_NM'] as String?,
      streFileNm: json['STRE_FILE_NM'] as String?,
      fileExtsn: json['FILE_EXTSN'] as String?,
      fileSize: json['FILE_SIZE'] as int?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STCCLCreateManyInputToJson(
    STCCLCreateManyInput instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'CCL_TYPE': instance.cclType,
    'CCL_NM': instance.cclNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('FLPTH', instance.flpth);
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm);
  writeNotNull('STRE_FILE_NM', instance.streFileNm);
  writeNotNull('FILE_EXTSN', instance.fileExtsn);
  writeNotNull('FILE_SIZE', instance.fileSize);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STCCLUpdateManyMutationInput _$STCCLUpdateManyMutationInputFromJson(
        Map<String, dynamic> json) =>
    STCCLUpdateManyMutationInput(
      seq: json['SEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      cclType: json['CCL_TYPE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CCL_TYPE'] as Map<String, dynamic>),
      cclNm: json['CCL_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CCL_NM'] as Map<String, dynamic>),
      flpth: json['FLPTH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FLPTH'] as Map<String, dynamic>),
      orginalFileNm: json['ORGINAL_FILE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ORGINAL_FILE_NM'] as Map<String, dynamic>),
      streFileNm: json['STRE_FILE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['STRE_FILE_NM'] as Map<String, dynamic>),
      fileExtsn: json['FILE_EXTSN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FILE_EXTSN'] as Map<String, dynamic>),
      fileSize: json['FILE_SIZE'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['FILE_SIZE'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STCCLUpdateManyMutationInputToJson(
    STCCLUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('CCL_TYPE', instance.cclType?.toJson());
  writeNotNull('CCL_NM', instance.cclNm?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm?.toJson());
  writeNotNull('STRE_FILE_NM', instance.streFileNm?.toJson());
  writeNotNull('FILE_EXTSN', instance.fileExtsn?.toJson());
  writeNotNull('FILE_SIZE', instance.fileSize?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STCCLUncheckedUpdateManyInput _$STCCLUncheckedUpdateManyInputFromJson(
        Map<String, dynamic> json) =>
    STCCLUncheckedUpdateManyInput(
      seq: json['SEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      cclType: json['CCL_TYPE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CCL_TYPE'] as Map<String, dynamic>),
      cclNm: json['CCL_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CCL_NM'] as Map<String, dynamic>),
      flpth: json['FLPTH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FLPTH'] as Map<String, dynamic>),
      orginalFileNm: json['ORGINAL_FILE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ORGINAL_FILE_NM'] as Map<String, dynamic>),
      streFileNm: json['STRE_FILE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['STRE_FILE_NM'] as Map<String, dynamic>),
      fileExtsn: json['FILE_EXTSN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FILE_EXTSN'] as Map<String, dynamic>),
      fileSize: json['FILE_SIZE'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['FILE_SIZE'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STCCLUncheckedUpdateManyInputToJson(
    STCCLUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('CCL_TYPE', instance.cclType?.toJson());
  writeNotNull('CCL_NM', instance.cclNm?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm?.toJson());
  writeNotNull('STRE_FILE_NM', instance.streFileNm?.toJson());
  writeNotNull('FILE_EXTSN', instance.fileExtsn?.toJson());
  writeNotNull('FILE_SIZE', instance.fileSize?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STCODEMSTCreateInput _$STCODEMSTCreateInputFromJson(
        Map<String, dynamic> json) =>
    STCODEMSTCreateInput(
      cdGrp: json['CD_GRP'] as String,
      cdKey: json['CD_KEY'] as String,
      cdVal: json['CD_VAL'] as String,
      cdDesc: json['CD_DESC'] as String?,
      cdSrt: json['CD_SRT'] as int,
      depth: json['DEPTH'] as int?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STCODEMSTCreateInputToJson(
    STCODEMSTCreateInput instance) {
  final val = <String, dynamic>{
    'CD_GRP': instance.cdGrp,
    'CD_KEY': instance.cdKey,
    'CD_VAL': instance.cdVal,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CD_DESC', instance.cdDesc);
  val['CD_SRT'] = instance.cdSrt;
  writeNotNull('DEPTH', instance.depth);
  val['REG_ID'] = instance.regId;
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STCODEMSTUncheckedCreateInput _$STCODEMSTUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    STCODEMSTUncheckedCreateInput(
      cdGrp: json['CD_GRP'] as String,
      cdKey: json['CD_KEY'] as String,
      cdVal: json['CD_VAL'] as String,
      cdDesc: json['CD_DESC'] as String?,
      cdSrt: json['CD_SRT'] as int,
      depth: json['DEPTH'] as int?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STCODEMSTUncheckedCreateInputToJson(
    STCODEMSTUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'CD_GRP': instance.cdGrp,
    'CD_KEY': instance.cdKey,
    'CD_VAL': instance.cdVal,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CD_DESC', instance.cdDesc);
  val['CD_SRT'] = instance.cdSrt;
  writeNotNull('DEPTH', instance.depth);
  val['REG_ID'] = instance.regId;
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STCODEMSTUpdateInput _$STCODEMSTUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STCODEMSTUpdateInput(
      cdGrp: json['CD_GRP'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CD_GRP'] as Map<String, dynamic>),
      cdKey: json['CD_KEY'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CD_KEY'] as Map<String, dynamic>),
      cdVal: json['CD_VAL'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CD_VAL'] as Map<String, dynamic>),
      cdDesc: json['CD_DESC'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CD_DESC'] as Map<String, dynamic>),
      cdSrt: json['CD_SRT'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['CD_SRT'] as Map<String, dynamic>),
      depth: json['DEPTH'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['DEPTH'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STCODEMSTUpdateInputToJson(
    STCODEMSTUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CD_GRP', instance.cdGrp?.toJson());
  writeNotNull('CD_KEY', instance.cdKey?.toJson());
  writeNotNull('CD_VAL', instance.cdVal?.toJson());
  writeNotNull('CD_DESC', instance.cdDesc?.toJson());
  writeNotNull('CD_SRT', instance.cdSrt?.toJson());
  writeNotNull('DEPTH', instance.depth?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STCODEMSTUncheckedUpdateInput _$STCODEMSTUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STCODEMSTUncheckedUpdateInput(
      cdGrp: json['CD_GRP'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CD_GRP'] as Map<String, dynamic>),
      cdKey: json['CD_KEY'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CD_KEY'] as Map<String, dynamic>),
      cdVal: json['CD_VAL'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CD_VAL'] as Map<String, dynamic>),
      cdDesc: json['CD_DESC'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CD_DESC'] as Map<String, dynamic>),
      cdSrt: json['CD_SRT'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['CD_SRT'] as Map<String, dynamic>),
      depth: json['DEPTH'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['DEPTH'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STCODEMSTUncheckedUpdateInputToJson(
    STCODEMSTUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CD_GRP', instance.cdGrp?.toJson());
  writeNotNull('CD_KEY', instance.cdKey?.toJson());
  writeNotNull('CD_VAL', instance.cdVal?.toJson());
  writeNotNull('CD_DESC', instance.cdDesc?.toJson());
  writeNotNull('CD_SRT', instance.cdSrt?.toJson());
  writeNotNull('DEPTH', instance.depth?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STCODEMSTCreateManyInput _$STCODEMSTCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    STCODEMSTCreateManyInput(
      cdGrp: json['CD_GRP'] as String,
      cdKey: json['CD_KEY'] as String,
      cdVal: json['CD_VAL'] as String,
      cdDesc: json['CD_DESC'] as String?,
      cdSrt: json['CD_SRT'] as int,
      depth: json['DEPTH'] as int?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STCODEMSTCreateManyInputToJson(
    STCODEMSTCreateManyInput instance) {
  final val = <String, dynamic>{
    'CD_GRP': instance.cdGrp,
    'CD_KEY': instance.cdKey,
    'CD_VAL': instance.cdVal,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CD_DESC', instance.cdDesc);
  val['CD_SRT'] = instance.cdSrt;
  writeNotNull('DEPTH', instance.depth);
  val['REG_ID'] = instance.regId;
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STCODEMSTUpdateManyMutationInput _$STCODEMSTUpdateManyMutationInputFromJson(
        Map<String, dynamic> json) =>
    STCODEMSTUpdateManyMutationInput(
      cdGrp: json['CD_GRP'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CD_GRP'] as Map<String, dynamic>),
      cdKey: json['CD_KEY'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CD_KEY'] as Map<String, dynamic>),
      cdVal: json['CD_VAL'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CD_VAL'] as Map<String, dynamic>),
      cdDesc: json['CD_DESC'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CD_DESC'] as Map<String, dynamic>),
      cdSrt: json['CD_SRT'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['CD_SRT'] as Map<String, dynamic>),
      depth: json['DEPTH'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['DEPTH'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STCODEMSTUpdateManyMutationInputToJson(
    STCODEMSTUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CD_GRP', instance.cdGrp?.toJson());
  writeNotNull('CD_KEY', instance.cdKey?.toJson());
  writeNotNull('CD_VAL', instance.cdVal?.toJson());
  writeNotNull('CD_DESC', instance.cdDesc?.toJson());
  writeNotNull('CD_SRT', instance.cdSrt?.toJson());
  writeNotNull('DEPTH', instance.depth?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STCODEMSTUncheckedUpdateManyInput _$STCODEMSTUncheckedUpdateManyInputFromJson(
        Map<String, dynamic> json) =>
    STCODEMSTUncheckedUpdateManyInput(
      cdGrp: json['CD_GRP'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CD_GRP'] as Map<String, dynamic>),
      cdKey: json['CD_KEY'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CD_KEY'] as Map<String, dynamic>),
      cdVal: json['CD_VAL'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CD_VAL'] as Map<String, dynamic>),
      cdDesc: json['CD_DESC'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CD_DESC'] as Map<String, dynamic>),
      cdSrt: json['CD_SRT'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['CD_SRT'] as Map<String, dynamic>),
      depth: json['DEPTH'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['DEPTH'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STCODEMSTUncheckedUpdateManyInputToJson(
    STCODEMSTUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CD_GRP', instance.cdGrp?.toJson());
  writeNotNull('CD_KEY', instance.cdKey?.toJson());
  writeNotNull('CD_VAL', instance.cdVal?.toJson());
  writeNotNull('CD_DESC', instance.cdDesc?.toJson());
  writeNotNull('CD_SRT', instance.cdSrt?.toJson());
  writeNotNull('DEPTH', instance.depth?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STCONNECTLOGCreateInput _$STCONNECTLOGCreateInputFromJson(
        Map<String, dynamic> json) =>
    STCONNECTLOGCreateInput(
      seq: json['SEQ'] as int,
      userId: json['USER_ID'] as String,
      connType: json['CONN_TYPE'] as String?,
      osType: json['OS_TYPE'] as String?,
      browserType: json['BROWSER_TYPE'] as String?,
      conneIp: json['CONNE_IP'] as String?,
      regDate: json['REG_DATE'] as String?,
    );

Map<String, dynamic> _$STCONNECTLOGCreateInputToJson(
    STCONNECTLOGCreateInput instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'USER_ID': instance.userId,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CONN_TYPE', instance.connType);
  writeNotNull('OS_TYPE', instance.osType);
  writeNotNull('BROWSER_TYPE', instance.browserType);
  writeNotNull('CONNE_IP', instance.conneIp);
  writeNotNull('REG_DATE', instance.regDate);
  return val;
}

STCONNECTLOGUncheckedCreateInput _$STCONNECTLOGUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    STCONNECTLOGUncheckedCreateInput(
      seq: json['SEQ'] as int,
      userId: json['USER_ID'] as String,
      connType: json['CONN_TYPE'] as String?,
      osType: json['OS_TYPE'] as String?,
      browserType: json['BROWSER_TYPE'] as String?,
      conneIp: json['CONNE_IP'] as String?,
      regDate: json['REG_DATE'] as String?,
    );

Map<String, dynamic> _$STCONNECTLOGUncheckedCreateInputToJson(
    STCONNECTLOGUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'USER_ID': instance.userId,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CONN_TYPE', instance.connType);
  writeNotNull('OS_TYPE', instance.osType);
  writeNotNull('BROWSER_TYPE', instance.browserType);
  writeNotNull('CONNE_IP', instance.conneIp);
  writeNotNull('REG_DATE', instance.regDate);
  return val;
}

STCONNECTLOGUpdateInput _$STCONNECTLOGUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STCONNECTLOGUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      userId: json['USER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_ID'] as Map<String, dynamic>),
      connType: json['CONN_TYPE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CONN_TYPE'] as Map<String, dynamic>),
      osType: json['OS_TYPE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['OS_TYPE'] as Map<String, dynamic>),
      browserType: json['BROWSER_TYPE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['BROWSER_TYPE'] as Map<String, dynamic>),
      conneIp: json['CONNE_IP'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CONNE_IP'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STCONNECTLOGUpdateInputToJson(
    STCONNECTLOGUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('CONN_TYPE', instance.connType?.toJson());
  writeNotNull('OS_TYPE', instance.osType?.toJson());
  writeNotNull('BROWSER_TYPE', instance.browserType?.toJson());
  writeNotNull('CONNE_IP', instance.conneIp?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

STCONNECTLOGUncheckedUpdateInput _$STCONNECTLOGUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STCONNECTLOGUncheckedUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      userId: json['USER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_ID'] as Map<String, dynamic>),
      connType: json['CONN_TYPE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CONN_TYPE'] as Map<String, dynamic>),
      osType: json['OS_TYPE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['OS_TYPE'] as Map<String, dynamic>),
      browserType: json['BROWSER_TYPE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['BROWSER_TYPE'] as Map<String, dynamic>),
      conneIp: json['CONNE_IP'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CONNE_IP'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STCONNECTLOGUncheckedUpdateInputToJson(
    STCONNECTLOGUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('CONN_TYPE', instance.connType?.toJson());
  writeNotNull('OS_TYPE', instance.osType?.toJson());
  writeNotNull('BROWSER_TYPE', instance.browserType?.toJson());
  writeNotNull('CONNE_IP', instance.conneIp?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

STCONNECTLOGCreateManyInput _$STCONNECTLOGCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    STCONNECTLOGCreateManyInput(
      seq: json['SEQ'] as int,
      userId: json['USER_ID'] as String,
      connType: json['CONN_TYPE'] as String?,
      osType: json['OS_TYPE'] as String?,
      browserType: json['BROWSER_TYPE'] as String?,
      conneIp: json['CONNE_IP'] as String?,
      regDate: json['REG_DATE'] as String?,
    );

Map<String, dynamic> _$STCONNECTLOGCreateManyInputToJson(
    STCONNECTLOGCreateManyInput instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'USER_ID': instance.userId,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CONN_TYPE', instance.connType);
  writeNotNull('OS_TYPE', instance.osType);
  writeNotNull('BROWSER_TYPE', instance.browserType);
  writeNotNull('CONNE_IP', instance.conneIp);
  writeNotNull('REG_DATE', instance.regDate);
  return val;
}

STCONNECTLOGUpdateManyMutationInput
    _$STCONNECTLOGUpdateManyMutationInputFromJson(Map<String, dynamic> json) =>
        STCONNECTLOGUpdateManyMutationInput(
          seq: json['SEQ'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          userId: json['USER_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['USER_ID'] as Map<String, dynamic>),
          connType: json['CONN_TYPE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CONN_TYPE'] as Map<String, dynamic>),
          osType: json['OS_TYPE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['OS_TYPE'] as Map<String, dynamic>),
          browserType: json['BROWSER_TYPE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['BROWSER_TYPE'] as Map<String, dynamic>),
          conneIp: json['CONNE_IP'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CONNE_IP'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STCONNECTLOGUpdateManyMutationInputToJson(
    STCONNECTLOGUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('CONN_TYPE', instance.connType?.toJson());
  writeNotNull('OS_TYPE', instance.osType?.toJson());
  writeNotNull('BROWSER_TYPE', instance.browserType?.toJson());
  writeNotNull('CONNE_IP', instance.conneIp?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

STCONNECTLOGUncheckedUpdateManyInput
    _$STCONNECTLOGUncheckedUpdateManyInputFromJson(Map<String, dynamic> json) =>
        STCONNECTLOGUncheckedUpdateManyInput(
          seq: json['SEQ'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          userId: json['USER_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['USER_ID'] as Map<String, dynamic>),
          connType: json['CONN_TYPE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CONN_TYPE'] as Map<String, dynamic>),
          osType: json['OS_TYPE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['OS_TYPE'] as Map<String, dynamic>),
          browserType: json['BROWSER_TYPE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['BROWSER_TYPE'] as Map<String, dynamic>),
          conneIp: json['CONNE_IP'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CONNE_IP'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STCONNECTLOGUncheckedUpdateManyInputToJson(
    STCONNECTLOGUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('CONN_TYPE', instance.connType?.toJson());
  writeNotNull('OS_TYPE', instance.osType?.toJson());
  writeNotNull('BROWSER_TYPE', instance.browserType?.toJson());
  writeNotNull('CONNE_IP', instance.conneIp?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

STCONTENTSFILECreateInput _$STCONTENTSFILECreateInputFromJson(
        Map<String, dynamic> json) =>
    STCONTENTSFILECreateInput(
      mseq: json['MSEQ'] as String,
      fileTp: json['FILE_TP'] as String?,
      flpth: json['FLPTH'] as String,
      orginalFileNm: json['ORGINAL_FILE_NM'] as String,
      streFileNm: json['STRE_FILE_NM'] as String,
      fileSize: json['FILE_SIZE'] as int,
    );

Map<String, dynamic> _$STCONTENTSFILECreateInputToJson(
    STCONTENTSFILECreateInput instance) {
  final val = <String, dynamic>{
    'MSEQ': instance.mseq,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('FILE_TP', instance.fileTp);
  val['FLPTH'] = instance.flpth;
  val['ORGINAL_FILE_NM'] = instance.orginalFileNm;
  val['STRE_FILE_NM'] = instance.streFileNm;
  val['FILE_SIZE'] = instance.fileSize;
  return val;
}

STCONTENTSFILEUncheckedCreateInput _$STCONTENTSFILEUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    STCONTENTSFILEUncheckedCreateInput(
      seq: json['SEQ'] as int?,
      mseq: json['MSEQ'] as String,
      fileTp: json['FILE_TP'] as String?,
      flpth: json['FLPTH'] as String,
      orginalFileNm: json['ORGINAL_FILE_NM'] as String,
      streFileNm: json['STRE_FILE_NM'] as String,
      fileSize: json['FILE_SIZE'] as int,
    );

Map<String, dynamic> _$STCONTENTSFILEUncheckedCreateInputToJson(
    STCONTENTSFILEUncheckedCreateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq);
  val['MSEQ'] = instance.mseq;
  writeNotNull('FILE_TP', instance.fileTp);
  val['FLPTH'] = instance.flpth;
  val['ORGINAL_FILE_NM'] = instance.orginalFileNm;
  val['STRE_FILE_NM'] = instance.streFileNm;
  val['FILE_SIZE'] = instance.fileSize;
  return val;
}

STCONTENTSFILEUpdateInput _$STCONTENTSFILEUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STCONTENTSFILEUpdateInput(
      mseq: json['MSEQ'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MSEQ'] as Map<String, dynamic>),
      fileTp: json['FILE_TP'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FILE_TP'] as Map<String, dynamic>),
      flpth: json['FLPTH'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['FLPTH'] as Map<String, dynamic>),
      orginalFileNm: json['ORGINAL_FILE_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['ORGINAL_FILE_NM'] as Map<String, dynamic>),
      streFileNm: json['STRE_FILE_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['STRE_FILE_NM'] as Map<String, dynamic>),
      fileSize: json['FILE_SIZE'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['FILE_SIZE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STCONTENTSFILEUpdateInputToJson(
    STCONTENTSFILEUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('FILE_TP', instance.fileTp?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm?.toJson());
  writeNotNull('STRE_FILE_NM', instance.streFileNm?.toJson());
  writeNotNull('FILE_SIZE', instance.fileSize?.toJson());
  return val;
}

STCONTENTSFILEUncheckedUpdateInput _$STCONTENTSFILEUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STCONTENTSFILEUncheckedUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      mseq: json['MSEQ'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MSEQ'] as Map<String, dynamic>),
      fileTp: json['FILE_TP'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FILE_TP'] as Map<String, dynamic>),
      flpth: json['FLPTH'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['FLPTH'] as Map<String, dynamic>),
      orginalFileNm: json['ORGINAL_FILE_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['ORGINAL_FILE_NM'] as Map<String, dynamic>),
      streFileNm: json['STRE_FILE_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['STRE_FILE_NM'] as Map<String, dynamic>),
      fileSize: json['FILE_SIZE'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['FILE_SIZE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STCONTENTSFILEUncheckedUpdateInputToJson(
    STCONTENTSFILEUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('FILE_TP', instance.fileTp?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm?.toJson());
  writeNotNull('STRE_FILE_NM', instance.streFileNm?.toJson());
  writeNotNull('FILE_SIZE', instance.fileSize?.toJson());
  return val;
}

STCONTENTSFILECreateManyInput _$STCONTENTSFILECreateManyInputFromJson(
        Map<String, dynamic> json) =>
    STCONTENTSFILECreateManyInput(
      seq: json['SEQ'] as int?,
      mseq: json['MSEQ'] as String,
      fileTp: json['FILE_TP'] as String?,
      flpth: json['FLPTH'] as String,
      orginalFileNm: json['ORGINAL_FILE_NM'] as String,
      streFileNm: json['STRE_FILE_NM'] as String,
      fileSize: json['FILE_SIZE'] as int,
    );

Map<String, dynamic> _$STCONTENTSFILECreateManyInputToJson(
    STCONTENTSFILECreateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq);
  val['MSEQ'] = instance.mseq;
  writeNotNull('FILE_TP', instance.fileTp);
  val['FLPTH'] = instance.flpth;
  val['ORGINAL_FILE_NM'] = instance.orginalFileNm;
  val['STRE_FILE_NM'] = instance.streFileNm;
  val['FILE_SIZE'] = instance.fileSize;
  return val;
}

STCONTENTSFILEUpdateManyMutationInput
    _$STCONTENTSFILEUpdateManyMutationInputFromJson(
            Map<String, dynamic> json) =>
        STCONTENTSFILEUpdateManyMutationInput(
          mseq: json['MSEQ'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['MSEQ'] as Map<String, dynamic>),
          fileTp: json['FILE_TP'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['FILE_TP'] as Map<String, dynamic>),
          flpth: json['FLPTH'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['FLPTH'] as Map<String, dynamic>),
          orginalFileNm: json['ORGINAL_FILE_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['ORGINAL_FILE_NM'] as Map<String, dynamic>),
          streFileNm: json['STRE_FILE_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['STRE_FILE_NM'] as Map<String, dynamic>),
          fileSize: json['FILE_SIZE'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['FILE_SIZE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STCONTENTSFILEUpdateManyMutationInputToJson(
    STCONTENTSFILEUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('FILE_TP', instance.fileTp?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm?.toJson());
  writeNotNull('STRE_FILE_NM', instance.streFileNm?.toJson());
  writeNotNull('FILE_SIZE', instance.fileSize?.toJson());
  return val;
}

STCONTENTSFILEUncheckedUpdateManyInput
    _$STCONTENTSFILEUncheckedUpdateManyInputFromJson(
            Map<String, dynamic> json) =>
        STCONTENTSFILEUncheckedUpdateManyInput(
          seq: json['SEQ'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          mseq: json['MSEQ'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['MSEQ'] as Map<String, dynamic>),
          fileTp: json['FILE_TP'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['FILE_TP'] as Map<String, dynamic>),
          flpth: json['FLPTH'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['FLPTH'] as Map<String, dynamic>),
          orginalFileNm: json['ORGINAL_FILE_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['ORGINAL_FILE_NM'] as Map<String, dynamic>),
          streFileNm: json['STRE_FILE_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['STRE_FILE_NM'] as Map<String, dynamic>),
          fileSize: json['FILE_SIZE'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['FILE_SIZE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STCONTENTSFILEUncheckedUpdateManyInputToJson(
    STCONTENTSFILEUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('FILE_TP', instance.fileTp?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm?.toJson());
  writeNotNull('STRE_FILE_NM', instance.streFileNm?.toJson());
  writeNotNull('FILE_SIZE', instance.fileSize?.toJson());
  return val;
}

STCONTENTSMSTCreateInput _$STCONTENTSMSTCreateInputFromJson(
        Map<String, dynamic> json) =>
    STCONTENTSMSTCreateInput(
      seq: json['SEQ'] as int,
      cntsNm: json['CNTS_NM'] as String,
      pubDate: json['PUB_DATE'] as String?,
      pubState: json['PUB_STATE'] as String?,
      cn: json['CN'] as String?,
      srchYn: json['SRCH_YN'] as String?,
      fileYn: json['FILE_YN'] as String?,
      imageYn: json['IMAGE_YN'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STCONTENTSMSTCreateInputToJson(
    STCONTENTSMSTCreateInput instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'CNTS_NM': instance.cntsNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('PUB_DATE', instance.pubDate);
  writeNotNull('PUB_STATE', instance.pubState);
  writeNotNull('CN', instance.cn);
  writeNotNull('SRCH_YN', instance.srchYn);
  writeNotNull('FILE_YN', instance.fileYn);
  writeNotNull('IMAGE_YN', instance.imageYn);
  val['REG_ID'] = instance.regId;
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STCONTENTSMSTUncheckedCreateInput _$STCONTENTSMSTUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    STCONTENTSMSTUncheckedCreateInput(
      seq: json['SEQ'] as int,
      cntsNm: json['CNTS_NM'] as String,
      pubDate: json['PUB_DATE'] as String?,
      pubState: json['PUB_STATE'] as String?,
      cn: json['CN'] as String?,
      srchYn: json['SRCH_YN'] as String?,
      fileYn: json['FILE_YN'] as String?,
      imageYn: json['IMAGE_YN'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STCONTENTSMSTUncheckedCreateInputToJson(
    STCONTENTSMSTUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'CNTS_NM': instance.cntsNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('PUB_DATE', instance.pubDate);
  writeNotNull('PUB_STATE', instance.pubState);
  writeNotNull('CN', instance.cn);
  writeNotNull('SRCH_YN', instance.srchYn);
  writeNotNull('FILE_YN', instance.fileYn);
  writeNotNull('IMAGE_YN', instance.imageYn);
  val['REG_ID'] = instance.regId;
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STCONTENTSMSTUpdateInput _$STCONTENTSMSTUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STCONTENTSMSTUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      cntsNm: json['CNTS_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CNTS_NM'] as Map<String, dynamic>),
      pubDate: json['PUB_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['PUB_DATE'] as Map<String, dynamic>),
      pubState: json['PUB_STATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['PUB_STATE'] as Map<String, dynamic>),
      cn: json['CN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CN'] as Map<String, dynamic>),
      srchYn: json['SRCH_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SRCH_YN'] as Map<String, dynamic>),
      fileYn: json['FILE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FILE_YN'] as Map<String, dynamic>),
      imageYn: json['IMAGE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['IMAGE_YN'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STCONTENTSMSTUpdateInputToJson(
    STCONTENTSMSTUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('CNTS_NM', instance.cntsNm?.toJson());
  writeNotNull('PUB_DATE', instance.pubDate?.toJson());
  writeNotNull('PUB_STATE', instance.pubState?.toJson());
  writeNotNull('CN', instance.cn?.toJson());
  writeNotNull('SRCH_YN', instance.srchYn?.toJson());
  writeNotNull('FILE_YN', instance.fileYn?.toJson());
  writeNotNull('IMAGE_YN', instance.imageYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STCONTENTSMSTUncheckedUpdateInput _$STCONTENTSMSTUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STCONTENTSMSTUncheckedUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      cntsNm: json['CNTS_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CNTS_NM'] as Map<String, dynamic>),
      pubDate: json['PUB_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['PUB_DATE'] as Map<String, dynamic>),
      pubState: json['PUB_STATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['PUB_STATE'] as Map<String, dynamic>),
      cn: json['CN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CN'] as Map<String, dynamic>),
      srchYn: json['SRCH_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SRCH_YN'] as Map<String, dynamic>),
      fileYn: json['FILE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FILE_YN'] as Map<String, dynamic>),
      imageYn: json['IMAGE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['IMAGE_YN'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STCONTENTSMSTUncheckedUpdateInputToJson(
    STCONTENTSMSTUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('CNTS_NM', instance.cntsNm?.toJson());
  writeNotNull('PUB_DATE', instance.pubDate?.toJson());
  writeNotNull('PUB_STATE', instance.pubState?.toJson());
  writeNotNull('CN', instance.cn?.toJson());
  writeNotNull('SRCH_YN', instance.srchYn?.toJson());
  writeNotNull('FILE_YN', instance.fileYn?.toJson());
  writeNotNull('IMAGE_YN', instance.imageYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STCONTENTSMSTCreateManyInput _$STCONTENTSMSTCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    STCONTENTSMSTCreateManyInput(
      seq: json['SEQ'] as int,
      cntsNm: json['CNTS_NM'] as String,
      pubDate: json['PUB_DATE'] as String?,
      pubState: json['PUB_STATE'] as String?,
      cn: json['CN'] as String?,
      srchYn: json['SRCH_YN'] as String?,
      fileYn: json['FILE_YN'] as String?,
      imageYn: json['IMAGE_YN'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STCONTENTSMSTCreateManyInputToJson(
    STCONTENTSMSTCreateManyInput instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'CNTS_NM': instance.cntsNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('PUB_DATE', instance.pubDate);
  writeNotNull('PUB_STATE', instance.pubState);
  writeNotNull('CN', instance.cn);
  writeNotNull('SRCH_YN', instance.srchYn);
  writeNotNull('FILE_YN', instance.fileYn);
  writeNotNull('IMAGE_YN', instance.imageYn);
  val['REG_ID'] = instance.regId;
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STCONTENTSMSTUpdateManyMutationInput
    _$STCONTENTSMSTUpdateManyMutationInputFromJson(Map<String, dynamic> json) =>
        STCONTENTSMSTUpdateManyMutationInput(
          seq: json['SEQ'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          cntsNm: json['CNTS_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['CNTS_NM'] as Map<String, dynamic>),
          pubDate: json['PUB_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['PUB_DATE'] as Map<String, dynamic>),
          pubState: json['PUB_STATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['PUB_STATE'] as Map<String, dynamic>),
          cn: json['CN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CN'] as Map<String, dynamic>),
          srchYn: json['SRCH_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['SRCH_YN'] as Map<String, dynamic>),
          fileYn: json['FILE_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['FILE_YN'] as Map<String, dynamic>),
          imageYn: json['IMAGE_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['IMAGE_YN'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delId: json['DEL_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_ID'] as Map<String, dynamic>),
          delDate: json['DEL_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STCONTENTSMSTUpdateManyMutationInputToJson(
    STCONTENTSMSTUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('CNTS_NM', instance.cntsNm?.toJson());
  writeNotNull('PUB_DATE', instance.pubDate?.toJson());
  writeNotNull('PUB_STATE', instance.pubState?.toJson());
  writeNotNull('CN', instance.cn?.toJson());
  writeNotNull('SRCH_YN', instance.srchYn?.toJson());
  writeNotNull('FILE_YN', instance.fileYn?.toJson());
  writeNotNull('IMAGE_YN', instance.imageYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STCONTENTSMSTUncheckedUpdateManyInput
    _$STCONTENTSMSTUncheckedUpdateManyInputFromJson(
            Map<String, dynamic> json) =>
        STCONTENTSMSTUncheckedUpdateManyInput(
          seq: json['SEQ'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          cntsNm: json['CNTS_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['CNTS_NM'] as Map<String, dynamic>),
          pubDate: json['PUB_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['PUB_DATE'] as Map<String, dynamic>),
          pubState: json['PUB_STATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['PUB_STATE'] as Map<String, dynamic>),
          cn: json['CN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CN'] as Map<String, dynamic>),
          srchYn: json['SRCH_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['SRCH_YN'] as Map<String, dynamic>),
          fileYn: json['FILE_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['FILE_YN'] as Map<String, dynamic>),
          imageYn: json['IMAGE_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['IMAGE_YN'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delId: json['DEL_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_ID'] as Map<String, dynamic>),
          delDate: json['DEL_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STCONTENTSMSTUncheckedUpdateManyInputToJson(
    STCONTENTSMSTUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('CNTS_NM', instance.cntsNm?.toJson());
  writeNotNull('PUB_DATE', instance.pubDate?.toJson());
  writeNotNull('PUB_STATE', instance.pubState?.toJson());
  writeNotNull('CN', instance.cn?.toJson());
  writeNotNull('SRCH_YN', instance.srchYn?.toJson());
  writeNotNull('FILE_YN', instance.fileYn?.toJson());
  writeNotNull('IMAGE_YN', instance.imageYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STDEPTCreateInput _$STDEPTCreateInputFromJson(Map<String, dynamic> json) =>
    STDEPTCreateInput(
      deptCd: json['DEPT_CD'] as String,
      deptNm: json['DEPT_NM'] as String,
      upperDeptCd: json['UPPER_DEPT_CD'] as String?,
      upperDeptNm: json['UPPER_DEPT_NM'] as String?,
      sort: json['SORT'] as int?,
      mainYn: json['MAIN_YN'] as String?,
      deptDesc: json['DEPT_DESC'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STDEPTCreateInputToJson(STDEPTCreateInput instance) {
  final val = <String, dynamic>{
    'DEPT_CD': instance.deptCd,
    'DEPT_NM': instance.deptNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('UPPER_DEPT_CD', instance.upperDeptCd);
  writeNotNull('UPPER_DEPT_NM', instance.upperDeptNm);
  writeNotNull('SORT', instance.sort);
  writeNotNull('MAIN_YN', instance.mainYn);
  writeNotNull('DEPT_DESC', instance.deptDesc);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STDEPTUncheckedCreateInput _$STDEPTUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    STDEPTUncheckedCreateInput(
      deptCd: json['DEPT_CD'] as String,
      deptNm: json['DEPT_NM'] as String,
      upperDeptCd: json['UPPER_DEPT_CD'] as String?,
      upperDeptNm: json['UPPER_DEPT_NM'] as String?,
      sort: json['SORT'] as int?,
      mainYn: json['MAIN_YN'] as String?,
      deptDesc: json['DEPT_DESC'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STDEPTUncheckedCreateInputToJson(
    STDEPTUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'DEPT_CD': instance.deptCd,
    'DEPT_NM': instance.deptNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('UPPER_DEPT_CD', instance.upperDeptCd);
  writeNotNull('UPPER_DEPT_NM', instance.upperDeptNm);
  writeNotNull('SORT', instance.sort);
  writeNotNull('MAIN_YN', instance.mainYn);
  writeNotNull('DEPT_DESC', instance.deptDesc);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STDEPTUpdateInput _$STDEPTUpdateInputFromJson(Map<String, dynamic> json) =>
    STDEPTUpdateInput(
      deptCd: json['DEPT_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['DEPT_CD'] as Map<String, dynamic>),
      deptNm: json['DEPT_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['DEPT_NM'] as Map<String, dynamic>),
      upperDeptCd: json['UPPER_DEPT_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['UPPER_DEPT_CD'] as Map<String, dynamic>),
      upperDeptNm: json['UPPER_DEPT_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['UPPER_DEPT_NM'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['SORT'] as Map<String, dynamic>),
      mainYn: json['MAIN_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MAIN_YN'] as Map<String, dynamic>),
      deptDesc: json['DEPT_DESC'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEPT_DESC'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STDEPTUpdateInputToJson(STDEPTUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('DEPT_CD', instance.deptCd?.toJson());
  writeNotNull('DEPT_NM', instance.deptNm?.toJson());
  writeNotNull('UPPER_DEPT_CD', instance.upperDeptCd?.toJson());
  writeNotNull('UPPER_DEPT_NM', instance.upperDeptNm?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('MAIN_YN', instance.mainYn?.toJson());
  writeNotNull('DEPT_DESC', instance.deptDesc?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STDEPTUncheckedUpdateInput _$STDEPTUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STDEPTUncheckedUpdateInput(
      deptCd: json['DEPT_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['DEPT_CD'] as Map<String, dynamic>),
      deptNm: json['DEPT_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['DEPT_NM'] as Map<String, dynamic>),
      upperDeptCd: json['UPPER_DEPT_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['UPPER_DEPT_CD'] as Map<String, dynamic>),
      upperDeptNm: json['UPPER_DEPT_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['UPPER_DEPT_NM'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['SORT'] as Map<String, dynamic>),
      mainYn: json['MAIN_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MAIN_YN'] as Map<String, dynamic>),
      deptDesc: json['DEPT_DESC'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEPT_DESC'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STDEPTUncheckedUpdateInputToJson(
    STDEPTUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('DEPT_CD', instance.deptCd?.toJson());
  writeNotNull('DEPT_NM', instance.deptNm?.toJson());
  writeNotNull('UPPER_DEPT_CD', instance.upperDeptCd?.toJson());
  writeNotNull('UPPER_DEPT_NM', instance.upperDeptNm?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('MAIN_YN', instance.mainYn?.toJson());
  writeNotNull('DEPT_DESC', instance.deptDesc?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STDEPTCreateManyInput _$STDEPTCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    STDEPTCreateManyInput(
      deptCd: json['DEPT_CD'] as String,
      deptNm: json['DEPT_NM'] as String,
      upperDeptCd: json['UPPER_DEPT_CD'] as String?,
      upperDeptNm: json['UPPER_DEPT_NM'] as String?,
      sort: json['SORT'] as int?,
      mainYn: json['MAIN_YN'] as String?,
      deptDesc: json['DEPT_DESC'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STDEPTCreateManyInputToJson(
    STDEPTCreateManyInput instance) {
  final val = <String, dynamic>{
    'DEPT_CD': instance.deptCd,
    'DEPT_NM': instance.deptNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('UPPER_DEPT_CD', instance.upperDeptCd);
  writeNotNull('UPPER_DEPT_NM', instance.upperDeptNm);
  writeNotNull('SORT', instance.sort);
  writeNotNull('MAIN_YN', instance.mainYn);
  writeNotNull('DEPT_DESC', instance.deptDesc);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STDEPTUpdateManyMutationInput _$STDEPTUpdateManyMutationInputFromJson(
        Map<String, dynamic> json) =>
    STDEPTUpdateManyMutationInput(
      deptCd: json['DEPT_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['DEPT_CD'] as Map<String, dynamic>),
      deptNm: json['DEPT_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['DEPT_NM'] as Map<String, dynamic>),
      upperDeptCd: json['UPPER_DEPT_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['UPPER_DEPT_CD'] as Map<String, dynamic>),
      upperDeptNm: json['UPPER_DEPT_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['UPPER_DEPT_NM'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['SORT'] as Map<String, dynamic>),
      mainYn: json['MAIN_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MAIN_YN'] as Map<String, dynamic>),
      deptDesc: json['DEPT_DESC'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEPT_DESC'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STDEPTUpdateManyMutationInputToJson(
    STDEPTUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('DEPT_CD', instance.deptCd?.toJson());
  writeNotNull('DEPT_NM', instance.deptNm?.toJson());
  writeNotNull('UPPER_DEPT_CD', instance.upperDeptCd?.toJson());
  writeNotNull('UPPER_DEPT_NM', instance.upperDeptNm?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('MAIN_YN', instance.mainYn?.toJson());
  writeNotNull('DEPT_DESC', instance.deptDesc?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STDEPTUncheckedUpdateManyInput _$STDEPTUncheckedUpdateManyInputFromJson(
        Map<String, dynamic> json) =>
    STDEPTUncheckedUpdateManyInput(
      deptCd: json['DEPT_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['DEPT_CD'] as Map<String, dynamic>),
      deptNm: json['DEPT_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['DEPT_NM'] as Map<String, dynamic>),
      upperDeptCd: json['UPPER_DEPT_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['UPPER_DEPT_CD'] as Map<String, dynamic>),
      upperDeptNm: json['UPPER_DEPT_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['UPPER_DEPT_NM'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['SORT'] as Map<String, dynamic>),
      mainYn: json['MAIN_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MAIN_YN'] as Map<String, dynamic>),
      deptDesc: json['DEPT_DESC'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEPT_DESC'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STDEPTUncheckedUpdateManyInputToJson(
    STDEPTUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('DEPT_CD', instance.deptCd?.toJson());
  writeNotNull('DEPT_NM', instance.deptNm?.toJson());
  writeNotNull('UPPER_DEPT_CD', instance.upperDeptCd?.toJson());
  writeNotNull('UPPER_DEPT_NM', instance.upperDeptNm?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('MAIN_YN', instance.mainYn?.toJson());
  writeNotNull('DEPT_DESC', instance.deptDesc?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STDEPTEMPCreateInput _$STDEPTEMPCreateInputFromJson(
        Map<String, dynamic> json) =>
    STDEPTEMPCreateInput(
      empNo: json['EMP_NO'] as String,
      empNm: json['EMP_NM'] as String,
      deptCd: json['DEPT_CD'] as String?,
      deptNm: json['DEPT_NM'] as String?,
      fctnCd: json['FCTN_CD'] as String?,
      fctnNm: json['FCTN_NM'] as String?,
      ofcpCd: json['OFCP_CD'] as String?,
      ofcpNm: json['OFCP_NM'] as String?,
      emailAddr: json['EMAIL_ADDR'] as String?,
      offmTelno: json['OFFM_TELNO'] as String?,
      htelTelno: json['HTEL_TELNO'] as String?,
      deptYn: json['DEPT_YN'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STDEPTEMPCreateInputToJson(
    STDEPTEMPCreateInput instance) {
  final val = <String, dynamic>{
    'EMP_NO': instance.empNo,
    'EMP_NM': instance.empNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('DEPT_CD', instance.deptCd);
  writeNotNull('DEPT_NM', instance.deptNm);
  writeNotNull('FCTN_CD', instance.fctnCd);
  writeNotNull('FCTN_NM', instance.fctnNm);
  writeNotNull('OFCP_CD', instance.ofcpCd);
  writeNotNull('OFCP_NM', instance.ofcpNm);
  writeNotNull('EMAIL_ADDR', instance.emailAddr);
  writeNotNull('OFFM_TELNO', instance.offmTelno);
  writeNotNull('HTEL_TELNO', instance.htelTelno);
  writeNotNull('DEPT_YN', instance.deptYn);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STDEPTEMPUncheckedCreateInput _$STDEPTEMPUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    STDEPTEMPUncheckedCreateInput(
      empNo: json['EMP_NO'] as String,
      empNm: json['EMP_NM'] as String,
      deptCd: json['DEPT_CD'] as String?,
      deptNm: json['DEPT_NM'] as String?,
      fctnCd: json['FCTN_CD'] as String?,
      fctnNm: json['FCTN_NM'] as String?,
      ofcpCd: json['OFCP_CD'] as String?,
      ofcpNm: json['OFCP_NM'] as String?,
      emailAddr: json['EMAIL_ADDR'] as String?,
      offmTelno: json['OFFM_TELNO'] as String?,
      htelTelno: json['HTEL_TELNO'] as String?,
      deptYn: json['DEPT_YN'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STDEPTEMPUncheckedCreateInputToJson(
    STDEPTEMPUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'EMP_NO': instance.empNo,
    'EMP_NM': instance.empNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('DEPT_CD', instance.deptCd);
  writeNotNull('DEPT_NM', instance.deptNm);
  writeNotNull('FCTN_CD', instance.fctnCd);
  writeNotNull('FCTN_NM', instance.fctnNm);
  writeNotNull('OFCP_CD', instance.ofcpCd);
  writeNotNull('OFCP_NM', instance.ofcpNm);
  writeNotNull('EMAIL_ADDR', instance.emailAddr);
  writeNotNull('OFFM_TELNO', instance.offmTelno);
  writeNotNull('HTEL_TELNO', instance.htelTelno);
  writeNotNull('DEPT_YN', instance.deptYn);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STDEPTEMPUpdateInput _$STDEPTEMPUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STDEPTEMPUpdateInput(
      empNo: json['EMP_NO'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['EMP_NO'] as Map<String, dynamic>),
      empNm: json['EMP_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['EMP_NM'] as Map<String, dynamic>),
      deptCd: json['DEPT_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEPT_CD'] as Map<String, dynamic>),
      deptNm: json['DEPT_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEPT_NM'] as Map<String, dynamic>),
      fctnCd: json['FCTN_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FCTN_CD'] as Map<String, dynamic>),
      fctnNm: json['FCTN_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FCTN_NM'] as Map<String, dynamic>),
      ofcpCd: json['OFCP_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['OFCP_CD'] as Map<String, dynamic>),
      ofcpNm: json['OFCP_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['OFCP_NM'] as Map<String, dynamic>),
      emailAddr: json['EMAIL_ADDR'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EMAIL_ADDR'] as Map<String, dynamic>),
      offmTelno: json['OFFM_TELNO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['OFFM_TELNO'] as Map<String, dynamic>),
      htelTelno: json['HTEL_TELNO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['HTEL_TELNO'] as Map<String, dynamic>),
      deptYn: json['DEPT_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEPT_YN'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STDEPTEMPUpdateInputToJson(
    STDEPTEMPUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('EMP_NO', instance.empNo?.toJson());
  writeNotNull('EMP_NM', instance.empNm?.toJson());
  writeNotNull('DEPT_CD', instance.deptCd?.toJson());
  writeNotNull('DEPT_NM', instance.deptNm?.toJson());
  writeNotNull('FCTN_CD', instance.fctnCd?.toJson());
  writeNotNull('FCTN_NM', instance.fctnNm?.toJson());
  writeNotNull('OFCP_CD', instance.ofcpCd?.toJson());
  writeNotNull('OFCP_NM', instance.ofcpNm?.toJson());
  writeNotNull('EMAIL_ADDR', instance.emailAddr?.toJson());
  writeNotNull('OFFM_TELNO', instance.offmTelno?.toJson());
  writeNotNull('HTEL_TELNO', instance.htelTelno?.toJson());
  writeNotNull('DEPT_YN', instance.deptYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STDEPTEMPUncheckedUpdateInput _$STDEPTEMPUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STDEPTEMPUncheckedUpdateInput(
      empNo: json['EMP_NO'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['EMP_NO'] as Map<String, dynamic>),
      empNm: json['EMP_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['EMP_NM'] as Map<String, dynamic>),
      deptCd: json['DEPT_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEPT_CD'] as Map<String, dynamic>),
      deptNm: json['DEPT_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEPT_NM'] as Map<String, dynamic>),
      fctnCd: json['FCTN_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FCTN_CD'] as Map<String, dynamic>),
      fctnNm: json['FCTN_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FCTN_NM'] as Map<String, dynamic>),
      ofcpCd: json['OFCP_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['OFCP_CD'] as Map<String, dynamic>),
      ofcpNm: json['OFCP_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['OFCP_NM'] as Map<String, dynamic>),
      emailAddr: json['EMAIL_ADDR'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EMAIL_ADDR'] as Map<String, dynamic>),
      offmTelno: json['OFFM_TELNO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['OFFM_TELNO'] as Map<String, dynamic>),
      htelTelno: json['HTEL_TELNO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['HTEL_TELNO'] as Map<String, dynamic>),
      deptYn: json['DEPT_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEPT_YN'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STDEPTEMPUncheckedUpdateInputToJson(
    STDEPTEMPUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('EMP_NO', instance.empNo?.toJson());
  writeNotNull('EMP_NM', instance.empNm?.toJson());
  writeNotNull('DEPT_CD', instance.deptCd?.toJson());
  writeNotNull('DEPT_NM', instance.deptNm?.toJson());
  writeNotNull('FCTN_CD', instance.fctnCd?.toJson());
  writeNotNull('FCTN_NM', instance.fctnNm?.toJson());
  writeNotNull('OFCP_CD', instance.ofcpCd?.toJson());
  writeNotNull('OFCP_NM', instance.ofcpNm?.toJson());
  writeNotNull('EMAIL_ADDR', instance.emailAddr?.toJson());
  writeNotNull('OFFM_TELNO', instance.offmTelno?.toJson());
  writeNotNull('HTEL_TELNO', instance.htelTelno?.toJson());
  writeNotNull('DEPT_YN', instance.deptYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STDEPTEMPCreateManyInput _$STDEPTEMPCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    STDEPTEMPCreateManyInput(
      empNo: json['EMP_NO'] as String,
      empNm: json['EMP_NM'] as String,
      deptCd: json['DEPT_CD'] as String?,
      deptNm: json['DEPT_NM'] as String?,
      fctnCd: json['FCTN_CD'] as String?,
      fctnNm: json['FCTN_NM'] as String?,
      ofcpCd: json['OFCP_CD'] as String?,
      ofcpNm: json['OFCP_NM'] as String?,
      emailAddr: json['EMAIL_ADDR'] as String?,
      offmTelno: json['OFFM_TELNO'] as String?,
      htelTelno: json['HTEL_TELNO'] as String?,
      deptYn: json['DEPT_YN'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STDEPTEMPCreateManyInputToJson(
    STDEPTEMPCreateManyInput instance) {
  final val = <String, dynamic>{
    'EMP_NO': instance.empNo,
    'EMP_NM': instance.empNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('DEPT_CD', instance.deptCd);
  writeNotNull('DEPT_NM', instance.deptNm);
  writeNotNull('FCTN_CD', instance.fctnCd);
  writeNotNull('FCTN_NM', instance.fctnNm);
  writeNotNull('OFCP_CD', instance.ofcpCd);
  writeNotNull('OFCP_NM', instance.ofcpNm);
  writeNotNull('EMAIL_ADDR', instance.emailAddr);
  writeNotNull('OFFM_TELNO', instance.offmTelno);
  writeNotNull('HTEL_TELNO', instance.htelTelno);
  writeNotNull('DEPT_YN', instance.deptYn);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STDEPTEMPUpdateManyMutationInput _$STDEPTEMPUpdateManyMutationInputFromJson(
        Map<String, dynamic> json) =>
    STDEPTEMPUpdateManyMutationInput(
      empNo: json['EMP_NO'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['EMP_NO'] as Map<String, dynamic>),
      empNm: json['EMP_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['EMP_NM'] as Map<String, dynamic>),
      deptCd: json['DEPT_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEPT_CD'] as Map<String, dynamic>),
      deptNm: json['DEPT_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEPT_NM'] as Map<String, dynamic>),
      fctnCd: json['FCTN_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FCTN_CD'] as Map<String, dynamic>),
      fctnNm: json['FCTN_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FCTN_NM'] as Map<String, dynamic>),
      ofcpCd: json['OFCP_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['OFCP_CD'] as Map<String, dynamic>),
      ofcpNm: json['OFCP_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['OFCP_NM'] as Map<String, dynamic>),
      emailAddr: json['EMAIL_ADDR'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EMAIL_ADDR'] as Map<String, dynamic>),
      offmTelno: json['OFFM_TELNO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['OFFM_TELNO'] as Map<String, dynamic>),
      htelTelno: json['HTEL_TELNO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['HTEL_TELNO'] as Map<String, dynamic>),
      deptYn: json['DEPT_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEPT_YN'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STDEPTEMPUpdateManyMutationInputToJson(
    STDEPTEMPUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('EMP_NO', instance.empNo?.toJson());
  writeNotNull('EMP_NM', instance.empNm?.toJson());
  writeNotNull('DEPT_CD', instance.deptCd?.toJson());
  writeNotNull('DEPT_NM', instance.deptNm?.toJson());
  writeNotNull('FCTN_CD', instance.fctnCd?.toJson());
  writeNotNull('FCTN_NM', instance.fctnNm?.toJson());
  writeNotNull('OFCP_CD', instance.ofcpCd?.toJson());
  writeNotNull('OFCP_NM', instance.ofcpNm?.toJson());
  writeNotNull('EMAIL_ADDR', instance.emailAddr?.toJson());
  writeNotNull('OFFM_TELNO', instance.offmTelno?.toJson());
  writeNotNull('HTEL_TELNO', instance.htelTelno?.toJson());
  writeNotNull('DEPT_YN', instance.deptYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STDEPTEMPUncheckedUpdateManyInput _$STDEPTEMPUncheckedUpdateManyInputFromJson(
        Map<String, dynamic> json) =>
    STDEPTEMPUncheckedUpdateManyInput(
      empNo: json['EMP_NO'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['EMP_NO'] as Map<String, dynamic>),
      empNm: json['EMP_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['EMP_NM'] as Map<String, dynamic>),
      deptCd: json['DEPT_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEPT_CD'] as Map<String, dynamic>),
      deptNm: json['DEPT_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEPT_NM'] as Map<String, dynamic>),
      fctnCd: json['FCTN_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FCTN_CD'] as Map<String, dynamic>),
      fctnNm: json['FCTN_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FCTN_NM'] as Map<String, dynamic>),
      ofcpCd: json['OFCP_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['OFCP_CD'] as Map<String, dynamic>),
      ofcpNm: json['OFCP_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['OFCP_NM'] as Map<String, dynamic>),
      emailAddr: json['EMAIL_ADDR'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EMAIL_ADDR'] as Map<String, dynamic>),
      offmTelno: json['OFFM_TELNO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['OFFM_TELNO'] as Map<String, dynamic>),
      htelTelno: json['HTEL_TELNO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['HTEL_TELNO'] as Map<String, dynamic>),
      deptYn: json['DEPT_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEPT_YN'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STDEPTEMPUncheckedUpdateManyInputToJson(
    STDEPTEMPUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('EMP_NO', instance.empNo?.toJson());
  writeNotNull('EMP_NM', instance.empNm?.toJson());
  writeNotNull('DEPT_CD', instance.deptCd?.toJson());
  writeNotNull('DEPT_NM', instance.deptNm?.toJson());
  writeNotNull('FCTN_CD', instance.fctnCd?.toJson());
  writeNotNull('FCTN_NM', instance.fctnNm?.toJson());
  writeNotNull('OFCP_CD', instance.ofcpCd?.toJson());
  writeNotNull('OFCP_NM', instance.ofcpNm?.toJson());
  writeNotNull('EMAIL_ADDR', instance.emailAddr?.toJson());
  writeNotNull('OFFM_TELNO', instance.offmTelno?.toJson());
  writeNotNull('HTEL_TELNO', instance.htelTelno?.toJson());
  writeNotNull('DEPT_YN', instance.deptYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STMENUCreateInput _$STMENUCreateInputFromJson(Map<String, dynamic> json) =>
    STMENUCreateInput(
      menuCd: json['MENU_CD'] as String,
      menuNm: json['MENU_NM'] as String,
      menuPath: json['MENU_PATH'] as String?,
      menuMapping: json['MENU_MAPPING'] as String?,
      menuSrt: json['MENU_SRT'] as int,
      menuDeps: json['MENU_DEPS'] as int,
      menuIcon: json['MENU_ICON'] as String?,
      menuTp: json['MENU_TP'] as String?,
      mainExpsrYn: json['MAIN_EXPSR_YN'] as String?,
      subExpsrYn: json['SUB_EXPSR_YN'] as String?,
      upendClas: json['UPEND_CLAS'] as String?,
      upendCn: json['UPEND_CN'] as String?,
      cclType: json['CCL_TYPE'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STMENUCreateInputToJson(STMENUCreateInput instance) {
  final val = <String, dynamic>{
    'MENU_CD': instance.menuCd,
    'MENU_NM': instance.menuNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_PATH', instance.menuPath);
  writeNotNull('MENU_MAPPING', instance.menuMapping);
  val['MENU_SRT'] = instance.menuSrt;
  val['MENU_DEPS'] = instance.menuDeps;
  writeNotNull('MENU_ICON', instance.menuIcon);
  writeNotNull('MENU_TP', instance.menuTp);
  writeNotNull('MAIN_EXPSR_YN', instance.mainExpsrYn);
  writeNotNull('SUB_EXPSR_YN', instance.subExpsrYn);
  writeNotNull('UPEND_CLAS', instance.upendClas);
  writeNotNull('UPEND_CN', instance.upendCn);
  writeNotNull('CCL_TYPE', instance.cclType);
  val['REG_ID'] = instance.regId;
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STMENUUncheckedCreateInput _$STMENUUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    STMENUUncheckedCreateInput(
      menuCd: json['MENU_CD'] as String,
      menuNm: json['MENU_NM'] as String,
      menuPath: json['MENU_PATH'] as String?,
      menuMapping: json['MENU_MAPPING'] as String?,
      menuSrt: json['MENU_SRT'] as int,
      menuDeps: json['MENU_DEPS'] as int,
      menuIcon: json['MENU_ICON'] as String?,
      menuTp: json['MENU_TP'] as String?,
      mainExpsrYn: json['MAIN_EXPSR_YN'] as String?,
      subExpsrYn: json['SUB_EXPSR_YN'] as String?,
      upendClas: json['UPEND_CLAS'] as String?,
      upendCn: json['UPEND_CN'] as String?,
      cclType: json['CCL_TYPE'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STMENUUncheckedCreateInputToJson(
    STMENUUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'MENU_CD': instance.menuCd,
    'MENU_NM': instance.menuNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_PATH', instance.menuPath);
  writeNotNull('MENU_MAPPING', instance.menuMapping);
  val['MENU_SRT'] = instance.menuSrt;
  val['MENU_DEPS'] = instance.menuDeps;
  writeNotNull('MENU_ICON', instance.menuIcon);
  writeNotNull('MENU_TP', instance.menuTp);
  writeNotNull('MAIN_EXPSR_YN', instance.mainExpsrYn);
  writeNotNull('SUB_EXPSR_YN', instance.subExpsrYn);
  writeNotNull('UPEND_CLAS', instance.upendClas);
  writeNotNull('UPEND_CN', instance.upendCn);
  writeNotNull('CCL_TYPE', instance.cclType);
  val['REG_ID'] = instance.regId;
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STMENUUpdateInput _$STMENUUpdateInputFromJson(Map<String, dynamic> json) =>
    STMENUUpdateInput(
      menuCd: json['MENU_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_CD'] as Map<String, dynamic>),
      menuNm: json['MENU_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_NM'] as Map<String, dynamic>),
      menuPath: json['MENU_PATH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MENU_PATH'] as Map<String, dynamic>),
      menuMapping: json['MENU_MAPPING'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MENU_MAPPING'] as Map<String, dynamic>),
      menuSrt: json['MENU_SRT'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['MENU_SRT'] as Map<String, dynamic>),
      menuDeps: json['MENU_DEPS'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['MENU_DEPS'] as Map<String, dynamic>),
      menuIcon: json['MENU_ICON'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MENU_ICON'] as Map<String, dynamic>),
      menuTp: json['MENU_TP'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_TP'] as Map<String, dynamic>),
      mainExpsrYn: json['MAIN_EXPSR_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MAIN_EXPSR_YN'] as Map<String, dynamic>),
      subExpsrYn: json['SUB_EXPSR_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SUB_EXPSR_YN'] as Map<String, dynamic>),
      upendClas: json['UPEND_CLAS'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['UPEND_CLAS'] as Map<String, dynamic>),
      upendCn: json['UPEND_CN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['UPEND_CN'] as Map<String, dynamic>),
      cclType: json['CCL_TYPE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CCL_TYPE'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STMENUUpdateInputToJson(STMENUUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_CD', instance.menuCd?.toJson());
  writeNotNull('MENU_NM', instance.menuNm?.toJson());
  writeNotNull('MENU_PATH', instance.menuPath?.toJson());
  writeNotNull('MENU_MAPPING', instance.menuMapping?.toJson());
  writeNotNull('MENU_SRT', instance.menuSrt?.toJson());
  writeNotNull('MENU_DEPS', instance.menuDeps?.toJson());
  writeNotNull('MENU_ICON', instance.menuIcon?.toJson());
  writeNotNull('MENU_TP', instance.menuTp?.toJson());
  writeNotNull('MAIN_EXPSR_YN', instance.mainExpsrYn?.toJson());
  writeNotNull('SUB_EXPSR_YN', instance.subExpsrYn?.toJson());
  writeNotNull('UPEND_CLAS', instance.upendClas?.toJson());
  writeNotNull('UPEND_CN', instance.upendCn?.toJson());
  writeNotNull('CCL_TYPE', instance.cclType?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STMENUUncheckedUpdateInput _$STMENUUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STMENUUncheckedUpdateInput(
      menuCd: json['MENU_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_CD'] as Map<String, dynamic>),
      menuNm: json['MENU_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_NM'] as Map<String, dynamic>),
      menuPath: json['MENU_PATH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MENU_PATH'] as Map<String, dynamic>),
      menuMapping: json['MENU_MAPPING'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MENU_MAPPING'] as Map<String, dynamic>),
      menuSrt: json['MENU_SRT'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['MENU_SRT'] as Map<String, dynamic>),
      menuDeps: json['MENU_DEPS'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['MENU_DEPS'] as Map<String, dynamic>),
      menuIcon: json['MENU_ICON'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MENU_ICON'] as Map<String, dynamic>),
      menuTp: json['MENU_TP'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_TP'] as Map<String, dynamic>),
      mainExpsrYn: json['MAIN_EXPSR_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MAIN_EXPSR_YN'] as Map<String, dynamic>),
      subExpsrYn: json['SUB_EXPSR_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SUB_EXPSR_YN'] as Map<String, dynamic>),
      upendClas: json['UPEND_CLAS'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['UPEND_CLAS'] as Map<String, dynamic>),
      upendCn: json['UPEND_CN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['UPEND_CN'] as Map<String, dynamic>),
      cclType: json['CCL_TYPE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CCL_TYPE'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STMENUUncheckedUpdateInputToJson(
    STMENUUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_CD', instance.menuCd?.toJson());
  writeNotNull('MENU_NM', instance.menuNm?.toJson());
  writeNotNull('MENU_PATH', instance.menuPath?.toJson());
  writeNotNull('MENU_MAPPING', instance.menuMapping?.toJson());
  writeNotNull('MENU_SRT', instance.menuSrt?.toJson());
  writeNotNull('MENU_DEPS', instance.menuDeps?.toJson());
  writeNotNull('MENU_ICON', instance.menuIcon?.toJson());
  writeNotNull('MENU_TP', instance.menuTp?.toJson());
  writeNotNull('MAIN_EXPSR_YN', instance.mainExpsrYn?.toJson());
  writeNotNull('SUB_EXPSR_YN', instance.subExpsrYn?.toJson());
  writeNotNull('UPEND_CLAS', instance.upendClas?.toJson());
  writeNotNull('UPEND_CN', instance.upendCn?.toJson());
  writeNotNull('CCL_TYPE', instance.cclType?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STMENUCreateManyInput _$STMENUCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    STMENUCreateManyInput(
      menuCd: json['MENU_CD'] as String,
      menuNm: json['MENU_NM'] as String,
      menuPath: json['MENU_PATH'] as String?,
      menuMapping: json['MENU_MAPPING'] as String?,
      menuSrt: json['MENU_SRT'] as int,
      menuDeps: json['MENU_DEPS'] as int,
      menuIcon: json['MENU_ICON'] as String?,
      menuTp: json['MENU_TP'] as String?,
      mainExpsrYn: json['MAIN_EXPSR_YN'] as String?,
      subExpsrYn: json['SUB_EXPSR_YN'] as String?,
      upendClas: json['UPEND_CLAS'] as String?,
      upendCn: json['UPEND_CN'] as String?,
      cclType: json['CCL_TYPE'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STMENUCreateManyInputToJson(
    STMENUCreateManyInput instance) {
  final val = <String, dynamic>{
    'MENU_CD': instance.menuCd,
    'MENU_NM': instance.menuNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_PATH', instance.menuPath);
  writeNotNull('MENU_MAPPING', instance.menuMapping);
  val['MENU_SRT'] = instance.menuSrt;
  val['MENU_DEPS'] = instance.menuDeps;
  writeNotNull('MENU_ICON', instance.menuIcon);
  writeNotNull('MENU_TP', instance.menuTp);
  writeNotNull('MAIN_EXPSR_YN', instance.mainExpsrYn);
  writeNotNull('SUB_EXPSR_YN', instance.subExpsrYn);
  writeNotNull('UPEND_CLAS', instance.upendClas);
  writeNotNull('UPEND_CN', instance.upendCn);
  writeNotNull('CCL_TYPE', instance.cclType);
  val['REG_ID'] = instance.regId;
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STMENUUpdateManyMutationInput _$STMENUUpdateManyMutationInputFromJson(
        Map<String, dynamic> json) =>
    STMENUUpdateManyMutationInput(
      menuCd: json['MENU_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_CD'] as Map<String, dynamic>),
      menuNm: json['MENU_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_NM'] as Map<String, dynamic>),
      menuPath: json['MENU_PATH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MENU_PATH'] as Map<String, dynamic>),
      menuMapping: json['MENU_MAPPING'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MENU_MAPPING'] as Map<String, dynamic>),
      menuSrt: json['MENU_SRT'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['MENU_SRT'] as Map<String, dynamic>),
      menuDeps: json['MENU_DEPS'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['MENU_DEPS'] as Map<String, dynamic>),
      menuIcon: json['MENU_ICON'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MENU_ICON'] as Map<String, dynamic>),
      menuTp: json['MENU_TP'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_TP'] as Map<String, dynamic>),
      mainExpsrYn: json['MAIN_EXPSR_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MAIN_EXPSR_YN'] as Map<String, dynamic>),
      subExpsrYn: json['SUB_EXPSR_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SUB_EXPSR_YN'] as Map<String, dynamic>),
      upendClas: json['UPEND_CLAS'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['UPEND_CLAS'] as Map<String, dynamic>),
      upendCn: json['UPEND_CN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['UPEND_CN'] as Map<String, dynamic>),
      cclType: json['CCL_TYPE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CCL_TYPE'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STMENUUpdateManyMutationInputToJson(
    STMENUUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_CD', instance.menuCd?.toJson());
  writeNotNull('MENU_NM', instance.menuNm?.toJson());
  writeNotNull('MENU_PATH', instance.menuPath?.toJson());
  writeNotNull('MENU_MAPPING', instance.menuMapping?.toJson());
  writeNotNull('MENU_SRT', instance.menuSrt?.toJson());
  writeNotNull('MENU_DEPS', instance.menuDeps?.toJson());
  writeNotNull('MENU_ICON', instance.menuIcon?.toJson());
  writeNotNull('MENU_TP', instance.menuTp?.toJson());
  writeNotNull('MAIN_EXPSR_YN', instance.mainExpsrYn?.toJson());
  writeNotNull('SUB_EXPSR_YN', instance.subExpsrYn?.toJson());
  writeNotNull('UPEND_CLAS', instance.upendClas?.toJson());
  writeNotNull('UPEND_CN', instance.upendCn?.toJson());
  writeNotNull('CCL_TYPE', instance.cclType?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STMENUUncheckedUpdateManyInput _$STMENUUncheckedUpdateManyInputFromJson(
        Map<String, dynamic> json) =>
    STMENUUncheckedUpdateManyInput(
      menuCd: json['MENU_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_CD'] as Map<String, dynamic>),
      menuNm: json['MENU_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_NM'] as Map<String, dynamic>),
      menuPath: json['MENU_PATH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MENU_PATH'] as Map<String, dynamic>),
      menuMapping: json['MENU_MAPPING'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MENU_MAPPING'] as Map<String, dynamic>),
      menuSrt: json['MENU_SRT'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['MENU_SRT'] as Map<String, dynamic>),
      menuDeps: json['MENU_DEPS'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['MENU_DEPS'] as Map<String, dynamic>),
      menuIcon: json['MENU_ICON'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MENU_ICON'] as Map<String, dynamic>),
      menuTp: json['MENU_TP'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_TP'] as Map<String, dynamic>),
      mainExpsrYn: json['MAIN_EXPSR_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MAIN_EXPSR_YN'] as Map<String, dynamic>),
      subExpsrYn: json['SUB_EXPSR_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SUB_EXPSR_YN'] as Map<String, dynamic>),
      upendClas: json['UPEND_CLAS'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['UPEND_CLAS'] as Map<String, dynamic>),
      upendCn: json['UPEND_CN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['UPEND_CN'] as Map<String, dynamic>),
      cclType: json['CCL_TYPE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CCL_TYPE'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STMENUUncheckedUpdateManyInputToJson(
    STMENUUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_CD', instance.menuCd?.toJson());
  writeNotNull('MENU_NM', instance.menuNm?.toJson());
  writeNotNull('MENU_PATH', instance.menuPath?.toJson());
  writeNotNull('MENU_MAPPING', instance.menuMapping?.toJson());
  writeNotNull('MENU_SRT', instance.menuSrt?.toJson());
  writeNotNull('MENU_DEPS', instance.menuDeps?.toJson());
  writeNotNull('MENU_ICON', instance.menuIcon?.toJson());
  writeNotNull('MENU_TP', instance.menuTp?.toJson());
  writeNotNull('MAIN_EXPSR_YN', instance.mainExpsrYn?.toJson());
  writeNotNull('SUB_EXPSR_YN', instance.subExpsrYn?.toJson());
  writeNotNull('UPEND_CLAS', instance.upendClas?.toJson());
  writeNotNull('UPEND_CN', instance.upendCn?.toJson());
  writeNotNull('CCL_TYPE', instance.cclType?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STMESSAGETMPLATCreateInput _$STMESSAGETMPLATCreateInputFromJson(
        Map<String, dynamic> json) =>
    STMESSAGETMPLATCreateInput(
      msgDivCd: json['MSG_DIV_CD'] as String,
      msgCd: json['MSG_CD'] as String,
      msgNm: json['MSG_NM'] as String?,
      msgTmplat: json['MSG_TMPLAT'] as String?,
      useYn: json['USE_YN'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
    );

Map<String, dynamic> _$STMESSAGETMPLATCreateInputToJson(
    STMESSAGETMPLATCreateInput instance) {
  final val = <String, dynamic>{
    'MSG_DIV_CD': instance.msgDivCd,
    'MSG_CD': instance.msgCd,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MSG_NM', instance.msgNm);
  writeNotNull('MSG_TMPLAT', instance.msgTmplat);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  return val;
}

STMESSAGETMPLATUncheckedCreateInput
    _$STMESSAGETMPLATUncheckedCreateInputFromJson(Map<String, dynamic> json) =>
        STMESSAGETMPLATUncheckedCreateInput(
          msgDivCd: json['MSG_DIV_CD'] as String,
          msgCd: json['MSG_CD'] as String,
          msgNm: json['MSG_NM'] as String?,
          msgTmplat: json['MSG_TMPLAT'] as String?,
          useYn: json['USE_YN'] as String?,
          editId: json['EDIT_ID'] as String?,
          editDate: json['EDIT_DATE'] as String?,
        );

Map<String, dynamic> _$STMESSAGETMPLATUncheckedCreateInputToJson(
    STMESSAGETMPLATUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'MSG_DIV_CD': instance.msgDivCd,
    'MSG_CD': instance.msgCd,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MSG_NM', instance.msgNm);
  writeNotNull('MSG_TMPLAT', instance.msgTmplat);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  return val;
}

STMESSAGETMPLATUpdateInput _$STMESSAGETMPLATUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STMESSAGETMPLATUpdateInput(
      msgDivCd: json['MSG_DIV_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MSG_DIV_CD'] as Map<String, dynamic>),
      msgCd: json['MSG_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MSG_CD'] as Map<String, dynamic>),
      msgNm: json['MSG_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MSG_NM'] as Map<String, dynamic>),
      msgTmplat: json['MSG_TMPLAT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MSG_TMPLAT'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STMESSAGETMPLATUpdateInputToJson(
    STMESSAGETMPLATUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MSG_DIV_CD', instance.msgDivCd?.toJson());
  writeNotNull('MSG_CD', instance.msgCd?.toJson());
  writeNotNull('MSG_NM', instance.msgNm?.toJson());
  writeNotNull('MSG_TMPLAT', instance.msgTmplat?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  return val;
}

STMESSAGETMPLATUncheckedUpdateInput
    _$STMESSAGETMPLATUncheckedUpdateInputFromJson(Map<String, dynamic> json) =>
        STMESSAGETMPLATUncheckedUpdateInput(
          msgDivCd: json['MSG_DIV_CD'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['MSG_DIV_CD'] as Map<String, dynamic>),
          msgCd: json['MSG_CD'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['MSG_CD'] as Map<String, dynamic>),
          msgNm: json['MSG_NM'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['MSG_NM'] as Map<String, dynamic>),
          msgTmplat: json['MSG_TMPLAT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['MSG_TMPLAT'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STMESSAGETMPLATUncheckedUpdateInputToJson(
    STMESSAGETMPLATUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MSG_DIV_CD', instance.msgDivCd?.toJson());
  writeNotNull('MSG_CD', instance.msgCd?.toJson());
  writeNotNull('MSG_NM', instance.msgNm?.toJson());
  writeNotNull('MSG_TMPLAT', instance.msgTmplat?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  return val;
}

STMESSAGETMPLATCreateManyInput _$STMESSAGETMPLATCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    STMESSAGETMPLATCreateManyInput(
      msgDivCd: json['MSG_DIV_CD'] as String,
      msgCd: json['MSG_CD'] as String,
      msgNm: json['MSG_NM'] as String?,
      msgTmplat: json['MSG_TMPLAT'] as String?,
      useYn: json['USE_YN'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
    );

Map<String, dynamic> _$STMESSAGETMPLATCreateManyInputToJson(
    STMESSAGETMPLATCreateManyInput instance) {
  final val = <String, dynamic>{
    'MSG_DIV_CD': instance.msgDivCd,
    'MSG_CD': instance.msgCd,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MSG_NM', instance.msgNm);
  writeNotNull('MSG_TMPLAT', instance.msgTmplat);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  return val;
}

STMESSAGETMPLATUpdateManyMutationInput
    _$STMESSAGETMPLATUpdateManyMutationInputFromJson(
            Map<String, dynamic> json) =>
        STMESSAGETMPLATUpdateManyMutationInput(
          msgDivCd: json['MSG_DIV_CD'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['MSG_DIV_CD'] as Map<String, dynamic>),
          msgCd: json['MSG_CD'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['MSG_CD'] as Map<String, dynamic>),
          msgNm: json['MSG_NM'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['MSG_NM'] as Map<String, dynamic>),
          msgTmplat: json['MSG_TMPLAT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['MSG_TMPLAT'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STMESSAGETMPLATUpdateManyMutationInputToJson(
    STMESSAGETMPLATUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MSG_DIV_CD', instance.msgDivCd?.toJson());
  writeNotNull('MSG_CD', instance.msgCd?.toJson());
  writeNotNull('MSG_NM', instance.msgNm?.toJson());
  writeNotNull('MSG_TMPLAT', instance.msgTmplat?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  return val;
}

STMESSAGETMPLATUncheckedUpdateManyInput
    _$STMESSAGETMPLATUncheckedUpdateManyInputFromJson(
            Map<String, dynamic> json) =>
        STMESSAGETMPLATUncheckedUpdateManyInput(
          msgDivCd: json['MSG_DIV_CD'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['MSG_DIV_CD'] as Map<String, dynamic>),
          msgCd: json['MSG_CD'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['MSG_CD'] as Map<String, dynamic>),
          msgNm: json['MSG_NM'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['MSG_NM'] as Map<String, dynamic>),
          msgTmplat: json['MSG_TMPLAT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['MSG_TMPLAT'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$STMESSAGETMPLATUncheckedUpdateManyInputToJson(
    STMESSAGETMPLATUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MSG_DIV_CD', instance.msgDivCd?.toJson());
  writeNotNull('MSG_CD', instance.msgCd?.toJson());
  writeNotNull('MSG_NM', instance.msgNm?.toJson());
  writeNotNull('MSG_TMPLAT', instance.msgTmplat?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  return val;
}

STMIMETYPECreateInput _$STMIMETYPECreateInputFromJson(
        Map<String, dynamic> json) =>
    STMIMETYPECreateInput(
      extnNm: json['EXTN_NM'] as String,
      fileMt: json['FILE_MT'] as String,
    );

Map<String, dynamic> _$STMIMETYPECreateInputToJson(
        STMIMETYPECreateInput instance) =>
    <String, dynamic>{
      'EXTN_NM': instance.extnNm,
      'FILE_MT': instance.fileMt,
    };

STMIMETYPEUncheckedCreateInput _$STMIMETYPEUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    STMIMETYPEUncheckedCreateInput(
      seq: json['SEQ'] as int?,
      extnNm: json['EXTN_NM'] as String,
      fileMt: json['FILE_MT'] as String,
    );

Map<String, dynamic> _$STMIMETYPEUncheckedCreateInputToJson(
    STMIMETYPEUncheckedCreateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq);
  val['EXTN_NM'] = instance.extnNm;
  val['FILE_MT'] = instance.fileMt;
  return val;
}

STMIMETYPEUpdateInput _$STMIMETYPEUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STMIMETYPEUpdateInput(
      extnNm: json['EXTN_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['EXTN_NM'] as Map<String, dynamic>),
      fileMt: json['FILE_MT'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['FILE_MT'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STMIMETYPEUpdateInputToJson(
    STMIMETYPEUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('EXTN_NM', instance.extnNm?.toJson());
  writeNotNull('FILE_MT', instance.fileMt?.toJson());
  return val;
}

STMIMETYPEUncheckedUpdateInput _$STMIMETYPEUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STMIMETYPEUncheckedUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      extnNm: json['EXTN_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['EXTN_NM'] as Map<String, dynamic>),
      fileMt: json['FILE_MT'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['FILE_MT'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STMIMETYPEUncheckedUpdateInputToJson(
    STMIMETYPEUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('EXTN_NM', instance.extnNm?.toJson());
  writeNotNull('FILE_MT', instance.fileMt?.toJson());
  return val;
}

STMIMETYPECreateManyInput _$STMIMETYPECreateManyInputFromJson(
        Map<String, dynamic> json) =>
    STMIMETYPECreateManyInput(
      seq: json['SEQ'] as int?,
      extnNm: json['EXTN_NM'] as String,
      fileMt: json['FILE_MT'] as String,
    );

Map<String, dynamic> _$STMIMETYPECreateManyInputToJson(
    STMIMETYPECreateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq);
  val['EXTN_NM'] = instance.extnNm;
  val['FILE_MT'] = instance.fileMt;
  return val;
}

STMIMETYPEUpdateManyMutationInput _$STMIMETYPEUpdateManyMutationInputFromJson(
        Map<String, dynamic> json) =>
    STMIMETYPEUpdateManyMutationInput(
      extnNm: json['EXTN_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['EXTN_NM'] as Map<String, dynamic>),
      fileMt: json['FILE_MT'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['FILE_MT'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STMIMETYPEUpdateManyMutationInputToJson(
    STMIMETYPEUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('EXTN_NM', instance.extnNm?.toJson());
  writeNotNull('FILE_MT', instance.fileMt?.toJson());
  return val;
}

STMIMETYPEUncheckedUpdateManyInput _$STMIMETYPEUncheckedUpdateManyInputFromJson(
        Map<String, dynamic> json) =>
    STMIMETYPEUncheckedUpdateManyInput(
      seq: json['SEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      extnNm: json['EXTN_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['EXTN_NM'] as Map<String, dynamic>),
      fileMt: json['FILE_MT'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['FILE_MT'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STMIMETYPEUncheckedUpdateManyInputToJson(
    STMIMETYPEUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('EXTN_NM', instance.extnNm?.toJson());
  writeNotNull('FILE_MT', instance.fileMt?.toJson());
  return val;
}

STMNGRGRPCreateInput _$STMNGRGRPCreateInputFromJson(
        Map<String, dynamic> json) =>
    STMNGRGRPCreateInput(
      grpCd: json['GRP_CD'] as String,
      grpNm: json['GRP_NM'] as String?,
      grpDesc: json['GRP_DESC'] as String?,
      sort: json['SORT'] as int?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STMNGRGRPCreateInputToJson(
    STMNGRGRPCreateInput instance) {
  final val = <String, dynamic>{
    'GRP_CD': instance.grpCd,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('GRP_NM', instance.grpNm);
  writeNotNull('GRP_DESC', instance.grpDesc);
  writeNotNull('SORT', instance.sort);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STMNGRGRPUncheckedCreateInput _$STMNGRGRPUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    STMNGRGRPUncheckedCreateInput(
      grpCd: json['GRP_CD'] as String,
      grpNm: json['GRP_NM'] as String?,
      grpDesc: json['GRP_DESC'] as String?,
      sort: json['SORT'] as int?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STMNGRGRPUncheckedCreateInputToJson(
    STMNGRGRPUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'GRP_CD': instance.grpCd,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('GRP_NM', instance.grpNm);
  writeNotNull('GRP_DESC', instance.grpDesc);
  writeNotNull('SORT', instance.sort);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STMNGRGRPUpdateInput _$STMNGRGRPUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STMNGRGRPUpdateInput(
      grpCd: json['GRP_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['GRP_CD'] as Map<String, dynamic>),
      grpNm: json['GRP_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['GRP_NM'] as Map<String, dynamic>),
      grpDesc: json['GRP_DESC'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['GRP_DESC'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['SORT'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STMNGRGRPUpdateInputToJson(
    STMNGRGRPUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('GRP_CD', instance.grpCd?.toJson());
  writeNotNull('GRP_NM', instance.grpNm?.toJson());
  writeNotNull('GRP_DESC', instance.grpDesc?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STMNGRGRPUncheckedUpdateInput _$STMNGRGRPUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STMNGRGRPUncheckedUpdateInput(
      grpCd: json['GRP_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['GRP_CD'] as Map<String, dynamic>),
      grpNm: json['GRP_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['GRP_NM'] as Map<String, dynamic>),
      grpDesc: json['GRP_DESC'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['GRP_DESC'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['SORT'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STMNGRGRPUncheckedUpdateInputToJson(
    STMNGRGRPUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('GRP_CD', instance.grpCd?.toJson());
  writeNotNull('GRP_NM', instance.grpNm?.toJson());
  writeNotNull('GRP_DESC', instance.grpDesc?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STMNGRGRPCreateManyInput _$STMNGRGRPCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    STMNGRGRPCreateManyInput(
      grpCd: json['GRP_CD'] as String,
      grpNm: json['GRP_NM'] as String?,
      grpDesc: json['GRP_DESC'] as String?,
      sort: json['SORT'] as int?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STMNGRGRPCreateManyInputToJson(
    STMNGRGRPCreateManyInput instance) {
  final val = <String, dynamic>{
    'GRP_CD': instance.grpCd,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('GRP_NM', instance.grpNm);
  writeNotNull('GRP_DESC', instance.grpDesc);
  writeNotNull('SORT', instance.sort);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STMNGRGRPUpdateManyMutationInput _$STMNGRGRPUpdateManyMutationInputFromJson(
        Map<String, dynamic> json) =>
    STMNGRGRPUpdateManyMutationInput(
      grpCd: json['GRP_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['GRP_CD'] as Map<String, dynamic>),
      grpNm: json['GRP_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['GRP_NM'] as Map<String, dynamic>),
      grpDesc: json['GRP_DESC'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['GRP_DESC'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['SORT'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STMNGRGRPUpdateManyMutationInputToJson(
    STMNGRGRPUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('GRP_CD', instance.grpCd?.toJson());
  writeNotNull('GRP_NM', instance.grpNm?.toJson());
  writeNotNull('GRP_DESC', instance.grpDesc?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STMNGRGRPUncheckedUpdateManyInput _$STMNGRGRPUncheckedUpdateManyInputFromJson(
        Map<String, dynamic> json) =>
    STMNGRGRPUncheckedUpdateManyInput(
      grpCd: json['GRP_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['GRP_CD'] as Map<String, dynamic>),
      grpNm: json['GRP_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['GRP_NM'] as Map<String, dynamic>),
      grpDesc: json['GRP_DESC'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['GRP_DESC'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['SORT'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STMNGRGRPUncheckedUpdateManyInputToJson(
    STMNGRGRPUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('GRP_CD', instance.grpCd?.toJson());
  writeNotNull('GRP_NM', instance.grpNm?.toJson());
  writeNotNull('GRP_DESC', instance.grpDesc?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STMNGRMSTCreateInput _$STMNGRMSTCreateInputFromJson(
        Map<String, dynamic> json) =>
    STMNGRMSTCreateInput(
      mngrId: json['MNGR_ID'] as String,
      mngrNm: json['MNGR_NM'] as String,
      mngrPw: json['MNGR_PW'] as String?,
      grpCd: json['GRP_CD'] as String?,
      grade: json['GRADE'] as String?,
      permCd: json['PERM_CD'] as String,
      acsYn: json['ACS_YN'] as String?,
      clph: json['CLPH'] as String?,
      empNo: json['EMP_NO'] as String?,
      joinDate: json['JOIN_DATE'] as String?,
      retireDate: _$JsonConverterFromJson<String, DateTime>(
          json['RETIRE_DATE'], const DateTimeJsonConverter().fromJson),
      pwdChgDate: _$JsonConverterFromJson<String, DateTime>(
          json['PWD_CHG_DATE'], const DateTimeJsonConverter().fromJson),
      pwdWrongCnt: json['PWD_WRONG_CNT'] as int?,
      pwdWrongDate: json['PWD_WRONG_DATE'] as String?,
      lstLoginDate: json['LST_LOGIN_DATE'] as String?,
      flpth: json['FLPTH'] as String?,
      fileNm: json['FILE_NM'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STMNGRMSTCreateInputToJson(
    STMNGRMSTCreateInput instance) {
  final val = <String, dynamic>{
    'MNGR_ID': instance.mngrId,
    'MNGR_NM': instance.mngrNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MNGR_PW', instance.mngrPw);
  writeNotNull('GRP_CD', instance.grpCd);
  writeNotNull('GRADE', instance.grade);
  val['PERM_CD'] = instance.permCd;
  writeNotNull('ACS_YN', instance.acsYn);
  writeNotNull('CLPH', instance.clph);
  writeNotNull('EMP_NO', instance.empNo);
  writeNotNull('JOIN_DATE', instance.joinDate);
  writeNotNull(
      'RETIRE_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.retireDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'PWD_CHG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.pwdChgDate, const DateTimeJsonConverter().toJson));
  writeNotNull('PWD_WRONG_CNT', instance.pwdWrongCnt);
  writeNotNull('PWD_WRONG_DATE', instance.pwdWrongDate);
  writeNotNull('LST_LOGIN_DATE', instance.lstLoginDate);
  writeNotNull('FLPTH', instance.flpth);
  writeNotNull('FILE_NM', instance.fileNm);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STMNGRMSTUncheckedCreateInput _$STMNGRMSTUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    STMNGRMSTUncheckedCreateInput(
      mngrId: json['MNGR_ID'] as String,
      mngrNm: json['MNGR_NM'] as String,
      mngrPw: json['MNGR_PW'] as String?,
      grpCd: json['GRP_CD'] as String?,
      grade: json['GRADE'] as String?,
      permCd: json['PERM_CD'] as String,
      acsYn: json['ACS_YN'] as String?,
      clph: json['CLPH'] as String?,
      empNo: json['EMP_NO'] as String?,
      joinDate: json['JOIN_DATE'] as String?,
      retireDate: _$JsonConverterFromJson<String, DateTime>(
          json['RETIRE_DATE'], const DateTimeJsonConverter().fromJson),
      pwdChgDate: _$JsonConverterFromJson<String, DateTime>(
          json['PWD_CHG_DATE'], const DateTimeJsonConverter().fromJson),
      pwdWrongCnt: json['PWD_WRONG_CNT'] as int?,
      pwdWrongDate: json['PWD_WRONG_DATE'] as String?,
      lstLoginDate: json['LST_LOGIN_DATE'] as String?,
      flpth: json['FLPTH'] as String?,
      fileNm: json['FILE_NM'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STMNGRMSTUncheckedCreateInputToJson(
    STMNGRMSTUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'MNGR_ID': instance.mngrId,
    'MNGR_NM': instance.mngrNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MNGR_PW', instance.mngrPw);
  writeNotNull('GRP_CD', instance.grpCd);
  writeNotNull('GRADE', instance.grade);
  val['PERM_CD'] = instance.permCd;
  writeNotNull('ACS_YN', instance.acsYn);
  writeNotNull('CLPH', instance.clph);
  writeNotNull('EMP_NO', instance.empNo);
  writeNotNull('JOIN_DATE', instance.joinDate);
  writeNotNull(
      'RETIRE_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.retireDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'PWD_CHG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.pwdChgDate, const DateTimeJsonConverter().toJson));
  writeNotNull('PWD_WRONG_CNT', instance.pwdWrongCnt);
  writeNotNull('PWD_WRONG_DATE', instance.pwdWrongDate);
  writeNotNull('LST_LOGIN_DATE', instance.lstLoginDate);
  writeNotNull('FLPTH', instance.flpth);
  writeNotNull('FILE_NM', instance.fileNm);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STMNGRMSTUpdateInput _$STMNGRMSTUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STMNGRMSTUpdateInput(
      mngrId: json['MNGR_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MNGR_ID'] as Map<String, dynamic>),
      mngrNm: json['MNGR_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MNGR_NM'] as Map<String, dynamic>),
      mngrPw: json['MNGR_PW'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MNGR_PW'] as Map<String, dynamic>),
      grpCd: json['GRP_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['GRP_CD'] as Map<String, dynamic>),
      grade: json['GRADE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['GRADE'] as Map<String, dynamic>),
      permCd: json['PERM_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['PERM_CD'] as Map<String, dynamic>),
      acsYn: json['ACS_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ACS_YN'] as Map<String, dynamic>),
      clph: json['CLPH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CLPH'] as Map<String, dynamic>),
      empNo: json['EMP_NO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EMP_NO'] as Map<String, dynamic>),
      joinDate: json['JOIN_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['JOIN_DATE'] as Map<String, dynamic>),
      retireDate: json['RETIRE_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['RETIRE_DATE'] as Map<String, dynamic>),
      pwdChgDate: json['PWD_CHG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['PWD_CHG_DATE'] as Map<String, dynamic>),
      pwdWrongCnt: json['PWD_WRONG_CNT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['PWD_WRONG_CNT'] as Map<String, dynamic>),
      pwdWrongDate: json['PWD_WRONG_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['PWD_WRONG_DATE'] as Map<String, dynamic>),
      lstLoginDate: json['LST_LOGIN_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['LST_LOGIN_DATE'] as Map<String, dynamic>),
      flpth: json['FLPTH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FLPTH'] as Map<String, dynamic>),
      fileNm: json['FILE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FILE_NM'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STMNGRMSTUpdateInputToJson(
    STMNGRMSTUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MNGR_ID', instance.mngrId?.toJson());
  writeNotNull('MNGR_NM', instance.mngrNm?.toJson());
  writeNotNull('MNGR_PW', instance.mngrPw?.toJson());
  writeNotNull('GRP_CD', instance.grpCd?.toJson());
  writeNotNull('GRADE', instance.grade?.toJson());
  writeNotNull('PERM_CD', instance.permCd?.toJson());
  writeNotNull('ACS_YN', instance.acsYn?.toJson());
  writeNotNull('CLPH', instance.clph?.toJson());
  writeNotNull('EMP_NO', instance.empNo?.toJson());
  writeNotNull('JOIN_DATE', instance.joinDate?.toJson());
  writeNotNull('RETIRE_DATE', instance.retireDate?.toJson());
  writeNotNull('PWD_CHG_DATE', instance.pwdChgDate?.toJson());
  writeNotNull('PWD_WRONG_CNT', instance.pwdWrongCnt?.toJson());
  writeNotNull('PWD_WRONG_DATE', instance.pwdWrongDate?.toJson());
  writeNotNull('LST_LOGIN_DATE', instance.lstLoginDate?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('FILE_NM', instance.fileNm?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STMNGRMSTUncheckedUpdateInput _$STMNGRMSTUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STMNGRMSTUncheckedUpdateInput(
      mngrId: json['MNGR_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MNGR_ID'] as Map<String, dynamic>),
      mngrNm: json['MNGR_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MNGR_NM'] as Map<String, dynamic>),
      mngrPw: json['MNGR_PW'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MNGR_PW'] as Map<String, dynamic>),
      grpCd: json['GRP_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['GRP_CD'] as Map<String, dynamic>),
      grade: json['GRADE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['GRADE'] as Map<String, dynamic>),
      permCd: json['PERM_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['PERM_CD'] as Map<String, dynamic>),
      acsYn: json['ACS_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ACS_YN'] as Map<String, dynamic>),
      clph: json['CLPH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CLPH'] as Map<String, dynamic>),
      empNo: json['EMP_NO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EMP_NO'] as Map<String, dynamic>),
      joinDate: json['JOIN_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['JOIN_DATE'] as Map<String, dynamic>),
      retireDate: json['RETIRE_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['RETIRE_DATE'] as Map<String, dynamic>),
      pwdChgDate: json['PWD_CHG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['PWD_CHG_DATE'] as Map<String, dynamic>),
      pwdWrongCnt: json['PWD_WRONG_CNT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['PWD_WRONG_CNT'] as Map<String, dynamic>),
      pwdWrongDate: json['PWD_WRONG_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['PWD_WRONG_DATE'] as Map<String, dynamic>),
      lstLoginDate: json['LST_LOGIN_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['LST_LOGIN_DATE'] as Map<String, dynamic>),
      flpth: json['FLPTH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FLPTH'] as Map<String, dynamic>),
      fileNm: json['FILE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FILE_NM'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STMNGRMSTUncheckedUpdateInputToJson(
    STMNGRMSTUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MNGR_ID', instance.mngrId?.toJson());
  writeNotNull('MNGR_NM', instance.mngrNm?.toJson());
  writeNotNull('MNGR_PW', instance.mngrPw?.toJson());
  writeNotNull('GRP_CD', instance.grpCd?.toJson());
  writeNotNull('GRADE', instance.grade?.toJson());
  writeNotNull('PERM_CD', instance.permCd?.toJson());
  writeNotNull('ACS_YN', instance.acsYn?.toJson());
  writeNotNull('CLPH', instance.clph?.toJson());
  writeNotNull('EMP_NO', instance.empNo?.toJson());
  writeNotNull('JOIN_DATE', instance.joinDate?.toJson());
  writeNotNull('RETIRE_DATE', instance.retireDate?.toJson());
  writeNotNull('PWD_CHG_DATE', instance.pwdChgDate?.toJson());
  writeNotNull('PWD_WRONG_CNT', instance.pwdWrongCnt?.toJson());
  writeNotNull('PWD_WRONG_DATE', instance.pwdWrongDate?.toJson());
  writeNotNull('LST_LOGIN_DATE', instance.lstLoginDate?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('FILE_NM', instance.fileNm?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STMNGRMSTCreateManyInput _$STMNGRMSTCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    STMNGRMSTCreateManyInput(
      mngrId: json['MNGR_ID'] as String,
      mngrNm: json['MNGR_NM'] as String,
      mngrPw: json['MNGR_PW'] as String?,
      grpCd: json['GRP_CD'] as String?,
      grade: json['GRADE'] as String?,
      permCd: json['PERM_CD'] as String,
      acsYn: json['ACS_YN'] as String?,
      clph: json['CLPH'] as String?,
      empNo: json['EMP_NO'] as String?,
      joinDate: json['JOIN_DATE'] as String?,
      retireDate: _$JsonConverterFromJson<String, DateTime>(
          json['RETIRE_DATE'], const DateTimeJsonConverter().fromJson),
      pwdChgDate: _$JsonConverterFromJson<String, DateTime>(
          json['PWD_CHG_DATE'], const DateTimeJsonConverter().fromJson),
      pwdWrongCnt: json['PWD_WRONG_CNT'] as int?,
      pwdWrongDate: json['PWD_WRONG_DATE'] as String?,
      lstLoginDate: json['LST_LOGIN_DATE'] as String?,
      flpth: json['FLPTH'] as String?,
      fileNm: json['FILE_NM'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STMNGRMSTCreateManyInputToJson(
    STMNGRMSTCreateManyInput instance) {
  final val = <String, dynamic>{
    'MNGR_ID': instance.mngrId,
    'MNGR_NM': instance.mngrNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MNGR_PW', instance.mngrPw);
  writeNotNull('GRP_CD', instance.grpCd);
  writeNotNull('GRADE', instance.grade);
  val['PERM_CD'] = instance.permCd;
  writeNotNull('ACS_YN', instance.acsYn);
  writeNotNull('CLPH', instance.clph);
  writeNotNull('EMP_NO', instance.empNo);
  writeNotNull('JOIN_DATE', instance.joinDate);
  writeNotNull(
      'RETIRE_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.retireDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'PWD_CHG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.pwdChgDate, const DateTimeJsonConverter().toJson));
  writeNotNull('PWD_WRONG_CNT', instance.pwdWrongCnt);
  writeNotNull('PWD_WRONG_DATE', instance.pwdWrongDate);
  writeNotNull('LST_LOGIN_DATE', instance.lstLoginDate);
  writeNotNull('FLPTH', instance.flpth);
  writeNotNull('FILE_NM', instance.fileNm);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STMNGRMSTUpdateManyMutationInput _$STMNGRMSTUpdateManyMutationInputFromJson(
        Map<String, dynamic> json) =>
    STMNGRMSTUpdateManyMutationInput(
      mngrId: json['MNGR_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MNGR_ID'] as Map<String, dynamic>),
      mngrNm: json['MNGR_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MNGR_NM'] as Map<String, dynamic>),
      mngrPw: json['MNGR_PW'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MNGR_PW'] as Map<String, dynamic>),
      grpCd: json['GRP_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['GRP_CD'] as Map<String, dynamic>),
      grade: json['GRADE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['GRADE'] as Map<String, dynamic>),
      permCd: json['PERM_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['PERM_CD'] as Map<String, dynamic>),
      acsYn: json['ACS_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ACS_YN'] as Map<String, dynamic>),
      clph: json['CLPH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CLPH'] as Map<String, dynamic>),
      empNo: json['EMP_NO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EMP_NO'] as Map<String, dynamic>),
      joinDate: json['JOIN_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['JOIN_DATE'] as Map<String, dynamic>),
      retireDate: json['RETIRE_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['RETIRE_DATE'] as Map<String, dynamic>),
      pwdChgDate: json['PWD_CHG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['PWD_CHG_DATE'] as Map<String, dynamic>),
      pwdWrongCnt: json['PWD_WRONG_CNT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['PWD_WRONG_CNT'] as Map<String, dynamic>),
      pwdWrongDate: json['PWD_WRONG_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['PWD_WRONG_DATE'] as Map<String, dynamic>),
      lstLoginDate: json['LST_LOGIN_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['LST_LOGIN_DATE'] as Map<String, dynamic>),
      flpth: json['FLPTH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FLPTH'] as Map<String, dynamic>),
      fileNm: json['FILE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FILE_NM'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STMNGRMSTUpdateManyMutationInputToJson(
    STMNGRMSTUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MNGR_ID', instance.mngrId?.toJson());
  writeNotNull('MNGR_NM', instance.mngrNm?.toJson());
  writeNotNull('MNGR_PW', instance.mngrPw?.toJson());
  writeNotNull('GRP_CD', instance.grpCd?.toJson());
  writeNotNull('GRADE', instance.grade?.toJson());
  writeNotNull('PERM_CD', instance.permCd?.toJson());
  writeNotNull('ACS_YN', instance.acsYn?.toJson());
  writeNotNull('CLPH', instance.clph?.toJson());
  writeNotNull('EMP_NO', instance.empNo?.toJson());
  writeNotNull('JOIN_DATE', instance.joinDate?.toJson());
  writeNotNull('RETIRE_DATE', instance.retireDate?.toJson());
  writeNotNull('PWD_CHG_DATE', instance.pwdChgDate?.toJson());
  writeNotNull('PWD_WRONG_CNT', instance.pwdWrongCnt?.toJson());
  writeNotNull('PWD_WRONG_DATE', instance.pwdWrongDate?.toJson());
  writeNotNull('LST_LOGIN_DATE', instance.lstLoginDate?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('FILE_NM', instance.fileNm?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STMNGRMSTUncheckedUpdateManyInput _$STMNGRMSTUncheckedUpdateManyInputFromJson(
        Map<String, dynamic> json) =>
    STMNGRMSTUncheckedUpdateManyInput(
      mngrId: json['MNGR_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MNGR_ID'] as Map<String, dynamic>),
      mngrNm: json['MNGR_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MNGR_NM'] as Map<String, dynamic>),
      mngrPw: json['MNGR_PW'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MNGR_PW'] as Map<String, dynamic>),
      grpCd: json['GRP_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['GRP_CD'] as Map<String, dynamic>),
      grade: json['GRADE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['GRADE'] as Map<String, dynamic>),
      permCd: json['PERM_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['PERM_CD'] as Map<String, dynamic>),
      acsYn: json['ACS_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ACS_YN'] as Map<String, dynamic>),
      clph: json['CLPH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CLPH'] as Map<String, dynamic>),
      empNo: json['EMP_NO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EMP_NO'] as Map<String, dynamic>),
      joinDate: json['JOIN_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['JOIN_DATE'] as Map<String, dynamic>),
      retireDate: json['RETIRE_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['RETIRE_DATE'] as Map<String, dynamic>),
      pwdChgDate: json['PWD_CHG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['PWD_CHG_DATE'] as Map<String, dynamic>),
      pwdWrongCnt: json['PWD_WRONG_CNT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['PWD_WRONG_CNT'] as Map<String, dynamic>),
      pwdWrongDate: json['PWD_WRONG_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['PWD_WRONG_DATE'] as Map<String, dynamic>),
      lstLoginDate: json['LST_LOGIN_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['LST_LOGIN_DATE'] as Map<String, dynamic>),
      flpth: json['FLPTH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FLPTH'] as Map<String, dynamic>),
      fileNm: json['FILE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FILE_NM'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STMNGRMSTUncheckedUpdateManyInputToJson(
    STMNGRMSTUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MNGR_ID', instance.mngrId?.toJson());
  writeNotNull('MNGR_NM', instance.mngrNm?.toJson());
  writeNotNull('MNGR_PW', instance.mngrPw?.toJson());
  writeNotNull('GRP_CD', instance.grpCd?.toJson());
  writeNotNull('GRADE', instance.grade?.toJson());
  writeNotNull('PERM_CD', instance.permCd?.toJson());
  writeNotNull('ACS_YN', instance.acsYn?.toJson());
  writeNotNull('CLPH', instance.clph?.toJson());
  writeNotNull('EMP_NO', instance.empNo?.toJson());
  writeNotNull('JOIN_DATE', instance.joinDate?.toJson());
  writeNotNull('RETIRE_DATE', instance.retireDate?.toJson());
  writeNotNull('PWD_CHG_DATE', instance.pwdChgDate?.toJson());
  writeNotNull('PWD_WRONG_CNT', instance.pwdWrongCnt?.toJson());
  writeNotNull('PWD_WRONG_DATE', instance.pwdWrongDate?.toJson());
  writeNotNull('LST_LOGIN_DATE', instance.lstLoginDate?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('FILE_NM', instance.fileNm?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STMYSTNGCreateInput _$STMYSTNGCreateInputFromJson(Map<String, dynamic> json) =>
    STMYSTNGCreateInput(
      userId: json['USER_ID'] as String,
      stngCd: json['STNG_CD'] as String,
      userDiv: json['USER_DIV'] as String,
      stngData: json['STNG_DATA'] as String?,
    );

Map<String, dynamic> _$STMYSTNGCreateInputToJson(STMYSTNGCreateInput instance) {
  final val = <String, dynamic>{
    'USER_ID': instance.userId,
    'STNG_CD': instance.stngCd,
    'USER_DIV': instance.userDiv,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('STNG_DATA', instance.stngData);
  return val;
}

STMYSTNGUncheckedCreateInput _$STMYSTNGUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    STMYSTNGUncheckedCreateInput(
      userId: json['USER_ID'] as String,
      stngCd: json['STNG_CD'] as String,
      userDiv: json['USER_DIV'] as String,
      stngData: json['STNG_DATA'] as String?,
    );

Map<String, dynamic> _$STMYSTNGUncheckedCreateInputToJson(
    STMYSTNGUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'USER_ID': instance.userId,
    'STNG_CD': instance.stngCd,
    'USER_DIV': instance.userDiv,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('STNG_DATA', instance.stngData);
  return val;
}

STMYSTNGUpdateInput _$STMYSTNGUpdateInputFromJson(Map<String, dynamic> json) =>
    STMYSTNGUpdateInput(
      userId: json['USER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_ID'] as Map<String, dynamic>),
      stngCd: json['STNG_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['STNG_CD'] as Map<String, dynamic>),
      userDiv: json['USER_DIV'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_DIV'] as Map<String, dynamic>),
      stngData: json['STNG_DATA'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['STNG_DATA'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STMYSTNGUpdateInputToJson(STMYSTNGUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('STNG_CD', instance.stngCd?.toJson());
  writeNotNull('USER_DIV', instance.userDiv?.toJson());
  writeNotNull('STNG_DATA', instance.stngData?.toJson());
  return val;
}

STMYSTNGUncheckedUpdateInput _$STMYSTNGUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STMYSTNGUncheckedUpdateInput(
      userId: json['USER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_ID'] as Map<String, dynamic>),
      stngCd: json['STNG_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['STNG_CD'] as Map<String, dynamic>),
      userDiv: json['USER_DIV'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_DIV'] as Map<String, dynamic>),
      stngData: json['STNG_DATA'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['STNG_DATA'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STMYSTNGUncheckedUpdateInputToJson(
    STMYSTNGUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('STNG_CD', instance.stngCd?.toJson());
  writeNotNull('USER_DIV', instance.userDiv?.toJson());
  writeNotNull('STNG_DATA', instance.stngData?.toJson());
  return val;
}

STMYSTNGCreateManyInput _$STMYSTNGCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    STMYSTNGCreateManyInput(
      userId: json['USER_ID'] as String,
      stngCd: json['STNG_CD'] as String,
      userDiv: json['USER_DIV'] as String,
      stngData: json['STNG_DATA'] as String?,
    );

Map<String, dynamic> _$STMYSTNGCreateManyInputToJson(
    STMYSTNGCreateManyInput instance) {
  final val = <String, dynamic>{
    'USER_ID': instance.userId,
    'STNG_CD': instance.stngCd,
    'USER_DIV': instance.userDiv,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('STNG_DATA', instance.stngData);
  return val;
}

STMYSTNGUpdateManyMutationInput _$STMYSTNGUpdateManyMutationInputFromJson(
        Map<String, dynamic> json) =>
    STMYSTNGUpdateManyMutationInput(
      userId: json['USER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_ID'] as Map<String, dynamic>),
      stngCd: json['STNG_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['STNG_CD'] as Map<String, dynamic>),
      userDiv: json['USER_DIV'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_DIV'] as Map<String, dynamic>),
      stngData: json['STNG_DATA'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['STNG_DATA'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STMYSTNGUpdateManyMutationInputToJson(
    STMYSTNGUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('STNG_CD', instance.stngCd?.toJson());
  writeNotNull('USER_DIV', instance.userDiv?.toJson());
  writeNotNull('STNG_DATA', instance.stngData?.toJson());
  return val;
}

STMYSTNGUncheckedUpdateManyInput _$STMYSTNGUncheckedUpdateManyInputFromJson(
        Map<String, dynamic> json) =>
    STMYSTNGUncheckedUpdateManyInput(
      userId: json['USER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_ID'] as Map<String, dynamic>),
      stngCd: json['STNG_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['STNG_CD'] as Map<String, dynamic>),
      userDiv: json['USER_DIV'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_DIV'] as Map<String, dynamic>),
      stngData: json['STNG_DATA'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['STNG_DATA'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STMYSTNGUncheckedUpdateManyInputToJson(
    STMYSTNGUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('STNG_CD', instance.stngCd?.toJson());
  writeNotNull('USER_DIV', instance.userDiv?.toJson());
  writeNotNull('STNG_DATA', instance.stngData?.toJson());
  return val;
}

STPERMDTLCreateInput _$STPERMDTLCreateInputFromJson(
        Map<String, dynamic> json) =>
    STPERMDTLCreateInput(
      permCd: json['PERM_CD'] as String,
      menuCd: json['MENU_CD'] as String,
      readYn: json['READ_YN'] as String?,
      regYn: json['REG_YN'] as String?,
      mdfcnYn: json['MDFCN_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      manageYn: json['MANAGE_YN'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
    );

Map<String, dynamic> _$STPERMDTLCreateInputToJson(
    STPERMDTLCreateInput instance) {
  final val = <String, dynamic>{
    'PERM_CD': instance.permCd,
    'MENU_CD': instance.menuCd,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('READ_YN', instance.readYn);
  writeNotNull('REG_YN', instance.regYn);
  writeNotNull('MDFCN_YN', instance.mdfcnYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull('MANAGE_YN', instance.manageYn);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  return val;
}

STPERMDTLUncheckedCreateInput _$STPERMDTLUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    STPERMDTLUncheckedCreateInput(
      permCd: json['PERM_CD'] as String,
      menuCd: json['MENU_CD'] as String,
      readYn: json['READ_YN'] as String?,
      regYn: json['REG_YN'] as String?,
      mdfcnYn: json['MDFCN_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      manageYn: json['MANAGE_YN'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
    );

Map<String, dynamic> _$STPERMDTLUncheckedCreateInputToJson(
    STPERMDTLUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'PERM_CD': instance.permCd,
    'MENU_CD': instance.menuCd,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('READ_YN', instance.readYn);
  writeNotNull('REG_YN', instance.regYn);
  writeNotNull('MDFCN_YN', instance.mdfcnYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull('MANAGE_YN', instance.manageYn);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  return val;
}

STPERMDTLUpdateInput _$STPERMDTLUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STPERMDTLUpdateInput(
      permCd: json['PERM_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['PERM_CD'] as Map<String, dynamic>),
      menuCd: json['MENU_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_CD'] as Map<String, dynamic>),
      readYn: json['READ_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['READ_YN'] as Map<String, dynamic>),
      regYn: json['REG_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_YN'] as Map<String, dynamic>),
      mdfcnYn: json['MDFCN_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MDFCN_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      manageYn: json['MANAGE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MANAGE_YN'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STPERMDTLUpdateInputToJson(
    STPERMDTLUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('PERM_CD', instance.permCd?.toJson());
  writeNotNull('MENU_CD', instance.menuCd?.toJson());
  writeNotNull('READ_YN', instance.readYn?.toJson());
  writeNotNull('REG_YN', instance.regYn?.toJson());
  writeNotNull('MDFCN_YN', instance.mdfcnYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('MANAGE_YN', instance.manageYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

STPERMDTLUncheckedUpdateInput _$STPERMDTLUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STPERMDTLUncheckedUpdateInput(
      permCd: json['PERM_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['PERM_CD'] as Map<String, dynamic>),
      menuCd: json['MENU_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_CD'] as Map<String, dynamic>),
      readYn: json['READ_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['READ_YN'] as Map<String, dynamic>),
      regYn: json['REG_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_YN'] as Map<String, dynamic>),
      mdfcnYn: json['MDFCN_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MDFCN_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      manageYn: json['MANAGE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MANAGE_YN'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STPERMDTLUncheckedUpdateInputToJson(
    STPERMDTLUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('PERM_CD', instance.permCd?.toJson());
  writeNotNull('MENU_CD', instance.menuCd?.toJson());
  writeNotNull('READ_YN', instance.readYn?.toJson());
  writeNotNull('REG_YN', instance.regYn?.toJson());
  writeNotNull('MDFCN_YN', instance.mdfcnYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('MANAGE_YN', instance.manageYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

STPERMDTLCreateManyInput _$STPERMDTLCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    STPERMDTLCreateManyInput(
      permCd: json['PERM_CD'] as String,
      menuCd: json['MENU_CD'] as String,
      readYn: json['READ_YN'] as String?,
      regYn: json['REG_YN'] as String?,
      mdfcnYn: json['MDFCN_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      manageYn: json['MANAGE_YN'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
    );

Map<String, dynamic> _$STPERMDTLCreateManyInputToJson(
    STPERMDTLCreateManyInput instance) {
  final val = <String, dynamic>{
    'PERM_CD': instance.permCd,
    'MENU_CD': instance.menuCd,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('READ_YN', instance.readYn);
  writeNotNull('REG_YN', instance.regYn);
  writeNotNull('MDFCN_YN', instance.mdfcnYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull('MANAGE_YN', instance.manageYn);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  return val;
}

STPERMDTLUpdateManyMutationInput _$STPERMDTLUpdateManyMutationInputFromJson(
        Map<String, dynamic> json) =>
    STPERMDTLUpdateManyMutationInput(
      permCd: json['PERM_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['PERM_CD'] as Map<String, dynamic>),
      menuCd: json['MENU_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_CD'] as Map<String, dynamic>),
      readYn: json['READ_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['READ_YN'] as Map<String, dynamic>),
      regYn: json['REG_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_YN'] as Map<String, dynamic>),
      mdfcnYn: json['MDFCN_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MDFCN_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      manageYn: json['MANAGE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MANAGE_YN'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STPERMDTLUpdateManyMutationInputToJson(
    STPERMDTLUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('PERM_CD', instance.permCd?.toJson());
  writeNotNull('MENU_CD', instance.menuCd?.toJson());
  writeNotNull('READ_YN', instance.readYn?.toJson());
  writeNotNull('REG_YN', instance.regYn?.toJson());
  writeNotNull('MDFCN_YN', instance.mdfcnYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('MANAGE_YN', instance.manageYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

STPERMDTLUncheckedUpdateManyInput _$STPERMDTLUncheckedUpdateManyInputFromJson(
        Map<String, dynamic> json) =>
    STPERMDTLUncheckedUpdateManyInput(
      permCd: json['PERM_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['PERM_CD'] as Map<String, dynamic>),
      menuCd: json['MENU_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_CD'] as Map<String, dynamic>),
      readYn: json['READ_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['READ_YN'] as Map<String, dynamic>),
      regYn: json['REG_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_YN'] as Map<String, dynamic>),
      mdfcnYn: json['MDFCN_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MDFCN_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      manageYn: json['MANAGE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MANAGE_YN'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STPERMDTLUncheckedUpdateManyInputToJson(
    STPERMDTLUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('PERM_CD', instance.permCd?.toJson());
  writeNotNull('MENU_CD', instance.menuCd?.toJson());
  writeNotNull('READ_YN', instance.readYn?.toJson());
  writeNotNull('REG_YN', instance.regYn?.toJson());
  writeNotNull('MDFCN_YN', instance.mdfcnYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('MANAGE_YN', instance.manageYn?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  return val;
}

STPERMMSTCreateInput _$STPERMMSTCreateInputFromJson(
        Map<String, dynamic> json) =>
    STPERMMSTCreateInput(
      permCd: json['PERM_CD'] as String,
      permNm: json['PERM_NM'] as String,
      sort: json['SORT'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STPERMMSTCreateInputToJson(
    STPERMMSTCreateInput instance) {
  final val = <String, dynamic>{
    'PERM_CD': instance.permCd,
    'PERM_NM': instance.permNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SORT', instance.sort);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STPERMMSTUncheckedCreateInput _$STPERMMSTUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    STPERMMSTUncheckedCreateInput(
      permCd: json['PERM_CD'] as String,
      permNm: json['PERM_NM'] as String,
      sort: json['SORT'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STPERMMSTUncheckedCreateInputToJson(
    STPERMMSTUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'PERM_CD': instance.permCd,
    'PERM_NM': instance.permNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SORT', instance.sort);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STPERMMSTUpdateInput _$STPERMMSTUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STPERMMSTUpdateInput(
      permCd: json['PERM_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['PERM_CD'] as Map<String, dynamic>),
      permNm: json['PERM_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['PERM_NM'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SORT'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STPERMMSTUpdateInputToJson(
    STPERMMSTUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('PERM_CD', instance.permCd?.toJson());
  writeNotNull('PERM_NM', instance.permNm?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STPERMMSTUncheckedUpdateInput _$STPERMMSTUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STPERMMSTUncheckedUpdateInput(
      permCd: json['PERM_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['PERM_CD'] as Map<String, dynamic>),
      permNm: json['PERM_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['PERM_NM'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SORT'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STPERMMSTUncheckedUpdateInputToJson(
    STPERMMSTUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('PERM_CD', instance.permCd?.toJson());
  writeNotNull('PERM_NM', instance.permNm?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STPERMMSTCreateManyInput _$STPERMMSTCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    STPERMMSTCreateManyInput(
      permCd: json['PERM_CD'] as String,
      permNm: json['PERM_NM'] as String,
      sort: json['SORT'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STPERMMSTCreateManyInputToJson(
    STPERMMSTCreateManyInput instance) {
  final val = <String, dynamic>{
    'PERM_CD': instance.permCd,
    'PERM_NM': instance.permNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SORT', instance.sort);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STPERMMSTUpdateManyMutationInput _$STPERMMSTUpdateManyMutationInputFromJson(
        Map<String, dynamic> json) =>
    STPERMMSTUpdateManyMutationInput(
      permCd: json['PERM_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['PERM_CD'] as Map<String, dynamic>),
      permNm: json['PERM_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['PERM_NM'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SORT'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STPERMMSTUpdateManyMutationInputToJson(
    STPERMMSTUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('PERM_CD', instance.permCd?.toJson());
  writeNotNull('PERM_NM', instance.permNm?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STPERMMSTUncheckedUpdateManyInput _$STPERMMSTUncheckedUpdateManyInputFromJson(
        Map<String, dynamic> json) =>
    STPERMMSTUncheckedUpdateManyInput(
      permCd: json['PERM_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['PERM_CD'] as Map<String, dynamic>),
      permNm: json['PERM_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['PERM_NM'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SORT'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STPERMMSTUncheckedUpdateManyInputToJson(
    STPERMMSTUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('PERM_CD', instance.permCd?.toJson());
  writeNotNull('PERM_NM', instance.permNm?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STPOPUPCreateInput _$STPOPUPCreateInputFromJson(Map<String, dynamic> json) =>
    STPOPUPCreateInput(
      popCd: json['POP_CD'] as String,
      popNm: json['POP_NM'] as String,
      popTy: json['POP_TY'] as String,
      imgText: json['IMG_TEXT'] as String?,
      lkUrl: json['LK_URL'] as String?,
      lkTarget: json['LK_TARGET'] as String?,
      bgngDate: json['BGNG_DATE'] as String,
      endDate: json['END_DATE'] as String,
      spwgPred: json['SPWG_PRED'] as String?,
      flpth: json['FLPTH'] as String?,
      fileNm: json['FILE_NM'] as String?,
      useYn: json['USE_YN'] as String?,
      beforeCd: json['BEFORE_CD'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STPOPUPCreateInputToJson(STPOPUPCreateInput instance) {
  final val = <String, dynamic>{
    'POP_CD': instance.popCd,
    'POP_NM': instance.popNm,
    'POP_TY': instance.popTy,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('IMG_TEXT', instance.imgText);
  writeNotNull('LK_URL', instance.lkUrl);
  writeNotNull('LK_TARGET', instance.lkTarget);
  val['BGNG_DATE'] = instance.bgngDate;
  val['END_DATE'] = instance.endDate;
  writeNotNull('SPWG_PRED', instance.spwgPred);
  writeNotNull('FLPTH', instance.flpth);
  writeNotNull('FILE_NM', instance.fileNm);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('BEFORE_CD', instance.beforeCd);
  val['REG_ID'] = instance.regId;
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STPOPUPUncheckedCreateInput _$STPOPUPUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    STPOPUPUncheckedCreateInput(
      popCd: json['POP_CD'] as String,
      popNm: json['POP_NM'] as String,
      popTy: json['POP_TY'] as String,
      imgText: json['IMG_TEXT'] as String?,
      lkUrl: json['LK_URL'] as String?,
      lkTarget: json['LK_TARGET'] as String?,
      bgngDate: json['BGNG_DATE'] as String,
      endDate: json['END_DATE'] as String,
      spwgPred: json['SPWG_PRED'] as String?,
      flpth: json['FLPTH'] as String?,
      fileNm: json['FILE_NM'] as String?,
      useYn: json['USE_YN'] as String?,
      beforeCd: json['BEFORE_CD'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STPOPUPUncheckedCreateInputToJson(
    STPOPUPUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'POP_CD': instance.popCd,
    'POP_NM': instance.popNm,
    'POP_TY': instance.popTy,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('IMG_TEXT', instance.imgText);
  writeNotNull('LK_URL', instance.lkUrl);
  writeNotNull('LK_TARGET', instance.lkTarget);
  val['BGNG_DATE'] = instance.bgngDate;
  val['END_DATE'] = instance.endDate;
  writeNotNull('SPWG_PRED', instance.spwgPred);
  writeNotNull('FLPTH', instance.flpth);
  writeNotNull('FILE_NM', instance.fileNm);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('BEFORE_CD', instance.beforeCd);
  val['REG_ID'] = instance.regId;
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STPOPUPUpdateInput _$STPOPUPUpdateInputFromJson(Map<String, dynamic> json) =>
    STPOPUPUpdateInput(
      popCd: json['POP_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['POP_CD'] as Map<String, dynamic>),
      popNm: json['POP_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['POP_NM'] as Map<String, dynamic>),
      popTy: json['POP_TY'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['POP_TY'] as Map<String, dynamic>),
      imgText: json['IMG_TEXT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['IMG_TEXT'] as Map<String, dynamic>),
      lkUrl: json['LK_URL'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['LK_URL'] as Map<String, dynamic>),
      lkTarget: json['LK_TARGET'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['LK_TARGET'] as Map<String, dynamic>),
      bgngDate: json['BGNG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['BGNG_DATE'] as Map<String, dynamic>),
      endDate: json['END_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['END_DATE'] as Map<String, dynamic>),
      spwgPred: json['SPWG_PRED'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SPWG_PRED'] as Map<String, dynamic>),
      flpth: json['FLPTH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FLPTH'] as Map<String, dynamic>),
      fileNm: json['FILE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FILE_NM'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      beforeCd: json['BEFORE_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['BEFORE_CD'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STPOPUPUpdateInputToJson(STPOPUPUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('POP_CD', instance.popCd?.toJson());
  writeNotNull('POP_NM', instance.popNm?.toJson());
  writeNotNull('POP_TY', instance.popTy?.toJson());
  writeNotNull('IMG_TEXT', instance.imgText?.toJson());
  writeNotNull('LK_URL', instance.lkUrl?.toJson());
  writeNotNull('LK_TARGET', instance.lkTarget?.toJson());
  writeNotNull('BGNG_DATE', instance.bgngDate?.toJson());
  writeNotNull('END_DATE', instance.endDate?.toJson());
  writeNotNull('SPWG_PRED', instance.spwgPred?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('FILE_NM', instance.fileNm?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('BEFORE_CD', instance.beforeCd?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STPOPUPUncheckedUpdateInput _$STPOPUPUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STPOPUPUncheckedUpdateInput(
      popCd: json['POP_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['POP_CD'] as Map<String, dynamic>),
      popNm: json['POP_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['POP_NM'] as Map<String, dynamic>),
      popTy: json['POP_TY'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['POP_TY'] as Map<String, dynamic>),
      imgText: json['IMG_TEXT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['IMG_TEXT'] as Map<String, dynamic>),
      lkUrl: json['LK_URL'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['LK_URL'] as Map<String, dynamic>),
      lkTarget: json['LK_TARGET'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['LK_TARGET'] as Map<String, dynamic>),
      bgngDate: json['BGNG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['BGNG_DATE'] as Map<String, dynamic>),
      endDate: json['END_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['END_DATE'] as Map<String, dynamic>),
      spwgPred: json['SPWG_PRED'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SPWG_PRED'] as Map<String, dynamic>),
      flpth: json['FLPTH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FLPTH'] as Map<String, dynamic>),
      fileNm: json['FILE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FILE_NM'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      beforeCd: json['BEFORE_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['BEFORE_CD'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STPOPUPUncheckedUpdateInputToJson(
    STPOPUPUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('POP_CD', instance.popCd?.toJson());
  writeNotNull('POP_NM', instance.popNm?.toJson());
  writeNotNull('POP_TY', instance.popTy?.toJson());
  writeNotNull('IMG_TEXT', instance.imgText?.toJson());
  writeNotNull('LK_URL', instance.lkUrl?.toJson());
  writeNotNull('LK_TARGET', instance.lkTarget?.toJson());
  writeNotNull('BGNG_DATE', instance.bgngDate?.toJson());
  writeNotNull('END_DATE', instance.endDate?.toJson());
  writeNotNull('SPWG_PRED', instance.spwgPred?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('FILE_NM', instance.fileNm?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('BEFORE_CD', instance.beforeCd?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STPOPUPCreateManyInput _$STPOPUPCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    STPOPUPCreateManyInput(
      popCd: json['POP_CD'] as String,
      popNm: json['POP_NM'] as String,
      popTy: json['POP_TY'] as String,
      imgText: json['IMG_TEXT'] as String?,
      lkUrl: json['LK_URL'] as String?,
      lkTarget: json['LK_TARGET'] as String?,
      bgngDate: json['BGNG_DATE'] as String,
      endDate: json['END_DATE'] as String,
      spwgPred: json['SPWG_PRED'] as String?,
      flpth: json['FLPTH'] as String?,
      fileNm: json['FILE_NM'] as String?,
      useYn: json['USE_YN'] as String?,
      beforeCd: json['BEFORE_CD'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STPOPUPCreateManyInputToJson(
    STPOPUPCreateManyInput instance) {
  final val = <String, dynamic>{
    'POP_CD': instance.popCd,
    'POP_NM': instance.popNm,
    'POP_TY': instance.popTy,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('IMG_TEXT', instance.imgText);
  writeNotNull('LK_URL', instance.lkUrl);
  writeNotNull('LK_TARGET', instance.lkTarget);
  val['BGNG_DATE'] = instance.bgngDate;
  val['END_DATE'] = instance.endDate;
  writeNotNull('SPWG_PRED', instance.spwgPred);
  writeNotNull('FLPTH', instance.flpth);
  writeNotNull('FILE_NM', instance.fileNm);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('BEFORE_CD', instance.beforeCd);
  val['REG_ID'] = instance.regId;
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STPOPUPUpdateManyMutationInput _$STPOPUPUpdateManyMutationInputFromJson(
        Map<String, dynamic> json) =>
    STPOPUPUpdateManyMutationInput(
      popCd: json['POP_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['POP_CD'] as Map<String, dynamic>),
      popNm: json['POP_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['POP_NM'] as Map<String, dynamic>),
      popTy: json['POP_TY'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['POP_TY'] as Map<String, dynamic>),
      imgText: json['IMG_TEXT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['IMG_TEXT'] as Map<String, dynamic>),
      lkUrl: json['LK_URL'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['LK_URL'] as Map<String, dynamic>),
      lkTarget: json['LK_TARGET'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['LK_TARGET'] as Map<String, dynamic>),
      bgngDate: json['BGNG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['BGNG_DATE'] as Map<String, dynamic>),
      endDate: json['END_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['END_DATE'] as Map<String, dynamic>),
      spwgPred: json['SPWG_PRED'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SPWG_PRED'] as Map<String, dynamic>),
      flpth: json['FLPTH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FLPTH'] as Map<String, dynamic>),
      fileNm: json['FILE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FILE_NM'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      beforeCd: json['BEFORE_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['BEFORE_CD'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STPOPUPUpdateManyMutationInputToJson(
    STPOPUPUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('POP_CD', instance.popCd?.toJson());
  writeNotNull('POP_NM', instance.popNm?.toJson());
  writeNotNull('POP_TY', instance.popTy?.toJson());
  writeNotNull('IMG_TEXT', instance.imgText?.toJson());
  writeNotNull('LK_URL', instance.lkUrl?.toJson());
  writeNotNull('LK_TARGET', instance.lkTarget?.toJson());
  writeNotNull('BGNG_DATE', instance.bgngDate?.toJson());
  writeNotNull('END_DATE', instance.endDate?.toJson());
  writeNotNull('SPWG_PRED', instance.spwgPred?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('FILE_NM', instance.fileNm?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('BEFORE_CD', instance.beforeCd?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STPOPUPUncheckedUpdateManyInput _$STPOPUPUncheckedUpdateManyInputFromJson(
        Map<String, dynamic> json) =>
    STPOPUPUncheckedUpdateManyInput(
      popCd: json['POP_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['POP_CD'] as Map<String, dynamic>),
      popNm: json['POP_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['POP_NM'] as Map<String, dynamic>),
      popTy: json['POP_TY'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['POP_TY'] as Map<String, dynamic>),
      imgText: json['IMG_TEXT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['IMG_TEXT'] as Map<String, dynamic>),
      lkUrl: json['LK_URL'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['LK_URL'] as Map<String, dynamic>),
      lkTarget: json['LK_TARGET'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['LK_TARGET'] as Map<String, dynamic>),
      bgngDate: json['BGNG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['BGNG_DATE'] as Map<String, dynamic>),
      endDate: json['END_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['END_DATE'] as Map<String, dynamic>),
      spwgPred: json['SPWG_PRED'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['SPWG_PRED'] as Map<String, dynamic>),
      flpth: json['FLPTH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FLPTH'] as Map<String, dynamic>),
      fileNm: json['FILE_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['FILE_NM'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      beforeCd: json['BEFORE_CD'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['BEFORE_CD'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STPOPUPUncheckedUpdateManyInputToJson(
    STPOPUPUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('POP_CD', instance.popCd?.toJson());
  writeNotNull('POP_NM', instance.popNm?.toJson());
  writeNotNull('POP_TY', instance.popTy?.toJson());
  writeNotNull('IMG_TEXT', instance.imgText?.toJson());
  writeNotNull('LK_URL', instance.lkUrl?.toJson());
  writeNotNull('LK_TARGET', instance.lkTarget?.toJson());
  writeNotNull('BGNG_DATE', instance.bgngDate?.toJson());
  writeNotNull('END_DATE', instance.endDate?.toJson());
  writeNotNull('SPWG_PRED', instance.spwgPred?.toJson());
  writeNotNull('FLPTH', instance.flpth?.toJson());
  writeNotNull('FILE_NM', instance.fileNm?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('BEFORE_CD', instance.beforeCd?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STSTNGCreateInput _$STSTNGCreateInputFromJson(Map<String, dynamic> json) =>
    STSTNGCreateInput(
      stngCd: json['STNG_CD'] as String,
      stngData: json['STNG_DATA'] as String?,
      title: json['TITLE'] as String?,
      descCn: json['DESC_CN'] as String?,
      sort: json['SORT'] as int?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
    );

Map<String, dynamic> _$STSTNGCreateInputToJson(STSTNGCreateInput instance) {
  final val = <String, dynamic>{
    'STNG_CD': instance.stngCd,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('STNG_DATA', instance.stngData);
  writeNotNull('TITLE', instance.title);
  writeNotNull('DESC_CN', instance.descCn);
  writeNotNull('SORT', instance.sort);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  return val;
}

STSTNGUncheckedCreateInput _$STSTNGUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    STSTNGUncheckedCreateInput(
      stngCd: json['STNG_CD'] as String,
      stngData: json['STNG_DATA'] as String?,
      title: json['TITLE'] as String?,
      descCn: json['DESC_CN'] as String?,
      sort: json['SORT'] as int?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
    );

Map<String, dynamic> _$STSTNGUncheckedCreateInputToJson(
    STSTNGUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'STNG_CD': instance.stngCd,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('STNG_DATA', instance.stngData);
  writeNotNull('TITLE', instance.title);
  writeNotNull('DESC_CN', instance.descCn);
  writeNotNull('SORT', instance.sort);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  return val;
}

STSTNGUpdateInput _$STSTNGUpdateInputFromJson(Map<String, dynamic> json) =>
    STSTNGUpdateInput(
      stngCd: json['STNG_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['STNG_CD'] as Map<String, dynamic>),
      stngData: json['STNG_DATA'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['STNG_DATA'] as Map<String, dynamic>),
      title: json['TITLE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['TITLE'] as Map<String, dynamic>),
      descCn: json['DESC_CN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DESC_CN'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['SORT'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STSTNGUpdateInputToJson(STSTNGUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('STNG_CD', instance.stngCd?.toJson());
  writeNotNull('STNG_DATA', instance.stngData?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('DESC_CN', instance.descCn?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  return val;
}

STSTNGUncheckedUpdateInput _$STSTNGUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STSTNGUncheckedUpdateInput(
      stngCd: json['STNG_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['STNG_CD'] as Map<String, dynamic>),
      stngData: json['STNG_DATA'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['STNG_DATA'] as Map<String, dynamic>),
      title: json['TITLE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['TITLE'] as Map<String, dynamic>),
      descCn: json['DESC_CN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DESC_CN'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['SORT'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STSTNGUncheckedUpdateInputToJson(
    STSTNGUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('STNG_CD', instance.stngCd?.toJson());
  writeNotNull('STNG_DATA', instance.stngData?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('DESC_CN', instance.descCn?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  return val;
}

STSTNGCreateManyInput _$STSTNGCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    STSTNGCreateManyInput(
      stngCd: json['STNG_CD'] as String,
      stngData: json['STNG_DATA'] as String?,
      title: json['TITLE'] as String?,
      descCn: json['DESC_CN'] as String?,
      sort: json['SORT'] as int?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
    );

Map<String, dynamic> _$STSTNGCreateManyInputToJson(
    STSTNGCreateManyInput instance) {
  final val = <String, dynamic>{
    'STNG_CD': instance.stngCd,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('STNG_DATA', instance.stngData);
  writeNotNull('TITLE', instance.title);
  writeNotNull('DESC_CN', instance.descCn);
  writeNotNull('SORT', instance.sort);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  return val;
}

STSTNGUpdateManyMutationInput _$STSTNGUpdateManyMutationInputFromJson(
        Map<String, dynamic> json) =>
    STSTNGUpdateManyMutationInput(
      stngCd: json['STNG_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['STNG_CD'] as Map<String, dynamic>),
      stngData: json['STNG_DATA'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['STNG_DATA'] as Map<String, dynamic>),
      title: json['TITLE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['TITLE'] as Map<String, dynamic>),
      descCn: json['DESC_CN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DESC_CN'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['SORT'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STSTNGUpdateManyMutationInputToJson(
    STSTNGUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('STNG_CD', instance.stngCd?.toJson());
  writeNotNull('STNG_DATA', instance.stngData?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('DESC_CN', instance.descCn?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  return val;
}

STSTNGUncheckedUpdateManyInput _$STSTNGUncheckedUpdateManyInputFromJson(
        Map<String, dynamic> json) =>
    STSTNGUncheckedUpdateManyInput(
      stngCd: json['STNG_CD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['STNG_CD'] as Map<String, dynamic>),
      stngData: json['STNG_DATA'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['STNG_DATA'] as Map<String, dynamic>),
      title: json['TITLE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['TITLE'] as Map<String, dynamic>),
      descCn: json['DESC_CN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DESC_CN'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['SORT'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STSTNGUncheckedUpdateManyInputToJson(
    STSTNGUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('STNG_CD', instance.stngCd?.toJson());
  writeNotNull('STNG_DATA', instance.stngData?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('DESC_CN', instance.descCn?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  return val;
}

STUSERMSTCreateInput _$STUSERMSTCreateInputFromJson(
        Map<String, dynamic> json) =>
    STUSERMSTCreateInput(
      userId: json['USER_ID'] as String,
      userNm: json['USER_NM'] as String?,
      userPw: json['USER_PW'] as String,
      userDiv: json['USER_DIV'] as String?,
      status: json['STATUS'] as String?,
      prevLoginYn: json['PREV_LOGIN_YN'] as String?,
      withdrawnYn: json['WITHDRAWN_YN'] as String?,
      clph: json['CLPH'] as String?,
      email: json['EMAIL'] as String?,
      lstLoginDate: json['LST_LOGIN_DATE'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STUSERMSTCreateInputToJson(
    STUSERMSTCreateInput instance) {
  final val = <String, dynamic>{
    'USER_ID': instance.userId,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_NM', instance.userNm);
  val['USER_PW'] = instance.userPw;
  writeNotNull('USER_DIV', instance.userDiv);
  writeNotNull('STATUS', instance.status);
  writeNotNull('PREV_LOGIN_YN', instance.prevLoginYn);
  writeNotNull('WITHDRAWN_YN', instance.withdrawnYn);
  writeNotNull('CLPH', instance.clph);
  writeNotNull('EMAIL', instance.email);
  writeNotNull('LST_LOGIN_DATE', instance.lstLoginDate);
  val['REG_ID'] = instance.regId;
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STUSERMSTUncheckedCreateInput _$STUSERMSTUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    STUSERMSTUncheckedCreateInput(
      userId: json['USER_ID'] as String,
      userNm: json['USER_NM'] as String?,
      userPw: json['USER_PW'] as String,
      userDiv: json['USER_DIV'] as String?,
      status: json['STATUS'] as String?,
      prevLoginYn: json['PREV_LOGIN_YN'] as String?,
      withdrawnYn: json['WITHDRAWN_YN'] as String?,
      clph: json['CLPH'] as String?,
      email: json['EMAIL'] as String?,
      lstLoginDate: json['LST_LOGIN_DATE'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STUSERMSTUncheckedCreateInputToJson(
    STUSERMSTUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'USER_ID': instance.userId,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_NM', instance.userNm);
  val['USER_PW'] = instance.userPw;
  writeNotNull('USER_DIV', instance.userDiv);
  writeNotNull('STATUS', instance.status);
  writeNotNull('PREV_LOGIN_YN', instance.prevLoginYn);
  writeNotNull('WITHDRAWN_YN', instance.withdrawnYn);
  writeNotNull('CLPH', instance.clph);
  writeNotNull('EMAIL', instance.email);
  writeNotNull('LST_LOGIN_DATE', instance.lstLoginDate);
  val['REG_ID'] = instance.regId;
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STUSERMSTUpdateInput _$STUSERMSTUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STUSERMSTUpdateInput(
      userId: json['USER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_ID'] as Map<String, dynamic>),
      userNm: json['USER_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USER_NM'] as Map<String, dynamic>),
      userPw: json['USER_PW'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_PW'] as Map<String, dynamic>),
      userDiv: json['USER_DIV'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USER_DIV'] as Map<String, dynamic>),
      status: json['STATUS'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['STATUS'] as Map<String, dynamic>),
      prevLoginYn: json['PREV_LOGIN_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['PREV_LOGIN_YN'] as Map<String, dynamic>),
      withdrawnYn: json['WITHDRAWN_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['WITHDRAWN_YN'] as Map<String, dynamic>),
      clph: json['CLPH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CLPH'] as Map<String, dynamic>),
      email: json['EMAIL'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EMAIL'] as Map<String, dynamic>),
      lstLoginDate: json['LST_LOGIN_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['LST_LOGIN_DATE'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STUSERMSTUpdateInputToJson(
    STUSERMSTUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('USER_NM', instance.userNm?.toJson());
  writeNotNull('USER_PW', instance.userPw?.toJson());
  writeNotNull('USER_DIV', instance.userDiv?.toJson());
  writeNotNull('STATUS', instance.status?.toJson());
  writeNotNull('PREV_LOGIN_YN', instance.prevLoginYn?.toJson());
  writeNotNull('WITHDRAWN_YN', instance.withdrawnYn?.toJson());
  writeNotNull('CLPH', instance.clph?.toJson());
  writeNotNull('EMAIL', instance.email?.toJson());
  writeNotNull('LST_LOGIN_DATE', instance.lstLoginDate?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STUSERMSTUncheckedUpdateInput _$STUSERMSTUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    STUSERMSTUncheckedUpdateInput(
      userId: json['USER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_ID'] as Map<String, dynamic>),
      userNm: json['USER_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USER_NM'] as Map<String, dynamic>),
      userPw: json['USER_PW'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_PW'] as Map<String, dynamic>),
      userDiv: json['USER_DIV'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USER_DIV'] as Map<String, dynamic>),
      status: json['STATUS'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['STATUS'] as Map<String, dynamic>),
      prevLoginYn: json['PREV_LOGIN_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['PREV_LOGIN_YN'] as Map<String, dynamic>),
      withdrawnYn: json['WITHDRAWN_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['WITHDRAWN_YN'] as Map<String, dynamic>),
      clph: json['CLPH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CLPH'] as Map<String, dynamic>),
      email: json['EMAIL'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EMAIL'] as Map<String, dynamic>),
      lstLoginDate: json['LST_LOGIN_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['LST_LOGIN_DATE'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STUSERMSTUncheckedUpdateInputToJson(
    STUSERMSTUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('USER_NM', instance.userNm?.toJson());
  writeNotNull('USER_PW', instance.userPw?.toJson());
  writeNotNull('USER_DIV', instance.userDiv?.toJson());
  writeNotNull('STATUS', instance.status?.toJson());
  writeNotNull('PREV_LOGIN_YN', instance.prevLoginYn?.toJson());
  writeNotNull('WITHDRAWN_YN', instance.withdrawnYn?.toJson());
  writeNotNull('CLPH', instance.clph?.toJson());
  writeNotNull('EMAIL', instance.email?.toJson());
  writeNotNull('LST_LOGIN_DATE', instance.lstLoginDate?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STUSERMSTCreateManyInput _$STUSERMSTCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    STUSERMSTCreateManyInput(
      userId: json['USER_ID'] as String,
      userNm: json['USER_NM'] as String?,
      userPw: json['USER_PW'] as String,
      userDiv: json['USER_DIV'] as String?,
      status: json['STATUS'] as String?,
      prevLoginYn: json['PREV_LOGIN_YN'] as String?,
      withdrawnYn: json['WITHDRAWN_YN'] as String?,
      clph: json['CLPH'] as String?,
      email: json['EMAIL'] as String?,
      lstLoginDate: json['LST_LOGIN_DATE'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STUSERMSTCreateManyInputToJson(
    STUSERMSTCreateManyInput instance) {
  final val = <String, dynamic>{
    'USER_ID': instance.userId,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_NM', instance.userNm);
  val['USER_PW'] = instance.userPw;
  writeNotNull('USER_DIV', instance.userDiv);
  writeNotNull('STATUS', instance.status);
  writeNotNull('PREV_LOGIN_YN', instance.prevLoginYn);
  writeNotNull('WITHDRAWN_YN', instance.withdrawnYn);
  writeNotNull('CLPH', instance.clph);
  writeNotNull('EMAIL', instance.email);
  writeNotNull('LST_LOGIN_DATE', instance.lstLoginDate);
  val['REG_ID'] = instance.regId;
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STUSERMSTUpdateManyMutationInput _$STUSERMSTUpdateManyMutationInputFromJson(
        Map<String, dynamic> json) =>
    STUSERMSTUpdateManyMutationInput(
      userId: json['USER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_ID'] as Map<String, dynamic>),
      userNm: json['USER_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USER_NM'] as Map<String, dynamic>),
      userPw: json['USER_PW'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_PW'] as Map<String, dynamic>),
      userDiv: json['USER_DIV'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USER_DIV'] as Map<String, dynamic>),
      status: json['STATUS'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['STATUS'] as Map<String, dynamic>),
      prevLoginYn: json['PREV_LOGIN_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['PREV_LOGIN_YN'] as Map<String, dynamic>),
      withdrawnYn: json['WITHDRAWN_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['WITHDRAWN_YN'] as Map<String, dynamic>),
      clph: json['CLPH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CLPH'] as Map<String, dynamic>),
      email: json['EMAIL'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EMAIL'] as Map<String, dynamic>),
      lstLoginDate: json['LST_LOGIN_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['LST_LOGIN_DATE'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STUSERMSTUpdateManyMutationInputToJson(
    STUSERMSTUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('USER_NM', instance.userNm?.toJson());
  writeNotNull('USER_PW', instance.userPw?.toJson());
  writeNotNull('USER_DIV', instance.userDiv?.toJson());
  writeNotNull('STATUS', instance.status?.toJson());
  writeNotNull('PREV_LOGIN_YN', instance.prevLoginYn?.toJson());
  writeNotNull('WITHDRAWN_YN', instance.withdrawnYn?.toJson());
  writeNotNull('CLPH', instance.clph?.toJson());
  writeNotNull('EMAIL', instance.email?.toJson());
  writeNotNull('LST_LOGIN_DATE', instance.lstLoginDate?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

STUSERMSTUncheckedUpdateManyInput _$STUSERMSTUncheckedUpdateManyInputFromJson(
        Map<String, dynamic> json) =>
    STUSERMSTUncheckedUpdateManyInput(
      userId: json['USER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_ID'] as Map<String, dynamic>),
      userNm: json['USER_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USER_NM'] as Map<String, dynamic>),
      userPw: json['USER_PW'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_PW'] as Map<String, dynamic>),
      userDiv: json['USER_DIV'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USER_DIV'] as Map<String, dynamic>),
      status: json['STATUS'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['STATUS'] as Map<String, dynamic>),
      prevLoginYn: json['PREV_LOGIN_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['PREV_LOGIN_YN'] as Map<String, dynamic>),
      withdrawnYn: json['WITHDRAWN_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['WITHDRAWN_YN'] as Map<String, dynamic>),
      clph: json['CLPH'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CLPH'] as Map<String, dynamic>),
      email: json['EMAIL'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EMAIL'] as Map<String, dynamic>),
      lstLoginDate: json['LST_LOGIN_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['LST_LOGIN_DATE'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$STUSERMSTUncheckedUpdateManyInputToJson(
    STUSERMSTUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('USER_NM', instance.userNm?.toJson());
  writeNotNull('USER_PW', instance.userPw?.toJson());
  writeNotNull('USER_DIV', instance.userDiv?.toJson());
  writeNotNull('STATUS', instance.status?.toJson());
  writeNotNull('PREV_LOGIN_YN', instance.prevLoginYn?.toJson());
  writeNotNull('WITHDRAWN_YN', instance.withdrawnYn?.toJson());
  writeNotNull('CLPH', instance.clph?.toJson());
  writeNotNull('EMAIL', instance.email?.toJson());
  writeNotNull('LST_LOGIN_DATE', instance.lstLoginDate?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

WORKREPORTDETAILTBLCreateInput _$WORKREPORTDETAILTBLCreateInputFromJson(
        Map<String, dynamic> json) =>
    WORKREPORTDETAILTBLCreateInput(
      reportId: json['REPORT_ID'] as String,
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      projectNm: json['PROJECT_NM'] as String,
      projectSubNm: json['PROJECT_SUB_NM'] as String,
      detailContent: json['DETAIL_CONTENT'] as String?,
      worker: json['WORKER'] as String?,
      grade: json['GRADE'] as String?,
      processRate: json['PROCESS_RATE'] as String?,
      workDate: json['WORK_DATE'] as String?,
      processType: json['PROCESS_TYPE'] as String?,
      subjectYn: json['SUBJECT_YN'] as String?,
      regUser: json['REG_USER'] as String,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      completeDate: json['COMPLETE_DATE'] as String?,
    );

Map<String, dynamic> _$WORKREPORTDETAILTBLCreateInputToJson(
    WORKREPORTDETAILTBLCreateInput instance) {
  final val = <String, dynamic>{
    'REPORT_ID': instance.reportId,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['PROJECT_NM'] = instance.projectNm;
  val['PROJECT_SUB_NM'] = instance.projectSubNm;
  writeNotNull('DETAIL_CONTENT', instance.detailContent);
  writeNotNull('WORKER', instance.worker);
  writeNotNull('GRADE', instance.grade);
  writeNotNull('PROCESS_RATE', instance.processRate);
  writeNotNull('WORK_DATE', instance.workDate);
  writeNotNull('PROCESS_TYPE', instance.processType);
  writeNotNull('SUBJECT_YN', instance.subjectYn);
  val['REG_USER'] = instance.regUser;
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull('COMPLETE_DATE', instance.completeDate);
  return val;
}

WORKREPORTDETAILTBLUncheckedCreateInput
    _$WORKREPORTDETAILTBLUncheckedCreateInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTDETAILTBLUncheckedCreateInput(
          reportId: json['REPORT_ID'] as String,
          seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
          projectNm: json['PROJECT_NM'] as String,
          projectSubNm: json['PROJECT_SUB_NM'] as String,
          detailContent: json['DETAIL_CONTENT'] as String?,
          worker: json['WORKER'] as String?,
          grade: json['GRADE'] as String?,
          processRate: json['PROCESS_RATE'] as String?,
          workDate: json['WORK_DATE'] as String?,
          processType: json['PROCESS_TYPE'] as String?,
          subjectYn: json['SUBJECT_YN'] as String?,
          regUser: json['REG_USER'] as String,
          regDate: _$JsonConverterFromJson<String, DateTime>(
              json['REG_DATE'], const DateTimeJsonConverter().fromJson),
          completeDate: json['COMPLETE_DATE'] as String?,
        );

Map<String, dynamic> _$WORKREPORTDETAILTBLUncheckedCreateInputToJson(
    WORKREPORTDETAILTBLUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'REPORT_ID': instance.reportId,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['PROJECT_NM'] = instance.projectNm;
  val['PROJECT_SUB_NM'] = instance.projectSubNm;
  writeNotNull('DETAIL_CONTENT', instance.detailContent);
  writeNotNull('WORKER', instance.worker);
  writeNotNull('GRADE', instance.grade);
  writeNotNull('PROCESS_RATE', instance.processRate);
  writeNotNull('WORK_DATE', instance.workDate);
  writeNotNull('PROCESS_TYPE', instance.processType);
  writeNotNull('SUBJECT_YN', instance.subjectYn);
  val['REG_USER'] = instance.regUser;
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull('COMPLETE_DATE', instance.completeDate);
  return val;
}

WORKREPORTDETAILTBLUpdateInput _$WORKREPORTDETAILTBLUpdateInputFromJson(
        Map<String, dynamic> json) =>
    WORKREPORTDETAILTBLUpdateInput(
      reportId: json['REPORT_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REPORT_ID'] as Map<String, dynamic>),
      seq: json['SEQ'] == null
          ? null
          : BigIntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      projectNm: json['PROJECT_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['PROJECT_NM'] as Map<String, dynamic>),
      projectSubNm: json['PROJECT_SUB_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['PROJECT_SUB_NM'] as Map<String, dynamic>),
      detailContent: json['DETAIL_CONTENT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DETAIL_CONTENT'] as Map<String, dynamic>),
      worker: json['WORKER'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['WORKER'] as Map<String, dynamic>),
      grade: json['GRADE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['GRADE'] as Map<String, dynamic>),
      processRate: json['PROCESS_RATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['PROCESS_RATE'] as Map<String, dynamic>),
      workDate: json['WORK_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['WORK_DATE'] as Map<String, dynamic>),
      processType: json['PROCESS_TYPE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['PROCESS_TYPE'] as Map<String, dynamic>),
      subjectYn: json['SUBJECT_YN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['SUBJECT_YN'] as Map<String, dynamic>),
      regUser: json['REG_USER'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_USER'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      completeDate: json['COMPLETE_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['COMPLETE_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$WORKREPORTDETAILTBLUpdateInputToJson(
    WORKREPORTDETAILTBLUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', instance.reportId?.toJson());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('PROJECT_NM', instance.projectNm?.toJson());
  writeNotNull('PROJECT_SUB_NM', instance.projectSubNm?.toJson());
  writeNotNull('DETAIL_CONTENT', instance.detailContent?.toJson());
  writeNotNull('WORKER', instance.worker?.toJson());
  writeNotNull('GRADE', instance.grade?.toJson());
  writeNotNull('PROCESS_RATE', instance.processRate?.toJson());
  writeNotNull('WORK_DATE', instance.workDate?.toJson());
  writeNotNull('PROCESS_TYPE', instance.processType?.toJson());
  writeNotNull('SUBJECT_YN', instance.subjectYn?.toJson());
  writeNotNull('REG_USER', instance.regUser?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('COMPLETE_DATE', instance.completeDate?.toJson());
  return val;
}

WORKREPORTDETAILTBLUncheckedUpdateInput
    _$WORKREPORTDETAILTBLUncheckedUpdateInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTDETAILTBLUncheckedUpdateInput(
          reportId: json['REPORT_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REPORT_ID'] as Map<String, dynamic>),
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          projectNm: json['PROJECT_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['PROJECT_NM'] as Map<String, dynamic>),
          projectSubNm: json['PROJECT_SUB_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['PROJECT_SUB_NM'] as Map<String, dynamic>),
          detailContent: json['DETAIL_CONTENT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DETAIL_CONTENT'] as Map<String, dynamic>),
          worker: json['WORKER'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['WORKER'] as Map<String, dynamic>),
          grade: json['GRADE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['GRADE'] as Map<String, dynamic>),
          processRate: json['PROCESS_RATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['PROCESS_RATE'] as Map<String, dynamic>),
          workDate: json['WORK_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['WORK_DATE'] as Map<String, dynamic>),
          processType: json['PROCESS_TYPE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['PROCESS_TYPE'] as Map<String, dynamic>),
          subjectYn: json['SUBJECT_YN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['SUBJECT_YN'] as Map<String, dynamic>),
          regUser: json['REG_USER'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REG_USER'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          completeDate: json['COMPLETE_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['COMPLETE_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$WORKREPORTDETAILTBLUncheckedUpdateInputToJson(
    WORKREPORTDETAILTBLUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', instance.reportId?.toJson());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('PROJECT_NM', instance.projectNm?.toJson());
  writeNotNull('PROJECT_SUB_NM', instance.projectSubNm?.toJson());
  writeNotNull('DETAIL_CONTENT', instance.detailContent?.toJson());
  writeNotNull('WORKER', instance.worker?.toJson());
  writeNotNull('GRADE', instance.grade?.toJson());
  writeNotNull('PROCESS_RATE', instance.processRate?.toJson());
  writeNotNull('WORK_DATE', instance.workDate?.toJson());
  writeNotNull('PROCESS_TYPE', instance.processType?.toJson());
  writeNotNull('SUBJECT_YN', instance.subjectYn?.toJson());
  writeNotNull('REG_USER', instance.regUser?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('COMPLETE_DATE', instance.completeDate?.toJson());
  return val;
}

WORKREPORTDETAILTBLCreateManyInput _$WORKREPORTDETAILTBLCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    WORKREPORTDETAILTBLCreateManyInput(
      reportId: json['REPORT_ID'] as String,
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      projectNm: json['PROJECT_NM'] as String,
      projectSubNm: json['PROJECT_SUB_NM'] as String,
      detailContent: json['DETAIL_CONTENT'] as String?,
      worker: json['WORKER'] as String?,
      grade: json['GRADE'] as String?,
      processRate: json['PROCESS_RATE'] as String?,
      workDate: json['WORK_DATE'] as String?,
      processType: json['PROCESS_TYPE'] as String?,
      subjectYn: json['SUBJECT_YN'] as String?,
      regUser: json['REG_USER'] as String,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      completeDate: json['COMPLETE_DATE'] as String?,
    );

Map<String, dynamic> _$WORKREPORTDETAILTBLCreateManyInputToJson(
    WORKREPORTDETAILTBLCreateManyInput instance) {
  final val = <String, dynamic>{
    'REPORT_ID': instance.reportId,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  val['PROJECT_NM'] = instance.projectNm;
  val['PROJECT_SUB_NM'] = instance.projectSubNm;
  writeNotNull('DETAIL_CONTENT', instance.detailContent);
  writeNotNull('WORKER', instance.worker);
  writeNotNull('GRADE', instance.grade);
  writeNotNull('PROCESS_RATE', instance.processRate);
  writeNotNull('WORK_DATE', instance.workDate);
  writeNotNull('PROCESS_TYPE', instance.processType);
  writeNotNull('SUBJECT_YN', instance.subjectYn);
  val['REG_USER'] = instance.regUser;
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull('COMPLETE_DATE', instance.completeDate);
  return val;
}

WORKREPORTDETAILTBLUpdateManyMutationInput
    _$WORKREPORTDETAILTBLUpdateManyMutationInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTDETAILTBLUpdateManyMutationInput(
          reportId: json['REPORT_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REPORT_ID'] as Map<String, dynamic>),
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          projectNm: json['PROJECT_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['PROJECT_NM'] as Map<String, dynamic>),
          projectSubNm: json['PROJECT_SUB_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['PROJECT_SUB_NM'] as Map<String, dynamic>),
          detailContent: json['DETAIL_CONTENT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DETAIL_CONTENT'] as Map<String, dynamic>),
          worker: json['WORKER'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['WORKER'] as Map<String, dynamic>),
          grade: json['GRADE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['GRADE'] as Map<String, dynamic>),
          processRate: json['PROCESS_RATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['PROCESS_RATE'] as Map<String, dynamic>),
          workDate: json['WORK_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['WORK_DATE'] as Map<String, dynamic>),
          processType: json['PROCESS_TYPE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['PROCESS_TYPE'] as Map<String, dynamic>),
          subjectYn: json['SUBJECT_YN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['SUBJECT_YN'] as Map<String, dynamic>),
          regUser: json['REG_USER'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REG_USER'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          completeDate: json['COMPLETE_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['COMPLETE_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$WORKREPORTDETAILTBLUpdateManyMutationInputToJson(
    WORKREPORTDETAILTBLUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', instance.reportId?.toJson());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('PROJECT_NM', instance.projectNm?.toJson());
  writeNotNull('PROJECT_SUB_NM', instance.projectSubNm?.toJson());
  writeNotNull('DETAIL_CONTENT', instance.detailContent?.toJson());
  writeNotNull('WORKER', instance.worker?.toJson());
  writeNotNull('GRADE', instance.grade?.toJson());
  writeNotNull('PROCESS_RATE', instance.processRate?.toJson());
  writeNotNull('WORK_DATE', instance.workDate?.toJson());
  writeNotNull('PROCESS_TYPE', instance.processType?.toJson());
  writeNotNull('SUBJECT_YN', instance.subjectYn?.toJson());
  writeNotNull('REG_USER', instance.regUser?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('COMPLETE_DATE', instance.completeDate?.toJson());
  return val;
}

WORKREPORTDETAILTBLUncheckedUpdateManyInput
    _$WORKREPORTDETAILTBLUncheckedUpdateManyInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTDETAILTBLUncheckedUpdateManyInput(
          reportId: json['REPORT_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REPORT_ID'] as Map<String, dynamic>),
          seq: json['SEQ'] == null
              ? null
              : BigIntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          projectNm: json['PROJECT_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['PROJECT_NM'] as Map<String, dynamic>),
          projectSubNm: json['PROJECT_SUB_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['PROJECT_SUB_NM'] as Map<String, dynamic>),
          detailContent: json['DETAIL_CONTENT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DETAIL_CONTENT'] as Map<String, dynamic>),
          worker: json['WORKER'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['WORKER'] as Map<String, dynamic>),
          grade: json['GRADE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['GRADE'] as Map<String, dynamic>),
          processRate: json['PROCESS_RATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['PROCESS_RATE'] as Map<String, dynamic>),
          workDate: json['WORK_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['WORK_DATE'] as Map<String, dynamic>),
          processType: json['PROCESS_TYPE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['PROCESS_TYPE'] as Map<String, dynamic>),
          subjectYn: json['SUBJECT_YN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['SUBJECT_YN'] as Map<String, dynamic>),
          regUser: json['REG_USER'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REG_USER'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          completeDate: json['COMPLETE_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['COMPLETE_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$WORKREPORTDETAILTBLUncheckedUpdateManyInputToJson(
    WORKREPORTDETAILTBLUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', instance.reportId?.toJson());
  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('PROJECT_NM', instance.projectNm?.toJson());
  writeNotNull('PROJECT_SUB_NM', instance.projectSubNm?.toJson());
  writeNotNull('DETAIL_CONTENT', instance.detailContent?.toJson());
  writeNotNull('WORKER', instance.worker?.toJson());
  writeNotNull('GRADE', instance.grade?.toJson());
  writeNotNull('PROCESS_RATE', instance.processRate?.toJson());
  writeNotNull('WORK_DATE', instance.workDate?.toJson());
  writeNotNull('PROCESS_TYPE', instance.processType?.toJson());
  writeNotNull('SUBJECT_YN', instance.subjectYn?.toJson());
  writeNotNull('REG_USER', instance.regUser?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('COMPLETE_DATE', instance.completeDate?.toJson());
  return val;
}

WORKREPORTHTMLTBLCreateInput _$WORKREPORTHTMLTBLCreateInputFromJson(
        Map<String, dynamic> json) =>
    WORKREPORTHTMLTBLCreateInput(
      reportId: json['REPORT_ID'] as String,
      userId: json['USER_ID'] as String,
      title: json['TITLE'] as String,
      htmlContent: json['HTML_CONTENT'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$WORKREPORTHTMLTBLCreateInputToJson(
    WORKREPORTHTMLTBLCreateInput instance) {
  final val = <String, dynamic>{
    'REPORT_ID': instance.reportId,
    'USER_ID': instance.userId,
    'TITLE': instance.title,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('HTML_CONTENT', instance.htmlContent);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

WORKREPORTHTMLTBLUncheckedCreateInput
    _$WORKREPORTHTMLTBLUncheckedCreateInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTHTMLTBLUncheckedCreateInput(
          reportId: json['REPORT_ID'] as String,
          userId: json['USER_ID'] as String,
          title: json['TITLE'] as String,
          htmlContent: json['HTML_CONTENT'] as String?,
          regDate: _$JsonConverterFromJson<String, DateTime>(
              json['REG_DATE'], const DateTimeJsonConverter().fromJson),
          delYn: json['DEL_YN'] as String?,
        );

Map<String, dynamic> _$WORKREPORTHTMLTBLUncheckedCreateInputToJson(
    WORKREPORTHTMLTBLUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'REPORT_ID': instance.reportId,
    'USER_ID': instance.userId,
    'TITLE': instance.title,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('HTML_CONTENT', instance.htmlContent);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

WORKREPORTHTMLTBLUpdateInput _$WORKREPORTHTMLTBLUpdateInputFromJson(
        Map<String, dynamic> json) =>
    WORKREPORTHTMLTBLUpdateInput(
      reportId: json['REPORT_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REPORT_ID'] as Map<String, dynamic>),
      userId: json['USER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_ID'] as Map<String, dynamic>),
      title: json['TITLE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['TITLE'] as Map<String, dynamic>),
      htmlContent: json['HTML_CONTENT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['HTML_CONTENT'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$WORKREPORTHTMLTBLUpdateInputToJson(
    WORKREPORTHTMLTBLUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', instance.reportId?.toJson());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('HTML_CONTENT', instance.htmlContent?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

WORKREPORTHTMLTBLUncheckedUpdateInput
    _$WORKREPORTHTMLTBLUncheckedUpdateInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTHTMLTBLUncheckedUpdateInput(
          reportId: json['REPORT_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REPORT_ID'] as Map<String, dynamic>),
          userId: json['USER_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['USER_ID'] as Map<String, dynamic>),
          title: json['TITLE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['TITLE'] as Map<String, dynamic>),
          htmlContent: json['HTML_CONTENT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['HTML_CONTENT'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$WORKREPORTHTMLTBLUncheckedUpdateInputToJson(
    WORKREPORTHTMLTBLUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', instance.reportId?.toJson());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('HTML_CONTENT', instance.htmlContent?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

WORKREPORTHTMLTBLCreateManyInput _$WORKREPORTHTMLTBLCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    WORKREPORTHTMLTBLCreateManyInput(
      reportId: json['REPORT_ID'] as String,
      userId: json['USER_ID'] as String,
      title: json['TITLE'] as String,
      htmlContent: json['HTML_CONTENT'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$WORKREPORTHTMLTBLCreateManyInputToJson(
    WORKREPORTHTMLTBLCreateManyInput instance) {
  final val = <String, dynamic>{
    'REPORT_ID': instance.reportId,
    'USER_ID': instance.userId,
    'TITLE': instance.title,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('HTML_CONTENT', instance.htmlContent);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

WORKREPORTHTMLTBLUpdateManyMutationInput
    _$WORKREPORTHTMLTBLUpdateManyMutationInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTHTMLTBLUpdateManyMutationInput(
          reportId: json['REPORT_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REPORT_ID'] as Map<String, dynamic>),
          userId: json['USER_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['USER_ID'] as Map<String, dynamic>),
          title: json['TITLE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['TITLE'] as Map<String, dynamic>),
          htmlContent: json['HTML_CONTENT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['HTML_CONTENT'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$WORKREPORTHTMLTBLUpdateManyMutationInputToJson(
    WORKREPORTHTMLTBLUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', instance.reportId?.toJson());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('HTML_CONTENT', instance.htmlContent?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

WORKREPORTHTMLTBLUncheckedUpdateManyInput
    _$WORKREPORTHTMLTBLUncheckedUpdateManyInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTHTMLTBLUncheckedUpdateManyInput(
          reportId: json['REPORT_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REPORT_ID'] as Map<String, dynamic>),
          userId: json['USER_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['USER_ID'] as Map<String, dynamic>),
          title: json['TITLE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['TITLE'] as Map<String, dynamic>),
          htmlContent: json['HTML_CONTENT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['HTML_CONTENT'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$WORKREPORTHTMLTBLUncheckedUpdateManyInputToJson(
    WORKREPORTHTMLTBLUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', instance.reportId?.toJson());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('HTML_CONTENT', instance.htmlContent?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

WORKREPORTHTMLTBLBACKCreateInput _$WORKREPORTHTMLTBLBACKCreateInputFromJson(
        Map<String, dynamic> json) =>
    WORKREPORTHTMLTBLBACKCreateInput(
      reportId: json['REPORT_ID'] as String,
      userId: json['USER_ID'] as String,
      title: json['TITLE'] as String,
      htmlContent: json['HTML_CONTENT'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$WORKREPORTHTMLTBLBACKCreateInputToJson(
    WORKREPORTHTMLTBLBACKCreateInput instance) {
  final val = <String, dynamic>{
    'REPORT_ID': instance.reportId,
    'USER_ID': instance.userId,
    'TITLE': instance.title,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('HTML_CONTENT', instance.htmlContent);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

WORKREPORTHTMLTBLBACKUncheckedCreateInput
    _$WORKREPORTHTMLTBLBACKUncheckedCreateInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTHTMLTBLBACKUncheckedCreateInput(
          reportId: json['REPORT_ID'] as String,
          userId: json['USER_ID'] as String,
          title: json['TITLE'] as String,
          htmlContent: json['HTML_CONTENT'] as String?,
          regDate: _$JsonConverterFromJson<String, DateTime>(
              json['REG_DATE'], const DateTimeJsonConverter().fromJson),
          delYn: json['DEL_YN'] as String?,
        );

Map<String, dynamic> _$WORKREPORTHTMLTBLBACKUncheckedCreateInputToJson(
    WORKREPORTHTMLTBLBACKUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'REPORT_ID': instance.reportId,
    'USER_ID': instance.userId,
    'TITLE': instance.title,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('HTML_CONTENT', instance.htmlContent);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

WORKREPORTHTMLTBLBACKUpdateInput _$WORKREPORTHTMLTBLBACKUpdateInputFromJson(
        Map<String, dynamic> json) =>
    WORKREPORTHTMLTBLBACKUpdateInput(
      reportId: json['REPORT_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REPORT_ID'] as Map<String, dynamic>),
      userId: json['USER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_ID'] as Map<String, dynamic>),
      title: json['TITLE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['TITLE'] as Map<String, dynamic>),
      htmlContent: json['HTML_CONTENT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['HTML_CONTENT'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$WORKREPORTHTMLTBLBACKUpdateInputToJson(
    WORKREPORTHTMLTBLBACKUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', instance.reportId?.toJson());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('HTML_CONTENT', instance.htmlContent?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

WORKREPORTHTMLTBLBACKUncheckedUpdateInput
    _$WORKREPORTHTMLTBLBACKUncheckedUpdateInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTHTMLTBLBACKUncheckedUpdateInput(
          reportId: json['REPORT_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REPORT_ID'] as Map<String, dynamic>),
          userId: json['USER_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['USER_ID'] as Map<String, dynamic>),
          title: json['TITLE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['TITLE'] as Map<String, dynamic>),
          htmlContent: json['HTML_CONTENT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['HTML_CONTENT'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$WORKREPORTHTMLTBLBACKUncheckedUpdateInputToJson(
    WORKREPORTHTMLTBLBACKUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', instance.reportId?.toJson());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('HTML_CONTENT', instance.htmlContent?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

WORKREPORTHTMLTBLBACKCreateManyInput
    _$WORKREPORTHTMLTBLBACKCreateManyInputFromJson(Map<String, dynamic> json) =>
        WORKREPORTHTMLTBLBACKCreateManyInput(
          reportId: json['REPORT_ID'] as String,
          userId: json['USER_ID'] as String,
          title: json['TITLE'] as String,
          htmlContent: json['HTML_CONTENT'] as String?,
          regDate: _$JsonConverterFromJson<String, DateTime>(
              json['REG_DATE'], const DateTimeJsonConverter().fromJson),
          delYn: json['DEL_YN'] as String?,
        );

Map<String, dynamic> _$WORKREPORTHTMLTBLBACKCreateManyInputToJson(
    WORKREPORTHTMLTBLBACKCreateManyInput instance) {
  final val = <String, dynamic>{
    'REPORT_ID': instance.reportId,
    'USER_ID': instance.userId,
    'TITLE': instance.title,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('HTML_CONTENT', instance.htmlContent);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

WORKREPORTHTMLTBLBACKUpdateManyMutationInput
    _$WORKREPORTHTMLTBLBACKUpdateManyMutationInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTHTMLTBLBACKUpdateManyMutationInput(
          reportId: json['REPORT_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REPORT_ID'] as Map<String, dynamic>),
          userId: json['USER_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['USER_ID'] as Map<String, dynamic>),
          title: json['TITLE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['TITLE'] as Map<String, dynamic>),
          htmlContent: json['HTML_CONTENT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['HTML_CONTENT'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$WORKREPORTHTMLTBLBACKUpdateManyMutationInputToJson(
    WORKREPORTHTMLTBLBACKUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', instance.reportId?.toJson());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('HTML_CONTENT', instance.htmlContent?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

WORKREPORTHTMLTBLBACKUncheckedUpdateManyInput
    _$WORKREPORTHTMLTBLBACKUncheckedUpdateManyInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTHTMLTBLBACKUncheckedUpdateManyInput(
          reportId: json['REPORT_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REPORT_ID'] as Map<String, dynamic>),
          userId: json['USER_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['USER_ID'] as Map<String, dynamic>),
          title: json['TITLE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['TITLE'] as Map<String, dynamic>),
          htmlContent: json['HTML_CONTENT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['HTML_CONTENT'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$WORKREPORTHTMLTBLBACKUncheckedUpdateManyInputToJson(
    WORKREPORTHTMLTBLBACKUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', instance.reportId?.toJson());
  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('HTML_CONTENT', instance.htmlContent?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

WORKREPORTMASTERTBLCreateInput _$WORKREPORTMASTERTBLCreateInputFromJson(
        Map<String, dynamic> json) =>
    WORKREPORTMASTERTBLCreateInput(
      reportId: json['REPORT_ID'] as String,
      title: json['TITLE'] as String,
      dept: json['DEPT'] as String,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$WORKREPORTMASTERTBLCreateInputToJson(
    WORKREPORTMASTERTBLCreateInput instance) {
  final val = <String, dynamic>{
    'REPORT_ID': instance.reportId,
    'TITLE': instance.title,
    'DEPT': instance.dept,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

WORKREPORTMASTERTBLUncheckedCreateInput
    _$WORKREPORTMASTERTBLUncheckedCreateInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTMASTERTBLUncheckedCreateInput(
          reportId: json['REPORT_ID'] as String,
          title: json['TITLE'] as String,
          dept: json['DEPT'] as String,
          regDate: _$JsonConverterFromJson<String, DateTime>(
              json['REG_DATE'], const DateTimeJsonConverter().fromJson),
          updDate: _$JsonConverterFromJson<String, DateTime>(
              json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
          delYn: json['DEL_YN'] as String?,
        );

Map<String, dynamic> _$WORKREPORTMASTERTBLUncheckedCreateInputToJson(
    WORKREPORTMASTERTBLUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'REPORT_ID': instance.reportId,
    'TITLE': instance.title,
    'DEPT': instance.dept,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

WORKREPORTMASTERTBLUpdateInput _$WORKREPORTMASTERTBLUpdateInputFromJson(
        Map<String, dynamic> json) =>
    WORKREPORTMASTERTBLUpdateInput(
      reportId: json['REPORT_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REPORT_ID'] as Map<String, dynamic>),
      title: json['TITLE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['TITLE'] as Map<String, dynamic>),
      dept: json['DEPT'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['DEPT'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : NullableDateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$WORKREPORTMASTERTBLUpdateInputToJson(
    WORKREPORTMASTERTBLUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', instance.reportId?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('DEPT', instance.dept?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

WORKREPORTMASTERTBLUncheckedUpdateInput
    _$WORKREPORTMASTERTBLUncheckedUpdateInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTMASTERTBLUncheckedUpdateInput(
          reportId: json['REPORT_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REPORT_ID'] as Map<String, dynamic>),
          title: json['TITLE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['TITLE'] as Map<String, dynamic>),
          dept: json['DEPT'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['DEPT'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : NullableDateTimeFieldUpdateOperationsInput.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$WORKREPORTMASTERTBLUncheckedUpdateInputToJson(
    WORKREPORTMASTERTBLUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', instance.reportId?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('DEPT', instance.dept?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

WORKREPORTMASTERTBLCreateManyInput _$WORKREPORTMASTERTBLCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    WORKREPORTMASTERTBLCreateManyInput(
      reportId: json['REPORT_ID'] as String,
      title: json['TITLE'] as String,
      dept: json['DEPT'] as String,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$WORKREPORTMASTERTBLCreateManyInputToJson(
    WORKREPORTMASTERTBLCreateManyInput instance) {
  final val = <String, dynamic>{
    'REPORT_ID': instance.reportId,
    'TITLE': instance.title,
    'DEPT': instance.dept,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

WORKREPORTMASTERTBLUpdateManyMutationInput
    _$WORKREPORTMASTERTBLUpdateManyMutationInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTMASTERTBLUpdateManyMutationInput(
          reportId: json['REPORT_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REPORT_ID'] as Map<String, dynamic>),
          title: json['TITLE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['TITLE'] as Map<String, dynamic>),
          dept: json['DEPT'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['DEPT'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : NullableDateTimeFieldUpdateOperationsInput.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$WORKREPORTMASTERTBLUpdateManyMutationInputToJson(
    WORKREPORTMASTERTBLUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', instance.reportId?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('DEPT', instance.dept?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

WORKREPORTMASTERTBLUncheckedUpdateManyInput
    _$WORKREPORTMASTERTBLUncheckedUpdateManyInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTMASTERTBLUncheckedUpdateManyInput(
          reportId: json['REPORT_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REPORT_ID'] as Map<String, dynamic>),
          title: json['TITLE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['TITLE'] as Map<String, dynamic>),
          dept: json['DEPT'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['DEPT'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : NullableDateTimeFieldUpdateOperationsInput.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$WORKREPORTMASTERTBLUncheckedUpdateManyInputToJson(
    WORKREPORTMASTERTBLUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', instance.reportId?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('DEPT', instance.dept?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  return val;
}

WORKREQUESTMSTCreateInput _$WORKREQUESTMSTCreateInputFromJson(
        Map<String, dynamic> json) =>
    WORKREQUESTMSTCreateInput(
      seq: json['SEQ'] as int,
      rqstrDpnm: json['RQSTR_DPNM'] as String,
      rqstrNm: json['RQSTR_NM'] as String,
      rqstrId: json['RQSTR_ID'] as String,
      rqstrDate: json['RQSTR_DATE'] as String,
      hopeDate: json['HOPE_DATE'] as String,
      chrDprNm: json['CHR_DPR_NM'] as String,
      chrNm: json['CHR_NM'] as String,
      chrId: json['CHR_ID'] as String,
      chrChk: json['CHR_CHK'] as String?,
      title: json['TITLE'] as String,
      cn: json['CN'] as String,
      etc: json['ETC'] as String?,
      doc: json['DOC'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$WORKREQUESTMSTCreateInputToJson(
    WORKREQUESTMSTCreateInput instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'RQSTR_DPNM': instance.rqstrDpnm,
    'RQSTR_NM': instance.rqstrNm,
    'RQSTR_ID': instance.rqstrId,
    'RQSTR_DATE': instance.rqstrDate,
    'HOPE_DATE': instance.hopeDate,
    'CHR_DPR_NM': instance.chrDprNm,
    'CHR_NM': instance.chrNm,
    'CHR_ID': instance.chrId,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CHR_CHK', instance.chrChk);
  val['TITLE'] = instance.title;
  val['CN'] = instance.cn;
  writeNotNull('ETC', instance.etc);
  writeNotNull('DOC', instance.doc);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

WORKREQUESTMSTUncheckedCreateInput _$WORKREQUESTMSTUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    WORKREQUESTMSTUncheckedCreateInput(
      seq: json['SEQ'] as int,
      rqstrDpnm: json['RQSTR_DPNM'] as String,
      rqstrNm: json['RQSTR_NM'] as String,
      rqstrId: json['RQSTR_ID'] as String,
      rqstrDate: json['RQSTR_DATE'] as String,
      hopeDate: json['HOPE_DATE'] as String,
      chrDprNm: json['CHR_DPR_NM'] as String,
      chrNm: json['CHR_NM'] as String,
      chrId: json['CHR_ID'] as String,
      chrChk: json['CHR_CHK'] as String?,
      title: json['TITLE'] as String,
      cn: json['CN'] as String,
      etc: json['ETC'] as String?,
      doc: json['DOC'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$WORKREQUESTMSTUncheckedCreateInputToJson(
    WORKREQUESTMSTUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'RQSTR_DPNM': instance.rqstrDpnm,
    'RQSTR_NM': instance.rqstrNm,
    'RQSTR_ID': instance.rqstrId,
    'RQSTR_DATE': instance.rqstrDate,
    'HOPE_DATE': instance.hopeDate,
    'CHR_DPR_NM': instance.chrDprNm,
    'CHR_NM': instance.chrNm,
    'CHR_ID': instance.chrId,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CHR_CHK', instance.chrChk);
  val['TITLE'] = instance.title;
  val['CN'] = instance.cn;
  writeNotNull('ETC', instance.etc);
  writeNotNull('DOC', instance.doc);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

WORKREQUESTMSTUpdateInput _$WORKREQUESTMSTUpdateInputFromJson(
        Map<String, dynamic> json) =>
    WORKREQUESTMSTUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      rqstrDpnm: json['RQSTR_DPNM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['RQSTR_DPNM'] as Map<String, dynamic>),
      rqstrNm: json['RQSTR_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['RQSTR_NM'] as Map<String, dynamic>),
      rqstrId: json['RQSTR_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['RQSTR_ID'] as Map<String, dynamic>),
      rqstrDate: json['RQSTR_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['RQSTR_DATE'] as Map<String, dynamic>),
      hopeDate: json['HOPE_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['HOPE_DATE'] as Map<String, dynamic>),
      chrDprNm: json['CHR_DPR_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CHR_DPR_NM'] as Map<String, dynamic>),
      chrNm: json['CHR_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CHR_NM'] as Map<String, dynamic>),
      chrId: json['CHR_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CHR_ID'] as Map<String, dynamic>),
      chrChk: json['CHR_CHK'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CHR_CHK'] as Map<String, dynamic>),
      title: json['TITLE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['TITLE'] as Map<String, dynamic>),
      cn: json['CN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CN'] as Map<String, dynamic>),
      etc: json['ETC'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ETC'] as Map<String, dynamic>),
      doc: json['DOC'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DOC'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$WORKREQUESTMSTUpdateInputToJson(
    WORKREQUESTMSTUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('RQSTR_DPNM', instance.rqstrDpnm?.toJson());
  writeNotNull('RQSTR_NM', instance.rqstrNm?.toJson());
  writeNotNull('RQSTR_ID', instance.rqstrId?.toJson());
  writeNotNull('RQSTR_DATE', instance.rqstrDate?.toJson());
  writeNotNull('HOPE_DATE', instance.hopeDate?.toJson());
  writeNotNull('CHR_DPR_NM', instance.chrDprNm?.toJson());
  writeNotNull('CHR_NM', instance.chrNm?.toJson());
  writeNotNull('CHR_ID', instance.chrId?.toJson());
  writeNotNull('CHR_CHK', instance.chrChk?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('CN', instance.cn?.toJson());
  writeNotNull('ETC', instance.etc?.toJson());
  writeNotNull('DOC', instance.doc?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

WORKREQUESTMSTUncheckedUpdateInput _$WORKREQUESTMSTUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    WORKREQUESTMSTUncheckedUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      rqstrDpnm: json['RQSTR_DPNM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['RQSTR_DPNM'] as Map<String, dynamic>),
      rqstrNm: json['RQSTR_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['RQSTR_NM'] as Map<String, dynamic>),
      rqstrId: json['RQSTR_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['RQSTR_ID'] as Map<String, dynamic>),
      rqstrDate: json['RQSTR_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['RQSTR_DATE'] as Map<String, dynamic>),
      hopeDate: json['HOPE_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['HOPE_DATE'] as Map<String, dynamic>),
      chrDprNm: json['CHR_DPR_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CHR_DPR_NM'] as Map<String, dynamic>),
      chrNm: json['CHR_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CHR_NM'] as Map<String, dynamic>),
      chrId: json['CHR_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CHR_ID'] as Map<String, dynamic>),
      chrChk: json['CHR_CHK'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['CHR_CHK'] as Map<String, dynamic>),
      title: json['TITLE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['TITLE'] as Map<String, dynamic>),
      cn: json['CN'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['CN'] as Map<String, dynamic>),
      etc: json['ETC'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['ETC'] as Map<String, dynamic>),
      doc: json['DOC'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DOC'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$WORKREQUESTMSTUncheckedUpdateInputToJson(
    WORKREQUESTMSTUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('RQSTR_DPNM', instance.rqstrDpnm?.toJson());
  writeNotNull('RQSTR_NM', instance.rqstrNm?.toJson());
  writeNotNull('RQSTR_ID', instance.rqstrId?.toJson());
  writeNotNull('RQSTR_DATE', instance.rqstrDate?.toJson());
  writeNotNull('HOPE_DATE', instance.hopeDate?.toJson());
  writeNotNull('CHR_DPR_NM', instance.chrDprNm?.toJson());
  writeNotNull('CHR_NM', instance.chrNm?.toJson());
  writeNotNull('CHR_ID', instance.chrId?.toJson());
  writeNotNull('CHR_CHK', instance.chrChk?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('CN', instance.cn?.toJson());
  writeNotNull('ETC', instance.etc?.toJson());
  writeNotNull('DOC', instance.doc?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

WORKREQUESTMSTCreateManyInput _$WORKREQUESTMSTCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    WORKREQUESTMSTCreateManyInput(
      seq: json['SEQ'] as int,
      rqstrDpnm: json['RQSTR_DPNM'] as String,
      rqstrNm: json['RQSTR_NM'] as String,
      rqstrId: json['RQSTR_ID'] as String,
      rqstrDate: json['RQSTR_DATE'] as String,
      hopeDate: json['HOPE_DATE'] as String,
      chrDprNm: json['CHR_DPR_NM'] as String,
      chrNm: json['CHR_NM'] as String,
      chrId: json['CHR_ID'] as String,
      chrChk: json['CHR_CHK'] as String?,
      title: json['TITLE'] as String,
      cn: json['CN'] as String,
      etc: json['ETC'] as String?,
      doc: json['DOC'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$WORKREQUESTMSTCreateManyInputToJson(
    WORKREQUESTMSTCreateManyInput instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'RQSTR_DPNM': instance.rqstrDpnm,
    'RQSTR_NM': instance.rqstrNm,
    'RQSTR_ID': instance.rqstrId,
    'RQSTR_DATE': instance.rqstrDate,
    'HOPE_DATE': instance.hopeDate,
    'CHR_DPR_NM': instance.chrDprNm,
    'CHR_NM': instance.chrNm,
    'CHR_ID': instance.chrId,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CHR_CHK', instance.chrChk);
  val['TITLE'] = instance.title;
  val['CN'] = instance.cn;
  writeNotNull('ETC', instance.etc);
  writeNotNull('DOC', instance.doc);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

WORKREQUESTMSTUpdateManyMutationInput
    _$WORKREQUESTMSTUpdateManyMutationInputFromJson(
            Map<String, dynamic> json) =>
        WORKREQUESTMSTUpdateManyMutationInput(
          seq: json['SEQ'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          rqstrDpnm: json['RQSTR_DPNM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['RQSTR_DPNM'] as Map<String, dynamic>),
          rqstrNm: json['RQSTR_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['RQSTR_NM'] as Map<String, dynamic>),
          rqstrId: json['RQSTR_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['RQSTR_ID'] as Map<String, dynamic>),
          rqstrDate: json['RQSTR_DATE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['RQSTR_DATE'] as Map<String, dynamic>),
          hopeDate: json['HOPE_DATE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['HOPE_DATE'] as Map<String, dynamic>),
          chrDprNm: json['CHR_DPR_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['CHR_DPR_NM'] as Map<String, dynamic>),
          chrNm: json['CHR_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['CHR_NM'] as Map<String, dynamic>),
          chrId: json['CHR_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['CHR_ID'] as Map<String, dynamic>),
          chrChk: json['CHR_CHK'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CHR_CHK'] as Map<String, dynamic>),
          title: json['TITLE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['TITLE'] as Map<String, dynamic>),
          cn: json['CN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['CN'] as Map<String, dynamic>),
          etc: json['ETC'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['ETC'] as Map<String, dynamic>),
          doc: json['DOC'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DOC'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delId: json['DEL_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_ID'] as Map<String, dynamic>),
          delDate: json['DEL_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$WORKREQUESTMSTUpdateManyMutationInputToJson(
    WORKREQUESTMSTUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('RQSTR_DPNM', instance.rqstrDpnm?.toJson());
  writeNotNull('RQSTR_NM', instance.rqstrNm?.toJson());
  writeNotNull('RQSTR_ID', instance.rqstrId?.toJson());
  writeNotNull('RQSTR_DATE', instance.rqstrDate?.toJson());
  writeNotNull('HOPE_DATE', instance.hopeDate?.toJson());
  writeNotNull('CHR_DPR_NM', instance.chrDprNm?.toJson());
  writeNotNull('CHR_NM', instance.chrNm?.toJson());
  writeNotNull('CHR_ID', instance.chrId?.toJson());
  writeNotNull('CHR_CHK', instance.chrChk?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('CN', instance.cn?.toJson());
  writeNotNull('ETC', instance.etc?.toJson());
  writeNotNull('DOC', instance.doc?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

WORKREQUESTMSTUncheckedUpdateManyInput
    _$WORKREQUESTMSTUncheckedUpdateManyInputFromJson(
            Map<String, dynamic> json) =>
        WORKREQUESTMSTUncheckedUpdateManyInput(
          seq: json['SEQ'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          rqstrDpnm: json['RQSTR_DPNM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['RQSTR_DPNM'] as Map<String, dynamic>),
          rqstrNm: json['RQSTR_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['RQSTR_NM'] as Map<String, dynamic>),
          rqstrId: json['RQSTR_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['RQSTR_ID'] as Map<String, dynamic>),
          rqstrDate: json['RQSTR_DATE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['RQSTR_DATE'] as Map<String, dynamic>),
          hopeDate: json['HOPE_DATE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['HOPE_DATE'] as Map<String, dynamic>),
          chrDprNm: json['CHR_DPR_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['CHR_DPR_NM'] as Map<String, dynamic>),
          chrNm: json['CHR_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['CHR_NM'] as Map<String, dynamic>),
          chrId: json['CHR_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['CHR_ID'] as Map<String, dynamic>),
          chrChk: json['CHR_CHK'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['CHR_CHK'] as Map<String, dynamic>),
          title: json['TITLE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['TITLE'] as Map<String, dynamic>),
          cn: json['CN'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['CN'] as Map<String, dynamic>),
          etc: json['ETC'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['ETC'] as Map<String, dynamic>),
          doc: json['DOC'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DOC'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delId: json['DEL_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_ID'] as Map<String, dynamic>),
          delDate: json['DEL_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$WORKREQUESTMSTUncheckedUpdateManyInputToJson(
    WORKREQUESTMSTUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('RQSTR_DPNM', instance.rqstrDpnm?.toJson());
  writeNotNull('RQSTR_NM', instance.rqstrNm?.toJson());
  writeNotNull('RQSTR_ID', instance.rqstrId?.toJson());
  writeNotNull('RQSTR_DATE', instance.rqstrDate?.toJson());
  writeNotNull('HOPE_DATE', instance.hopeDate?.toJson());
  writeNotNull('CHR_DPR_NM', instance.chrDprNm?.toJson());
  writeNotNull('CHR_NM', instance.chrNm?.toJson());
  writeNotNull('CHR_ID', instance.chrId?.toJson());
  writeNotNull('CHR_CHK', instance.chrChk?.toJson());
  writeNotNull('TITLE', instance.title?.toJson());
  writeNotNull('CN', instance.cn?.toJson());
  writeNotNull('ETC', instance.etc?.toJson());
  writeNotNull('DOC', instance.doc?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

WORKREQUESTREFCreateInput _$WORKREQUESTREFCreateInputFromJson(
        Map<String, dynamic> json) =>
    WORKREQUESTREFCreateInput(
      seq: json['SEQ'] as int,
      mseq: json['MSEQ'] as int,
      refId: json['REF_ID'] as String,
      refNm: json['REF_NM'] as String?,
      refDep: json['REF_DEP'] as String?,
      refGrade: json['REF_GRADE'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$WORKREQUESTREFCreateInputToJson(
    WORKREQUESTREFCreateInput instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'MSEQ': instance.mseq,
    'REF_ID': instance.refId,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REF_NM', instance.refNm);
  writeNotNull('REF_DEP', instance.refDep);
  writeNotNull('REF_GRADE', instance.refGrade);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

WORKREQUESTREFUncheckedCreateInput _$WORKREQUESTREFUncheckedCreateInputFromJson(
        Map<String, dynamic> json) =>
    WORKREQUESTREFUncheckedCreateInput(
      seq: json['SEQ'] as int,
      mseq: json['MSEQ'] as int,
      refId: json['REF_ID'] as String,
      refNm: json['REF_NM'] as String?,
      refDep: json['REF_DEP'] as String?,
      refGrade: json['REF_GRADE'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$WORKREQUESTREFUncheckedCreateInputToJson(
    WORKREQUESTREFUncheckedCreateInput instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'MSEQ': instance.mseq,
    'REF_ID': instance.refId,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REF_NM', instance.refNm);
  writeNotNull('REF_DEP', instance.refDep);
  writeNotNull('REF_GRADE', instance.refGrade);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

WORKREQUESTREFUpdateInput _$WORKREQUESTREFUpdateInputFromJson(
        Map<String, dynamic> json) =>
    WORKREQUESTREFUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      mseq: json['MSEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['MSEQ'] as Map<String, dynamic>),
      refId: json['REF_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REF_ID'] as Map<String, dynamic>),
      refNm: json['REF_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REF_NM'] as Map<String, dynamic>),
      refDep: json['REF_DEP'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REF_DEP'] as Map<String, dynamic>),
      refGrade: json['REF_GRADE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REF_GRADE'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$WORKREQUESTREFUpdateInputToJson(
    WORKREQUESTREFUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('REF_ID', instance.refId?.toJson());
  writeNotNull('REF_NM', instance.refNm?.toJson());
  writeNotNull('REF_DEP', instance.refDep?.toJson());
  writeNotNull('REF_GRADE', instance.refGrade?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

WORKREQUESTREFUncheckedUpdateInput _$WORKREQUESTREFUncheckedUpdateInputFromJson(
        Map<String, dynamic> json) =>
    WORKREQUESTREFUncheckedUpdateInput(
      seq: json['SEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SEQ'] as Map<String, dynamic>),
      mseq: json['MSEQ'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['MSEQ'] as Map<String, dynamic>),
      refId: json['REF_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REF_ID'] as Map<String, dynamic>),
      refNm: json['REF_NM'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REF_NM'] as Map<String, dynamic>),
      refDep: json['REF_DEP'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REF_DEP'] as Map<String, dynamic>),
      refGrade: json['REF_GRADE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['REF_GRADE'] as Map<String, dynamic>),
      regId: json['REG_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      editId: json['EDIT_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_ID'] as Map<String, dynamic>),
      editDate: json['EDIT_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['EDIT_DATE'] as Map<String, dynamic>),
      delId: json['DEL_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_ID'] as Map<String, dynamic>),
      delDate: json['DEL_DATE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_DATE'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$WORKREQUESTREFUncheckedUpdateInputToJson(
    WORKREQUESTREFUncheckedUpdateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('REF_ID', instance.refId?.toJson());
  writeNotNull('REF_NM', instance.refNm?.toJson());
  writeNotNull('REF_DEP', instance.refDep?.toJson());
  writeNotNull('REF_GRADE', instance.refGrade?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

WORKREQUESTREFCreateManyInput _$WORKREQUESTREFCreateManyInputFromJson(
        Map<String, dynamic> json) =>
    WORKREQUESTREFCreateManyInput(
      seq: json['SEQ'] as int,
      mseq: json['MSEQ'] as int,
      refId: json['REF_ID'] as String,
      refNm: json['REF_NM'] as String?,
      refDep: json['REF_DEP'] as String?,
      refGrade: json['REF_GRADE'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$WORKREQUESTREFCreateManyInputToJson(
    WORKREQUESTREFCreateManyInput instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'MSEQ': instance.mseq,
    'REF_ID': instance.refId,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REF_NM', instance.refNm);
  writeNotNull('REF_DEP', instance.refDep);
  writeNotNull('REF_GRADE', instance.refGrade);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

WORKREQUESTREFUpdateManyMutationInput
    _$WORKREQUESTREFUpdateManyMutationInputFromJson(
            Map<String, dynamic> json) =>
        WORKREQUESTREFUpdateManyMutationInput(
          seq: json['SEQ'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          mseq: json['MSEQ'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['MSEQ'] as Map<String, dynamic>),
          refId: json['REF_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REF_ID'] as Map<String, dynamic>),
          refNm: json['REF_NM'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REF_NM'] as Map<String, dynamic>),
          refDep: json['REF_DEP'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REF_DEP'] as Map<String, dynamic>),
          refGrade: json['REF_GRADE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REF_GRADE'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delId: json['DEL_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_ID'] as Map<String, dynamic>),
          delDate: json['DEL_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$WORKREQUESTREFUpdateManyMutationInputToJson(
    WORKREQUESTREFUpdateManyMutationInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('REF_ID', instance.refId?.toJson());
  writeNotNull('REF_NM', instance.refNm?.toJson());
  writeNotNull('REF_DEP', instance.refDep?.toJson());
  writeNotNull('REF_GRADE', instance.refGrade?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

WORKREQUESTREFUncheckedUpdateManyInput
    _$WORKREQUESTREFUncheckedUpdateManyInputFromJson(
            Map<String, dynamic> json) =>
        WORKREQUESTREFUncheckedUpdateManyInput(
          seq: json['SEQ'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['SEQ'] as Map<String, dynamic>),
          mseq: json['MSEQ'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['MSEQ'] as Map<String, dynamic>),
          refId: json['REF_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REF_ID'] as Map<String, dynamic>),
          refNm: json['REF_NM'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REF_NM'] as Map<String, dynamic>),
          refDep: json['REF_DEP'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REF_DEP'] as Map<String, dynamic>),
          refGrade: json['REF_GRADE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['REF_GRADE'] as Map<String, dynamic>),
          regId: json['REG_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REG_ID'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          editId: json['EDIT_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_ID'] as Map<String, dynamic>),
          editDate: json['EDIT_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['EDIT_DATE'] as Map<String, dynamic>),
          delId: json['DEL_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_ID'] as Map<String, dynamic>),
          delDate: json['DEL_DATE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_DATE'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$WORKREQUESTREFUncheckedUpdateManyInputToJson(
    WORKREQUESTREFUncheckedUpdateManyInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toJson());
  writeNotNull('MSEQ', instance.mseq?.toJson());
  writeNotNull('REF_ID', instance.refId?.toJson());
  writeNotNull('REF_NM', instance.refNm?.toJson());
  writeNotNull('REF_DEP', instance.refDep?.toJson());
  writeNotNull('REF_GRADE', instance.refGrade?.toJson());
  writeNotNull('REG_ID', instance.regId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('EDIT_ID', instance.editId?.toJson());
  writeNotNull('EDIT_DATE', instance.editDate?.toJson());
  writeNotNull('DEL_ID', instance.delId?.toJson());
  writeNotNull('DEL_DATE', instance.delDate?.toJson());
  return val;
}

StringFilter _$StringFilterFromJson(Map<String, dynamic> json) => StringFilter(
      equals: json['equals'] as String?,
      $in: (json['in'] as List<dynamic>?)?.map((e) => e as String),
      notIn: (json['notIn'] as List<dynamic>?)?.map((e) => e as String),
      lt: json['lt'] as String?,
      lte: json['lte'] as String?,
      gt: json['gt'] as String?,
      gte: json['gte'] as String?,
      contains: json['contains'] as String?,
      startsWith: json['startsWith'] as String?,
      endsWith: json['endsWith'] as String?,
      not: json['not'] == null
          ? null
          : NestedStringFilter.fromJson(json['not'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$StringFilterToJson(StringFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals);
  writeNotNull('in', instance.$in?.toList());
  writeNotNull('notIn', instance.notIn?.toList());
  writeNotNull('lt', instance.lt);
  writeNotNull('lte', instance.lte);
  writeNotNull('gt', instance.gt);
  writeNotNull('gte', instance.gte);
  writeNotNull('contains', instance.contains);
  writeNotNull('startsWith', instance.startsWith);
  writeNotNull('endsWith', instance.endsWith);
  writeNotNull('not', instance.not?.toJson());
  return val;
}

StringNullableFilter _$StringNullableFilterFromJson(
        Map<String, dynamic> json) =>
    StringNullableFilter(
      equals: json['equals'] as String?,
      $in: (json['in'] as List<dynamic>?)?.map((e) => e as String),
      notIn: (json['notIn'] as List<dynamic>?)?.map((e) => e as String),
      lt: json['lt'] as String?,
      lte: json['lte'] as String?,
      gt: json['gt'] as String?,
      gte: json['gte'] as String?,
      contains: json['contains'] as String?,
      startsWith: json['startsWith'] as String?,
      endsWith: json['endsWith'] as String?,
      not: json['not'] == null
          ? null
          : NestedStringNullableFilter.fromJson(
              json['not'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$StringNullableFilterToJson(
    StringNullableFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals);
  writeNotNull('in', instance.$in?.toList());
  writeNotNull('notIn', instance.notIn?.toList());
  writeNotNull('lt', instance.lt);
  writeNotNull('lte', instance.lte);
  writeNotNull('gt', instance.gt);
  writeNotNull('gte', instance.gte);
  writeNotNull('contains', instance.contains);
  writeNotNull('startsWith', instance.startsWith);
  writeNotNull('endsWith', instance.endsWith);
  writeNotNull('not', instance.not?.toJson());
  return val;
}

IntNullableFilter _$IntNullableFilterFromJson(Map<String, dynamic> json) =>
    IntNullableFilter(
      equals: json['equals'] as int?,
      $in: (json['in'] as List<dynamic>?)?.map((e) => e as int),
      notIn: (json['notIn'] as List<dynamic>?)?.map((e) => e as int),
      lt: json['lt'] as int?,
      lte: json['lte'] as int?,
      gt: json['gt'] as int?,
      gte: json['gte'] as int?,
      not: json['not'] == null
          ? null
          : NestedIntNullableFilter.fromJson(
              json['not'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$IntNullableFilterToJson(IntNullableFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals);
  writeNotNull('in', instance.$in?.toList());
  writeNotNull('notIn', instance.notIn?.toList());
  writeNotNull('lt', instance.lt);
  writeNotNull('lte', instance.lte);
  writeNotNull('gt', instance.gt);
  writeNotNull('gte', instance.gte);
  writeNotNull('not', instance.not?.toJson());
  return val;
}

DateTimeFilter _$DateTimeFilterFromJson(Map<String, dynamic> json) =>
    DateTimeFilter(
      equals: _$JsonConverterFromJson<String, DateTime>(
          json['equals'], const DateTimeJsonConverter().fromJson),
      $in: (json['in'] as List<dynamic>?)
          ?.map((e) => const DateTimeJsonConverter().fromJson(e as String)),
      notIn: (json['notIn'] as List<dynamic>?)
          ?.map((e) => const DateTimeJsonConverter().fromJson(e as String)),
      lt: _$JsonConverterFromJson<String, DateTime>(
          json['lt'], const DateTimeJsonConverter().fromJson),
      lte: _$JsonConverterFromJson<String, DateTime>(
          json['lte'], const DateTimeJsonConverter().fromJson),
      gt: _$JsonConverterFromJson<String, DateTime>(
          json['gt'], const DateTimeJsonConverter().fromJson),
      gte: _$JsonConverterFromJson<String, DateTime>(
          json['gte'], const DateTimeJsonConverter().fromJson),
      not: json['not'] == null
          ? null
          : NestedDateTimeFilter.fromJson(json['not'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$DateTimeFilterToJson(DateTimeFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull(
      'equals',
      _$JsonConverterToJson<String, DateTime>(
          instance.equals, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'in', instance.$in?.map(const DateTimeJsonConverter().toJson).toList());
  writeNotNull('notIn',
      instance.notIn?.map(const DateTimeJsonConverter().toJson).toList());
  writeNotNull(
      'lt',
      _$JsonConverterToJson<String, DateTime>(
          instance.lt, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'lte',
      _$JsonConverterToJson<String, DateTime>(
          instance.lte, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'gt',
      _$JsonConverterToJson<String, DateTime>(
          instance.gt, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'gte',
      _$JsonConverterToJson<String, DateTime>(
          instance.gte, const DateTimeJsonConverter().toJson));
  writeNotNull('not', instance.not?.toJson());
  return val;
}

SortOrderInput _$SortOrderInputFromJson(Map<String, dynamic> json) =>
    SortOrderInput(
      sort: $enumDecode(_$SortOrderEnumMap, json['sort']),
      nulls: $enumDecodeNullable(_$NullsOrderEnumMap, json['nulls']),
    );

Map<String, dynamic> _$SortOrderInputToJson(SortOrderInput instance) {
  final val = <String, dynamic>{
    'sort': _$SortOrderEnumMap[instance.sort]!,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('nulls', _$NullsOrderEnumMap[instance.nulls]);
  return val;
}

const _$NullsOrderEnumMap = {
  NullsOrder.first: 'first',
  NullsOrder.last: 'last',
};

ALLCODETBLCODETYPEUNITTYPECompoundUniqueInput
    _$ALLCODETBLCODETYPEUNITTYPECompoundUniqueInputFromJson(
            Map<String, dynamic> json) =>
        ALLCODETBLCODETYPEUNITTYPECompoundUniqueInput(
          codeType: json['CODE_TYPE'] as String,
          unitType: json['UNIT_TYPE'] as String,
        );

Map<String, dynamic> _$ALLCODETBLCODETYPEUNITTYPECompoundUniqueInputToJson(
        ALLCODETBLCODETYPEUNITTYPECompoundUniqueInput instance) =>
    <String, dynamic>{
      'CODE_TYPE': instance.codeType,
      'UNIT_TYPE': instance.unitType,
    };

ALLCODETBLCountOrderByAggregateInput
    _$ALLCODETBLCountOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        ALLCODETBLCountOrderByAggregateInput(
          codeType: $enumDecodeNullable(_$SortOrderEnumMap, json['CODE_TYPE']),
          codeName: $enumDecodeNullable(_$SortOrderEnumMap, json['CODE_NAME']),
          unitType: $enumDecodeNullable(_$SortOrderEnumMap, json['UNIT_TYPE']),
          unitName: $enumDecodeNullable(_$SortOrderEnumMap, json['UNIT_NAME']),
          sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
        );

Map<String, dynamic> _$ALLCODETBLCountOrderByAggregateInputToJson(
    ALLCODETBLCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CODE_TYPE', _$SortOrderEnumMap[instance.codeType]);
  writeNotNull('CODE_NAME', _$SortOrderEnumMap[instance.codeName]);
  writeNotNull('UNIT_TYPE', _$SortOrderEnumMap[instance.unitType]);
  writeNotNull('UNIT_NAME', _$SortOrderEnumMap[instance.unitName]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  return val;
}

ALLCODETBLAvgOrderByAggregateInput _$ALLCODETBLAvgOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    ALLCODETBLAvgOrderByAggregateInput(
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
    );

Map<String, dynamic> _$ALLCODETBLAvgOrderByAggregateInputToJson(
    ALLCODETBLAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  return val;
}

ALLCODETBLMaxOrderByAggregateInput _$ALLCODETBLMaxOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    ALLCODETBLMaxOrderByAggregateInput(
      codeType: $enumDecodeNullable(_$SortOrderEnumMap, json['CODE_TYPE']),
      codeName: $enumDecodeNullable(_$SortOrderEnumMap, json['CODE_NAME']),
      unitType: $enumDecodeNullable(_$SortOrderEnumMap, json['UNIT_TYPE']),
      unitName: $enumDecodeNullable(_$SortOrderEnumMap, json['UNIT_NAME']),
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
      useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
      delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
    );

Map<String, dynamic> _$ALLCODETBLMaxOrderByAggregateInputToJson(
    ALLCODETBLMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CODE_TYPE', _$SortOrderEnumMap[instance.codeType]);
  writeNotNull('CODE_NAME', _$SortOrderEnumMap[instance.codeName]);
  writeNotNull('UNIT_TYPE', _$SortOrderEnumMap[instance.unitType]);
  writeNotNull('UNIT_NAME', _$SortOrderEnumMap[instance.unitName]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  return val;
}

ALLCODETBLMinOrderByAggregateInput _$ALLCODETBLMinOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    ALLCODETBLMinOrderByAggregateInput(
      codeType: $enumDecodeNullable(_$SortOrderEnumMap, json['CODE_TYPE']),
      codeName: $enumDecodeNullable(_$SortOrderEnumMap, json['CODE_NAME']),
      unitType: $enumDecodeNullable(_$SortOrderEnumMap, json['UNIT_TYPE']),
      unitName: $enumDecodeNullable(_$SortOrderEnumMap, json['UNIT_NAME']),
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
      useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
      delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
    );

Map<String, dynamic> _$ALLCODETBLMinOrderByAggregateInputToJson(
    ALLCODETBLMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CODE_TYPE', _$SortOrderEnumMap[instance.codeType]);
  writeNotNull('CODE_NAME', _$SortOrderEnumMap[instance.codeName]);
  writeNotNull('UNIT_TYPE', _$SortOrderEnumMap[instance.unitType]);
  writeNotNull('UNIT_NAME', _$SortOrderEnumMap[instance.unitName]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  return val;
}

ALLCODETBLSumOrderByAggregateInput _$ALLCODETBLSumOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    ALLCODETBLSumOrderByAggregateInput(
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
    );

Map<String, dynamic> _$ALLCODETBLSumOrderByAggregateInputToJson(
    ALLCODETBLSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  return val;
}

StringWithAggregatesFilter _$StringWithAggregatesFilterFromJson(
        Map<String, dynamic> json) =>
    StringWithAggregatesFilter(
      equals: json['equals'] as String?,
      $in: (json['in'] as List<dynamic>?)?.map((e) => e as String),
      notIn: (json['notIn'] as List<dynamic>?)?.map((e) => e as String),
      lt: json['lt'] as String?,
      lte: json['lte'] as String?,
      gt: json['gt'] as String?,
      gte: json['gte'] as String?,
      contains: json['contains'] as String?,
      startsWith: json['startsWith'] as String?,
      endsWith: json['endsWith'] as String?,
      not: json['not'] == null
          ? null
          : NestedStringWithAggregatesFilter.fromJson(
              json['not'] as Map<String, dynamic>),
      $count: json['_count'] == null
          ? null
          : NestedIntFilter.fromJson(json['_count'] as Map<String, dynamic>),
      $min: json['_min'] == null
          ? null
          : NestedStringFilter.fromJson(json['_min'] as Map<String, dynamic>),
      $max: json['_max'] == null
          ? null
          : NestedStringFilter.fromJson(json['_max'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$StringWithAggregatesFilterToJson(
    StringWithAggregatesFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals);
  writeNotNull('in', instance.$in?.toList());
  writeNotNull('notIn', instance.notIn?.toList());
  writeNotNull('lt', instance.lt);
  writeNotNull('lte', instance.lte);
  writeNotNull('gt', instance.gt);
  writeNotNull('gte', instance.gte);
  writeNotNull('contains', instance.contains);
  writeNotNull('startsWith', instance.startsWith);
  writeNotNull('endsWith', instance.endsWith);
  writeNotNull('not', instance.not?.toJson());
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  return val;
}

StringNullableWithAggregatesFilter _$StringNullableWithAggregatesFilterFromJson(
        Map<String, dynamic> json) =>
    StringNullableWithAggregatesFilter(
      equals: json['equals'] as String?,
      $in: (json['in'] as List<dynamic>?)?.map((e) => e as String),
      notIn: (json['notIn'] as List<dynamic>?)?.map((e) => e as String),
      lt: json['lt'] as String?,
      lte: json['lte'] as String?,
      gt: json['gt'] as String?,
      gte: json['gte'] as String?,
      contains: json['contains'] as String?,
      startsWith: json['startsWith'] as String?,
      endsWith: json['endsWith'] as String?,
      not: json['not'] == null
          ? null
          : NestedStringNullableWithAggregatesFilter.fromJson(
              json['not'] as Map<String, dynamic>),
      $count: json['_count'] == null
          ? null
          : NestedIntNullableFilter.fromJson(
              json['_count'] as Map<String, dynamic>),
      $min: json['_min'] == null
          ? null
          : NestedStringNullableFilter.fromJson(
              json['_min'] as Map<String, dynamic>),
      $max: json['_max'] == null
          ? null
          : NestedStringNullableFilter.fromJson(
              json['_max'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$StringNullableWithAggregatesFilterToJson(
    StringNullableWithAggregatesFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals);
  writeNotNull('in', instance.$in?.toList());
  writeNotNull('notIn', instance.notIn?.toList());
  writeNotNull('lt', instance.lt);
  writeNotNull('lte', instance.lte);
  writeNotNull('gt', instance.gt);
  writeNotNull('gte', instance.gte);
  writeNotNull('contains', instance.contains);
  writeNotNull('startsWith', instance.startsWith);
  writeNotNull('endsWith', instance.endsWith);
  writeNotNull('not', instance.not?.toJson());
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  return val;
}

IntNullableWithAggregatesFilter _$IntNullableWithAggregatesFilterFromJson(
        Map<String, dynamic> json) =>
    IntNullableWithAggregatesFilter(
      equals: json['equals'] as int?,
      $in: (json['in'] as List<dynamic>?)?.map((e) => e as int),
      notIn: (json['notIn'] as List<dynamic>?)?.map((e) => e as int),
      lt: json['lt'] as int?,
      lte: json['lte'] as int?,
      gt: json['gt'] as int?,
      gte: json['gte'] as int?,
      not: json['not'] == null
          ? null
          : NestedIntNullableWithAggregatesFilter.fromJson(
              json['not'] as Map<String, dynamic>),
      $count: json['_count'] == null
          ? null
          : NestedIntNullableFilter.fromJson(
              json['_count'] as Map<String, dynamic>),
      $avg: json['_avg'] == null
          ? null
          : NestedFloatNullableFilter.fromJson(
              json['_avg'] as Map<String, dynamic>),
      $sum: json['_sum'] == null
          ? null
          : NestedIntNullableFilter.fromJson(
              json['_sum'] as Map<String, dynamic>),
      $min: json['_min'] == null
          ? null
          : NestedIntNullableFilter.fromJson(
              json['_min'] as Map<String, dynamic>),
      $max: json['_max'] == null
          ? null
          : NestedIntNullableFilter.fromJson(
              json['_max'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$IntNullableWithAggregatesFilterToJson(
    IntNullableWithAggregatesFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals);
  writeNotNull('in', instance.$in?.toList());
  writeNotNull('notIn', instance.notIn?.toList());
  writeNotNull('lt', instance.lt);
  writeNotNull('lte', instance.lte);
  writeNotNull('gt', instance.gt);
  writeNotNull('gte', instance.gte);
  writeNotNull('not', instance.not?.toJson());
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  return val;
}

DateTimeWithAggregatesFilter _$DateTimeWithAggregatesFilterFromJson(
        Map<String, dynamic> json) =>
    DateTimeWithAggregatesFilter(
      equals: _$JsonConverterFromJson<String, DateTime>(
          json['equals'], const DateTimeJsonConverter().fromJson),
      $in: (json['in'] as List<dynamic>?)
          ?.map((e) => const DateTimeJsonConverter().fromJson(e as String)),
      notIn: (json['notIn'] as List<dynamic>?)
          ?.map((e) => const DateTimeJsonConverter().fromJson(e as String)),
      lt: _$JsonConverterFromJson<String, DateTime>(
          json['lt'], const DateTimeJsonConverter().fromJson),
      lte: _$JsonConverterFromJson<String, DateTime>(
          json['lte'], const DateTimeJsonConverter().fromJson),
      gt: _$JsonConverterFromJson<String, DateTime>(
          json['gt'], const DateTimeJsonConverter().fromJson),
      gte: _$JsonConverterFromJson<String, DateTime>(
          json['gte'], const DateTimeJsonConverter().fromJson),
      not: json['not'] == null
          ? null
          : NestedDateTimeWithAggregatesFilter.fromJson(
              json['not'] as Map<String, dynamic>),
      $count: json['_count'] == null
          ? null
          : NestedIntFilter.fromJson(json['_count'] as Map<String, dynamic>),
      $min: json['_min'] == null
          ? null
          : NestedDateTimeFilter.fromJson(json['_min'] as Map<String, dynamic>),
      $max: json['_max'] == null
          ? null
          : NestedDateTimeFilter.fromJson(json['_max'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$DateTimeWithAggregatesFilterToJson(
    DateTimeWithAggregatesFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull(
      'equals',
      _$JsonConverterToJson<String, DateTime>(
          instance.equals, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'in', instance.$in?.map(const DateTimeJsonConverter().toJson).toList());
  writeNotNull('notIn',
      instance.notIn?.map(const DateTimeJsonConverter().toJson).toList());
  writeNotNull(
      'lt',
      _$JsonConverterToJson<String, DateTime>(
          instance.lt, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'lte',
      _$JsonConverterToJson<String, DateTime>(
          instance.lte, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'gt',
      _$JsonConverterToJson<String, DateTime>(
          instance.gt, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'gte',
      _$JsonConverterToJson<String, DateTime>(
          instance.gte, const DateTimeJsonConverter().toJson));
  writeNotNull('not', instance.not?.toJson());
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  return val;
}

DecimalFilter _$DecimalFilterFromJson(Map<String, dynamic> json) =>
    DecimalFilter(
      equals: (json['equals'] as num?)?.toDouble(),
      $in: (json['in'] as List<dynamic>?)?.map((e) => (e as num).toDouble()),
      notIn:
          (json['notIn'] as List<dynamic>?)?.map((e) => (e as num).toDouble()),
      lt: (json['lt'] as num?)?.toDouble(),
      lte: (json['lte'] as num?)?.toDouble(),
      gt: (json['gt'] as num?)?.toDouble(),
      gte: (json['gte'] as num?)?.toDouble(),
      not: json['not'] == null
          ? null
          : NestedDecimalFilter.fromJson(json['not'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$DecimalFilterToJson(DecimalFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals);
  writeNotNull('in', instance.$in?.toList());
  writeNotNull('notIn', instance.notIn?.toList());
  writeNotNull('lt', instance.lt);
  writeNotNull('lte', instance.lte);
  writeNotNull('gt', instance.gt);
  writeNotNull('gte', instance.gte);
  writeNotNull('not', instance.not?.toJson());
  return val;
}

APPROVALATTACHFILETBLAPPROVALIDSEQCompoundUniqueInput
    _$APPROVALATTACHFILETBLAPPROVALIDSEQCompoundUniqueInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALATTACHFILETBLAPPROVALIDSEQCompoundUniqueInput(
          approvalId: json['APPROVAL_ID'] as String,
          seq: (json['SEQ'] as num).toDouble(),
        );

Map<String, dynamic>
    _$APPROVALATTACHFILETBLAPPROVALIDSEQCompoundUniqueInputToJson(
            APPROVALATTACHFILETBLAPPROVALIDSEQCompoundUniqueInput instance) =>
        <String, dynamic>{
          'APPROVAL_ID': instance.approvalId,
          'SEQ': instance.seq,
        };

APPROVALATTACHFILETBLCountOrderByAggregateInput
    _$APPROVALATTACHFILETBLCountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALATTACHFILETBLCountOrderByAggregateInput(
          approvalId:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_ID']),
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          oriFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ORI_FILE_NM']),
          saveFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['SAVE_FILE_NM']),
          fileSize: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_SIZE']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
        );

Map<String, dynamic> _$APPROVALATTACHFILETBLCountOrderByAggregateInputToJson(
    APPROVALATTACHFILETBLCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_ID', _$SortOrderEnumMap[instance.approvalId]);
  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ORI_FILE_NM', _$SortOrderEnumMap[instance.oriFileNm]);
  writeNotNull('SAVE_FILE_NM', _$SortOrderEnumMap[instance.saveFileNm]);
  writeNotNull('FILE_SIZE', _$SortOrderEnumMap[instance.fileSize]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  return val;
}

APPROVALATTACHFILETBLAvgOrderByAggregateInput
    _$APPROVALATTACHFILETBLAvgOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALATTACHFILETBLAvgOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          fileSize: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_SIZE']),
        );

Map<String, dynamic> _$APPROVALATTACHFILETBLAvgOrderByAggregateInputToJson(
    APPROVALATTACHFILETBLAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('FILE_SIZE', _$SortOrderEnumMap[instance.fileSize]);
  return val;
}

APPROVALATTACHFILETBLMaxOrderByAggregateInput
    _$APPROVALATTACHFILETBLMaxOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALATTACHFILETBLMaxOrderByAggregateInput(
          approvalId:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_ID']),
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          oriFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ORI_FILE_NM']),
          saveFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['SAVE_FILE_NM']),
          fileSize: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_SIZE']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
        );

Map<String, dynamic> _$APPROVALATTACHFILETBLMaxOrderByAggregateInputToJson(
    APPROVALATTACHFILETBLMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_ID', _$SortOrderEnumMap[instance.approvalId]);
  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ORI_FILE_NM', _$SortOrderEnumMap[instance.oriFileNm]);
  writeNotNull('SAVE_FILE_NM', _$SortOrderEnumMap[instance.saveFileNm]);
  writeNotNull('FILE_SIZE', _$SortOrderEnumMap[instance.fileSize]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  return val;
}

APPROVALATTACHFILETBLMinOrderByAggregateInput
    _$APPROVALATTACHFILETBLMinOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALATTACHFILETBLMinOrderByAggregateInput(
          approvalId:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_ID']),
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          oriFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ORI_FILE_NM']),
          saveFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['SAVE_FILE_NM']),
          fileSize: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_SIZE']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
        );

Map<String, dynamic> _$APPROVALATTACHFILETBLMinOrderByAggregateInputToJson(
    APPROVALATTACHFILETBLMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_ID', _$SortOrderEnumMap[instance.approvalId]);
  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ORI_FILE_NM', _$SortOrderEnumMap[instance.oriFileNm]);
  writeNotNull('SAVE_FILE_NM', _$SortOrderEnumMap[instance.saveFileNm]);
  writeNotNull('FILE_SIZE', _$SortOrderEnumMap[instance.fileSize]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  return val;
}

APPROVALATTACHFILETBLSumOrderByAggregateInput
    _$APPROVALATTACHFILETBLSumOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALATTACHFILETBLSumOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          fileSize: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_SIZE']),
        );

Map<String, dynamic> _$APPROVALATTACHFILETBLSumOrderByAggregateInputToJson(
    APPROVALATTACHFILETBLSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('FILE_SIZE', _$SortOrderEnumMap[instance.fileSize]);
  return val;
}

DecimalWithAggregatesFilter _$DecimalWithAggregatesFilterFromJson(
        Map<String, dynamic> json) =>
    DecimalWithAggregatesFilter(
      equals: (json['equals'] as num?)?.toDouble(),
      $in: (json['in'] as List<dynamic>?)?.map((e) => (e as num).toDouble()),
      notIn:
          (json['notIn'] as List<dynamic>?)?.map((e) => (e as num).toDouble()),
      lt: (json['lt'] as num?)?.toDouble(),
      lte: (json['lte'] as num?)?.toDouble(),
      gt: (json['gt'] as num?)?.toDouble(),
      gte: (json['gte'] as num?)?.toDouble(),
      not: json['not'] == null
          ? null
          : NestedDecimalWithAggregatesFilter.fromJson(
              json['not'] as Map<String, dynamic>),
      $count: json['_count'] == null
          ? null
          : NestedIntFilter.fromJson(json['_count'] as Map<String, dynamic>),
      $avg: json['_avg'] == null
          ? null
          : NestedDecimalFilter.fromJson(json['_avg'] as Map<String, dynamic>),
      $sum: json['_sum'] == null
          ? null
          : NestedDecimalFilter.fromJson(json['_sum'] as Map<String, dynamic>),
      $min: json['_min'] == null
          ? null
          : NestedDecimalFilter.fromJson(json['_min'] as Map<String, dynamic>),
      $max: json['_max'] == null
          ? null
          : NestedDecimalFilter.fromJson(json['_max'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$DecimalWithAggregatesFilterToJson(
    DecimalWithAggregatesFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals);
  writeNotNull('in', instance.$in?.toList());
  writeNotNull('notIn', instance.notIn?.toList());
  writeNotNull('lt', instance.lt);
  writeNotNull('lte', instance.lte);
  writeNotNull('gt', instance.gt);
  writeNotNull('gte', instance.gte);
  writeNotNull('not', instance.not?.toJson());
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  return val;
}

BigIntFilter _$BigIntFilterFromJson(Map<String, dynamic> json) => BigIntFilter(
      equals: json['equals'] == null
          ? null
          : BigInt.parse(json['equals'] as String),
      $in:
          (json['in'] as List<dynamic>?)?.map((e) => BigInt.parse(e as String)),
      notIn: (json['notIn'] as List<dynamic>?)
          ?.map((e) => BigInt.parse(e as String)),
      lt: json['lt'] == null ? null : BigInt.parse(json['lt'] as String),
      lte: json['lte'] == null ? null : BigInt.parse(json['lte'] as String),
      gt: json['gt'] == null ? null : BigInt.parse(json['gt'] as String),
      gte: json['gte'] == null ? null : BigInt.parse(json['gte'] as String),
      not: json['not'] == null
          ? null
          : NestedBigIntFilter.fromJson(json['not'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$BigIntFilterToJson(BigIntFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals?.toString());
  writeNotNull('in', instance.$in?.map((e) => e.toString()).toList());
  writeNotNull('notIn', instance.notIn?.map((e) => e.toString()).toList());
  writeNotNull('lt', instance.lt?.toString());
  writeNotNull('lte', instance.lte?.toString());
  writeNotNull('gt', instance.gt?.toString());
  writeNotNull('gte', instance.gte?.toString());
  writeNotNull('not', instance.not?.toJson());
  return val;
}

DateTimeNullableFilter _$DateTimeNullableFilterFromJson(
        Map<String, dynamic> json) =>
    DateTimeNullableFilter(
      equals: _$JsonConverterFromJson<String, DateTime>(
          json['equals'], const DateTimeJsonConverter().fromJson),
      $in: (json['in'] as List<dynamic>?)
          ?.map((e) => const DateTimeJsonConverter().fromJson(e as String)),
      notIn: (json['notIn'] as List<dynamic>?)
          ?.map((e) => const DateTimeJsonConverter().fromJson(e as String)),
      lt: _$JsonConverterFromJson<String, DateTime>(
          json['lt'], const DateTimeJsonConverter().fromJson),
      lte: _$JsonConverterFromJson<String, DateTime>(
          json['lte'], const DateTimeJsonConverter().fromJson),
      gt: _$JsonConverterFromJson<String, DateTime>(
          json['gt'], const DateTimeJsonConverter().fromJson),
      gte: _$JsonConverterFromJson<String, DateTime>(
          json['gte'], const DateTimeJsonConverter().fromJson),
      not: json['not'] == null
          ? null
          : NestedDateTimeNullableFilter.fromJson(
              json['not'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$DateTimeNullableFilterToJson(
    DateTimeNullableFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull(
      'equals',
      _$JsonConverterToJson<String, DateTime>(
          instance.equals, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'in', instance.$in?.map(const DateTimeJsonConverter().toJson).toList());
  writeNotNull('notIn',
      instance.notIn?.map(const DateTimeJsonConverter().toJson).toList());
  writeNotNull(
      'lt',
      _$JsonConverterToJson<String, DateTime>(
          instance.lt, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'lte',
      _$JsonConverterToJson<String, DateTime>(
          instance.lte, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'gt',
      _$JsonConverterToJson<String, DateTime>(
          instance.gt, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'gte',
      _$JsonConverterToJson<String, DateTime>(
          instance.gte, const DateTimeJsonConverter().toJson));
  writeNotNull('not', instance.not?.toJson());
  return val;
}

APPROVALDOCINFOTBLCountOrderByAggregateInput
    _$APPROVALDOCINFOTBLCountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALDOCINFOTBLCountOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          docType: $enumDecodeNullable(_$SortOrderEnumMap, json['DOC_TYPE']),
          docNm: $enumDecodeNullable(_$SortOrderEnumMap, json['DOC_NM']),
          title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
          approvalLineType: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_LINE_TYPE']),
          approvalLineContent: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_LINE_CONTENT']),
          approvalLineContentBak: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_LINE_CONTENT_BAK']),
          content: $enumDecodeNullable(_$SortOrderEnumMap, json['CONTENT']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          userNm: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_NM']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$APPROVALDOCINFOTBLCountOrderByAggregateInputToJson(
    APPROVALDOCINFOTBLCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('DOC_TYPE', _$SortOrderEnumMap[instance.docType]);
  writeNotNull('DOC_NM', _$SortOrderEnumMap[instance.docNm]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull(
      'APPROVAL_LINE_TYPE', _$SortOrderEnumMap[instance.approvalLineType]);
  writeNotNull('APPROVAL_LINE_CONTENT',
      _$SortOrderEnumMap[instance.approvalLineContent]);
  writeNotNull('APPROVAL_LINE_CONTENT_BAK',
      _$SortOrderEnumMap[instance.approvalLineContentBak]);
  writeNotNull('CONTENT', _$SortOrderEnumMap[instance.content]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('USER_NM', _$SortOrderEnumMap[instance.userNm]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

APPROVALDOCINFOTBLAvgOrderByAggregateInput
    _$APPROVALDOCINFOTBLAvgOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALDOCINFOTBLAvgOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
        );

Map<String, dynamic> _$APPROVALDOCINFOTBLAvgOrderByAggregateInputToJson(
    APPROVALDOCINFOTBLAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  return val;
}

APPROVALDOCINFOTBLMaxOrderByAggregateInput
    _$APPROVALDOCINFOTBLMaxOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALDOCINFOTBLMaxOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          docType: $enumDecodeNullable(_$SortOrderEnumMap, json['DOC_TYPE']),
          docNm: $enumDecodeNullable(_$SortOrderEnumMap, json['DOC_NM']),
          title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
          approvalLineType: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_LINE_TYPE']),
          approvalLineContent: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_LINE_CONTENT']),
          approvalLineContentBak: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_LINE_CONTENT_BAK']),
          content: $enumDecodeNullable(_$SortOrderEnumMap, json['CONTENT']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          userNm: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_NM']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$APPROVALDOCINFOTBLMaxOrderByAggregateInputToJson(
    APPROVALDOCINFOTBLMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('DOC_TYPE', _$SortOrderEnumMap[instance.docType]);
  writeNotNull('DOC_NM', _$SortOrderEnumMap[instance.docNm]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull(
      'APPROVAL_LINE_TYPE', _$SortOrderEnumMap[instance.approvalLineType]);
  writeNotNull('APPROVAL_LINE_CONTENT',
      _$SortOrderEnumMap[instance.approvalLineContent]);
  writeNotNull('APPROVAL_LINE_CONTENT_BAK',
      _$SortOrderEnumMap[instance.approvalLineContentBak]);
  writeNotNull('CONTENT', _$SortOrderEnumMap[instance.content]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('USER_NM', _$SortOrderEnumMap[instance.userNm]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

APPROVALDOCINFOTBLMinOrderByAggregateInput
    _$APPROVALDOCINFOTBLMinOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALDOCINFOTBLMinOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          docType: $enumDecodeNullable(_$SortOrderEnumMap, json['DOC_TYPE']),
          docNm: $enumDecodeNullable(_$SortOrderEnumMap, json['DOC_NM']),
          title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
          approvalLineType: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_LINE_TYPE']),
          approvalLineContent: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_LINE_CONTENT']),
          approvalLineContentBak: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_LINE_CONTENT_BAK']),
          content: $enumDecodeNullable(_$SortOrderEnumMap, json['CONTENT']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          userNm: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_NM']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$APPROVALDOCINFOTBLMinOrderByAggregateInputToJson(
    APPROVALDOCINFOTBLMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('DOC_TYPE', _$SortOrderEnumMap[instance.docType]);
  writeNotNull('DOC_NM', _$SortOrderEnumMap[instance.docNm]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull(
      'APPROVAL_LINE_TYPE', _$SortOrderEnumMap[instance.approvalLineType]);
  writeNotNull('APPROVAL_LINE_CONTENT',
      _$SortOrderEnumMap[instance.approvalLineContent]);
  writeNotNull('APPROVAL_LINE_CONTENT_BAK',
      _$SortOrderEnumMap[instance.approvalLineContentBak]);
  writeNotNull('CONTENT', _$SortOrderEnumMap[instance.content]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('USER_NM', _$SortOrderEnumMap[instance.userNm]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

APPROVALDOCINFOTBLSumOrderByAggregateInput
    _$APPROVALDOCINFOTBLSumOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALDOCINFOTBLSumOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
        );

Map<String, dynamic> _$APPROVALDOCINFOTBLSumOrderByAggregateInputToJson(
    APPROVALDOCINFOTBLSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  return val;
}

BigIntWithAggregatesFilter _$BigIntWithAggregatesFilterFromJson(
        Map<String, dynamic> json) =>
    BigIntWithAggregatesFilter(
      equals: json['equals'] == null
          ? null
          : BigInt.parse(json['equals'] as String),
      $in:
          (json['in'] as List<dynamic>?)?.map((e) => BigInt.parse(e as String)),
      notIn: (json['notIn'] as List<dynamic>?)
          ?.map((e) => BigInt.parse(e as String)),
      lt: json['lt'] == null ? null : BigInt.parse(json['lt'] as String),
      lte: json['lte'] == null ? null : BigInt.parse(json['lte'] as String),
      gt: json['gt'] == null ? null : BigInt.parse(json['gt'] as String),
      gte: json['gte'] == null ? null : BigInt.parse(json['gte'] as String),
      not: json['not'] == null
          ? null
          : NestedBigIntWithAggregatesFilter.fromJson(
              json['not'] as Map<String, dynamic>),
      $count: json['_count'] == null
          ? null
          : NestedIntFilter.fromJson(json['_count'] as Map<String, dynamic>),
      $avg: json['_avg'] == null
          ? null
          : NestedFloatFilter.fromJson(json['_avg'] as Map<String, dynamic>),
      $sum: json['_sum'] == null
          ? null
          : NestedBigIntFilter.fromJson(json['_sum'] as Map<String, dynamic>),
      $min: json['_min'] == null
          ? null
          : NestedBigIntFilter.fromJson(json['_min'] as Map<String, dynamic>),
      $max: json['_max'] == null
          ? null
          : NestedBigIntFilter.fromJson(json['_max'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$BigIntWithAggregatesFilterToJson(
    BigIntWithAggregatesFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals?.toString());
  writeNotNull('in', instance.$in?.map((e) => e.toString()).toList());
  writeNotNull('notIn', instance.notIn?.map((e) => e.toString()).toList());
  writeNotNull('lt', instance.lt?.toString());
  writeNotNull('lte', instance.lte?.toString());
  writeNotNull('gt', instance.gt?.toString());
  writeNotNull('gte', instance.gte?.toString());
  writeNotNull('not', instance.not?.toJson());
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  return val;
}

DateTimeNullableWithAggregatesFilter
    _$DateTimeNullableWithAggregatesFilterFromJson(Map<String, dynamic> json) =>
        DateTimeNullableWithAggregatesFilter(
          equals: _$JsonConverterFromJson<String, DateTime>(
              json['equals'], const DateTimeJsonConverter().fromJson),
          $in: (json['in'] as List<dynamic>?)
              ?.map((e) => const DateTimeJsonConverter().fromJson(e as String)),
          notIn: (json['notIn'] as List<dynamic>?)
              ?.map((e) => const DateTimeJsonConverter().fromJson(e as String)),
          lt: _$JsonConverterFromJson<String, DateTime>(
              json['lt'], const DateTimeJsonConverter().fromJson),
          lte: _$JsonConverterFromJson<String, DateTime>(
              json['lte'], const DateTimeJsonConverter().fromJson),
          gt: _$JsonConverterFromJson<String, DateTime>(
              json['gt'], const DateTimeJsonConverter().fromJson),
          gte: _$JsonConverterFromJson<String, DateTime>(
              json['gte'], const DateTimeJsonConverter().fromJson),
          not: json['not'] == null
              ? null
              : NestedDateTimeNullableWithAggregatesFilter.fromJson(
                  json['not'] as Map<String, dynamic>),
          $count: json['_count'] == null
              ? null
              : NestedIntNullableFilter.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : NestedDateTimeNullableFilter.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : NestedDateTimeNullableFilter.fromJson(
                  json['_max'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$DateTimeNullableWithAggregatesFilterToJson(
    DateTimeNullableWithAggregatesFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull(
      'equals',
      _$JsonConverterToJson<String, DateTime>(
          instance.equals, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'in', instance.$in?.map(const DateTimeJsonConverter().toJson).toList());
  writeNotNull('notIn',
      instance.notIn?.map(const DateTimeJsonConverter().toJson).toList());
  writeNotNull(
      'lt',
      _$JsonConverterToJson<String, DateTime>(
          instance.lt, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'lte',
      _$JsonConverterToJson<String, DateTime>(
          instance.lte, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'gt',
      _$JsonConverterToJson<String, DateTime>(
          instance.gt, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'gte',
      _$JsonConverterToJson<String, DateTime>(
          instance.gte, const DateTimeJsonConverter().toJson));
  writeNotNull('not', instance.not?.toJson());
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  return val;
}

IntFilter _$IntFilterFromJson(Map<String, dynamic> json) => IntFilter(
      equals: json['equals'] as int?,
      $in: (json['in'] as List<dynamic>?)?.map((e) => e as int),
      notIn: (json['notIn'] as List<dynamic>?)?.map((e) => e as int),
      lt: json['lt'] as int?,
      lte: json['lte'] as int?,
      gt: json['gt'] as int?,
      gte: json['gte'] as int?,
      not: json['not'] == null
          ? null
          : NestedIntFilter.fromJson(json['not'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$IntFilterToJson(IntFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals);
  writeNotNull('in', instance.$in?.toList());
  writeNotNull('notIn', instance.notIn?.toList());
  writeNotNull('lt', instance.lt);
  writeNotNull('lte', instance.lte);
  writeNotNull('gt', instance.gt);
  writeNotNull('gte', instance.gte);
  writeNotNull('not', instance.not?.toJson());
  return val;
}

APPROVALHISTORYTBLCountOrderByAggregateInput
    _$APPROVALHISTORYTBLCountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALHISTORYTBLCountOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          approvalId:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_ID']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          writerNm: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_NM']),
          docType: $enumDecodeNullable(_$SortOrderEnumMap, json['DOC_TYPE']),
          keepPriod:
              $enumDecodeNullable(_$SortOrderEnumMap, json['KEEP_PRIOD']),
          keepDate: $enumDecodeNullable(_$SortOrderEnumMap, json['KEEP_DATE']),
          grade: $enumDecodeNullable(_$SortOrderEnumMap, json['GRADE']),
          status: $enumDecodeNullable(_$SortOrderEnumMap, json['STATUS']),
          content: $enumDecodeNullable(_$SortOrderEnumMap, json['CONTENT']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$APPROVALHISTORYTBLCountOrderByAggregateInputToJson(
    APPROVALHISTORYTBLCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('APPROVAL_ID', _$SortOrderEnumMap[instance.approvalId]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('WRITER_NM', _$SortOrderEnumMap[instance.writerNm]);
  writeNotNull('DOC_TYPE', _$SortOrderEnumMap[instance.docType]);
  writeNotNull('KEEP_PRIOD', _$SortOrderEnumMap[instance.keepPriod]);
  writeNotNull('KEEP_DATE', _$SortOrderEnumMap[instance.keepDate]);
  writeNotNull('GRADE', _$SortOrderEnumMap[instance.grade]);
  writeNotNull('STATUS', _$SortOrderEnumMap[instance.status]);
  writeNotNull('CONTENT', _$SortOrderEnumMap[instance.content]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

APPROVALHISTORYTBLAvgOrderByAggregateInput
    _$APPROVALHISTORYTBLAvgOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALHISTORYTBLAvgOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          keepPriod:
              $enumDecodeNullable(_$SortOrderEnumMap, json['KEEP_PRIOD']),
        );

Map<String, dynamic> _$APPROVALHISTORYTBLAvgOrderByAggregateInputToJson(
    APPROVALHISTORYTBLAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('KEEP_PRIOD', _$SortOrderEnumMap[instance.keepPriod]);
  return val;
}

APPROVALHISTORYTBLMaxOrderByAggregateInput
    _$APPROVALHISTORYTBLMaxOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALHISTORYTBLMaxOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          approvalId:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_ID']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          writerNm: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_NM']),
          docType: $enumDecodeNullable(_$SortOrderEnumMap, json['DOC_TYPE']),
          keepPriod:
              $enumDecodeNullable(_$SortOrderEnumMap, json['KEEP_PRIOD']),
          keepDate: $enumDecodeNullable(_$SortOrderEnumMap, json['KEEP_DATE']),
          grade: $enumDecodeNullable(_$SortOrderEnumMap, json['GRADE']),
          status: $enumDecodeNullable(_$SortOrderEnumMap, json['STATUS']),
          content: $enumDecodeNullable(_$SortOrderEnumMap, json['CONTENT']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$APPROVALHISTORYTBLMaxOrderByAggregateInputToJson(
    APPROVALHISTORYTBLMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('APPROVAL_ID', _$SortOrderEnumMap[instance.approvalId]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('WRITER_NM', _$SortOrderEnumMap[instance.writerNm]);
  writeNotNull('DOC_TYPE', _$SortOrderEnumMap[instance.docType]);
  writeNotNull('KEEP_PRIOD', _$SortOrderEnumMap[instance.keepPriod]);
  writeNotNull('KEEP_DATE', _$SortOrderEnumMap[instance.keepDate]);
  writeNotNull('GRADE', _$SortOrderEnumMap[instance.grade]);
  writeNotNull('STATUS', _$SortOrderEnumMap[instance.status]);
  writeNotNull('CONTENT', _$SortOrderEnumMap[instance.content]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

APPROVALHISTORYTBLMinOrderByAggregateInput
    _$APPROVALHISTORYTBLMinOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALHISTORYTBLMinOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          approvalId:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_ID']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          writerNm: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_NM']),
          docType: $enumDecodeNullable(_$SortOrderEnumMap, json['DOC_TYPE']),
          keepPriod:
              $enumDecodeNullable(_$SortOrderEnumMap, json['KEEP_PRIOD']),
          keepDate: $enumDecodeNullable(_$SortOrderEnumMap, json['KEEP_DATE']),
          grade: $enumDecodeNullable(_$SortOrderEnumMap, json['GRADE']),
          status: $enumDecodeNullable(_$SortOrderEnumMap, json['STATUS']),
          content: $enumDecodeNullable(_$SortOrderEnumMap, json['CONTENT']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$APPROVALHISTORYTBLMinOrderByAggregateInputToJson(
    APPROVALHISTORYTBLMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('APPROVAL_ID', _$SortOrderEnumMap[instance.approvalId]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('WRITER_NM', _$SortOrderEnumMap[instance.writerNm]);
  writeNotNull('DOC_TYPE', _$SortOrderEnumMap[instance.docType]);
  writeNotNull('KEEP_PRIOD', _$SortOrderEnumMap[instance.keepPriod]);
  writeNotNull('KEEP_DATE', _$SortOrderEnumMap[instance.keepDate]);
  writeNotNull('GRADE', _$SortOrderEnumMap[instance.grade]);
  writeNotNull('STATUS', _$SortOrderEnumMap[instance.status]);
  writeNotNull('CONTENT', _$SortOrderEnumMap[instance.content]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

APPROVALHISTORYTBLSumOrderByAggregateInput
    _$APPROVALHISTORYTBLSumOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALHISTORYTBLSumOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          keepPriod:
              $enumDecodeNullable(_$SortOrderEnumMap, json['KEEP_PRIOD']),
        );

Map<String, dynamic> _$APPROVALHISTORYTBLSumOrderByAggregateInputToJson(
    APPROVALHISTORYTBLSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('KEEP_PRIOD', _$SortOrderEnumMap[instance.keepPriod]);
  return val;
}

IntWithAggregatesFilter _$IntWithAggregatesFilterFromJson(
        Map<String, dynamic> json) =>
    IntWithAggregatesFilter(
      equals: json['equals'] as int?,
      $in: (json['in'] as List<dynamic>?)?.map((e) => e as int),
      notIn: (json['notIn'] as List<dynamic>?)?.map((e) => e as int),
      lt: json['lt'] as int?,
      lte: json['lte'] as int?,
      gt: json['gt'] as int?,
      gte: json['gte'] as int?,
      not: json['not'] == null
          ? null
          : NestedIntWithAggregatesFilter.fromJson(
              json['not'] as Map<String, dynamic>),
      $count: json['_count'] == null
          ? null
          : NestedIntFilter.fromJson(json['_count'] as Map<String, dynamic>),
      $avg: json['_avg'] == null
          ? null
          : NestedFloatFilter.fromJson(json['_avg'] as Map<String, dynamic>),
      $sum: json['_sum'] == null
          ? null
          : NestedIntFilter.fromJson(json['_sum'] as Map<String, dynamic>),
      $min: json['_min'] == null
          ? null
          : NestedIntFilter.fromJson(json['_min'] as Map<String, dynamic>),
      $max: json['_max'] == null
          ? null
          : NestedIntFilter.fromJson(json['_max'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$IntWithAggregatesFilterToJson(
    IntWithAggregatesFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals);
  writeNotNull('in', instance.$in?.toList());
  writeNotNull('notIn', instance.notIn?.toList());
  writeNotNull('lt', instance.lt);
  writeNotNull('lte', instance.lte);
  writeNotNull('gt', instance.gt);
  writeNotNull('gte', instance.gte);
  writeNotNull('not', instance.not?.toJson());
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  return val;
}

DecimalNullableFilter _$DecimalNullableFilterFromJson(
        Map<String, dynamic> json) =>
    DecimalNullableFilter(
      equals: (json['equals'] as num?)?.toDouble(),
      $in: (json['in'] as List<dynamic>?)?.map((e) => (e as num).toDouble()),
      notIn:
          (json['notIn'] as List<dynamic>?)?.map((e) => (e as num).toDouble()),
      lt: (json['lt'] as num?)?.toDouble(),
      lte: (json['lte'] as num?)?.toDouble(),
      gt: (json['gt'] as num?)?.toDouble(),
      gte: (json['gte'] as num?)?.toDouble(),
      not: json['not'] == null
          ? null
          : NestedDecimalNullableFilter.fromJson(
              json['not'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$DecimalNullableFilterToJson(
    DecimalNullableFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals);
  writeNotNull('in', instance.$in?.toList());
  writeNotNull('notIn', instance.notIn?.toList());
  writeNotNull('lt', instance.lt);
  writeNotNull('lte', instance.lte);
  writeNotNull('gt', instance.gt);
  writeNotNull('gte', instance.gte);
  writeNotNull('not', instance.not?.toJson());
  return val;
}

APPROVALMASTERTBLCountOrderByAggregateInput
    _$APPROVALMASTERTBLCountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALMASTERTBLCountOrderByAggregateInput(
          approvalId:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_ID']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          writerNm: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_NM']),
          docType: $enumDecodeNullable(_$SortOrderEnumMap, json['DOC_TYPE']),
          keepPriod:
              $enumDecodeNullable(_$SortOrderEnumMap, json['KEEP_PRIOD']),
          keepDate: $enumDecodeNullable(_$SortOrderEnumMap, json['KEEP_DATE']),
          grade: $enumDecodeNullable(_$SortOrderEnumMap, json['GRADE']),
          status: $enumDecodeNullable(_$SortOrderEnumMap, json['STATUS']),
          title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
          header: $enumDecodeNullable(_$SortOrderEnumMap, json['HEADER']),
          content: $enumDecodeNullable(_$SortOrderEnumMap, json['CONTENT']),
          m1: $enumDecodeNullable(_$SortOrderEnumMap, json['M1']),
          m2: $enumDecodeNullable(_$SortOrderEnumMap, json['M2']),
          m3: $enumDecodeNullable(_$SortOrderEnumMap, json['M3']),
          m4: $enumDecodeNullable(_$SortOrderEnumMap, json['M4']),
          m5: $enumDecodeNullable(_$SortOrderEnumMap, json['M5']),
          m6: $enumDecodeNullable(_$SortOrderEnumMap, json['M6']),
          m7: $enumDecodeNullable(_$SortOrderEnumMap, json['M7']),
          m8: $enumDecodeNullable(_$SortOrderEnumMap, json['M8']),
          m9: $enumDecodeNullable(_$SortOrderEnumMap, json['M9']),
          m10: $enumDecodeNullable(_$SortOrderEnumMap, json['M10']),
          m11: $enumDecodeNullable(_$SortOrderEnumMap, json['M11']),
          m12: $enumDecodeNullable(_$SortOrderEnumMap, json['M12']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          completeDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['COMPLETE_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$APPROVALMASTERTBLCountOrderByAggregateInputToJson(
    APPROVALMASTERTBLCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_ID', _$SortOrderEnumMap[instance.approvalId]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('WRITER_NM', _$SortOrderEnumMap[instance.writerNm]);
  writeNotNull('DOC_TYPE', _$SortOrderEnumMap[instance.docType]);
  writeNotNull('KEEP_PRIOD', _$SortOrderEnumMap[instance.keepPriod]);
  writeNotNull('KEEP_DATE', _$SortOrderEnumMap[instance.keepDate]);
  writeNotNull('GRADE', _$SortOrderEnumMap[instance.grade]);
  writeNotNull('STATUS', _$SortOrderEnumMap[instance.status]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull('HEADER', _$SortOrderEnumMap[instance.header]);
  writeNotNull('CONTENT', _$SortOrderEnumMap[instance.content]);
  writeNotNull('M1', _$SortOrderEnumMap[instance.m1]);
  writeNotNull('M2', _$SortOrderEnumMap[instance.m2]);
  writeNotNull('M3', _$SortOrderEnumMap[instance.m3]);
  writeNotNull('M4', _$SortOrderEnumMap[instance.m4]);
  writeNotNull('M5', _$SortOrderEnumMap[instance.m5]);
  writeNotNull('M6', _$SortOrderEnumMap[instance.m6]);
  writeNotNull('M7', _$SortOrderEnumMap[instance.m7]);
  writeNotNull('M8', _$SortOrderEnumMap[instance.m8]);
  writeNotNull('M9', _$SortOrderEnumMap[instance.m9]);
  writeNotNull('M10', _$SortOrderEnumMap[instance.m10]);
  writeNotNull('M11', _$SortOrderEnumMap[instance.m11]);
  writeNotNull('M12', _$SortOrderEnumMap[instance.m12]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('COMPLETE_DATE', _$SortOrderEnumMap[instance.completeDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

APPROVALMASTERTBLAvgOrderByAggregateInput
    _$APPROVALMASTERTBLAvgOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALMASTERTBLAvgOrderByAggregateInput(
          keepPriod:
              $enumDecodeNullable(_$SortOrderEnumMap, json['KEEP_PRIOD']),
          m1: $enumDecodeNullable(_$SortOrderEnumMap, json['M1']),
          m2: $enumDecodeNullable(_$SortOrderEnumMap, json['M2']),
          m3: $enumDecodeNullable(_$SortOrderEnumMap, json['M3']),
          m4: $enumDecodeNullable(_$SortOrderEnumMap, json['M4']),
          m5: $enumDecodeNullable(_$SortOrderEnumMap, json['M5']),
          m6: $enumDecodeNullable(_$SortOrderEnumMap, json['M6']),
          m7: $enumDecodeNullable(_$SortOrderEnumMap, json['M7']),
          m8: $enumDecodeNullable(_$SortOrderEnumMap, json['M8']),
          m9: $enumDecodeNullable(_$SortOrderEnumMap, json['M9']),
          m10: $enumDecodeNullable(_$SortOrderEnumMap, json['M10']),
          m11: $enumDecodeNullable(_$SortOrderEnumMap, json['M11']),
          m12: $enumDecodeNullable(_$SortOrderEnumMap, json['M12']),
        );

Map<String, dynamic> _$APPROVALMASTERTBLAvgOrderByAggregateInputToJson(
    APPROVALMASTERTBLAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('KEEP_PRIOD', _$SortOrderEnumMap[instance.keepPriod]);
  writeNotNull('M1', _$SortOrderEnumMap[instance.m1]);
  writeNotNull('M2', _$SortOrderEnumMap[instance.m2]);
  writeNotNull('M3', _$SortOrderEnumMap[instance.m3]);
  writeNotNull('M4', _$SortOrderEnumMap[instance.m4]);
  writeNotNull('M5', _$SortOrderEnumMap[instance.m5]);
  writeNotNull('M6', _$SortOrderEnumMap[instance.m6]);
  writeNotNull('M7', _$SortOrderEnumMap[instance.m7]);
  writeNotNull('M8', _$SortOrderEnumMap[instance.m8]);
  writeNotNull('M9', _$SortOrderEnumMap[instance.m9]);
  writeNotNull('M10', _$SortOrderEnumMap[instance.m10]);
  writeNotNull('M11', _$SortOrderEnumMap[instance.m11]);
  writeNotNull('M12', _$SortOrderEnumMap[instance.m12]);
  return val;
}

APPROVALMASTERTBLMaxOrderByAggregateInput
    _$APPROVALMASTERTBLMaxOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALMASTERTBLMaxOrderByAggregateInput(
          approvalId:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_ID']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          writerNm: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_NM']),
          docType: $enumDecodeNullable(_$SortOrderEnumMap, json['DOC_TYPE']),
          keepPriod:
              $enumDecodeNullable(_$SortOrderEnumMap, json['KEEP_PRIOD']),
          keepDate: $enumDecodeNullable(_$SortOrderEnumMap, json['KEEP_DATE']),
          grade: $enumDecodeNullable(_$SortOrderEnumMap, json['GRADE']),
          status: $enumDecodeNullable(_$SortOrderEnumMap, json['STATUS']),
          title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
          header: $enumDecodeNullable(_$SortOrderEnumMap, json['HEADER']),
          content: $enumDecodeNullable(_$SortOrderEnumMap, json['CONTENT']),
          m1: $enumDecodeNullable(_$SortOrderEnumMap, json['M1']),
          m2: $enumDecodeNullable(_$SortOrderEnumMap, json['M2']),
          m3: $enumDecodeNullable(_$SortOrderEnumMap, json['M3']),
          m4: $enumDecodeNullable(_$SortOrderEnumMap, json['M4']),
          m5: $enumDecodeNullable(_$SortOrderEnumMap, json['M5']),
          m6: $enumDecodeNullable(_$SortOrderEnumMap, json['M6']),
          m7: $enumDecodeNullable(_$SortOrderEnumMap, json['M7']),
          m8: $enumDecodeNullable(_$SortOrderEnumMap, json['M8']),
          m9: $enumDecodeNullable(_$SortOrderEnumMap, json['M9']),
          m10: $enumDecodeNullable(_$SortOrderEnumMap, json['M10']),
          m11: $enumDecodeNullable(_$SortOrderEnumMap, json['M11']),
          m12: $enumDecodeNullable(_$SortOrderEnumMap, json['M12']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          completeDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['COMPLETE_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$APPROVALMASTERTBLMaxOrderByAggregateInputToJson(
    APPROVALMASTERTBLMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_ID', _$SortOrderEnumMap[instance.approvalId]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('WRITER_NM', _$SortOrderEnumMap[instance.writerNm]);
  writeNotNull('DOC_TYPE', _$SortOrderEnumMap[instance.docType]);
  writeNotNull('KEEP_PRIOD', _$SortOrderEnumMap[instance.keepPriod]);
  writeNotNull('KEEP_DATE', _$SortOrderEnumMap[instance.keepDate]);
  writeNotNull('GRADE', _$SortOrderEnumMap[instance.grade]);
  writeNotNull('STATUS', _$SortOrderEnumMap[instance.status]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull('HEADER', _$SortOrderEnumMap[instance.header]);
  writeNotNull('CONTENT', _$SortOrderEnumMap[instance.content]);
  writeNotNull('M1', _$SortOrderEnumMap[instance.m1]);
  writeNotNull('M2', _$SortOrderEnumMap[instance.m2]);
  writeNotNull('M3', _$SortOrderEnumMap[instance.m3]);
  writeNotNull('M4', _$SortOrderEnumMap[instance.m4]);
  writeNotNull('M5', _$SortOrderEnumMap[instance.m5]);
  writeNotNull('M6', _$SortOrderEnumMap[instance.m6]);
  writeNotNull('M7', _$SortOrderEnumMap[instance.m7]);
  writeNotNull('M8', _$SortOrderEnumMap[instance.m8]);
  writeNotNull('M9', _$SortOrderEnumMap[instance.m9]);
  writeNotNull('M10', _$SortOrderEnumMap[instance.m10]);
  writeNotNull('M11', _$SortOrderEnumMap[instance.m11]);
  writeNotNull('M12', _$SortOrderEnumMap[instance.m12]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('COMPLETE_DATE', _$SortOrderEnumMap[instance.completeDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

APPROVALMASTERTBLMinOrderByAggregateInput
    _$APPROVALMASTERTBLMinOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALMASTERTBLMinOrderByAggregateInput(
          approvalId:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_ID']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          writerNm: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_NM']),
          docType: $enumDecodeNullable(_$SortOrderEnumMap, json['DOC_TYPE']),
          keepPriod:
              $enumDecodeNullable(_$SortOrderEnumMap, json['KEEP_PRIOD']),
          keepDate: $enumDecodeNullable(_$SortOrderEnumMap, json['KEEP_DATE']),
          grade: $enumDecodeNullable(_$SortOrderEnumMap, json['GRADE']),
          status: $enumDecodeNullable(_$SortOrderEnumMap, json['STATUS']),
          title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
          header: $enumDecodeNullable(_$SortOrderEnumMap, json['HEADER']),
          content: $enumDecodeNullable(_$SortOrderEnumMap, json['CONTENT']),
          m1: $enumDecodeNullable(_$SortOrderEnumMap, json['M1']),
          m2: $enumDecodeNullable(_$SortOrderEnumMap, json['M2']),
          m3: $enumDecodeNullable(_$SortOrderEnumMap, json['M3']),
          m4: $enumDecodeNullable(_$SortOrderEnumMap, json['M4']),
          m5: $enumDecodeNullable(_$SortOrderEnumMap, json['M5']),
          m6: $enumDecodeNullable(_$SortOrderEnumMap, json['M6']),
          m7: $enumDecodeNullable(_$SortOrderEnumMap, json['M7']),
          m8: $enumDecodeNullable(_$SortOrderEnumMap, json['M8']),
          m9: $enumDecodeNullable(_$SortOrderEnumMap, json['M9']),
          m10: $enumDecodeNullable(_$SortOrderEnumMap, json['M10']),
          m11: $enumDecodeNullable(_$SortOrderEnumMap, json['M11']),
          m12: $enumDecodeNullable(_$SortOrderEnumMap, json['M12']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          completeDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['COMPLETE_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$APPROVALMASTERTBLMinOrderByAggregateInputToJson(
    APPROVALMASTERTBLMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_ID', _$SortOrderEnumMap[instance.approvalId]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('WRITER_NM', _$SortOrderEnumMap[instance.writerNm]);
  writeNotNull('DOC_TYPE', _$SortOrderEnumMap[instance.docType]);
  writeNotNull('KEEP_PRIOD', _$SortOrderEnumMap[instance.keepPriod]);
  writeNotNull('KEEP_DATE', _$SortOrderEnumMap[instance.keepDate]);
  writeNotNull('GRADE', _$SortOrderEnumMap[instance.grade]);
  writeNotNull('STATUS', _$SortOrderEnumMap[instance.status]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull('HEADER', _$SortOrderEnumMap[instance.header]);
  writeNotNull('CONTENT', _$SortOrderEnumMap[instance.content]);
  writeNotNull('M1', _$SortOrderEnumMap[instance.m1]);
  writeNotNull('M2', _$SortOrderEnumMap[instance.m2]);
  writeNotNull('M3', _$SortOrderEnumMap[instance.m3]);
  writeNotNull('M4', _$SortOrderEnumMap[instance.m4]);
  writeNotNull('M5', _$SortOrderEnumMap[instance.m5]);
  writeNotNull('M6', _$SortOrderEnumMap[instance.m6]);
  writeNotNull('M7', _$SortOrderEnumMap[instance.m7]);
  writeNotNull('M8', _$SortOrderEnumMap[instance.m8]);
  writeNotNull('M9', _$SortOrderEnumMap[instance.m9]);
  writeNotNull('M10', _$SortOrderEnumMap[instance.m10]);
  writeNotNull('M11', _$SortOrderEnumMap[instance.m11]);
  writeNotNull('M12', _$SortOrderEnumMap[instance.m12]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('COMPLETE_DATE', _$SortOrderEnumMap[instance.completeDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

APPROVALMASTERTBLSumOrderByAggregateInput
    _$APPROVALMASTERTBLSumOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALMASTERTBLSumOrderByAggregateInput(
          keepPriod:
              $enumDecodeNullable(_$SortOrderEnumMap, json['KEEP_PRIOD']),
          m1: $enumDecodeNullable(_$SortOrderEnumMap, json['M1']),
          m2: $enumDecodeNullable(_$SortOrderEnumMap, json['M2']),
          m3: $enumDecodeNullable(_$SortOrderEnumMap, json['M3']),
          m4: $enumDecodeNullable(_$SortOrderEnumMap, json['M4']),
          m5: $enumDecodeNullable(_$SortOrderEnumMap, json['M5']),
          m6: $enumDecodeNullable(_$SortOrderEnumMap, json['M6']),
          m7: $enumDecodeNullable(_$SortOrderEnumMap, json['M7']),
          m8: $enumDecodeNullable(_$SortOrderEnumMap, json['M8']),
          m9: $enumDecodeNullable(_$SortOrderEnumMap, json['M9']),
          m10: $enumDecodeNullable(_$SortOrderEnumMap, json['M10']),
          m11: $enumDecodeNullable(_$SortOrderEnumMap, json['M11']),
          m12: $enumDecodeNullable(_$SortOrderEnumMap, json['M12']),
        );

Map<String, dynamic> _$APPROVALMASTERTBLSumOrderByAggregateInputToJson(
    APPROVALMASTERTBLSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('KEEP_PRIOD', _$SortOrderEnumMap[instance.keepPriod]);
  writeNotNull('M1', _$SortOrderEnumMap[instance.m1]);
  writeNotNull('M2', _$SortOrderEnumMap[instance.m2]);
  writeNotNull('M3', _$SortOrderEnumMap[instance.m3]);
  writeNotNull('M4', _$SortOrderEnumMap[instance.m4]);
  writeNotNull('M5', _$SortOrderEnumMap[instance.m5]);
  writeNotNull('M6', _$SortOrderEnumMap[instance.m6]);
  writeNotNull('M7', _$SortOrderEnumMap[instance.m7]);
  writeNotNull('M8', _$SortOrderEnumMap[instance.m8]);
  writeNotNull('M9', _$SortOrderEnumMap[instance.m9]);
  writeNotNull('M10', _$SortOrderEnumMap[instance.m10]);
  writeNotNull('M11', _$SortOrderEnumMap[instance.m11]);
  writeNotNull('M12', _$SortOrderEnumMap[instance.m12]);
  return val;
}

DecimalNullableWithAggregatesFilter
    _$DecimalNullableWithAggregatesFilterFromJson(Map<String, dynamic> json) =>
        DecimalNullableWithAggregatesFilter(
          equals: (json['equals'] as num?)?.toDouble(),
          $in:
              (json['in'] as List<dynamic>?)?.map((e) => (e as num).toDouble()),
          notIn: (json['notIn'] as List<dynamic>?)
              ?.map((e) => (e as num).toDouble()),
          lt: (json['lt'] as num?)?.toDouble(),
          lte: (json['lte'] as num?)?.toDouble(),
          gt: (json['gt'] as num?)?.toDouble(),
          gte: (json['gte'] as num?)?.toDouble(),
          not: json['not'] == null
              ? null
              : NestedDecimalNullableWithAggregatesFilter.fromJson(
                  json['not'] as Map<String, dynamic>),
          $count: json['_count'] == null
              ? null
              : NestedIntNullableFilter.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : NestedDecimalNullableFilter.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : NestedDecimalNullableFilter.fromJson(
                  json['_sum'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : NestedDecimalNullableFilter.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : NestedDecimalNullableFilter.fromJson(
                  json['_max'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$DecimalNullableWithAggregatesFilterToJson(
    DecimalNullableWithAggregatesFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals);
  writeNotNull('in', instance.$in?.toList());
  writeNotNull('notIn', instance.notIn?.toList());
  writeNotNull('lt', instance.lt);
  writeNotNull('lte', instance.lte);
  writeNotNull('gt', instance.gt);
  writeNotNull('gte', instance.gte);
  writeNotNull('not', instance.not?.toJson());
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  return val;
}

APPROVALMEMOTBLCountOrderByAggregateInput
    _$APPROVALMEMOTBLCountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALMEMOTBLCountOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          approvalId:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_ID']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          writerNm: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_NM']),
          content: $enumDecodeNullable(_$SortOrderEnumMap, json['CONTENT']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$APPROVALMEMOTBLCountOrderByAggregateInputToJson(
    APPROVALMEMOTBLCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('APPROVAL_ID', _$SortOrderEnumMap[instance.approvalId]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('WRITER_NM', _$SortOrderEnumMap[instance.writerNm]);
  writeNotNull('CONTENT', _$SortOrderEnumMap[instance.content]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

APPROVALMEMOTBLAvgOrderByAggregateInput
    _$APPROVALMEMOTBLAvgOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALMEMOTBLAvgOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
        );

Map<String, dynamic> _$APPROVALMEMOTBLAvgOrderByAggregateInputToJson(
    APPROVALMEMOTBLAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  return val;
}

APPROVALMEMOTBLMaxOrderByAggregateInput
    _$APPROVALMEMOTBLMaxOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALMEMOTBLMaxOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          approvalId:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_ID']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          writerNm: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_NM']),
          content: $enumDecodeNullable(_$SortOrderEnumMap, json['CONTENT']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$APPROVALMEMOTBLMaxOrderByAggregateInputToJson(
    APPROVALMEMOTBLMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('APPROVAL_ID', _$SortOrderEnumMap[instance.approvalId]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('WRITER_NM', _$SortOrderEnumMap[instance.writerNm]);
  writeNotNull('CONTENT', _$SortOrderEnumMap[instance.content]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

APPROVALMEMOTBLMinOrderByAggregateInput
    _$APPROVALMEMOTBLMinOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALMEMOTBLMinOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          approvalId:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_ID']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          writerNm: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_NM']),
          content: $enumDecodeNullable(_$SortOrderEnumMap, json['CONTENT']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$APPROVALMEMOTBLMinOrderByAggregateInputToJson(
    APPROVALMEMOTBLMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('APPROVAL_ID', _$SortOrderEnumMap[instance.approvalId]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('WRITER_NM', _$SortOrderEnumMap[instance.writerNm]);
  writeNotNull('CONTENT', _$SortOrderEnumMap[instance.content]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

APPROVALMEMOTBLSumOrderByAggregateInput
    _$APPROVALMEMOTBLSumOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALMEMOTBLSumOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
        );

Map<String, dynamic> _$APPROVALMEMOTBLSumOrderByAggregateInputToJson(
    APPROVALMEMOTBLSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  return val;
}

APPROVALTYPETBLCountOrderByAggregateInput
    _$APPROVALTYPETBLCountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALTYPETBLCountOrderByAggregateInput(
          type: $enumDecodeNullable(_$SortOrderEnumMap, json['TYPE']),
          content: $enumDecodeNullable(_$SortOrderEnumMap, json['CONTENT']),
          contentBak:
              $enumDecodeNullable(_$SortOrderEnumMap, json['CONTENT_BAK']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$APPROVALTYPETBLCountOrderByAggregateInputToJson(
    APPROVALTYPETBLCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('TYPE', _$SortOrderEnumMap[instance.type]);
  writeNotNull('CONTENT', _$SortOrderEnumMap[instance.content]);
  writeNotNull('CONTENT_BAK', _$SortOrderEnumMap[instance.contentBak]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

APPROVALTYPETBLMaxOrderByAggregateInput
    _$APPROVALTYPETBLMaxOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALTYPETBLMaxOrderByAggregateInput(
          type: $enumDecodeNullable(_$SortOrderEnumMap, json['TYPE']),
          content: $enumDecodeNullable(_$SortOrderEnumMap, json['CONTENT']),
          contentBak:
              $enumDecodeNullable(_$SortOrderEnumMap, json['CONTENT_BAK']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$APPROVALTYPETBLMaxOrderByAggregateInputToJson(
    APPROVALTYPETBLMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('TYPE', _$SortOrderEnumMap[instance.type]);
  writeNotNull('CONTENT', _$SortOrderEnumMap[instance.content]);
  writeNotNull('CONTENT_BAK', _$SortOrderEnumMap[instance.contentBak]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

APPROVALTYPETBLMinOrderByAggregateInput
    _$APPROVALTYPETBLMinOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALTYPETBLMinOrderByAggregateInput(
          type: $enumDecodeNullable(_$SortOrderEnumMap, json['TYPE']),
          content: $enumDecodeNullable(_$SortOrderEnumMap, json['CONTENT']),
          contentBak:
              $enumDecodeNullable(_$SortOrderEnumMap, json['CONTENT_BAK']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$APPROVALTYPETBLMinOrderByAggregateInputToJson(
    APPROVALTYPETBLMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('TYPE', _$SortOrderEnumMap[instance.type]);
  writeNotNull('CONTENT', _$SortOrderEnumMap[instance.content]);
  writeNotNull('CONTENT_BAK', _$SortOrderEnumMap[instance.contentBak]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

APPROVALUSERTBLAPPROVALIDAPPROVALUSRIDAPPROVALUSRTYPECompoundUniqueInput
    _$APPROVALUSERTBLAPPROVALIDAPPROVALUSRIDAPPROVALUSRTYPECompoundUniqueInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALUSERTBLAPPROVALIDAPPROVALUSRIDAPPROVALUSRTYPECompoundUniqueInput(
          approvalId: json['APPROVAL_ID'] as String,
          approvalUsrId: json['APPROVAL_USR_ID'] as String,
          approvalUsrType: json['APPROVAL_USR_TYPE'] as String,
        );

Map<String, dynamic>
    _$APPROVALUSERTBLAPPROVALIDAPPROVALUSRIDAPPROVALUSRTYPECompoundUniqueInputToJson(
            APPROVALUSERTBLAPPROVALIDAPPROVALUSRIDAPPROVALUSRTYPECompoundUniqueInput
                instance) =>
        <String, dynamic>{
          'APPROVAL_ID': instance.approvalId,
          'APPROVAL_USR_ID': instance.approvalUsrId,
          'APPROVAL_USR_TYPE': instance.approvalUsrType,
        };

APPROVALUSERTBLCountOrderByAggregateInput
    _$APPROVALUSERTBLCountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALUSERTBLCountOrderByAggregateInput(
          approvalId:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_ID']),
          approvalUsrId:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_USR_ID']),
          approvalUsrGradeCd: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_USR_GRADE_CD']),
          approvalUsrType: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_USR_TYPE']),
          approvalUsrSort: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_USR_SORT']),
          approvalProcUserYn: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_PROC_USER_YN']),
          approvalProcYn:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_PROC_YN']),
          approvalProcDate: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_PROC_DATE']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$APPROVALUSERTBLCountOrderByAggregateInputToJson(
    APPROVALUSERTBLCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_ID', _$SortOrderEnumMap[instance.approvalId]);
  writeNotNull('APPROVAL_USR_ID', _$SortOrderEnumMap[instance.approvalUsrId]);
  writeNotNull(
      'APPROVAL_USR_GRADE_CD', _$SortOrderEnumMap[instance.approvalUsrGradeCd]);
  writeNotNull(
      'APPROVAL_USR_TYPE', _$SortOrderEnumMap[instance.approvalUsrType]);
  writeNotNull(
      'APPROVAL_USR_SORT', _$SortOrderEnumMap[instance.approvalUsrSort]);
  writeNotNull(
      'APPROVAL_PROC_USER_YN', _$SortOrderEnumMap[instance.approvalProcUserYn]);
  writeNotNull('APPROVAL_PROC_YN', _$SortOrderEnumMap[instance.approvalProcYn]);
  writeNotNull(
      'APPROVAL_PROC_DATE', _$SortOrderEnumMap[instance.approvalProcDate]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

APPROVALUSERTBLAvgOrderByAggregateInput
    _$APPROVALUSERTBLAvgOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALUSERTBLAvgOrderByAggregateInput(
          approvalUsrSort: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_USR_SORT']),
        );

Map<String, dynamic> _$APPROVALUSERTBLAvgOrderByAggregateInputToJson(
    APPROVALUSERTBLAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull(
      'APPROVAL_USR_SORT', _$SortOrderEnumMap[instance.approvalUsrSort]);
  return val;
}

APPROVALUSERTBLMaxOrderByAggregateInput
    _$APPROVALUSERTBLMaxOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALUSERTBLMaxOrderByAggregateInput(
          approvalId:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_ID']),
          approvalUsrId:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_USR_ID']),
          approvalUsrGradeCd: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_USR_GRADE_CD']),
          approvalUsrType: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_USR_TYPE']),
          approvalUsrSort: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_USR_SORT']),
          approvalProcUserYn: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_PROC_USER_YN']),
          approvalProcYn:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_PROC_YN']),
          approvalProcDate: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_PROC_DATE']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$APPROVALUSERTBLMaxOrderByAggregateInputToJson(
    APPROVALUSERTBLMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_ID', _$SortOrderEnumMap[instance.approvalId]);
  writeNotNull('APPROVAL_USR_ID', _$SortOrderEnumMap[instance.approvalUsrId]);
  writeNotNull(
      'APPROVAL_USR_GRADE_CD', _$SortOrderEnumMap[instance.approvalUsrGradeCd]);
  writeNotNull(
      'APPROVAL_USR_TYPE', _$SortOrderEnumMap[instance.approvalUsrType]);
  writeNotNull(
      'APPROVAL_USR_SORT', _$SortOrderEnumMap[instance.approvalUsrSort]);
  writeNotNull(
      'APPROVAL_PROC_USER_YN', _$SortOrderEnumMap[instance.approvalProcUserYn]);
  writeNotNull('APPROVAL_PROC_YN', _$SortOrderEnumMap[instance.approvalProcYn]);
  writeNotNull(
      'APPROVAL_PROC_DATE', _$SortOrderEnumMap[instance.approvalProcDate]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

APPROVALUSERTBLMinOrderByAggregateInput
    _$APPROVALUSERTBLMinOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALUSERTBLMinOrderByAggregateInput(
          approvalId:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_ID']),
          approvalUsrId:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_USR_ID']),
          approvalUsrGradeCd: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_USR_GRADE_CD']),
          approvalUsrType: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_USR_TYPE']),
          approvalUsrSort: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_USR_SORT']),
          approvalProcUserYn: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_PROC_USER_YN']),
          approvalProcYn:
              $enumDecodeNullable(_$SortOrderEnumMap, json['APPROVAL_PROC_YN']),
          approvalProcDate: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_PROC_DATE']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$APPROVALUSERTBLMinOrderByAggregateInputToJson(
    APPROVALUSERTBLMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_ID', _$SortOrderEnumMap[instance.approvalId]);
  writeNotNull('APPROVAL_USR_ID', _$SortOrderEnumMap[instance.approvalUsrId]);
  writeNotNull(
      'APPROVAL_USR_GRADE_CD', _$SortOrderEnumMap[instance.approvalUsrGradeCd]);
  writeNotNull(
      'APPROVAL_USR_TYPE', _$SortOrderEnumMap[instance.approvalUsrType]);
  writeNotNull(
      'APPROVAL_USR_SORT', _$SortOrderEnumMap[instance.approvalUsrSort]);
  writeNotNull(
      'APPROVAL_PROC_USER_YN', _$SortOrderEnumMap[instance.approvalProcUserYn]);
  writeNotNull('APPROVAL_PROC_YN', _$SortOrderEnumMap[instance.approvalProcYn]);
  writeNotNull(
      'APPROVAL_PROC_DATE', _$SortOrderEnumMap[instance.approvalProcDate]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

APPROVALUSERTBLSumOrderByAggregateInput
    _$APPROVALUSERTBLSumOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        APPROVALUSERTBLSumOrderByAggregateInput(
          approvalUsrSort: $enumDecodeNullable(
              _$SortOrderEnumMap, json['APPROVAL_USR_SORT']),
        );

Map<String, dynamic> _$APPROVALUSERTBLSumOrderByAggregateInputToJson(
    APPROVALUSERTBLSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull(
      'APPROVAL_USR_SORT', _$SortOrderEnumMap[instance.approvalUsrSort]);
  return val;
}

BOOKASSETTBLCountOrderByAggregateInput
    _$BOOKASSETTBLCountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        BOOKASSETTBLCountOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          assetNo: $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_NO']),
          bookNm: $enumDecodeNullable(_$SortOrderEnumMap, json['BOOK_NM']),
          cnt: $enumDecodeNullable(_$SortOrderEnumMap, json['CNT']),
          publisher: $enumDecodeNullable(_$SortOrderEnumMap, json['PUBLISHER']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
          buyDate: $enumDecodeNullable(_$SortOrderEnumMap, json['BUY_DATE']),
          mngDept: $enumDecodeNullable(_$SortOrderEnumMap, json['MNG_DEPT']),
          rentYn: $enumDecodeNullable(_$SortOrderEnumMap, json['RENT_YN']),
          rentUser: $enumDecodeNullable(_$SortOrderEnumMap, json['RENT_USER']),
          remarks: $enumDecodeNullable(_$SortOrderEnumMap, json['REMARKS']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
        );

Map<String, dynamic> _$BOOKASSETTBLCountOrderByAggregateInputToJson(
    BOOKASSETTBLCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ASSET_NO', _$SortOrderEnumMap[instance.assetNo]);
  writeNotNull('BOOK_NM', _$SortOrderEnumMap[instance.bookNm]);
  writeNotNull('CNT', _$SortOrderEnumMap[instance.cnt]);
  writeNotNull('PUBLISHER', _$SortOrderEnumMap[instance.publisher]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  writeNotNull('BUY_DATE', _$SortOrderEnumMap[instance.buyDate]);
  writeNotNull('MNG_DEPT', _$SortOrderEnumMap[instance.mngDept]);
  writeNotNull('RENT_YN', _$SortOrderEnumMap[instance.rentYn]);
  writeNotNull('RENT_USER', _$SortOrderEnumMap[instance.rentUser]);
  writeNotNull('REMARKS', _$SortOrderEnumMap[instance.remarks]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  return val;
}

BOOKASSETTBLAvgOrderByAggregateInput
    _$BOOKASSETTBLAvgOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        BOOKASSETTBLAvgOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          cnt: $enumDecodeNullable(_$SortOrderEnumMap, json['CNT']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
        );

Map<String, dynamic> _$BOOKASSETTBLAvgOrderByAggregateInputToJson(
    BOOKASSETTBLAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('CNT', _$SortOrderEnumMap[instance.cnt]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  return val;
}

BOOKASSETTBLMaxOrderByAggregateInput
    _$BOOKASSETTBLMaxOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        BOOKASSETTBLMaxOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          assetNo: $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_NO']),
          bookNm: $enumDecodeNullable(_$SortOrderEnumMap, json['BOOK_NM']),
          cnt: $enumDecodeNullable(_$SortOrderEnumMap, json['CNT']),
          publisher: $enumDecodeNullable(_$SortOrderEnumMap, json['PUBLISHER']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
          buyDate: $enumDecodeNullable(_$SortOrderEnumMap, json['BUY_DATE']),
          mngDept: $enumDecodeNullable(_$SortOrderEnumMap, json['MNG_DEPT']),
          rentYn: $enumDecodeNullable(_$SortOrderEnumMap, json['RENT_YN']),
          rentUser: $enumDecodeNullable(_$SortOrderEnumMap, json['RENT_USER']),
          remarks: $enumDecodeNullable(_$SortOrderEnumMap, json['REMARKS']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
        );

Map<String, dynamic> _$BOOKASSETTBLMaxOrderByAggregateInputToJson(
    BOOKASSETTBLMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ASSET_NO', _$SortOrderEnumMap[instance.assetNo]);
  writeNotNull('BOOK_NM', _$SortOrderEnumMap[instance.bookNm]);
  writeNotNull('CNT', _$SortOrderEnumMap[instance.cnt]);
  writeNotNull('PUBLISHER', _$SortOrderEnumMap[instance.publisher]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  writeNotNull('BUY_DATE', _$SortOrderEnumMap[instance.buyDate]);
  writeNotNull('MNG_DEPT', _$SortOrderEnumMap[instance.mngDept]);
  writeNotNull('RENT_YN', _$SortOrderEnumMap[instance.rentYn]);
  writeNotNull('RENT_USER', _$SortOrderEnumMap[instance.rentUser]);
  writeNotNull('REMARKS', _$SortOrderEnumMap[instance.remarks]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  return val;
}

BOOKASSETTBLMinOrderByAggregateInput
    _$BOOKASSETTBLMinOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        BOOKASSETTBLMinOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          assetNo: $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_NO']),
          bookNm: $enumDecodeNullable(_$SortOrderEnumMap, json['BOOK_NM']),
          cnt: $enumDecodeNullable(_$SortOrderEnumMap, json['CNT']),
          publisher: $enumDecodeNullable(_$SortOrderEnumMap, json['PUBLISHER']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
          buyDate: $enumDecodeNullable(_$SortOrderEnumMap, json['BUY_DATE']),
          mngDept: $enumDecodeNullable(_$SortOrderEnumMap, json['MNG_DEPT']),
          rentYn: $enumDecodeNullable(_$SortOrderEnumMap, json['RENT_YN']),
          rentUser: $enumDecodeNullable(_$SortOrderEnumMap, json['RENT_USER']),
          remarks: $enumDecodeNullable(_$SortOrderEnumMap, json['REMARKS']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
        );

Map<String, dynamic> _$BOOKASSETTBLMinOrderByAggregateInputToJson(
    BOOKASSETTBLMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ASSET_NO', _$SortOrderEnumMap[instance.assetNo]);
  writeNotNull('BOOK_NM', _$SortOrderEnumMap[instance.bookNm]);
  writeNotNull('CNT', _$SortOrderEnumMap[instance.cnt]);
  writeNotNull('PUBLISHER', _$SortOrderEnumMap[instance.publisher]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  writeNotNull('BUY_DATE', _$SortOrderEnumMap[instance.buyDate]);
  writeNotNull('MNG_DEPT', _$SortOrderEnumMap[instance.mngDept]);
  writeNotNull('RENT_YN', _$SortOrderEnumMap[instance.rentYn]);
  writeNotNull('RENT_USER', _$SortOrderEnumMap[instance.rentUser]);
  writeNotNull('REMARKS', _$SortOrderEnumMap[instance.remarks]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  return val;
}

BOOKASSETTBLSumOrderByAggregateInput
    _$BOOKASSETTBLSumOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        BOOKASSETTBLSumOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          cnt: $enumDecodeNullable(_$SortOrderEnumMap, json['CNT']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
        );

Map<String, dynamic> _$BOOKASSETTBLSumOrderByAggregateInputToJson(
    BOOKASSETTBLSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('CNT', _$SortOrderEnumMap[instance.cnt]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  return val;
}

CARASSETINSURTBLCountOrderByAggregateInput
    _$CARASSETINSURTBLCountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        CARASSETINSURTBLCountOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          guarantee: $enumDecodeNullable(_$SortOrderEnumMap, json['GUARANTEE']),
        );

Map<String, dynamic> _$CARASSETINSURTBLCountOrderByAggregateInputToJson(
    CARASSETINSURTBLCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('GUARANTEE', _$SortOrderEnumMap[instance.guarantee]);
  return val;
}

CARASSETINSURTBLAvgOrderByAggregateInput
    _$CARASSETINSURTBLAvgOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        CARASSETINSURTBLAvgOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
        );

Map<String, dynamic> _$CARASSETINSURTBLAvgOrderByAggregateInputToJson(
    CARASSETINSURTBLAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  return val;
}

CARASSETINSURTBLMaxOrderByAggregateInput
    _$CARASSETINSURTBLMaxOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        CARASSETINSURTBLMaxOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          guarantee: $enumDecodeNullable(_$SortOrderEnumMap, json['GUARANTEE']),
        );

Map<String, dynamic> _$CARASSETINSURTBLMaxOrderByAggregateInputToJson(
    CARASSETINSURTBLMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('GUARANTEE', _$SortOrderEnumMap[instance.guarantee]);
  return val;
}

CARASSETINSURTBLMinOrderByAggregateInput
    _$CARASSETINSURTBLMinOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        CARASSETINSURTBLMinOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          guarantee: $enumDecodeNullable(_$SortOrderEnumMap, json['GUARANTEE']),
        );

Map<String, dynamic> _$CARASSETINSURTBLMinOrderByAggregateInputToJson(
    CARASSETINSURTBLMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('GUARANTEE', _$SortOrderEnumMap[instance.guarantee]);
  return val;
}

CARASSETINSURTBLSumOrderByAggregateInput
    _$CARASSETINSURTBLSumOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        CARASSETINSURTBLSumOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
        );

Map<String, dynamic> _$CARASSETINSURTBLSumOrderByAggregateInputToJson(
    CARASSETINSURTBLSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  return val;
}

CARASSETTBLCountOrderByAggregateInput
    _$CARASSETTBLCountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        CARASSETTBLCountOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          assetNo: $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_NO']),
          modelNo: $enumDecodeNullable(_$SortOrderEnumMap, json['MODEL_NO']),
          carNo: $enumDecodeNullable(_$SortOrderEnumMap, json['CAR_NO']),
          owner: $enumDecodeNullable(_$SortOrderEnumMap, json['OWNER']),
          ownerType:
              $enumDecodeNullable(_$SortOrderEnumMap, json['OWNER_TYPE']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
          buyDate: $enumDecodeNullable(_$SortOrderEnumMap, json['BUY_DATE']),
          seller: $enumDecodeNullable(_$SortOrderEnumMap, json['SELLER']),
          remarks: $enumDecodeNullable(_$SortOrderEnumMap, json['REMARKS']),
          mngrNm: $enumDecodeNullable(_$SortOrderEnumMap, json['MNGR_NM']),
          fuel: $enumDecodeNullable(_$SortOrderEnumMap, json['FUEL']),
          manuDt: $enumDecodeNullable(_$SortOrderEnumMap, json['MANU_DT']),
          effic: $enumDecodeNullable(_$SortOrderEnumMap, json['EFFIC']),
          insur: $enumDecodeNullable(_$SortOrderEnumMap, json['INSUR']),
          insurMngr:
              $enumDecodeNullable(_$SortOrderEnumMap, json['INSUR_MNGR']),
          emgTel: $enumDecodeNullable(_$SortOrderEnumMap, json['EMG_TEL']),
          storeNm: $enumDecodeNullable(_$SortOrderEnumMap, json['STORE_NM']),
          storeTel: $enumDecodeNullable(_$SortOrderEnumMap, json['STORE_TEL']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
        );

Map<String, dynamic> _$CARASSETTBLCountOrderByAggregateInputToJson(
    CARASSETTBLCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ASSET_NO', _$SortOrderEnumMap[instance.assetNo]);
  writeNotNull('MODEL_NO', _$SortOrderEnumMap[instance.modelNo]);
  writeNotNull('CAR_NO', _$SortOrderEnumMap[instance.carNo]);
  writeNotNull('OWNER', _$SortOrderEnumMap[instance.owner]);
  writeNotNull('OWNER_TYPE', _$SortOrderEnumMap[instance.ownerType]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  writeNotNull('BUY_DATE', _$SortOrderEnumMap[instance.buyDate]);
  writeNotNull('SELLER', _$SortOrderEnumMap[instance.seller]);
  writeNotNull('REMARKS', _$SortOrderEnumMap[instance.remarks]);
  writeNotNull('MNGR_NM', _$SortOrderEnumMap[instance.mngrNm]);
  writeNotNull('FUEL', _$SortOrderEnumMap[instance.fuel]);
  writeNotNull('MANU_DT', _$SortOrderEnumMap[instance.manuDt]);
  writeNotNull('EFFIC', _$SortOrderEnumMap[instance.effic]);
  writeNotNull('INSUR', _$SortOrderEnumMap[instance.insur]);
  writeNotNull('INSUR_MNGR', _$SortOrderEnumMap[instance.insurMngr]);
  writeNotNull('EMG_TEL', _$SortOrderEnumMap[instance.emgTel]);
  writeNotNull('STORE_NM', _$SortOrderEnumMap[instance.storeNm]);
  writeNotNull('STORE_TEL', _$SortOrderEnumMap[instance.storeTel]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  return val;
}

CARASSETTBLAvgOrderByAggregateInput
    _$CARASSETTBLAvgOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        CARASSETTBLAvgOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
        );

Map<String, dynamic> _$CARASSETTBLAvgOrderByAggregateInputToJson(
    CARASSETTBLAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  return val;
}

CARASSETTBLMaxOrderByAggregateInput
    _$CARASSETTBLMaxOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        CARASSETTBLMaxOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          assetNo: $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_NO']),
          modelNo: $enumDecodeNullable(_$SortOrderEnumMap, json['MODEL_NO']),
          carNo: $enumDecodeNullable(_$SortOrderEnumMap, json['CAR_NO']),
          owner: $enumDecodeNullable(_$SortOrderEnumMap, json['OWNER']),
          ownerType:
              $enumDecodeNullable(_$SortOrderEnumMap, json['OWNER_TYPE']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
          buyDate: $enumDecodeNullable(_$SortOrderEnumMap, json['BUY_DATE']),
          seller: $enumDecodeNullable(_$SortOrderEnumMap, json['SELLER']),
          remarks: $enumDecodeNullable(_$SortOrderEnumMap, json['REMARKS']),
          mngrNm: $enumDecodeNullable(_$SortOrderEnumMap, json['MNGR_NM']),
          fuel: $enumDecodeNullable(_$SortOrderEnumMap, json['FUEL']),
          manuDt: $enumDecodeNullable(_$SortOrderEnumMap, json['MANU_DT']),
          effic: $enumDecodeNullable(_$SortOrderEnumMap, json['EFFIC']),
          insur: $enumDecodeNullable(_$SortOrderEnumMap, json['INSUR']),
          insurMngr:
              $enumDecodeNullable(_$SortOrderEnumMap, json['INSUR_MNGR']),
          emgTel: $enumDecodeNullable(_$SortOrderEnumMap, json['EMG_TEL']),
          storeNm: $enumDecodeNullable(_$SortOrderEnumMap, json['STORE_NM']),
          storeTel: $enumDecodeNullable(_$SortOrderEnumMap, json['STORE_TEL']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
        );

Map<String, dynamic> _$CARASSETTBLMaxOrderByAggregateInputToJson(
    CARASSETTBLMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ASSET_NO', _$SortOrderEnumMap[instance.assetNo]);
  writeNotNull('MODEL_NO', _$SortOrderEnumMap[instance.modelNo]);
  writeNotNull('CAR_NO', _$SortOrderEnumMap[instance.carNo]);
  writeNotNull('OWNER', _$SortOrderEnumMap[instance.owner]);
  writeNotNull('OWNER_TYPE', _$SortOrderEnumMap[instance.ownerType]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  writeNotNull('BUY_DATE', _$SortOrderEnumMap[instance.buyDate]);
  writeNotNull('SELLER', _$SortOrderEnumMap[instance.seller]);
  writeNotNull('REMARKS', _$SortOrderEnumMap[instance.remarks]);
  writeNotNull('MNGR_NM', _$SortOrderEnumMap[instance.mngrNm]);
  writeNotNull('FUEL', _$SortOrderEnumMap[instance.fuel]);
  writeNotNull('MANU_DT', _$SortOrderEnumMap[instance.manuDt]);
  writeNotNull('EFFIC', _$SortOrderEnumMap[instance.effic]);
  writeNotNull('INSUR', _$SortOrderEnumMap[instance.insur]);
  writeNotNull('INSUR_MNGR', _$SortOrderEnumMap[instance.insurMngr]);
  writeNotNull('EMG_TEL', _$SortOrderEnumMap[instance.emgTel]);
  writeNotNull('STORE_NM', _$SortOrderEnumMap[instance.storeNm]);
  writeNotNull('STORE_TEL', _$SortOrderEnumMap[instance.storeTel]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  return val;
}

CARASSETTBLMinOrderByAggregateInput
    _$CARASSETTBLMinOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        CARASSETTBLMinOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          assetNo: $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_NO']),
          modelNo: $enumDecodeNullable(_$SortOrderEnumMap, json['MODEL_NO']),
          carNo: $enumDecodeNullable(_$SortOrderEnumMap, json['CAR_NO']),
          owner: $enumDecodeNullable(_$SortOrderEnumMap, json['OWNER']),
          ownerType:
              $enumDecodeNullable(_$SortOrderEnumMap, json['OWNER_TYPE']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
          buyDate: $enumDecodeNullable(_$SortOrderEnumMap, json['BUY_DATE']),
          seller: $enumDecodeNullable(_$SortOrderEnumMap, json['SELLER']),
          remarks: $enumDecodeNullable(_$SortOrderEnumMap, json['REMARKS']),
          mngrNm: $enumDecodeNullable(_$SortOrderEnumMap, json['MNGR_NM']),
          fuel: $enumDecodeNullable(_$SortOrderEnumMap, json['FUEL']),
          manuDt: $enumDecodeNullable(_$SortOrderEnumMap, json['MANU_DT']),
          effic: $enumDecodeNullable(_$SortOrderEnumMap, json['EFFIC']),
          insur: $enumDecodeNullable(_$SortOrderEnumMap, json['INSUR']),
          insurMngr:
              $enumDecodeNullable(_$SortOrderEnumMap, json['INSUR_MNGR']),
          emgTel: $enumDecodeNullable(_$SortOrderEnumMap, json['EMG_TEL']),
          storeNm: $enumDecodeNullable(_$SortOrderEnumMap, json['STORE_NM']),
          storeTel: $enumDecodeNullable(_$SortOrderEnumMap, json['STORE_TEL']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
        );

Map<String, dynamic> _$CARASSETTBLMinOrderByAggregateInputToJson(
    CARASSETTBLMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ASSET_NO', _$SortOrderEnumMap[instance.assetNo]);
  writeNotNull('MODEL_NO', _$SortOrderEnumMap[instance.modelNo]);
  writeNotNull('CAR_NO', _$SortOrderEnumMap[instance.carNo]);
  writeNotNull('OWNER', _$SortOrderEnumMap[instance.owner]);
  writeNotNull('OWNER_TYPE', _$SortOrderEnumMap[instance.ownerType]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  writeNotNull('BUY_DATE', _$SortOrderEnumMap[instance.buyDate]);
  writeNotNull('SELLER', _$SortOrderEnumMap[instance.seller]);
  writeNotNull('REMARKS', _$SortOrderEnumMap[instance.remarks]);
  writeNotNull('MNGR_NM', _$SortOrderEnumMap[instance.mngrNm]);
  writeNotNull('FUEL', _$SortOrderEnumMap[instance.fuel]);
  writeNotNull('MANU_DT', _$SortOrderEnumMap[instance.manuDt]);
  writeNotNull('EFFIC', _$SortOrderEnumMap[instance.effic]);
  writeNotNull('INSUR', _$SortOrderEnumMap[instance.insur]);
  writeNotNull('INSUR_MNGR', _$SortOrderEnumMap[instance.insurMngr]);
  writeNotNull('EMG_TEL', _$SortOrderEnumMap[instance.emgTel]);
  writeNotNull('STORE_NM', _$SortOrderEnumMap[instance.storeNm]);
  writeNotNull('STORE_TEL', _$SortOrderEnumMap[instance.storeTel]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  return val;
}

CARASSETTBLSumOrderByAggregateInput
    _$CARASSETTBLSumOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        CARASSETTBLSumOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
        );

Map<String, dynamic> _$CARASSETTBLSumOrderByAggregateInputToJson(
    CARASSETTBLSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  return val;
}

CARCHARGETBLCountOrderByAggregateInput
    _$CARCHARGETBLCountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        CARCHARGETBLCountOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          item: $enumDecodeNullable(_$SortOrderEnumMap, json['ITEM']),
          charge: $enumDecodeNullable(_$SortOrderEnumMap, json['CHARGE']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          memo: $enumDecodeNullable(_$SortOrderEnumMap, json['MEMO']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
        );

Map<String, dynamic> _$CARCHARGETBLCountOrderByAggregateInputToJson(
    CARCHARGETBLCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ITEM', _$SortOrderEnumMap[instance.item]);
  writeNotNull('CHARGE', _$SortOrderEnumMap[instance.charge]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('MEMO', _$SortOrderEnumMap[instance.memo]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  return val;
}

CARCHARGETBLAvgOrderByAggregateInput
    _$CARCHARGETBLAvgOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        CARCHARGETBLAvgOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          charge: $enumDecodeNullable(_$SortOrderEnumMap, json['CHARGE']),
        );

Map<String, dynamic> _$CARCHARGETBLAvgOrderByAggregateInputToJson(
    CARCHARGETBLAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('CHARGE', _$SortOrderEnumMap[instance.charge]);
  return val;
}

CARCHARGETBLMaxOrderByAggregateInput
    _$CARCHARGETBLMaxOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        CARCHARGETBLMaxOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          item: $enumDecodeNullable(_$SortOrderEnumMap, json['ITEM']),
          charge: $enumDecodeNullable(_$SortOrderEnumMap, json['CHARGE']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          memo: $enumDecodeNullable(_$SortOrderEnumMap, json['MEMO']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
        );

Map<String, dynamic> _$CARCHARGETBLMaxOrderByAggregateInputToJson(
    CARCHARGETBLMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ITEM', _$SortOrderEnumMap[instance.item]);
  writeNotNull('CHARGE', _$SortOrderEnumMap[instance.charge]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('MEMO', _$SortOrderEnumMap[instance.memo]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  return val;
}

CARCHARGETBLMinOrderByAggregateInput
    _$CARCHARGETBLMinOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        CARCHARGETBLMinOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          item: $enumDecodeNullable(_$SortOrderEnumMap, json['ITEM']),
          charge: $enumDecodeNullable(_$SortOrderEnumMap, json['CHARGE']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          memo: $enumDecodeNullable(_$SortOrderEnumMap, json['MEMO']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
        );

Map<String, dynamic> _$CARCHARGETBLMinOrderByAggregateInputToJson(
    CARCHARGETBLMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ITEM', _$SortOrderEnumMap[instance.item]);
  writeNotNull('CHARGE', _$SortOrderEnumMap[instance.charge]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('MEMO', _$SortOrderEnumMap[instance.memo]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  return val;
}

CARCHARGETBLSumOrderByAggregateInput
    _$CARCHARGETBLSumOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        CARCHARGETBLSumOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          charge: $enumDecodeNullable(_$SortOrderEnumMap, json['CHARGE']),
        );

Map<String, dynamic> _$CARCHARGETBLSumOrderByAggregateInputToJson(
    CARCHARGETBLSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('CHARGE', _$SortOrderEnumMap[instance.charge]);
  return val;
}

CARINFOTBLCountOrderByAggregateInput
    _$CARINFOTBLCountOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        CARINFOTBLCountOrderByAggregateInput(
          sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
          carManageNo:
              $enumDecodeNullable(_$SortOrderEnumMap, json['CAR_MANAGE_NO']),
          model: $enumDecodeNullable(_$SortOrderEnumMap, json['MODEL']),
          userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          disusedYn:
              $enumDecodeNullable(_$SortOrderEnumMap, json['DISUSED_YN']),
        );

Map<String, dynamic> _$CARINFOTBLCountOrderByAggregateInputToJson(
    CARINFOTBLCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('CAR_MANAGE_NO', _$SortOrderEnumMap[instance.carManageNo]);
  writeNotNull('MODEL', _$SortOrderEnumMap[instance.model]);
  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('DISUSED_YN', _$SortOrderEnumMap[instance.disusedYn]);
  return val;
}

CARINFOTBLAvgOrderByAggregateInput _$CARINFOTBLAvgOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    CARINFOTBLAvgOrderByAggregateInput(
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
    );

Map<String, dynamic> _$CARINFOTBLAvgOrderByAggregateInputToJson(
    CARINFOTBLAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  return val;
}

CARINFOTBLMaxOrderByAggregateInput _$CARINFOTBLMaxOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    CARINFOTBLMaxOrderByAggregateInput(
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
      carManageNo:
          $enumDecodeNullable(_$SortOrderEnumMap, json['CAR_MANAGE_NO']),
      model: $enumDecodeNullable(_$SortOrderEnumMap, json['MODEL']),
      userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      disusedYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DISUSED_YN']),
    );

Map<String, dynamic> _$CARINFOTBLMaxOrderByAggregateInputToJson(
    CARINFOTBLMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('CAR_MANAGE_NO', _$SortOrderEnumMap[instance.carManageNo]);
  writeNotNull('MODEL', _$SortOrderEnumMap[instance.model]);
  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('DISUSED_YN', _$SortOrderEnumMap[instance.disusedYn]);
  return val;
}

CARINFOTBLMinOrderByAggregateInput _$CARINFOTBLMinOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    CARINFOTBLMinOrderByAggregateInput(
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
      carManageNo:
          $enumDecodeNullable(_$SortOrderEnumMap, json['CAR_MANAGE_NO']),
      model: $enumDecodeNullable(_$SortOrderEnumMap, json['MODEL']),
      userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      disusedYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DISUSED_YN']),
    );

Map<String, dynamic> _$CARINFOTBLMinOrderByAggregateInputToJson(
    CARINFOTBLMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('CAR_MANAGE_NO', _$SortOrderEnumMap[instance.carManageNo]);
  writeNotNull('MODEL', _$SortOrderEnumMap[instance.model]);
  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('DISUSED_YN', _$SortOrderEnumMap[instance.disusedYn]);
  return val;
}

CARINFOTBLSumOrderByAggregateInput _$CARINFOTBLSumOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    CARINFOTBLSumOrderByAggregateInput(
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
    );

Map<String, dynamic> _$CARINFOTBLSumOrderByAggregateInputToJson(
    CARINFOTBLSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  return val;
}

CARMILEAGETBLCountOrderByAggregateInput
    _$CARMILEAGETBLCountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        CARMILEAGETBLCountOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          carManageNo:
              $enumDecodeNullable(_$SortOrderEnumMap, json['CAR_MANAGE_NO']),
          forUse: $enumDecodeNullable(_$SortOrderEnumMap, json['FOR_USE']),
          stPoint: $enumDecodeNullable(_$SortOrderEnumMap, json['ST_POINT']),
          destination:
              $enumDecodeNullable(_$SortOrderEnumMap, json['DESTINATION']),
          mileage: $enumDecodeNullable(_$SortOrderEnumMap, json['MILEAGE']),
          totalMileage:
              $enumDecodeNullable(_$SortOrderEnumMap, json['TOTAL_MILEAGE']),
          recordDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['RECORD_DATE']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          editorId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDITOR_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          apprYn: $enumDecodeNullable(_$SortOrderEnumMap, json['APPR_YN']),
        );

Map<String, dynamic> _$CARMILEAGETBLCountOrderByAggregateInputToJson(
    CARMILEAGETBLCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('CAR_MANAGE_NO', _$SortOrderEnumMap[instance.carManageNo]);
  writeNotNull('FOR_USE', _$SortOrderEnumMap[instance.forUse]);
  writeNotNull('ST_POINT', _$SortOrderEnumMap[instance.stPoint]);
  writeNotNull('DESTINATION', _$SortOrderEnumMap[instance.destination]);
  writeNotNull('MILEAGE', _$SortOrderEnumMap[instance.mileage]);
  writeNotNull('TOTAL_MILEAGE', _$SortOrderEnumMap[instance.totalMileage]);
  writeNotNull('RECORD_DATE', _$SortOrderEnumMap[instance.recordDate]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('EDITOR_ID', _$SortOrderEnumMap[instance.editorId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('APPR_YN', _$SortOrderEnumMap[instance.apprYn]);
  return val;
}

CARMILEAGETBLAvgOrderByAggregateInput
    _$CARMILEAGETBLAvgOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        CARMILEAGETBLAvgOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mileage: $enumDecodeNullable(_$SortOrderEnumMap, json['MILEAGE']),
          totalMileage:
              $enumDecodeNullable(_$SortOrderEnumMap, json['TOTAL_MILEAGE']),
        );

Map<String, dynamic> _$CARMILEAGETBLAvgOrderByAggregateInputToJson(
    CARMILEAGETBLAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MILEAGE', _$SortOrderEnumMap[instance.mileage]);
  writeNotNull('TOTAL_MILEAGE', _$SortOrderEnumMap[instance.totalMileage]);
  return val;
}

CARMILEAGETBLMaxOrderByAggregateInput
    _$CARMILEAGETBLMaxOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        CARMILEAGETBLMaxOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          carManageNo:
              $enumDecodeNullable(_$SortOrderEnumMap, json['CAR_MANAGE_NO']),
          forUse: $enumDecodeNullable(_$SortOrderEnumMap, json['FOR_USE']),
          stPoint: $enumDecodeNullable(_$SortOrderEnumMap, json['ST_POINT']),
          destination:
              $enumDecodeNullable(_$SortOrderEnumMap, json['DESTINATION']),
          mileage: $enumDecodeNullable(_$SortOrderEnumMap, json['MILEAGE']),
          totalMileage:
              $enumDecodeNullable(_$SortOrderEnumMap, json['TOTAL_MILEAGE']),
          recordDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['RECORD_DATE']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          editorId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDITOR_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          apprYn: $enumDecodeNullable(_$SortOrderEnumMap, json['APPR_YN']),
        );

Map<String, dynamic> _$CARMILEAGETBLMaxOrderByAggregateInputToJson(
    CARMILEAGETBLMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('CAR_MANAGE_NO', _$SortOrderEnumMap[instance.carManageNo]);
  writeNotNull('FOR_USE', _$SortOrderEnumMap[instance.forUse]);
  writeNotNull('ST_POINT', _$SortOrderEnumMap[instance.stPoint]);
  writeNotNull('DESTINATION', _$SortOrderEnumMap[instance.destination]);
  writeNotNull('MILEAGE', _$SortOrderEnumMap[instance.mileage]);
  writeNotNull('TOTAL_MILEAGE', _$SortOrderEnumMap[instance.totalMileage]);
  writeNotNull('RECORD_DATE', _$SortOrderEnumMap[instance.recordDate]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('EDITOR_ID', _$SortOrderEnumMap[instance.editorId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('APPR_YN', _$SortOrderEnumMap[instance.apprYn]);
  return val;
}

CARMILEAGETBLMinOrderByAggregateInput
    _$CARMILEAGETBLMinOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        CARMILEAGETBLMinOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          carManageNo:
              $enumDecodeNullable(_$SortOrderEnumMap, json['CAR_MANAGE_NO']),
          forUse: $enumDecodeNullable(_$SortOrderEnumMap, json['FOR_USE']),
          stPoint: $enumDecodeNullable(_$SortOrderEnumMap, json['ST_POINT']),
          destination:
              $enumDecodeNullable(_$SortOrderEnumMap, json['DESTINATION']),
          mileage: $enumDecodeNullable(_$SortOrderEnumMap, json['MILEAGE']),
          totalMileage:
              $enumDecodeNullable(_$SortOrderEnumMap, json['TOTAL_MILEAGE']),
          recordDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['RECORD_DATE']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          editorId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDITOR_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          apprYn: $enumDecodeNullable(_$SortOrderEnumMap, json['APPR_YN']),
        );

Map<String, dynamic> _$CARMILEAGETBLMinOrderByAggregateInputToJson(
    CARMILEAGETBLMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('CAR_MANAGE_NO', _$SortOrderEnumMap[instance.carManageNo]);
  writeNotNull('FOR_USE', _$SortOrderEnumMap[instance.forUse]);
  writeNotNull('ST_POINT', _$SortOrderEnumMap[instance.stPoint]);
  writeNotNull('DESTINATION', _$SortOrderEnumMap[instance.destination]);
  writeNotNull('MILEAGE', _$SortOrderEnumMap[instance.mileage]);
  writeNotNull('TOTAL_MILEAGE', _$SortOrderEnumMap[instance.totalMileage]);
  writeNotNull('RECORD_DATE', _$SortOrderEnumMap[instance.recordDate]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('EDITOR_ID', _$SortOrderEnumMap[instance.editorId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('APPR_YN', _$SortOrderEnumMap[instance.apprYn]);
  return val;
}

CARMILEAGETBLSumOrderByAggregateInput
    _$CARMILEAGETBLSumOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        CARMILEAGETBLSumOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mileage: $enumDecodeNullable(_$SortOrderEnumMap, json['MILEAGE']),
          totalMileage:
              $enumDecodeNullable(_$SortOrderEnumMap, json['TOTAL_MILEAGE']),
        );

Map<String, dynamic> _$CARMILEAGETBLSumOrderByAggregateInputToJson(
    CARMILEAGETBLSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MILEAGE', _$SortOrderEnumMap[instance.mileage]);
  writeNotNull('TOTAL_MILEAGE', _$SortOrderEnumMap[instance.totalMileage]);
  return val;
}

CARPARTREPLACETBLCountOrderByAggregateInput
    _$CARPARTREPLACETBLCountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        CARPARTREPLACETBLCountOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          partNm: $enumDecodeNullable(_$SortOrderEnumMap, json['PART_NM']),
          replacePeriod:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPLACE_PERIOD']),
          reTotalMileage:
              $enumDecodeNullable(_$SortOrderEnumMap, json['RE_TOTAL_MILEAGE']),
          nowTotalMileage: $enumDecodeNullable(
              _$SortOrderEnumMap, json['NOW_TOTAL_MILEAGE']),
          remainMileage:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REMAIN_MILEAGE']),
          replaceCount:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPLACE_COUNT']),
          partReDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PART_RE_DATE']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
        );

Map<String, dynamic> _$CARPARTREPLACETBLCountOrderByAggregateInputToJson(
    CARPARTREPLACETBLCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('PART_NM', _$SortOrderEnumMap[instance.partNm]);
  writeNotNull('REPLACE_PERIOD', _$SortOrderEnumMap[instance.replacePeriod]);
  writeNotNull('RE_TOTAL_MILEAGE', _$SortOrderEnumMap[instance.reTotalMileage]);
  writeNotNull(
      'NOW_TOTAL_MILEAGE', _$SortOrderEnumMap[instance.nowTotalMileage]);
  writeNotNull('REMAIN_MILEAGE', _$SortOrderEnumMap[instance.remainMileage]);
  writeNotNull('REPLACE_COUNT', _$SortOrderEnumMap[instance.replaceCount]);
  writeNotNull('PART_RE_DATE', _$SortOrderEnumMap[instance.partReDate]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  return val;
}

CARPARTREPLACETBLAvgOrderByAggregateInput
    _$CARPARTREPLACETBLAvgOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        CARPARTREPLACETBLAvgOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          replacePeriod:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPLACE_PERIOD']),
          reTotalMileage:
              $enumDecodeNullable(_$SortOrderEnumMap, json['RE_TOTAL_MILEAGE']),
          nowTotalMileage: $enumDecodeNullable(
              _$SortOrderEnumMap, json['NOW_TOTAL_MILEAGE']),
          remainMileage:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REMAIN_MILEAGE']),
          replaceCount:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPLACE_COUNT']),
        );

Map<String, dynamic> _$CARPARTREPLACETBLAvgOrderByAggregateInputToJson(
    CARPARTREPLACETBLAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('REPLACE_PERIOD', _$SortOrderEnumMap[instance.replacePeriod]);
  writeNotNull('RE_TOTAL_MILEAGE', _$SortOrderEnumMap[instance.reTotalMileage]);
  writeNotNull(
      'NOW_TOTAL_MILEAGE', _$SortOrderEnumMap[instance.nowTotalMileage]);
  writeNotNull('REMAIN_MILEAGE', _$SortOrderEnumMap[instance.remainMileage]);
  writeNotNull('REPLACE_COUNT', _$SortOrderEnumMap[instance.replaceCount]);
  return val;
}

CARPARTREPLACETBLMaxOrderByAggregateInput
    _$CARPARTREPLACETBLMaxOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        CARPARTREPLACETBLMaxOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          partNm: $enumDecodeNullable(_$SortOrderEnumMap, json['PART_NM']),
          replacePeriod:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPLACE_PERIOD']),
          reTotalMileage:
              $enumDecodeNullable(_$SortOrderEnumMap, json['RE_TOTAL_MILEAGE']),
          nowTotalMileage: $enumDecodeNullable(
              _$SortOrderEnumMap, json['NOW_TOTAL_MILEAGE']),
          remainMileage:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REMAIN_MILEAGE']),
          replaceCount:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPLACE_COUNT']),
          partReDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PART_RE_DATE']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
        );

Map<String, dynamic> _$CARPARTREPLACETBLMaxOrderByAggregateInputToJson(
    CARPARTREPLACETBLMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('PART_NM', _$SortOrderEnumMap[instance.partNm]);
  writeNotNull('REPLACE_PERIOD', _$SortOrderEnumMap[instance.replacePeriod]);
  writeNotNull('RE_TOTAL_MILEAGE', _$SortOrderEnumMap[instance.reTotalMileage]);
  writeNotNull(
      'NOW_TOTAL_MILEAGE', _$SortOrderEnumMap[instance.nowTotalMileage]);
  writeNotNull('REMAIN_MILEAGE', _$SortOrderEnumMap[instance.remainMileage]);
  writeNotNull('REPLACE_COUNT', _$SortOrderEnumMap[instance.replaceCount]);
  writeNotNull('PART_RE_DATE', _$SortOrderEnumMap[instance.partReDate]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  return val;
}

CARPARTREPLACETBLMinOrderByAggregateInput
    _$CARPARTREPLACETBLMinOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        CARPARTREPLACETBLMinOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          partNm: $enumDecodeNullable(_$SortOrderEnumMap, json['PART_NM']),
          replacePeriod:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPLACE_PERIOD']),
          reTotalMileage:
              $enumDecodeNullable(_$SortOrderEnumMap, json['RE_TOTAL_MILEAGE']),
          nowTotalMileage: $enumDecodeNullable(
              _$SortOrderEnumMap, json['NOW_TOTAL_MILEAGE']),
          remainMileage:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REMAIN_MILEAGE']),
          replaceCount:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPLACE_COUNT']),
          partReDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PART_RE_DATE']),
          writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
        );

Map<String, dynamic> _$CARPARTREPLACETBLMinOrderByAggregateInputToJson(
    CARPARTREPLACETBLMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('PART_NM', _$SortOrderEnumMap[instance.partNm]);
  writeNotNull('REPLACE_PERIOD', _$SortOrderEnumMap[instance.replacePeriod]);
  writeNotNull('RE_TOTAL_MILEAGE', _$SortOrderEnumMap[instance.reTotalMileage]);
  writeNotNull(
      'NOW_TOTAL_MILEAGE', _$SortOrderEnumMap[instance.nowTotalMileage]);
  writeNotNull('REMAIN_MILEAGE', _$SortOrderEnumMap[instance.remainMileage]);
  writeNotNull('REPLACE_COUNT', _$SortOrderEnumMap[instance.replaceCount]);
  writeNotNull('PART_RE_DATE', _$SortOrderEnumMap[instance.partReDate]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  return val;
}

CARPARTREPLACETBLSumOrderByAggregateInput
    _$CARPARTREPLACETBLSumOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        CARPARTREPLACETBLSumOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          replacePeriod:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPLACE_PERIOD']),
          reTotalMileage:
              $enumDecodeNullable(_$SortOrderEnumMap, json['RE_TOTAL_MILEAGE']),
          nowTotalMileage: $enumDecodeNullable(
              _$SortOrderEnumMap, json['NOW_TOTAL_MILEAGE']),
          remainMileage:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REMAIN_MILEAGE']),
          replaceCount:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPLACE_COUNT']),
        );

Map<String, dynamic> _$CARPARTREPLACETBLSumOrderByAggregateInputToJson(
    CARPARTREPLACETBLSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('REPLACE_PERIOD', _$SortOrderEnumMap[instance.replacePeriod]);
  writeNotNull('RE_TOTAL_MILEAGE', _$SortOrderEnumMap[instance.reTotalMileage]);
  writeNotNull(
      'NOW_TOTAL_MILEAGE', _$SortOrderEnumMap[instance.nowTotalMileage]);
  writeNotNull('REMAIN_MILEAGE', _$SortOrderEnumMap[instance.remainMileage]);
  writeNotNull('REPLACE_COUNT', _$SortOrderEnumMap[instance.replaceCount]);
  return val;
}

BigIntNullableFilter _$BigIntNullableFilterFromJson(
        Map<String, dynamic> json) =>
    BigIntNullableFilter(
      equals: json['equals'] == null
          ? null
          : BigInt.parse(json['equals'] as String),
      $in:
          (json['in'] as List<dynamic>?)?.map((e) => BigInt.parse(e as String)),
      notIn: (json['notIn'] as List<dynamic>?)
          ?.map((e) => BigInt.parse(e as String)),
      lt: json['lt'] == null ? null : BigInt.parse(json['lt'] as String),
      lte: json['lte'] == null ? null : BigInt.parse(json['lte'] as String),
      gt: json['gt'] == null ? null : BigInt.parse(json['gt'] as String),
      gte: json['gte'] == null ? null : BigInt.parse(json['gte'] as String),
      not: json['not'] == null
          ? null
          : NestedBigIntNullableFilter.fromJson(
              json['not'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$BigIntNullableFilterToJson(
    BigIntNullableFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals?.toString());
  writeNotNull('in', instance.$in?.map((e) => e.toString()).toList());
  writeNotNull('notIn', instance.notIn?.map((e) => e.toString()).toList());
  writeNotNull('lt', instance.lt?.toString());
  writeNotNull('lte', instance.lte?.toString());
  writeNotNull('gt', instance.gt?.toString());
  writeNotNull('gte', instance.gte?.toString());
  writeNotNull('not', instance.not?.toJson());
  return val;
}

CARREPAIRLOGCountOrderByAggregateInput
    _$CARREPAIRLOGCountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        CARREPAIRLOGCountOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          assetNo: $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_NO']),
          repairDe: $enumDecodeNullable(_$SortOrderEnumMap, json['REPAIR_DE']),
          repairAmount:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPAIR_AMOUNT']),
          repairStore:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPAIR_STORE']),
          repairLog:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPAIR_LOG']),
          repairOwner:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPAIR_OWNER']),
          fileTp: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_TP']),
          flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
          orginalFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ORGINAL_FILE_NM']),
          streFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['STRE_FILE_NM']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$CARREPAIRLOGCountOrderByAggregateInputToJson(
    CARREPAIRLOGCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('ASSET_NO', _$SortOrderEnumMap[instance.assetNo]);
  writeNotNull('REPAIR_DE', _$SortOrderEnumMap[instance.repairDe]);
  writeNotNull('REPAIR_AMOUNT', _$SortOrderEnumMap[instance.repairAmount]);
  writeNotNull('REPAIR_STORE', _$SortOrderEnumMap[instance.repairStore]);
  writeNotNull('REPAIR_LOG', _$SortOrderEnumMap[instance.repairLog]);
  writeNotNull('REPAIR_OWNER', _$SortOrderEnumMap[instance.repairOwner]);
  writeNotNull('FILE_TP', _$SortOrderEnumMap[instance.fileTp]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('ORGINAL_FILE_NM', _$SortOrderEnumMap[instance.orginalFileNm]);
  writeNotNull('STRE_FILE_NM', _$SortOrderEnumMap[instance.streFileNm]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

CARREPAIRLOGAvgOrderByAggregateInput
    _$CARREPAIRLOGAvgOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        CARREPAIRLOGAvgOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
        );

Map<String, dynamic> _$CARREPAIRLOGAvgOrderByAggregateInputToJson(
    CARREPAIRLOGAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  return val;
}

CARREPAIRLOGMaxOrderByAggregateInput
    _$CARREPAIRLOGMaxOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        CARREPAIRLOGMaxOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          assetNo: $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_NO']),
          repairDe: $enumDecodeNullable(_$SortOrderEnumMap, json['REPAIR_DE']),
          repairAmount:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPAIR_AMOUNT']),
          repairStore:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPAIR_STORE']),
          repairLog:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPAIR_LOG']),
          repairOwner:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPAIR_OWNER']),
          fileTp: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_TP']),
          flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
          orginalFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ORGINAL_FILE_NM']),
          streFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['STRE_FILE_NM']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$CARREPAIRLOGMaxOrderByAggregateInputToJson(
    CARREPAIRLOGMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('ASSET_NO', _$SortOrderEnumMap[instance.assetNo]);
  writeNotNull('REPAIR_DE', _$SortOrderEnumMap[instance.repairDe]);
  writeNotNull('REPAIR_AMOUNT', _$SortOrderEnumMap[instance.repairAmount]);
  writeNotNull('REPAIR_STORE', _$SortOrderEnumMap[instance.repairStore]);
  writeNotNull('REPAIR_LOG', _$SortOrderEnumMap[instance.repairLog]);
  writeNotNull('REPAIR_OWNER', _$SortOrderEnumMap[instance.repairOwner]);
  writeNotNull('FILE_TP', _$SortOrderEnumMap[instance.fileTp]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('ORGINAL_FILE_NM', _$SortOrderEnumMap[instance.orginalFileNm]);
  writeNotNull('STRE_FILE_NM', _$SortOrderEnumMap[instance.streFileNm]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

CARREPAIRLOGMinOrderByAggregateInput
    _$CARREPAIRLOGMinOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        CARREPAIRLOGMinOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          assetNo: $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_NO']),
          repairDe: $enumDecodeNullable(_$SortOrderEnumMap, json['REPAIR_DE']),
          repairAmount:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPAIR_AMOUNT']),
          repairStore:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPAIR_STORE']),
          repairLog:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPAIR_LOG']),
          repairOwner:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REPAIR_OWNER']),
          fileTp: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_TP']),
          flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
          orginalFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ORGINAL_FILE_NM']),
          streFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['STRE_FILE_NM']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$CARREPAIRLOGMinOrderByAggregateInputToJson(
    CARREPAIRLOGMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('ASSET_NO', _$SortOrderEnumMap[instance.assetNo]);
  writeNotNull('REPAIR_DE', _$SortOrderEnumMap[instance.repairDe]);
  writeNotNull('REPAIR_AMOUNT', _$SortOrderEnumMap[instance.repairAmount]);
  writeNotNull('REPAIR_STORE', _$SortOrderEnumMap[instance.repairStore]);
  writeNotNull('REPAIR_LOG', _$SortOrderEnumMap[instance.repairLog]);
  writeNotNull('REPAIR_OWNER', _$SortOrderEnumMap[instance.repairOwner]);
  writeNotNull('FILE_TP', _$SortOrderEnumMap[instance.fileTp]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('ORGINAL_FILE_NM', _$SortOrderEnumMap[instance.orginalFileNm]);
  writeNotNull('STRE_FILE_NM', _$SortOrderEnumMap[instance.streFileNm]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

CARREPAIRLOGSumOrderByAggregateInput
    _$CARREPAIRLOGSumOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        CARREPAIRLOGSumOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
        );

Map<String, dynamic> _$CARREPAIRLOGSumOrderByAggregateInputToJson(
    CARREPAIRLOGSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  return val;
}

BigIntNullableWithAggregatesFilter _$BigIntNullableWithAggregatesFilterFromJson(
        Map<String, dynamic> json) =>
    BigIntNullableWithAggregatesFilter(
      equals: json['equals'] == null
          ? null
          : BigInt.parse(json['equals'] as String),
      $in:
          (json['in'] as List<dynamic>?)?.map((e) => BigInt.parse(e as String)),
      notIn: (json['notIn'] as List<dynamic>?)
          ?.map((e) => BigInt.parse(e as String)),
      lt: json['lt'] == null ? null : BigInt.parse(json['lt'] as String),
      lte: json['lte'] == null ? null : BigInt.parse(json['lte'] as String),
      gt: json['gt'] == null ? null : BigInt.parse(json['gt'] as String),
      gte: json['gte'] == null ? null : BigInt.parse(json['gte'] as String),
      not: json['not'] == null
          ? null
          : NestedBigIntNullableWithAggregatesFilter.fromJson(
              json['not'] as Map<String, dynamic>),
      $count: json['_count'] == null
          ? null
          : NestedIntNullableFilter.fromJson(
              json['_count'] as Map<String, dynamic>),
      $avg: json['_avg'] == null
          ? null
          : NestedFloatNullableFilter.fromJson(
              json['_avg'] as Map<String, dynamic>),
      $sum: json['_sum'] == null
          ? null
          : NestedBigIntNullableFilter.fromJson(
              json['_sum'] as Map<String, dynamic>),
      $min: json['_min'] == null
          ? null
          : NestedBigIntNullableFilter.fromJson(
              json['_min'] as Map<String, dynamic>),
      $max: json['_max'] == null
          ? null
          : NestedBigIntNullableFilter.fromJson(
              json['_max'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$BigIntNullableWithAggregatesFilterToJson(
    BigIntNullableWithAggregatesFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals?.toString());
  writeNotNull('in', instance.$in?.map((e) => e.toString()).toList());
  writeNotNull('notIn', instance.notIn?.map((e) => e.toString()).toList());
  writeNotNull('lt', instance.lt?.toString());
  writeNotNull('lte', instance.lte?.toString());
  writeNotNull('gt', instance.gt?.toString());
  writeNotNull('gte', instance.gte?.toString());
  writeNotNull('not', instance.not?.toJson());
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  return val;
}

CARUSEMANAGETBLCountOrderByAggregateInput
    _$CARUSEMANAGETBLCountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        CARUSEMANAGETBLCountOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          carNo: $enumDecodeNullable(_$SortOrderEnumMap, json['CAR_NO']),
          carType: $enumDecodeNullable(_$SortOrderEnumMap, json['CAR_TYPE']),
          destination:
              $enumDecodeNullable(_$SortOrderEnumMap, json['DESTINATION']),
          purpose: $enumDecodeNullable(_$SortOrderEnumMap, json['PURPOSE']),
          users: $enumDecodeNullable(_$SortOrderEnumMap, json['USERS']),
          useStartDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['USE_START_DATE']),
          useEndDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['USE_END_DATE']),
          useBeforeDistance: $enumDecodeNullable(
              _$SortOrderEnumMap, json['USE_BEFORE_DISTANCE']),
          useAfterDistance: $enumDecodeNullable(
              _$SortOrderEnumMap, json['USE_AFTER_DISTANCE']),
          remarks: $enumDecodeNullable(_$SortOrderEnumMap, json['REMARKS']),
          acceptYn: $enumDecodeNullable(_$SortOrderEnumMap, json['ACCEPT_YN']),
          regUser: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_USER']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          useStartHour:
              $enumDecodeNullable(_$SortOrderEnumMap, json['USE_START_HOUR']),
          useEndHour:
              $enumDecodeNullable(_$SortOrderEnumMap, json['USE_END_HOUR']),
          cardApply:
              $enumDecodeNullable(_$SortOrderEnumMap, json['CARD_APPLY']),
        );

Map<String, dynamic> _$CARUSEMANAGETBLCountOrderByAggregateInputToJson(
    CARUSEMANAGETBLCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('CAR_NO', _$SortOrderEnumMap[instance.carNo]);
  writeNotNull('CAR_TYPE', _$SortOrderEnumMap[instance.carType]);
  writeNotNull('DESTINATION', _$SortOrderEnumMap[instance.destination]);
  writeNotNull('PURPOSE', _$SortOrderEnumMap[instance.purpose]);
  writeNotNull('USERS', _$SortOrderEnumMap[instance.users]);
  writeNotNull('USE_START_DATE', _$SortOrderEnumMap[instance.useStartDate]);
  writeNotNull('USE_END_DATE', _$SortOrderEnumMap[instance.useEndDate]);
  writeNotNull(
      'USE_BEFORE_DISTANCE', _$SortOrderEnumMap[instance.useBeforeDistance]);
  writeNotNull(
      'USE_AFTER_DISTANCE', _$SortOrderEnumMap[instance.useAfterDistance]);
  writeNotNull('REMARKS', _$SortOrderEnumMap[instance.remarks]);
  writeNotNull('ACCEPT_YN', _$SortOrderEnumMap[instance.acceptYn]);
  writeNotNull('REG_USER', _$SortOrderEnumMap[instance.regUser]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('USE_START_HOUR', _$SortOrderEnumMap[instance.useStartHour]);
  writeNotNull('USE_END_HOUR', _$SortOrderEnumMap[instance.useEndHour]);
  writeNotNull('CARD_APPLY', _$SortOrderEnumMap[instance.cardApply]);
  return val;
}

CARUSEMANAGETBLAvgOrderByAggregateInput
    _$CARUSEMANAGETBLAvgOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        CARUSEMANAGETBLAvgOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          useBeforeDistance: $enumDecodeNullable(
              _$SortOrderEnumMap, json['USE_BEFORE_DISTANCE']),
          useAfterDistance: $enumDecodeNullable(
              _$SortOrderEnumMap, json['USE_AFTER_DISTANCE']),
        );

Map<String, dynamic> _$CARUSEMANAGETBLAvgOrderByAggregateInputToJson(
    CARUSEMANAGETBLAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull(
      'USE_BEFORE_DISTANCE', _$SortOrderEnumMap[instance.useBeforeDistance]);
  writeNotNull(
      'USE_AFTER_DISTANCE', _$SortOrderEnumMap[instance.useAfterDistance]);
  return val;
}

CARUSEMANAGETBLMaxOrderByAggregateInput
    _$CARUSEMANAGETBLMaxOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        CARUSEMANAGETBLMaxOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          carNo: $enumDecodeNullable(_$SortOrderEnumMap, json['CAR_NO']),
          carType: $enumDecodeNullable(_$SortOrderEnumMap, json['CAR_TYPE']),
          destination:
              $enumDecodeNullable(_$SortOrderEnumMap, json['DESTINATION']),
          purpose: $enumDecodeNullable(_$SortOrderEnumMap, json['PURPOSE']),
          users: $enumDecodeNullable(_$SortOrderEnumMap, json['USERS']),
          useStartDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['USE_START_DATE']),
          useEndDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['USE_END_DATE']),
          useBeforeDistance: $enumDecodeNullable(
              _$SortOrderEnumMap, json['USE_BEFORE_DISTANCE']),
          useAfterDistance: $enumDecodeNullable(
              _$SortOrderEnumMap, json['USE_AFTER_DISTANCE']),
          remarks: $enumDecodeNullable(_$SortOrderEnumMap, json['REMARKS']),
          acceptYn: $enumDecodeNullable(_$SortOrderEnumMap, json['ACCEPT_YN']),
          regUser: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_USER']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          useStartHour:
              $enumDecodeNullable(_$SortOrderEnumMap, json['USE_START_HOUR']),
          useEndHour:
              $enumDecodeNullable(_$SortOrderEnumMap, json['USE_END_HOUR']),
          cardApply:
              $enumDecodeNullable(_$SortOrderEnumMap, json['CARD_APPLY']),
        );

Map<String, dynamic> _$CARUSEMANAGETBLMaxOrderByAggregateInputToJson(
    CARUSEMANAGETBLMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('CAR_NO', _$SortOrderEnumMap[instance.carNo]);
  writeNotNull('CAR_TYPE', _$SortOrderEnumMap[instance.carType]);
  writeNotNull('DESTINATION', _$SortOrderEnumMap[instance.destination]);
  writeNotNull('PURPOSE', _$SortOrderEnumMap[instance.purpose]);
  writeNotNull('USERS', _$SortOrderEnumMap[instance.users]);
  writeNotNull('USE_START_DATE', _$SortOrderEnumMap[instance.useStartDate]);
  writeNotNull('USE_END_DATE', _$SortOrderEnumMap[instance.useEndDate]);
  writeNotNull(
      'USE_BEFORE_DISTANCE', _$SortOrderEnumMap[instance.useBeforeDistance]);
  writeNotNull(
      'USE_AFTER_DISTANCE', _$SortOrderEnumMap[instance.useAfterDistance]);
  writeNotNull('REMARKS', _$SortOrderEnumMap[instance.remarks]);
  writeNotNull('ACCEPT_YN', _$SortOrderEnumMap[instance.acceptYn]);
  writeNotNull('REG_USER', _$SortOrderEnumMap[instance.regUser]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('USE_START_HOUR', _$SortOrderEnumMap[instance.useStartHour]);
  writeNotNull('USE_END_HOUR', _$SortOrderEnumMap[instance.useEndHour]);
  writeNotNull('CARD_APPLY', _$SortOrderEnumMap[instance.cardApply]);
  return val;
}

CARUSEMANAGETBLMinOrderByAggregateInput
    _$CARUSEMANAGETBLMinOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        CARUSEMANAGETBLMinOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          carNo: $enumDecodeNullable(_$SortOrderEnumMap, json['CAR_NO']),
          carType: $enumDecodeNullable(_$SortOrderEnumMap, json['CAR_TYPE']),
          destination:
              $enumDecodeNullable(_$SortOrderEnumMap, json['DESTINATION']),
          purpose: $enumDecodeNullable(_$SortOrderEnumMap, json['PURPOSE']),
          users: $enumDecodeNullable(_$SortOrderEnumMap, json['USERS']),
          useStartDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['USE_START_DATE']),
          useEndDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['USE_END_DATE']),
          useBeforeDistance: $enumDecodeNullable(
              _$SortOrderEnumMap, json['USE_BEFORE_DISTANCE']),
          useAfterDistance: $enumDecodeNullable(
              _$SortOrderEnumMap, json['USE_AFTER_DISTANCE']),
          remarks: $enumDecodeNullable(_$SortOrderEnumMap, json['REMARKS']),
          acceptYn: $enumDecodeNullable(_$SortOrderEnumMap, json['ACCEPT_YN']),
          regUser: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_USER']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          useStartHour:
              $enumDecodeNullable(_$SortOrderEnumMap, json['USE_START_HOUR']),
          useEndHour:
              $enumDecodeNullable(_$SortOrderEnumMap, json['USE_END_HOUR']),
          cardApply:
              $enumDecodeNullable(_$SortOrderEnumMap, json['CARD_APPLY']),
        );

Map<String, dynamic> _$CARUSEMANAGETBLMinOrderByAggregateInputToJson(
    CARUSEMANAGETBLMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('CAR_NO', _$SortOrderEnumMap[instance.carNo]);
  writeNotNull('CAR_TYPE', _$SortOrderEnumMap[instance.carType]);
  writeNotNull('DESTINATION', _$SortOrderEnumMap[instance.destination]);
  writeNotNull('PURPOSE', _$SortOrderEnumMap[instance.purpose]);
  writeNotNull('USERS', _$SortOrderEnumMap[instance.users]);
  writeNotNull('USE_START_DATE', _$SortOrderEnumMap[instance.useStartDate]);
  writeNotNull('USE_END_DATE', _$SortOrderEnumMap[instance.useEndDate]);
  writeNotNull(
      'USE_BEFORE_DISTANCE', _$SortOrderEnumMap[instance.useBeforeDistance]);
  writeNotNull(
      'USE_AFTER_DISTANCE', _$SortOrderEnumMap[instance.useAfterDistance]);
  writeNotNull('REMARKS', _$SortOrderEnumMap[instance.remarks]);
  writeNotNull('ACCEPT_YN', _$SortOrderEnumMap[instance.acceptYn]);
  writeNotNull('REG_USER', _$SortOrderEnumMap[instance.regUser]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('USE_START_HOUR', _$SortOrderEnumMap[instance.useStartHour]);
  writeNotNull('USE_END_HOUR', _$SortOrderEnumMap[instance.useEndHour]);
  writeNotNull('CARD_APPLY', _$SortOrderEnumMap[instance.cardApply]);
  return val;
}

CARUSEMANAGETBLSumOrderByAggregateInput
    _$CARUSEMANAGETBLSumOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        CARUSEMANAGETBLSumOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          useBeforeDistance: $enumDecodeNullable(
              _$SortOrderEnumMap, json['USE_BEFORE_DISTANCE']),
          useAfterDistance: $enumDecodeNullable(
              _$SortOrderEnumMap, json['USE_AFTER_DISTANCE']),
        );

Map<String, dynamic> _$CARUSEMANAGETBLSumOrderByAggregateInputToJson(
    CARUSEMANAGETBLSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull(
      'USE_BEFORE_DISTANCE', _$SortOrderEnumMap[instance.useBeforeDistance]);
  writeNotNull(
      'USE_AFTER_DISTANCE', _$SortOrderEnumMap[instance.useAfterDistance]);
  return val;
}

HOLIDAYTBLUSERIDSTDYEARCompoundUniqueInput
    _$HOLIDAYTBLUSERIDSTDYEARCompoundUniqueInputFromJson(
            Map<String, dynamic> json) =>
        HOLIDAYTBLUSERIDSTDYEARCompoundUniqueInput(
          userId: json['USER_ID'] as String,
          stdYear: json['STD_YEAR'] as String,
        );

Map<String, dynamic> _$HOLIDAYTBLUSERIDSTDYEARCompoundUniqueInputToJson(
        HOLIDAYTBLUSERIDSTDYEARCompoundUniqueInput instance) =>
    <String, dynamic>{
      'USER_ID': instance.userId,
      'STD_YEAR': instance.stdYear,
    };

HOLIDAYTBLCountOrderByAggregateInput
    _$HOLIDAYTBLCountOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        HOLIDAYTBLCountOrderByAggregateInput(
          userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
          stdYear: $enumDecodeNullable(_$SortOrderEnumMap, json['STD_YEAR']),
          m1: $enumDecodeNullable(_$SortOrderEnumMap, json['M1']),
          m2: $enumDecodeNullable(_$SortOrderEnumMap, json['M2']),
          m3: $enumDecodeNullable(_$SortOrderEnumMap, json['M3']),
          m4: $enumDecodeNullable(_$SortOrderEnumMap, json['M4']),
          m5: $enumDecodeNullable(_$SortOrderEnumMap, json['M5']),
          m6: $enumDecodeNullable(_$SortOrderEnumMap, json['M6']),
          m7: $enumDecodeNullable(_$SortOrderEnumMap, json['M7']),
          m8: $enumDecodeNullable(_$SortOrderEnumMap, json['M8']),
          m9: $enumDecodeNullable(_$SortOrderEnumMap, json['M9']),
          m10: $enumDecodeNullable(_$SortOrderEnumMap, json['M10']),
          m11: $enumDecodeNullable(_$SortOrderEnumMap, json['M11']),
          m12: $enumDecodeNullable(_$SortOrderEnumMap, json['M12']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
        );

Map<String, dynamic> _$HOLIDAYTBLCountOrderByAggregateInputToJson(
    HOLIDAYTBLCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('STD_YEAR', _$SortOrderEnumMap[instance.stdYear]);
  writeNotNull('M1', _$SortOrderEnumMap[instance.m1]);
  writeNotNull('M2', _$SortOrderEnumMap[instance.m2]);
  writeNotNull('M3', _$SortOrderEnumMap[instance.m3]);
  writeNotNull('M4', _$SortOrderEnumMap[instance.m4]);
  writeNotNull('M5', _$SortOrderEnumMap[instance.m5]);
  writeNotNull('M6', _$SortOrderEnumMap[instance.m6]);
  writeNotNull('M7', _$SortOrderEnumMap[instance.m7]);
  writeNotNull('M8', _$SortOrderEnumMap[instance.m8]);
  writeNotNull('M9', _$SortOrderEnumMap[instance.m9]);
  writeNotNull('M10', _$SortOrderEnumMap[instance.m10]);
  writeNotNull('M11', _$SortOrderEnumMap[instance.m11]);
  writeNotNull('M12', _$SortOrderEnumMap[instance.m12]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  return val;
}

HOLIDAYTBLAvgOrderByAggregateInput _$HOLIDAYTBLAvgOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    HOLIDAYTBLAvgOrderByAggregateInput(
      m1: $enumDecodeNullable(_$SortOrderEnumMap, json['M1']),
      m2: $enumDecodeNullable(_$SortOrderEnumMap, json['M2']),
      m3: $enumDecodeNullable(_$SortOrderEnumMap, json['M3']),
      m4: $enumDecodeNullable(_$SortOrderEnumMap, json['M4']),
      m5: $enumDecodeNullable(_$SortOrderEnumMap, json['M5']),
      m6: $enumDecodeNullable(_$SortOrderEnumMap, json['M6']),
      m7: $enumDecodeNullable(_$SortOrderEnumMap, json['M7']),
      m8: $enumDecodeNullable(_$SortOrderEnumMap, json['M8']),
      m9: $enumDecodeNullable(_$SortOrderEnumMap, json['M9']),
      m10: $enumDecodeNullable(_$SortOrderEnumMap, json['M10']),
      m11: $enumDecodeNullable(_$SortOrderEnumMap, json['M11']),
      m12: $enumDecodeNullable(_$SortOrderEnumMap, json['M12']),
    );

Map<String, dynamic> _$HOLIDAYTBLAvgOrderByAggregateInputToJson(
    HOLIDAYTBLAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('M1', _$SortOrderEnumMap[instance.m1]);
  writeNotNull('M2', _$SortOrderEnumMap[instance.m2]);
  writeNotNull('M3', _$SortOrderEnumMap[instance.m3]);
  writeNotNull('M4', _$SortOrderEnumMap[instance.m4]);
  writeNotNull('M5', _$SortOrderEnumMap[instance.m5]);
  writeNotNull('M6', _$SortOrderEnumMap[instance.m6]);
  writeNotNull('M7', _$SortOrderEnumMap[instance.m7]);
  writeNotNull('M8', _$SortOrderEnumMap[instance.m8]);
  writeNotNull('M9', _$SortOrderEnumMap[instance.m9]);
  writeNotNull('M10', _$SortOrderEnumMap[instance.m10]);
  writeNotNull('M11', _$SortOrderEnumMap[instance.m11]);
  writeNotNull('M12', _$SortOrderEnumMap[instance.m12]);
  return val;
}

HOLIDAYTBLMaxOrderByAggregateInput _$HOLIDAYTBLMaxOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    HOLIDAYTBLMaxOrderByAggregateInput(
      userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
      stdYear: $enumDecodeNullable(_$SortOrderEnumMap, json['STD_YEAR']),
      m1: $enumDecodeNullable(_$SortOrderEnumMap, json['M1']),
      m2: $enumDecodeNullable(_$SortOrderEnumMap, json['M2']),
      m3: $enumDecodeNullable(_$SortOrderEnumMap, json['M3']),
      m4: $enumDecodeNullable(_$SortOrderEnumMap, json['M4']),
      m5: $enumDecodeNullable(_$SortOrderEnumMap, json['M5']),
      m6: $enumDecodeNullable(_$SortOrderEnumMap, json['M6']),
      m7: $enumDecodeNullable(_$SortOrderEnumMap, json['M7']),
      m8: $enumDecodeNullable(_$SortOrderEnumMap, json['M8']),
      m9: $enumDecodeNullable(_$SortOrderEnumMap, json['M9']),
      m10: $enumDecodeNullable(_$SortOrderEnumMap, json['M10']),
      m11: $enumDecodeNullable(_$SortOrderEnumMap, json['M11']),
      m12: $enumDecodeNullable(_$SortOrderEnumMap, json['M12']),
      useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
      delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
    );

Map<String, dynamic> _$HOLIDAYTBLMaxOrderByAggregateInputToJson(
    HOLIDAYTBLMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('STD_YEAR', _$SortOrderEnumMap[instance.stdYear]);
  writeNotNull('M1', _$SortOrderEnumMap[instance.m1]);
  writeNotNull('M2', _$SortOrderEnumMap[instance.m2]);
  writeNotNull('M3', _$SortOrderEnumMap[instance.m3]);
  writeNotNull('M4', _$SortOrderEnumMap[instance.m4]);
  writeNotNull('M5', _$SortOrderEnumMap[instance.m5]);
  writeNotNull('M6', _$SortOrderEnumMap[instance.m6]);
  writeNotNull('M7', _$SortOrderEnumMap[instance.m7]);
  writeNotNull('M8', _$SortOrderEnumMap[instance.m8]);
  writeNotNull('M9', _$SortOrderEnumMap[instance.m9]);
  writeNotNull('M10', _$SortOrderEnumMap[instance.m10]);
  writeNotNull('M11', _$SortOrderEnumMap[instance.m11]);
  writeNotNull('M12', _$SortOrderEnumMap[instance.m12]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  return val;
}

HOLIDAYTBLMinOrderByAggregateInput _$HOLIDAYTBLMinOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    HOLIDAYTBLMinOrderByAggregateInput(
      userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
      stdYear: $enumDecodeNullable(_$SortOrderEnumMap, json['STD_YEAR']),
      m1: $enumDecodeNullable(_$SortOrderEnumMap, json['M1']),
      m2: $enumDecodeNullable(_$SortOrderEnumMap, json['M2']),
      m3: $enumDecodeNullable(_$SortOrderEnumMap, json['M3']),
      m4: $enumDecodeNullable(_$SortOrderEnumMap, json['M4']),
      m5: $enumDecodeNullable(_$SortOrderEnumMap, json['M5']),
      m6: $enumDecodeNullable(_$SortOrderEnumMap, json['M6']),
      m7: $enumDecodeNullable(_$SortOrderEnumMap, json['M7']),
      m8: $enumDecodeNullable(_$SortOrderEnumMap, json['M8']),
      m9: $enumDecodeNullable(_$SortOrderEnumMap, json['M9']),
      m10: $enumDecodeNullable(_$SortOrderEnumMap, json['M10']),
      m11: $enumDecodeNullable(_$SortOrderEnumMap, json['M11']),
      m12: $enumDecodeNullable(_$SortOrderEnumMap, json['M12']),
      useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
      delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
    );

Map<String, dynamic> _$HOLIDAYTBLMinOrderByAggregateInputToJson(
    HOLIDAYTBLMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('STD_YEAR', _$SortOrderEnumMap[instance.stdYear]);
  writeNotNull('M1', _$SortOrderEnumMap[instance.m1]);
  writeNotNull('M2', _$SortOrderEnumMap[instance.m2]);
  writeNotNull('M3', _$SortOrderEnumMap[instance.m3]);
  writeNotNull('M4', _$SortOrderEnumMap[instance.m4]);
  writeNotNull('M5', _$SortOrderEnumMap[instance.m5]);
  writeNotNull('M6', _$SortOrderEnumMap[instance.m6]);
  writeNotNull('M7', _$SortOrderEnumMap[instance.m7]);
  writeNotNull('M8', _$SortOrderEnumMap[instance.m8]);
  writeNotNull('M9', _$SortOrderEnumMap[instance.m9]);
  writeNotNull('M10', _$SortOrderEnumMap[instance.m10]);
  writeNotNull('M11', _$SortOrderEnumMap[instance.m11]);
  writeNotNull('M12', _$SortOrderEnumMap[instance.m12]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  return val;
}

HOLIDAYTBLSumOrderByAggregateInput _$HOLIDAYTBLSumOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    HOLIDAYTBLSumOrderByAggregateInput(
      m1: $enumDecodeNullable(_$SortOrderEnumMap, json['M1']),
      m2: $enumDecodeNullable(_$SortOrderEnumMap, json['M2']),
      m3: $enumDecodeNullable(_$SortOrderEnumMap, json['M3']),
      m4: $enumDecodeNullable(_$SortOrderEnumMap, json['M4']),
      m5: $enumDecodeNullable(_$SortOrderEnumMap, json['M5']),
      m6: $enumDecodeNullable(_$SortOrderEnumMap, json['M6']),
      m7: $enumDecodeNullable(_$SortOrderEnumMap, json['M7']),
      m8: $enumDecodeNullable(_$SortOrderEnumMap, json['M8']),
      m9: $enumDecodeNullable(_$SortOrderEnumMap, json['M9']),
      m10: $enumDecodeNullable(_$SortOrderEnumMap, json['M10']),
      m11: $enumDecodeNullable(_$SortOrderEnumMap, json['M11']),
      m12: $enumDecodeNullable(_$SortOrderEnumMap, json['M12']),
    );

Map<String, dynamic> _$HOLIDAYTBLSumOrderByAggregateInputToJson(
    HOLIDAYTBLSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('M1', _$SortOrderEnumMap[instance.m1]);
  writeNotNull('M2', _$SortOrderEnumMap[instance.m2]);
  writeNotNull('M3', _$SortOrderEnumMap[instance.m3]);
  writeNotNull('M4', _$SortOrderEnumMap[instance.m4]);
  writeNotNull('M5', _$SortOrderEnumMap[instance.m5]);
  writeNotNull('M6', _$SortOrderEnumMap[instance.m6]);
  writeNotNull('M7', _$SortOrderEnumMap[instance.m7]);
  writeNotNull('M8', _$SortOrderEnumMap[instance.m8]);
  writeNotNull('M9', _$SortOrderEnumMap[instance.m9]);
  writeNotNull('M10', _$SortOrderEnumMap[instance.m10]);
  writeNotNull('M11', _$SortOrderEnumMap[instance.m11]);
  writeNotNull('M12', _$SortOrderEnumMap[instance.m12]);
  return val;
}

MENUTBLListRelationFilter _$MENUTBLListRelationFilterFromJson(
        Map<String, dynamic> json) =>
    MENUTBLListRelationFilter(
      every: json['every'] == null
          ? null
          : MENUTBLWhereInput.fromJson(json['every'] as Map<String, dynamic>),
      some: json['some'] == null
          ? null
          : MENUTBLWhereInput.fromJson(json['some'] as Map<String, dynamic>),
      none: json['none'] == null
          ? null
          : MENUTBLWhereInput.fromJson(json['none'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$MENUTBLListRelationFilterToJson(
    MENUTBLListRelationFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('every', instance.every?.toJson());
  writeNotNull('some', instance.some?.toJson());
  writeNotNull('none', instance.none?.toJson());
  return val;
}

MENUTBLOrderByRelationAggregateInput
    _$MENUTBLOrderByRelationAggregateInputFromJson(Map<String, dynamic> json) =>
        MENUTBLOrderByRelationAggregateInput(
          $count: $enumDecodeNullable(_$SortOrderEnumMap, json['_count']),
        );

Map<String, dynamic> _$MENUTBLOrderByRelationAggregateInputToJson(
    MENUTBLOrderByRelationAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('_count', _$SortOrderEnumMap[instance.$count]);
  return val;
}

MEMBERTBLCountOrderByAggregateInput
    _$MEMBERTBLCountOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        MEMBERTBLCountOrderByAggregateInput(
          userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
          passwd: $enumDecodeNullable(_$SortOrderEnumMap, json['PASSWD']),
          userNm: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_NM']),
          dept: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT']),
          grade: $enumDecodeNullable(_$SortOrderEnumMap, json['GRADE']),
          joinDate: $enumDecodeNullable(_$SortOrderEnumMap, json['JOIN_DATE']),
          retireDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['RETIRE_DATE']),
          pwdChgDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PWD_CHG_DATE']),
          pwdWrongCnt:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PWD_WRONG_CNT']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          lastLoginDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['LAST_LOGIN_DATE']),
          memo: $enumDecodeNullable(_$SortOrderEnumMap, json['MEMO']),
        );

Map<String, dynamic> _$MEMBERTBLCountOrderByAggregateInputToJson(
    MEMBERTBLCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('PASSWD', _$SortOrderEnumMap[instance.passwd]);
  writeNotNull('USER_NM', _$SortOrderEnumMap[instance.userNm]);
  writeNotNull('DEPT', _$SortOrderEnumMap[instance.dept]);
  writeNotNull('GRADE', _$SortOrderEnumMap[instance.grade]);
  writeNotNull('JOIN_DATE', _$SortOrderEnumMap[instance.joinDate]);
  writeNotNull('RETIRE_DATE', _$SortOrderEnumMap[instance.retireDate]);
  writeNotNull('PWD_CHG_DATE', _$SortOrderEnumMap[instance.pwdChgDate]);
  writeNotNull('PWD_WRONG_CNT', _$SortOrderEnumMap[instance.pwdWrongCnt]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('LAST_LOGIN_DATE', _$SortOrderEnumMap[instance.lastLoginDate]);
  writeNotNull('MEMO', _$SortOrderEnumMap[instance.memo]);
  return val;
}

MEMBERTBLAvgOrderByAggregateInput _$MEMBERTBLAvgOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    MEMBERTBLAvgOrderByAggregateInput(
      pwdWrongCnt:
          $enumDecodeNullable(_$SortOrderEnumMap, json['PWD_WRONG_CNT']),
    );

Map<String, dynamic> _$MEMBERTBLAvgOrderByAggregateInputToJson(
    MEMBERTBLAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('PWD_WRONG_CNT', _$SortOrderEnumMap[instance.pwdWrongCnt]);
  return val;
}

MEMBERTBLMaxOrderByAggregateInput _$MEMBERTBLMaxOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    MEMBERTBLMaxOrderByAggregateInput(
      userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
      passwd: $enumDecodeNullable(_$SortOrderEnumMap, json['PASSWD']),
      userNm: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_NM']),
      dept: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT']),
      grade: $enumDecodeNullable(_$SortOrderEnumMap, json['GRADE']),
      joinDate: $enumDecodeNullable(_$SortOrderEnumMap, json['JOIN_DATE']),
      retireDate: $enumDecodeNullable(_$SortOrderEnumMap, json['RETIRE_DATE']),
      pwdChgDate: $enumDecodeNullable(_$SortOrderEnumMap, json['PWD_CHG_DATE']),
      pwdWrongCnt:
          $enumDecodeNullable(_$SortOrderEnumMap, json['PWD_WRONG_CNT']),
      useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
      delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
      lastLoginDate:
          $enumDecodeNullable(_$SortOrderEnumMap, json['LAST_LOGIN_DATE']),
      memo: $enumDecodeNullable(_$SortOrderEnumMap, json['MEMO']),
    );

Map<String, dynamic> _$MEMBERTBLMaxOrderByAggregateInputToJson(
    MEMBERTBLMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('PASSWD', _$SortOrderEnumMap[instance.passwd]);
  writeNotNull('USER_NM', _$SortOrderEnumMap[instance.userNm]);
  writeNotNull('DEPT', _$SortOrderEnumMap[instance.dept]);
  writeNotNull('GRADE', _$SortOrderEnumMap[instance.grade]);
  writeNotNull('JOIN_DATE', _$SortOrderEnumMap[instance.joinDate]);
  writeNotNull('RETIRE_DATE', _$SortOrderEnumMap[instance.retireDate]);
  writeNotNull('PWD_CHG_DATE', _$SortOrderEnumMap[instance.pwdChgDate]);
  writeNotNull('PWD_WRONG_CNT', _$SortOrderEnumMap[instance.pwdWrongCnt]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('LAST_LOGIN_DATE', _$SortOrderEnumMap[instance.lastLoginDate]);
  writeNotNull('MEMO', _$SortOrderEnumMap[instance.memo]);
  return val;
}

MEMBERTBLMinOrderByAggregateInput _$MEMBERTBLMinOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    MEMBERTBLMinOrderByAggregateInput(
      userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
      passwd: $enumDecodeNullable(_$SortOrderEnumMap, json['PASSWD']),
      userNm: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_NM']),
      dept: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT']),
      grade: $enumDecodeNullable(_$SortOrderEnumMap, json['GRADE']),
      joinDate: $enumDecodeNullable(_$SortOrderEnumMap, json['JOIN_DATE']),
      retireDate: $enumDecodeNullable(_$SortOrderEnumMap, json['RETIRE_DATE']),
      pwdChgDate: $enumDecodeNullable(_$SortOrderEnumMap, json['PWD_CHG_DATE']),
      pwdWrongCnt:
          $enumDecodeNullable(_$SortOrderEnumMap, json['PWD_WRONG_CNT']),
      useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
      delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
      lastLoginDate:
          $enumDecodeNullable(_$SortOrderEnumMap, json['LAST_LOGIN_DATE']),
      memo: $enumDecodeNullable(_$SortOrderEnumMap, json['MEMO']),
    );

Map<String, dynamic> _$MEMBERTBLMinOrderByAggregateInputToJson(
    MEMBERTBLMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('PASSWD', _$SortOrderEnumMap[instance.passwd]);
  writeNotNull('USER_NM', _$SortOrderEnumMap[instance.userNm]);
  writeNotNull('DEPT', _$SortOrderEnumMap[instance.dept]);
  writeNotNull('GRADE', _$SortOrderEnumMap[instance.grade]);
  writeNotNull('JOIN_DATE', _$SortOrderEnumMap[instance.joinDate]);
  writeNotNull('RETIRE_DATE', _$SortOrderEnumMap[instance.retireDate]);
  writeNotNull('PWD_CHG_DATE', _$SortOrderEnumMap[instance.pwdChgDate]);
  writeNotNull('PWD_WRONG_CNT', _$SortOrderEnumMap[instance.pwdWrongCnt]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('LAST_LOGIN_DATE', _$SortOrderEnumMap[instance.lastLoginDate]);
  writeNotNull('MEMO', _$SortOrderEnumMap[instance.memo]);
  return val;
}

MEMBERTBLSumOrderByAggregateInput _$MEMBERTBLSumOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    MEMBERTBLSumOrderByAggregateInput(
      pwdWrongCnt:
          $enumDecodeNullable(_$SortOrderEnumMap, json['PWD_WRONG_CNT']),
    );

Map<String, dynamic> _$MEMBERTBLSumOrderByAggregateInputToJson(
    MEMBERTBLSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('PWD_WRONG_CNT', _$SortOrderEnumMap[instance.pwdWrongCnt]);
  return val;
}

MENUAUTHTBLUSERIDMENUIDCompoundUniqueInput
    _$MENUAUTHTBLUSERIDMENUIDCompoundUniqueInputFromJson(
            Map<String, dynamic> json) =>
        MENUAUTHTBLUSERIDMENUIDCompoundUniqueInput(
          userId: json['USER_ID'] as String,
          menuId: json['MENU_ID'] as String,
        );

Map<String, dynamic> _$MENUAUTHTBLUSERIDMENUIDCompoundUniqueInputToJson(
        MENUAUTHTBLUSERIDMENUIDCompoundUniqueInput instance) =>
    <String, dynamic>{
      'USER_ID': instance.userId,
      'MENU_ID': instance.menuId,
    };

MENUAUTHTBLCountOrderByAggregateInput
    _$MENUAUTHTBLCountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        MENUAUTHTBLCountOrderByAggregateInput(
          userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
          menuId: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_ID']),
          readYn: $enumDecodeNullable(_$SortOrderEnumMap, json['READ_YN']),
          writeYn: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITE_YN']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          updId: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
        );

Map<String, dynamic> _$MENUAUTHTBLCountOrderByAggregateInputToJson(
    MENUAUTHTBLCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('MENU_ID', _$SortOrderEnumMap[instance.menuId]);
  writeNotNull('READ_YN', _$SortOrderEnumMap[instance.readYn]);
  writeNotNull('WRITE_YN', _$SortOrderEnumMap[instance.writeYn]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('UPD_ID', _$SortOrderEnumMap[instance.updId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  return val;
}

MENUAUTHTBLMaxOrderByAggregateInput
    _$MENUAUTHTBLMaxOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        MENUAUTHTBLMaxOrderByAggregateInput(
          userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
          menuId: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_ID']),
          readYn: $enumDecodeNullable(_$SortOrderEnumMap, json['READ_YN']),
          writeYn: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITE_YN']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          updId: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
        );

Map<String, dynamic> _$MENUAUTHTBLMaxOrderByAggregateInputToJson(
    MENUAUTHTBLMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('MENU_ID', _$SortOrderEnumMap[instance.menuId]);
  writeNotNull('READ_YN', _$SortOrderEnumMap[instance.readYn]);
  writeNotNull('WRITE_YN', _$SortOrderEnumMap[instance.writeYn]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('UPD_ID', _$SortOrderEnumMap[instance.updId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  return val;
}

MENUAUTHTBLMinOrderByAggregateInput
    _$MENUAUTHTBLMinOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        MENUAUTHTBLMinOrderByAggregateInput(
          userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
          menuId: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_ID']),
          readYn: $enumDecodeNullable(_$SortOrderEnumMap, json['READ_YN']),
          writeYn: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITE_YN']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          updId: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
        );

Map<String, dynamic> _$MENUAUTHTBLMinOrderByAggregateInputToJson(
    MENUAUTHTBLMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('MENU_ID', _$SortOrderEnumMap[instance.menuId]);
  writeNotNull('READ_YN', _$SortOrderEnumMap[instance.readYn]);
  writeNotNull('WRITE_YN', _$SortOrderEnumMap[instance.writeYn]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('UPD_ID', _$SortOrderEnumMap[instance.updId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  return val;
}

MEMBERTBLRelationFilter _$MEMBERTBLRelationFilterFromJson(
        Map<String, dynamic> json) =>
    MEMBERTBLRelationFilter(
      $is: json['is'] == null
          ? null
          : MEMBERTBLWhereInput.fromJson(json['is'] as Map<String, dynamic>),
      isNot: json['isNot'] == null
          ? null
          : MEMBERTBLWhereInput.fromJson(json['isNot'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$MEMBERTBLRelationFilterToJson(
    MEMBERTBLRelationFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('is', instance.$is?.toJson());
  writeNotNull('isNot', instance.isNot?.toJson());
  return val;
}

MENUTBLCountOrderByAggregateInput _$MENUTBLCountOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    MENUTBLCountOrderByAggregateInput(
      menuId: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_ID']),
      menuNm: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_NM']),
      depth: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPTH']),
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
      ownerId: $enumDecodeNullable(_$SortOrderEnumMap, json['OWNER_ID']),
      url: $enumDecodeNullable(_$SortOrderEnumMap, json['URL']),
      writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
      useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
      delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
      dispYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DISP_YN']),
      menuIcon: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_ICON']),
    );

Map<String, dynamic> _$MENUTBLCountOrderByAggregateInputToJson(
    MENUTBLCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_ID', _$SortOrderEnumMap[instance.menuId]);
  writeNotNull('MENU_NM', _$SortOrderEnumMap[instance.menuNm]);
  writeNotNull('DEPTH', _$SortOrderEnumMap[instance.depth]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('OWNER_ID', _$SortOrderEnumMap[instance.ownerId]);
  writeNotNull('URL', _$SortOrderEnumMap[instance.url]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('DISP_YN', _$SortOrderEnumMap[instance.dispYn]);
  writeNotNull('MENU_ICON', _$SortOrderEnumMap[instance.menuIcon]);
  return val;
}

MENUTBLAvgOrderByAggregateInput _$MENUTBLAvgOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    MENUTBLAvgOrderByAggregateInput(
      depth: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPTH']),
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
    );

Map<String, dynamic> _$MENUTBLAvgOrderByAggregateInputToJson(
    MENUTBLAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('DEPTH', _$SortOrderEnumMap[instance.depth]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  return val;
}

MENUTBLMaxOrderByAggregateInput _$MENUTBLMaxOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    MENUTBLMaxOrderByAggregateInput(
      menuId: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_ID']),
      menuNm: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_NM']),
      depth: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPTH']),
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
      ownerId: $enumDecodeNullable(_$SortOrderEnumMap, json['OWNER_ID']),
      url: $enumDecodeNullable(_$SortOrderEnumMap, json['URL']),
      writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
      useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
      delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
      dispYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DISP_YN']),
      menuIcon: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_ICON']),
    );

Map<String, dynamic> _$MENUTBLMaxOrderByAggregateInputToJson(
    MENUTBLMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_ID', _$SortOrderEnumMap[instance.menuId]);
  writeNotNull('MENU_NM', _$SortOrderEnumMap[instance.menuNm]);
  writeNotNull('DEPTH', _$SortOrderEnumMap[instance.depth]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('OWNER_ID', _$SortOrderEnumMap[instance.ownerId]);
  writeNotNull('URL', _$SortOrderEnumMap[instance.url]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('DISP_YN', _$SortOrderEnumMap[instance.dispYn]);
  writeNotNull('MENU_ICON', _$SortOrderEnumMap[instance.menuIcon]);
  return val;
}

MENUTBLMinOrderByAggregateInput _$MENUTBLMinOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    MENUTBLMinOrderByAggregateInput(
      menuId: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_ID']),
      menuNm: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_NM']),
      depth: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPTH']),
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
      ownerId: $enumDecodeNullable(_$SortOrderEnumMap, json['OWNER_ID']),
      url: $enumDecodeNullable(_$SortOrderEnumMap, json['URL']),
      writerId: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITER_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
      useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
      delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
      dispYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DISP_YN']),
      menuIcon: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_ICON']),
    );

Map<String, dynamic> _$MENUTBLMinOrderByAggregateInputToJson(
    MENUTBLMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_ID', _$SortOrderEnumMap[instance.menuId]);
  writeNotNull('MENU_NM', _$SortOrderEnumMap[instance.menuNm]);
  writeNotNull('DEPTH', _$SortOrderEnumMap[instance.depth]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('OWNER_ID', _$SortOrderEnumMap[instance.ownerId]);
  writeNotNull('URL', _$SortOrderEnumMap[instance.url]);
  writeNotNull('WRITER_ID', _$SortOrderEnumMap[instance.writerId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('DISP_YN', _$SortOrderEnumMap[instance.dispYn]);
  writeNotNull('MENU_ICON', _$SortOrderEnumMap[instance.menuIcon]);
  return val;
}

MENUTBLSumOrderByAggregateInput _$MENUTBLSumOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    MENUTBLSumOrderByAggregateInput(
      depth: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPTH']),
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
    );

Map<String, dynamic> _$MENUTBLSumOrderByAggregateInputToJson(
    MENUTBLSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('DEPTH', _$SortOrderEnumMap[instance.depth]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  return val;
}

OFFICEASSETTBLCountOrderByAggregateInput
    _$OFFICEASSETTBLCountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        OFFICEASSETTBLCountOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          assetNo: $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_NO']),
          assetType:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_TYPE']),
          seller: $enumDecodeNullable(_$SortOrderEnumMap, json['SELLER']),
          buyDate: $enumDecodeNullable(_$SortOrderEnumMap, json['BUY_DATE']),
          modelNo: $enumDecodeNullable(_$SortOrderEnumMap, json['MODEL_NO']),
          serialNo: $enumDecodeNullable(_$SortOrderEnumMap, json['SERIAL_NO']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
          keepYear: $enumDecodeNullable(_$SortOrderEnumMap, json['KEEP_YEAR']),
          mngDept: $enumDecodeNullable(_$SortOrderEnumMap, json['MNG_DEPT']),
          assetAccount:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_ACCOUNT']),
          remarks: $enumDecodeNullable(_$SortOrderEnumMap, json['REMARKS']),
          carryOut: $enumDecodeNullable(_$SortOrderEnumMap, json['CARRY_OUT']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
        );

Map<String, dynamic> _$OFFICEASSETTBLCountOrderByAggregateInputToJson(
    OFFICEASSETTBLCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ASSET_NO', _$SortOrderEnumMap[instance.assetNo]);
  writeNotNull('ASSET_TYPE', _$SortOrderEnumMap[instance.assetType]);
  writeNotNull('SELLER', _$SortOrderEnumMap[instance.seller]);
  writeNotNull('BUY_DATE', _$SortOrderEnumMap[instance.buyDate]);
  writeNotNull('MODEL_NO', _$SortOrderEnumMap[instance.modelNo]);
  writeNotNull('SERIAL_NO', _$SortOrderEnumMap[instance.serialNo]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  writeNotNull('KEEP_YEAR', _$SortOrderEnumMap[instance.keepYear]);
  writeNotNull('MNG_DEPT', _$SortOrderEnumMap[instance.mngDept]);
  writeNotNull('ASSET_ACCOUNT', _$SortOrderEnumMap[instance.assetAccount]);
  writeNotNull('REMARKS', _$SortOrderEnumMap[instance.remarks]);
  writeNotNull('CARRY_OUT', _$SortOrderEnumMap[instance.carryOut]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  return val;
}

OFFICEASSETTBLAvgOrderByAggregateInput
    _$OFFICEASSETTBLAvgOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        OFFICEASSETTBLAvgOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
          keepYear: $enumDecodeNullable(_$SortOrderEnumMap, json['KEEP_YEAR']),
        );

Map<String, dynamic> _$OFFICEASSETTBLAvgOrderByAggregateInputToJson(
    OFFICEASSETTBLAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  writeNotNull('KEEP_YEAR', _$SortOrderEnumMap[instance.keepYear]);
  return val;
}

OFFICEASSETTBLMaxOrderByAggregateInput
    _$OFFICEASSETTBLMaxOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        OFFICEASSETTBLMaxOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          assetNo: $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_NO']),
          assetType:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_TYPE']),
          seller: $enumDecodeNullable(_$SortOrderEnumMap, json['SELLER']),
          buyDate: $enumDecodeNullable(_$SortOrderEnumMap, json['BUY_DATE']),
          modelNo: $enumDecodeNullable(_$SortOrderEnumMap, json['MODEL_NO']),
          serialNo: $enumDecodeNullable(_$SortOrderEnumMap, json['SERIAL_NO']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
          keepYear: $enumDecodeNullable(_$SortOrderEnumMap, json['KEEP_YEAR']),
          mngDept: $enumDecodeNullable(_$SortOrderEnumMap, json['MNG_DEPT']),
          assetAccount:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_ACCOUNT']),
          remarks: $enumDecodeNullable(_$SortOrderEnumMap, json['REMARKS']),
          carryOut: $enumDecodeNullable(_$SortOrderEnumMap, json['CARRY_OUT']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
        );

Map<String, dynamic> _$OFFICEASSETTBLMaxOrderByAggregateInputToJson(
    OFFICEASSETTBLMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ASSET_NO', _$SortOrderEnumMap[instance.assetNo]);
  writeNotNull('ASSET_TYPE', _$SortOrderEnumMap[instance.assetType]);
  writeNotNull('SELLER', _$SortOrderEnumMap[instance.seller]);
  writeNotNull('BUY_DATE', _$SortOrderEnumMap[instance.buyDate]);
  writeNotNull('MODEL_NO', _$SortOrderEnumMap[instance.modelNo]);
  writeNotNull('SERIAL_NO', _$SortOrderEnumMap[instance.serialNo]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  writeNotNull('KEEP_YEAR', _$SortOrderEnumMap[instance.keepYear]);
  writeNotNull('MNG_DEPT', _$SortOrderEnumMap[instance.mngDept]);
  writeNotNull('ASSET_ACCOUNT', _$SortOrderEnumMap[instance.assetAccount]);
  writeNotNull('REMARKS', _$SortOrderEnumMap[instance.remarks]);
  writeNotNull('CARRY_OUT', _$SortOrderEnumMap[instance.carryOut]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  return val;
}

OFFICEASSETTBLMinOrderByAggregateInput
    _$OFFICEASSETTBLMinOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        OFFICEASSETTBLMinOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          assetNo: $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_NO']),
          assetType:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_TYPE']),
          seller: $enumDecodeNullable(_$SortOrderEnumMap, json['SELLER']),
          buyDate: $enumDecodeNullable(_$SortOrderEnumMap, json['BUY_DATE']),
          modelNo: $enumDecodeNullable(_$SortOrderEnumMap, json['MODEL_NO']),
          serialNo: $enumDecodeNullable(_$SortOrderEnumMap, json['SERIAL_NO']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
          keepYear: $enumDecodeNullable(_$SortOrderEnumMap, json['KEEP_YEAR']),
          mngDept: $enumDecodeNullable(_$SortOrderEnumMap, json['MNG_DEPT']),
          assetAccount:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_ACCOUNT']),
          remarks: $enumDecodeNullable(_$SortOrderEnumMap, json['REMARKS']),
          carryOut: $enumDecodeNullable(_$SortOrderEnumMap, json['CARRY_OUT']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
        );

Map<String, dynamic> _$OFFICEASSETTBLMinOrderByAggregateInputToJson(
    OFFICEASSETTBLMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ASSET_NO', _$SortOrderEnumMap[instance.assetNo]);
  writeNotNull('ASSET_TYPE', _$SortOrderEnumMap[instance.assetType]);
  writeNotNull('SELLER', _$SortOrderEnumMap[instance.seller]);
  writeNotNull('BUY_DATE', _$SortOrderEnumMap[instance.buyDate]);
  writeNotNull('MODEL_NO', _$SortOrderEnumMap[instance.modelNo]);
  writeNotNull('SERIAL_NO', _$SortOrderEnumMap[instance.serialNo]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  writeNotNull('KEEP_YEAR', _$SortOrderEnumMap[instance.keepYear]);
  writeNotNull('MNG_DEPT', _$SortOrderEnumMap[instance.mngDept]);
  writeNotNull('ASSET_ACCOUNT', _$SortOrderEnumMap[instance.assetAccount]);
  writeNotNull('REMARKS', _$SortOrderEnumMap[instance.remarks]);
  writeNotNull('CARRY_OUT', _$SortOrderEnumMap[instance.carryOut]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  return val;
}

OFFICEASSETTBLSumOrderByAggregateInput
    _$OFFICEASSETTBLSumOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        OFFICEASSETTBLSumOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
          keepYear: $enumDecodeNullable(_$SortOrderEnumMap, json['KEEP_YEAR']),
        );

Map<String, dynamic> _$OFFICEASSETTBLSumOrderByAggregateInputToJson(
    OFFICEASSETTBLSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  writeNotNull('KEEP_YEAR', _$SortOrderEnumMap[instance.keepYear]);
  return val;
}

SERVERASSETTBLCountOrderByAggregateInput
    _$SERVERASSETTBLCountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        SERVERASSETTBLCountOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          assetNo: $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_NO']),
          assetType:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_TYPE']),
          maker: $enumDecodeNullable(_$SortOrderEnumMap, json['MAKER']),
          cnt: $enumDecodeNullable(_$SortOrderEnumMap, json['CNT']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
          buyDate: $enumDecodeNullable(_$SortOrderEnumMap, json['BUY_DATE']),
          seller: $enumDecodeNullable(_$SortOrderEnumMap, json['SELLER']),
          modelNo: $enumDecodeNullable(_$SortOrderEnumMap, json['MODEL_NO']),
          serialNo: $enumDecodeNullable(_$SortOrderEnumMap, json['SERIAL_NO']),
          hostname: $enumDecodeNullable(_$SortOrderEnumMap, json['HOSTNAME']),
          builtLoc: $enumDecodeNullable(_$SortOrderEnumMap, json['BUILT_LOC']),
          useDesc: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_DESC']),
          osInfo: $enumDecodeNullable(_$SortOrderEnumMap, json['OS_INFO']),
          cpuInfo: $enumDecodeNullable(_$SortOrderEnumMap, json['CPU_INFO']),
          ramInfo: $enumDecodeNullable(_$SortOrderEnumMap, json['RAM_INFO']),
          hddInfo: $enumDecodeNullable(_$SortOrderEnumMap, json['HDD_INFO']),
          ssdInfo: $enumDecodeNullable(_$SortOrderEnumMap, json['SSD_INFO']),
          odd: $enumDecodeNullable(_$SortOrderEnumMap, json['ODD']),
          remarks: $enumDecodeNullable(_$SortOrderEnumMap, json['REMARKS']),
          carryOut: $enumDecodeNullable(_$SortOrderEnumMap, json['CARRY_OUT']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
        );

Map<String, dynamic> _$SERVERASSETTBLCountOrderByAggregateInputToJson(
    SERVERASSETTBLCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ASSET_NO', _$SortOrderEnumMap[instance.assetNo]);
  writeNotNull('ASSET_TYPE', _$SortOrderEnumMap[instance.assetType]);
  writeNotNull('MAKER', _$SortOrderEnumMap[instance.maker]);
  writeNotNull('CNT', _$SortOrderEnumMap[instance.cnt]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  writeNotNull('BUY_DATE', _$SortOrderEnumMap[instance.buyDate]);
  writeNotNull('SELLER', _$SortOrderEnumMap[instance.seller]);
  writeNotNull('MODEL_NO', _$SortOrderEnumMap[instance.modelNo]);
  writeNotNull('SERIAL_NO', _$SortOrderEnumMap[instance.serialNo]);
  writeNotNull('HOSTNAME', _$SortOrderEnumMap[instance.hostname]);
  writeNotNull('BUILT_LOC', _$SortOrderEnumMap[instance.builtLoc]);
  writeNotNull('USE_DESC', _$SortOrderEnumMap[instance.useDesc]);
  writeNotNull('OS_INFO', _$SortOrderEnumMap[instance.osInfo]);
  writeNotNull('CPU_INFO', _$SortOrderEnumMap[instance.cpuInfo]);
  writeNotNull('RAM_INFO', _$SortOrderEnumMap[instance.ramInfo]);
  writeNotNull('HDD_INFO', _$SortOrderEnumMap[instance.hddInfo]);
  writeNotNull('SSD_INFO', _$SortOrderEnumMap[instance.ssdInfo]);
  writeNotNull('ODD', _$SortOrderEnumMap[instance.odd]);
  writeNotNull('REMARKS', _$SortOrderEnumMap[instance.remarks]);
  writeNotNull('CARRY_OUT', _$SortOrderEnumMap[instance.carryOut]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  return val;
}

SERVERASSETTBLAvgOrderByAggregateInput
    _$SERVERASSETTBLAvgOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        SERVERASSETTBLAvgOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          cnt: $enumDecodeNullable(_$SortOrderEnumMap, json['CNT']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
        );

Map<String, dynamic> _$SERVERASSETTBLAvgOrderByAggregateInputToJson(
    SERVERASSETTBLAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('CNT', _$SortOrderEnumMap[instance.cnt]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  return val;
}

SERVERASSETTBLMaxOrderByAggregateInput
    _$SERVERASSETTBLMaxOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        SERVERASSETTBLMaxOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          assetNo: $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_NO']),
          assetType:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_TYPE']),
          maker: $enumDecodeNullable(_$SortOrderEnumMap, json['MAKER']),
          cnt: $enumDecodeNullable(_$SortOrderEnumMap, json['CNT']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
          buyDate: $enumDecodeNullable(_$SortOrderEnumMap, json['BUY_DATE']),
          seller: $enumDecodeNullable(_$SortOrderEnumMap, json['SELLER']),
          modelNo: $enumDecodeNullable(_$SortOrderEnumMap, json['MODEL_NO']),
          serialNo: $enumDecodeNullable(_$SortOrderEnumMap, json['SERIAL_NO']),
          hostname: $enumDecodeNullable(_$SortOrderEnumMap, json['HOSTNAME']),
          builtLoc: $enumDecodeNullable(_$SortOrderEnumMap, json['BUILT_LOC']),
          useDesc: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_DESC']),
          osInfo: $enumDecodeNullable(_$SortOrderEnumMap, json['OS_INFO']),
          cpuInfo: $enumDecodeNullable(_$SortOrderEnumMap, json['CPU_INFO']),
          ramInfo: $enumDecodeNullable(_$SortOrderEnumMap, json['RAM_INFO']),
          hddInfo: $enumDecodeNullable(_$SortOrderEnumMap, json['HDD_INFO']),
          ssdInfo: $enumDecodeNullable(_$SortOrderEnumMap, json['SSD_INFO']),
          odd: $enumDecodeNullable(_$SortOrderEnumMap, json['ODD']),
          remarks: $enumDecodeNullable(_$SortOrderEnumMap, json['REMARKS']),
          carryOut: $enumDecodeNullable(_$SortOrderEnumMap, json['CARRY_OUT']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
        );

Map<String, dynamic> _$SERVERASSETTBLMaxOrderByAggregateInputToJson(
    SERVERASSETTBLMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ASSET_NO', _$SortOrderEnumMap[instance.assetNo]);
  writeNotNull('ASSET_TYPE', _$SortOrderEnumMap[instance.assetType]);
  writeNotNull('MAKER', _$SortOrderEnumMap[instance.maker]);
  writeNotNull('CNT', _$SortOrderEnumMap[instance.cnt]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  writeNotNull('BUY_DATE', _$SortOrderEnumMap[instance.buyDate]);
  writeNotNull('SELLER', _$SortOrderEnumMap[instance.seller]);
  writeNotNull('MODEL_NO', _$SortOrderEnumMap[instance.modelNo]);
  writeNotNull('SERIAL_NO', _$SortOrderEnumMap[instance.serialNo]);
  writeNotNull('HOSTNAME', _$SortOrderEnumMap[instance.hostname]);
  writeNotNull('BUILT_LOC', _$SortOrderEnumMap[instance.builtLoc]);
  writeNotNull('USE_DESC', _$SortOrderEnumMap[instance.useDesc]);
  writeNotNull('OS_INFO', _$SortOrderEnumMap[instance.osInfo]);
  writeNotNull('CPU_INFO', _$SortOrderEnumMap[instance.cpuInfo]);
  writeNotNull('RAM_INFO', _$SortOrderEnumMap[instance.ramInfo]);
  writeNotNull('HDD_INFO', _$SortOrderEnumMap[instance.hddInfo]);
  writeNotNull('SSD_INFO', _$SortOrderEnumMap[instance.ssdInfo]);
  writeNotNull('ODD', _$SortOrderEnumMap[instance.odd]);
  writeNotNull('REMARKS', _$SortOrderEnumMap[instance.remarks]);
  writeNotNull('CARRY_OUT', _$SortOrderEnumMap[instance.carryOut]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  return val;
}

SERVERASSETTBLMinOrderByAggregateInput
    _$SERVERASSETTBLMinOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        SERVERASSETTBLMinOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          assetNo: $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_NO']),
          assetType:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_TYPE']),
          maker: $enumDecodeNullable(_$SortOrderEnumMap, json['MAKER']),
          cnt: $enumDecodeNullable(_$SortOrderEnumMap, json['CNT']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
          buyDate: $enumDecodeNullable(_$SortOrderEnumMap, json['BUY_DATE']),
          seller: $enumDecodeNullable(_$SortOrderEnumMap, json['SELLER']),
          modelNo: $enumDecodeNullable(_$SortOrderEnumMap, json['MODEL_NO']),
          serialNo: $enumDecodeNullable(_$SortOrderEnumMap, json['SERIAL_NO']),
          hostname: $enumDecodeNullable(_$SortOrderEnumMap, json['HOSTNAME']),
          builtLoc: $enumDecodeNullable(_$SortOrderEnumMap, json['BUILT_LOC']),
          useDesc: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_DESC']),
          osInfo: $enumDecodeNullable(_$SortOrderEnumMap, json['OS_INFO']),
          cpuInfo: $enumDecodeNullable(_$SortOrderEnumMap, json['CPU_INFO']),
          ramInfo: $enumDecodeNullable(_$SortOrderEnumMap, json['RAM_INFO']),
          hddInfo: $enumDecodeNullable(_$SortOrderEnumMap, json['HDD_INFO']),
          ssdInfo: $enumDecodeNullable(_$SortOrderEnumMap, json['SSD_INFO']),
          odd: $enumDecodeNullable(_$SortOrderEnumMap, json['ODD']),
          remarks: $enumDecodeNullable(_$SortOrderEnumMap, json['REMARKS']),
          carryOut: $enumDecodeNullable(_$SortOrderEnumMap, json['CARRY_OUT']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
        );

Map<String, dynamic> _$SERVERASSETTBLMinOrderByAggregateInputToJson(
    SERVERASSETTBLMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ASSET_NO', _$SortOrderEnumMap[instance.assetNo]);
  writeNotNull('ASSET_TYPE', _$SortOrderEnumMap[instance.assetType]);
  writeNotNull('MAKER', _$SortOrderEnumMap[instance.maker]);
  writeNotNull('CNT', _$SortOrderEnumMap[instance.cnt]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  writeNotNull('BUY_DATE', _$SortOrderEnumMap[instance.buyDate]);
  writeNotNull('SELLER', _$SortOrderEnumMap[instance.seller]);
  writeNotNull('MODEL_NO', _$SortOrderEnumMap[instance.modelNo]);
  writeNotNull('SERIAL_NO', _$SortOrderEnumMap[instance.serialNo]);
  writeNotNull('HOSTNAME', _$SortOrderEnumMap[instance.hostname]);
  writeNotNull('BUILT_LOC', _$SortOrderEnumMap[instance.builtLoc]);
  writeNotNull('USE_DESC', _$SortOrderEnumMap[instance.useDesc]);
  writeNotNull('OS_INFO', _$SortOrderEnumMap[instance.osInfo]);
  writeNotNull('CPU_INFO', _$SortOrderEnumMap[instance.cpuInfo]);
  writeNotNull('RAM_INFO', _$SortOrderEnumMap[instance.ramInfo]);
  writeNotNull('HDD_INFO', _$SortOrderEnumMap[instance.hddInfo]);
  writeNotNull('SSD_INFO', _$SortOrderEnumMap[instance.ssdInfo]);
  writeNotNull('ODD', _$SortOrderEnumMap[instance.odd]);
  writeNotNull('REMARKS', _$SortOrderEnumMap[instance.remarks]);
  writeNotNull('CARRY_OUT', _$SortOrderEnumMap[instance.carryOut]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  return val;
}

SERVERASSETTBLSumOrderByAggregateInput
    _$SERVERASSETTBLSumOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        SERVERASSETTBLSumOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          cnt: $enumDecodeNullable(_$SortOrderEnumMap, json['CNT']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
        );

Map<String, dynamic> _$SERVERASSETTBLSumOrderByAggregateInputToJson(
    SERVERASSETTBLSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('CNT', _$SortOrderEnumMap[instance.cnt]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  return val;
}

SOFTWAREASSETTBLCountOrderByAggregateInput
    _$SOFTWAREASSETTBLCountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        SOFTWAREASSETTBLCountOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          assetNo: $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_NO']),
          softwareNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['SOFTWARE_NM']),
          versionNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['VERSION_NM']),
          cnt: $enumDecodeNullable(_$SortOrderEnumMap, json['CNT']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
          buyDate: $enumDecodeNullable(_$SortOrderEnumMap, json['BUY_DATE']),
          serialNo: $enumDecodeNullable(_$SortOrderEnumMap, json['SERIAL_NO']),
          licenseNo:
              $enumDecodeNullable(_$SortOrderEnumMap, json['LICENSE_NO']),
          userNm: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_NM']),
          remarks: $enumDecodeNullable(_$SortOrderEnumMap, json['REMARKS']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
        );

Map<String, dynamic> _$SOFTWAREASSETTBLCountOrderByAggregateInputToJson(
    SOFTWAREASSETTBLCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ASSET_NO', _$SortOrderEnumMap[instance.assetNo]);
  writeNotNull('SOFTWARE_NM', _$SortOrderEnumMap[instance.softwareNm]);
  writeNotNull('VERSION_NM', _$SortOrderEnumMap[instance.versionNm]);
  writeNotNull('CNT', _$SortOrderEnumMap[instance.cnt]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  writeNotNull('BUY_DATE', _$SortOrderEnumMap[instance.buyDate]);
  writeNotNull('SERIAL_NO', _$SortOrderEnumMap[instance.serialNo]);
  writeNotNull('LICENSE_NO', _$SortOrderEnumMap[instance.licenseNo]);
  writeNotNull('USER_NM', _$SortOrderEnumMap[instance.userNm]);
  writeNotNull('REMARKS', _$SortOrderEnumMap[instance.remarks]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  return val;
}

SOFTWAREASSETTBLAvgOrderByAggregateInput
    _$SOFTWAREASSETTBLAvgOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        SOFTWAREASSETTBLAvgOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          cnt: $enumDecodeNullable(_$SortOrderEnumMap, json['CNT']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
        );

Map<String, dynamic> _$SOFTWAREASSETTBLAvgOrderByAggregateInputToJson(
    SOFTWAREASSETTBLAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('CNT', _$SortOrderEnumMap[instance.cnt]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  return val;
}

SOFTWAREASSETTBLMaxOrderByAggregateInput
    _$SOFTWAREASSETTBLMaxOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        SOFTWAREASSETTBLMaxOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          assetNo: $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_NO']),
          softwareNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['SOFTWARE_NM']),
          versionNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['VERSION_NM']),
          cnt: $enumDecodeNullable(_$SortOrderEnumMap, json['CNT']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
          buyDate: $enumDecodeNullable(_$SortOrderEnumMap, json['BUY_DATE']),
          serialNo: $enumDecodeNullable(_$SortOrderEnumMap, json['SERIAL_NO']),
          licenseNo:
              $enumDecodeNullable(_$SortOrderEnumMap, json['LICENSE_NO']),
          userNm: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_NM']),
          remarks: $enumDecodeNullable(_$SortOrderEnumMap, json['REMARKS']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
        );

Map<String, dynamic> _$SOFTWAREASSETTBLMaxOrderByAggregateInputToJson(
    SOFTWAREASSETTBLMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ASSET_NO', _$SortOrderEnumMap[instance.assetNo]);
  writeNotNull('SOFTWARE_NM', _$SortOrderEnumMap[instance.softwareNm]);
  writeNotNull('VERSION_NM', _$SortOrderEnumMap[instance.versionNm]);
  writeNotNull('CNT', _$SortOrderEnumMap[instance.cnt]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  writeNotNull('BUY_DATE', _$SortOrderEnumMap[instance.buyDate]);
  writeNotNull('SERIAL_NO', _$SortOrderEnumMap[instance.serialNo]);
  writeNotNull('LICENSE_NO', _$SortOrderEnumMap[instance.licenseNo]);
  writeNotNull('USER_NM', _$SortOrderEnumMap[instance.userNm]);
  writeNotNull('REMARKS', _$SortOrderEnumMap[instance.remarks]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  return val;
}

SOFTWAREASSETTBLMinOrderByAggregateInput
    _$SOFTWAREASSETTBLMinOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        SOFTWAREASSETTBLMinOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          assetNo: $enumDecodeNullable(_$SortOrderEnumMap, json['ASSET_NO']),
          softwareNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['SOFTWARE_NM']),
          versionNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['VERSION_NM']),
          cnt: $enumDecodeNullable(_$SortOrderEnumMap, json['CNT']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
          buyDate: $enumDecodeNullable(_$SortOrderEnumMap, json['BUY_DATE']),
          serialNo: $enumDecodeNullable(_$SortOrderEnumMap, json['SERIAL_NO']),
          licenseNo:
              $enumDecodeNullable(_$SortOrderEnumMap, json['LICENSE_NO']),
          userNm: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_NM']),
          remarks: $enumDecodeNullable(_$SortOrderEnumMap, json['REMARKS']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
        );

Map<String, dynamic> _$SOFTWAREASSETTBLMinOrderByAggregateInputToJson(
    SOFTWAREASSETTBLMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('ASSET_NO', _$SortOrderEnumMap[instance.assetNo]);
  writeNotNull('SOFTWARE_NM', _$SortOrderEnumMap[instance.softwareNm]);
  writeNotNull('VERSION_NM', _$SortOrderEnumMap[instance.versionNm]);
  writeNotNull('CNT', _$SortOrderEnumMap[instance.cnt]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  writeNotNull('BUY_DATE', _$SortOrderEnumMap[instance.buyDate]);
  writeNotNull('SERIAL_NO', _$SortOrderEnumMap[instance.serialNo]);
  writeNotNull('LICENSE_NO', _$SortOrderEnumMap[instance.licenseNo]);
  writeNotNull('USER_NM', _$SortOrderEnumMap[instance.userNm]);
  writeNotNull('REMARKS', _$SortOrderEnumMap[instance.remarks]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  return val;
}

SOFTWAREASSETTBLSumOrderByAggregateInput
    _$SOFTWAREASSETTBLSumOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        SOFTWAREASSETTBLSumOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          cnt: $enumDecodeNullable(_$SortOrderEnumMap, json['CNT']),
          amount: $enumDecodeNullable(_$SortOrderEnumMap, json['AMOUNT']),
        );

Map<String, dynamic> _$SOFTWAREASSETTBLSumOrderByAggregateInputToJson(
    SOFTWAREASSETTBLSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('CNT', _$SortOrderEnumMap[instance.cnt]);
  writeNotNull('AMOUNT', _$SortOrderEnumMap[instance.amount]);
  return val;
}

STADMINMENUCountOrderByAggregateInput
    _$STADMINMENUCountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        STADMINMENUCountOrderByAggregateInput(
          menuCd: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_CD']),
          menuNm: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_NM']),
          menuPath: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_PATH']),
          menuSrt: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_SRT']),
          menuDeps: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_DEPS']),
          menuIcon: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_ICON']),
          menuTp: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_TP']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$STADMINMENUCountOrderByAggregateInputToJson(
    STADMINMENUCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_CD', _$SortOrderEnumMap[instance.menuCd]);
  writeNotNull('MENU_NM', _$SortOrderEnumMap[instance.menuNm]);
  writeNotNull('MENU_PATH', _$SortOrderEnumMap[instance.menuPath]);
  writeNotNull('MENU_SRT', _$SortOrderEnumMap[instance.menuSrt]);
  writeNotNull('MENU_DEPS', _$SortOrderEnumMap[instance.menuDeps]);
  writeNotNull('MENU_ICON', _$SortOrderEnumMap[instance.menuIcon]);
  writeNotNull('MENU_TP', _$SortOrderEnumMap[instance.menuTp]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STADMINMENUAvgOrderByAggregateInput
    _$STADMINMENUAvgOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        STADMINMENUAvgOrderByAggregateInput(
          menuSrt: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_SRT']),
          menuDeps: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_DEPS']),
        );

Map<String, dynamic> _$STADMINMENUAvgOrderByAggregateInputToJson(
    STADMINMENUAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_SRT', _$SortOrderEnumMap[instance.menuSrt]);
  writeNotNull('MENU_DEPS', _$SortOrderEnumMap[instance.menuDeps]);
  return val;
}

STADMINMENUMaxOrderByAggregateInput
    _$STADMINMENUMaxOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        STADMINMENUMaxOrderByAggregateInput(
          menuCd: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_CD']),
          menuNm: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_NM']),
          menuPath: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_PATH']),
          menuSrt: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_SRT']),
          menuDeps: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_DEPS']),
          menuIcon: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_ICON']),
          menuTp: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_TP']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$STADMINMENUMaxOrderByAggregateInputToJson(
    STADMINMENUMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_CD', _$SortOrderEnumMap[instance.menuCd]);
  writeNotNull('MENU_NM', _$SortOrderEnumMap[instance.menuNm]);
  writeNotNull('MENU_PATH', _$SortOrderEnumMap[instance.menuPath]);
  writeNotNull('MENU_SRT', _$SortOrderEnumMap[instance.menuSrt]);
  writeNotNull('MENU_DEPS', _$SortOrderEnumMap[instance.menuDeps]);
  writeNotNull('MENU_ICON', _$SortOrderEnumMap[instance.menuIcon]);
  writeNotNull('MENU_TP', _$SortOrderEnumMap[instance.menuTp]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STADMINMENUMinOrderByAggregateInput
    _$STADMINMENUMinOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        STADMINMENUMinOrderByAggregateInput(
          menuCd: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_CD']),
          menuNm: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_NM']),
          menuPath: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_PATH']),
          menuSrt: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_SRT']),
          menuDeps: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_DEPS']),
          menuIcon: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_ICON']),
          menuTp: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_TP']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$STADMINMENUMinOrderByAggregateInputToJson(
    STADMINMENUMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_CD', _$SortOrderEnumMap[instance.menuCd]);
  writeNotNull('MENU_NM', _$SortOrderEnumMap[instance.menuNm]);
  writeNotNull('MENU_PATH', _$SortOrderEnumMap[instance.menuPath]);
  writeNotNull('MENU_SRT', _$SortOrderEnumMap[instance.menuSrt]);
  writeNotNull('MENU_DEPS', _$SortOrderEnumMap[instance.menuDeps]);
  writeNotNull('MENU_ICON', _$SortOrderEnumMap[instance.menuIcon]);
  writeNotNull('MENU_TP', _$SortOrderEnumMap[instance.menuTp]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STADMINMENUSumOrderByAggregateInput
    _$STADMINMENUSumOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        STADMINMENUSumOrderByAggregateInput(
          menuSrt: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_SRT']),
          menuDeps: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_DEPS']),
        );

Map<String, dynamic> _$STADMINMENUSumOrderByAggregateInputToJson(
    STADMINMENUSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_SRT', _$SortOrderEnumMap[instance.menuSrt]);
  writeNotNull('MENU_DEPS', _$SortOrderEnumMap[instance.menuDeps]);
  return val;
}

STALARMCountOrderByAggregateInput _$STALARMCountOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STALARMCountOrderByAggregateInput(
      seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
      msgCd: $enumDecodeNullable(_$SortOrderEnumMap, json['MSG_CD']),
      msgCnts: $enumDecodeNullable(_$SortOrderEnumMap, json['MSG_CNTS']),
      sendDate: $enumDecodeNullable(_$SortOrderEnumMap, json['SEND_DATE']),
      sendDiv: $enumDecodeNullable(_$SortOrderEnumMap, json['SEND_DIV']),
      sendDeptCd: $enumDecodeNullable(_$SortOrderEnumMap, json['SEND_DEPT_CD']),
      sendId: $enumDecodeNullable(_$SortOrderEnumMap, json['SEND_ID']),
      recvId: $enumDecodeNullable(_$SortOrderEnumMap, json['RECV_ID']),
      popYn: $enumDecodeNullable(_$SortOrderEnumMap, json['POP_YN']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
    );

Map<String, dynamic> _$STALARMCountOrderByAggregateInputToJson(
    STALARMCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSG_CD', _$SortOrderEnumMap[instance.msgCd]);
  writeNotNull('MSG_CNTS', _$SortOrderEnumMap[instance.msgCnts]);
  writeNotNull('SEND_DATE', _$SortOrderEnumMap[instance.sendDate]);
  writeNotNull('SEND_DIV', _$SortOrderEnumMap[instance.sendDiv]);
  writeNotNull('SEND_DEPT_CD', _$SortOrderEnumMap[instance.sendDeptCd]);
  writeNotNull('SEND_ID', _$SortOrderEnumMap[instance.sendId]);
  writeNotNull('RECV_ID', _$SortOrderEnumMap[instance.recvId]);
  writeNotNull('POP_YN', _$SortOrderEnumMap[instance.popYn]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  return val;
}

STALARMAvgOrderByAggregateInput _$STALARMAvgOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STALARMAvgOrderByAggregateInput(
      seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
    );

Map<String, dynamic> _$STALARMAvgOrderByAggregateInputToJson(
    STALARMAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  return val;
}

STALARMMaxOrderByAggregateInput _$STALARMMaxOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STALARMMaxOrderByAggregateInput(
      seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
      msgCd: $enumDecodeNullable(_$SortOrderEnumMap, json['MSG_CD']),
      msgCnts: $enumDecodeNullable(_$SortOrderEnumMap, json['MSG_CNTS']),
      sendDate: $enumDecodeNullable(_$SortOrderEnumMap, json['SEND_DATE']),
      sendDiv: $enumDecodeNullable(_$SortOrderEnumMap, json['SEND_DIV']),
      sendDeptCd: $enumDecodeNullable(_$SortOrderEnumMap, json['SEND_DEPT_CD']),
      sendId: $enumDecodeNullable(_$SortOrderEnumMap, json['SEND_ID']),
      recvId: $enumDecodeNullable(_$SortOrderEnumMap, json['RECV_ID']),
      popYn: $enumDecodeNullable(_$SortOrderEnumMap, json['POP_YN']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
    );

Map<String, dynamic> _$STALARMMaxOrderByAggregateInputToJson(
    STALARMMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSG_CD', _$SortOrderEnumMap[instance.msgCd]);
  writeNotNull('MSG_CNTS', _$SortOrderEnumMap[instance.msgCnts]);
  writeNotNull('SEND_DATE', _$SortOrderEnumMap[instance.sendDate]);
  writeNotNull('SEND_DIV', _$SortOrderEnumMap[instance.sendDiv]);
  writeNotNull('SEND_DEPT_CD', _$SortOrderEnumMap[instance.sendDeptCd]);
  writeNotNull('SEND_ID', _$SortOrderEnumMap[instance.sendId]);
  writeNotNull('RECV_ID', _$SortOrderEnumMap[instance.recvId]);
  writeNotNull('POP_YN', _$SortOrderEnumMap[instance.popYn]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  return val;
}

STALARMMinOrderByAggregateInput _$STALARMMinOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STALARMMinOrderByAggregateInput(
      seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
      msgCd: $enumDecodeNullable(_$SortOrderEnumMap, json['MSG_CD']),
      msgCnts: $enumDecodeNullable(_$SortOrderEnumMap, json['MSG_CNTS']),
      sendDate: $enumDecodeNullable(_$SortOrderEnumMap, json['SEND_DATE']),
      sendDiv: $enumDecodeNullable(_$SortOrderEnumMap, json['SEND_DIV']),
      sendDeptCd: $enumDecodeNullable(_$SortOrderEnumMap, json['SEND_DEPT_CD']),
      sendId: $enumDecodeNullable(_$SortOrderEnumMap, json['SEND_ID']),
      recvId: $enumDecodeNullable(_$SortOrderEnumMap, json['RECV_ID']),
      popYn: $enumDecodeNullable(_$SortOrderEnumMap, json['POP_YN']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
    );

Map<String, dynamic> _$STALARMMinOrderByAggregateInputToJson(
    STALARMMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSG_CD', _$SortOrderEnumMap[instance.msgCd]);
  writeNotNull('MSG_CNTS', _$SortOrderEnumMap[instance.msgCnts]);
  writeNotNull('SEND_DATE', _$SortOrderEnumMap[instance.sendDate]);
  writeNotNull('SEND_DIV', _$SortOrderEnumMap[instance.sendDiv]);
  writeNotNull('SEND_DEPT_CD', _$SortOrderEnumMap[instance.sendDeptCd]);
  writeNotNull('SEND_ID', _$SortOrderEnumMap[instance.sendId]);
  writeNotNull('RECV_ID', _$SortOrderEnumMap[instance.recvId]);
  writeNotNull('POP_YN', _$SortOrderEnumMap[instance.popYn]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  return val;
}

STALARMSumOrderByAggregateInput _$STALARMSumOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STALARMSumOrderByAggregateInput(
      seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
    );

Map<String, dynamic> _$STALARMSumOrderByAggregateInputToJson(
    STALARMSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  return val;
}

STAUDITLOGCountOrderByAggregateInput
    _$STAUDITLOGCountOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        STAUDITLOGCountOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          logCode: $enumDecodeNullable(_$SortOrderEnumMap, json['LOG_CODE']),
          logCnts: $enumDecodeNullable(_$SortOrderEnumMap, json['LOG_CNTS']),
          errCode: $enumDecodeNullable(_$SortOrderEnumMap, json['ERR_CODE']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$STAUDITLOGCountOrderByAggregateInputToJson(
    STAUDITLOGCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('LOG_CODE', _$SortOrderEnumMap[instance.logCode]);
  writeNotNull('LOG_CNTS', _$SortOrderEnumMap[instance.logCnts]);
  writeNotNull('ERR_CODE', _$SortOrderEnumMap[instance.errCode]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STAUDITLOGAvgOrderByAggregateInput _$STAUDITLOGAvgOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STAUDITLOGAvgOrderByAggregateInput(
      seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
    );

Map<String, dynamic> _$STAUDITLOGAvgOrderByAggregateInputToJson(
    STAUDITLOGAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  return val;
}

STAUDITLOGMaxOrderByAggregateInput _$STAUDITLOGMaxOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STAUDITLOGMaxOrderByAggregateInput(
      seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
      logCode: $enumDecodeNullable(_$SortOrderEnumMap, json['LOG_CODE']),
      logCnts: $enumDecodeNullable(_$SortOrderEnumMap, json['LOG_CNTS']),
      errCode: $enumDecodeNullable(_$SortOrderEnumMap, json['ERR_CODE']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STAUDITLOGMaxOrderByAggregateInputToJson(
    STAUDITLOGMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('LOG_CODE', _$SortOrderEnumMap[instance.logCode]);
  writeNotNull('LOG_CNTS', _$SortOrderEnumMap[instance.logCnts]);
  writeNotNull('ERR_CODE', _$SortOrderEnumMap[instance.errCode]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STAUDITLOGMinOrderByAggregateInput _$STAUDITLOGMinOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STAUDITLOGMinOrderByAggregateInput(
      seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
      logCode: $enumDecodeNullable(_$SortOrderEnumMap, json['LOG_CODE']),
      logCnts: $enumDecodeNullable(_$SortOrderEnumMap, json['LOG_CNTS']),
      errCode: $enumDecodeNullable(_$SortOrderEnumMap, json['ERR_CODE']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STAUDITLOGMinOrderByAggregateInputToJson(
    STAUDITLOGMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('LOG_CODE', _$SortOrderEnumMap[instance.logCode]);
  writeNotNull('LOG_CNTS', _$SortOrderEnumMap[instance.logCnts]);
  writeNotNull('ERR_CODE', _$SortOrderEnumMap[instance.errCode]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STAUDITLOGSumOrderByAggregateInput _$STAUDITLOGSumOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STAUDITLOGSumOrderByAggregateInput(
      seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
    );

Map<String, dynamic> _$STAUDITLOGSumOrderByAggregateInputToJson(
    STAUDITLOGSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  return val;
}

STBANNERCountOrderByAggregateInput _$STBANNERCountOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STBANNERCountOrderByAggregateInput(
      bannerCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BANNER_CD']),
      lkUrl: $enumDecodeNullable(_$SortOrderEnumMap, json['LK_URL']),
      lkTarget: $enumDecodeNullable(_$SortOrderEnumMap, json['LK_TARGET']),
      flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
      fileNm: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_NM']),
      useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STBANNERCountOrderByAggregateInputToJson(
    STBANNERCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BANNER_CD', _$SortOrderEnumMap[instance.bannerCd]);
  writeNotNull('LK_URL', _$SortOrderEnumMap[instance.lkUrl]);
  writeNotNull('LK_TARGET', _$SortOrderEnumMap[instance.lkTarget]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('FILE_NM', _$SortOrderEnumMap[instance.fileNm]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STBANNERMaxOrderByAggregateInput _$STBANNERMaxOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STBANNERMaxOrderByAggregateInput(
      bannerCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BANNER_CD']),
      lkUrl: $enumDecodeNullable(_$SortOrderEnumMap, json['LK_URL']),
      lkTarget: $enumDecodeNullable(_$SortOrderEnumMap, json['LK_TARGET']),
      flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
      fileNm: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_NM']),
      useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STBANNERMaxOrderByAggregateInputToJson(
    STBANNERMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BANNER_CD', _$SortOrderEnumMap[instance.bannerCd]);
  writeNotNull('LK_URL', _$SortOrderEnumMap[instance.lkUrl]);
  writeNotNull('LK_TARGET', _$SortOrderEnumMap[instance.lkTarget]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('FILE_NM', _$SortOrderEnumMap[instance.fileNm]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STBANNERMinOrderByAggregateInput _$STBANNERMinOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STBANNERMinOrderByAggregateInput(
      bannerCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BANNER_CD']),
      lkUrl: $enumDecodeNullable(_$SortOrderEnumMap, json['LK_URL']),
      lkTarget: $enumDecodeNullable(_$SortOrderEnumMap, json['LK_TARGET']),
      flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
      fileNm: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_NM']),
      useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STBANNERMinOrderByAggregateInputToJson(
    STBANNERMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BANNER_CD', _$SortOrderEnumMap[instance.bannerCd]);
  writeNotNull('LK_URL', _$SortOrderEnumMap[instance.lkUrl]);
  writeNotNull('LK_TARGET', _$SortOrderEnumMap[instance.lkTarget]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('FILE_NM', _$SortOrderEnumMap[instance.fileNm]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STBOARDCOLUMNBOARDCDCOLCDCompoundUniqueInput
    _$STBOARDCOLUMNBOARDCDCOLCDCompoundUniqueInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDCOLUMNBOARDCDCOLCDCompoundUniqueInput(
          boardCd: json['BOARD_CD'] as String,
          colCd: json['COL_CD'] as String,
        );

Map<String, dynamic> _$STBOARDCOLUMNBOARDCDCOLCDCompoundUniqueInputToJson(
        STBOARDCOLUMNBOARDCDCOLCDCompoundUniqueInput instance) =>
    <String, dynamic>{
      'BOARD_CD': instance.boardCd,
      'COL_CD': instance.colCd,
    };

STBOARDCOLUMNCountOrderByAggregateInput
    _$STBOARDCOLUMNCountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDCOLUMNCountOrderByAggregateInput(
          boardCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_CD']),
          sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
          colCd: $enumDecodeNullable(_$SortOrderEnumMap, json['COL_CD']),
          colNm: $enumDecodeNullable(_$SortOrderEnumMap, json['COL_NM']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
        );

Map<String, dynamic> _$STBOARDCOLUMNCountOrderByAggregateInputToJson(
    STBOARDCOLUMNCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_CD', _$SortOrderEnumMap[instance.boardCd]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('COL_CD', _$SortOrderEnumMap[instance.colCd]);
  writeNotNull('COL_NM', _$SortOrderEnumMap[instance.colNm]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  return val;
}

STBOARDCOLUMNAvgOrderByAggregateInput
    _$STBOARDCOLUMNAvgOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDCOLUMNAvgOrderByAggregateInput(
          sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
        );

Map<String, dynamic> _$STBOARDCOLUMNAvgOrderByAggregateInputToJson(
    STBOARDCOLUMNAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  return val;
}

STBOARDCOLUMNMaxOrderByAggregateInput
    _$STBOARDCOLUMNMaxOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDCOLUMNMaxOrderByAggregateInput(
          boardCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_CD']),
          sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
          colCd: $enumDecodeNullable(_$SortOrderEnumMap, json['COL_CD']),
          colNm: $enumDecodeNullable(_$SortOrderEnumMap, json['COL_NM']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
        );

Map<String, dynamic> _$STBOARDCOLUMNMaxOrderByAggregateInputToJson(
    STBOARDCOLUMNMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_CD', _$SortOrderEnumMap[instance.boardCd]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('COL_CD', _$SortOrderEnumMap[instance.colCd]);
  writeNotNull('COL_NM', _$SortOrderEnumMap[instance.colNm]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  return val;
}

STBOARDCOLUMNMinOrderByAggregateInput
    _$STBOARDCOLUMNMinOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDCOLUMNMinOrderByAggregateInput(
          boardCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_CD']),
          sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
          colCd: $enumDecodeNullable(_$SortOrderEnumMap, json['COL_CD']),
          colNm: $enumDecodeNullable(_$SortOrderEnumMap, json['COL_NM']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
        );

Map<String, dynamic> _$STBOARDCOLUMNMinOrderByAggregateInputToJson(
    STBOARDCOLUMNMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_CD', _$SortOrderEnumMap[instance.boardCd]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('COL_CD', _$SortOrderEnumMap[instance.colCd]);
  writeNotNull('COL_NM', _$SortOrderEnumMap[instance.colNm]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  return val;
}

STBOARDCOLUMNSumOrderByAggregateInput
    _$STBOARDCOLUMNSumOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDCOLUMNSumOrderByAggregateInput(
          sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
        );

Map<String, dynamic> _$STBOARDCOLUMNSumOrderByAggregateInputToJson(
    STBOARDCOLUMNSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  return val;
}

STBOARDCOLUMNDFTBOARDTYCOLCDDELYNCompoundUniqueInput
    _$STBOARDCOLUMNDFTBOARDTYCOLCDDELYNCompoundUniqueInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDCOLUMNDFTBOARDTYCOLCDDELYNCompoundUniqueInput(
          boardTy: json['BOARD_TY'] as String,
          colCd: json['COL_CD'] as String,
          delYn: json['DEL_YN'] as String,
        );

Map<String, dynamic>
    _$STBOARDCOLUMNDFTBOARDTYCOLCDDELYNCompoundUniqueInputToJson(
            STBOARDCOLUMNDFTBOARDTYCOLCDDELYNCompoundUniqueInput instance) =>
        <String, dynamic>{
          'BOARD_TY': instance.boardTy,
          'COL_CD': instance.colCd,
          'DEL_YN': instance.delYn,
        };

STBOARDCOLUMNDFTCountOrderByAggregateInput
    _$STBOARDCOLUMNDFTCountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDCOLUMNDFTCountOrderByAggregateInput(
          boardTy: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_TY']),
          sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
          colCd: $enumDecodeNullable(_$SortOrderEnumMap, json['COL_CD']),
          colNm: $enumDecodeNullable(_$SortOrderEnumMap, json['COL_NM']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$STBOARDCOLUMNDFTCountOrderByAggregateInputToJson(
    STBOARDCOLUMNDFTCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_TY', _$SortOrderEnumMap[instance.boardTy]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('COL_CD', _$SortOrderEnumMap[instance.colCd]);
  writeNotNull('COL_NM', _$SortOrderEnumMap[instance.colNm]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

STBOARDCOLUMNDFTAvgOrderByAggregateInput
    _$STBOARDCOLUMNDFTAvgOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDCOLUMNDFTAvgOrderByAggregateInput(
          sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
        );

Map<String, dynamic> _$STBOARDCOLUMNDFTAvgOrderByAggregateInputToJson(
    STBOARDCOLUMNDFTAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  return val;
}

STBOARDCOLUMNDFTMaxOrderByAggregateInput
    _$STBOARDCOLUMNDFTMaxOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDCOLUMNDFTMaxOrderByAggregateInput(
          boardTy: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_TY']),
          sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
          colCd: $enumDecodeNullable(_$SortOrderEnumMap, json['COL_CD']),
          colNm: $enumDecodeNullable(_$SortOrderEnumMap, json['COL_NM']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$STBOARDCOLUMNDFTMaxOrderByAggregateInputToJson(
    STBOARDCOLUMNDFTMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_TY', _$SortOrderEnumMap[instance.boardTy]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('COL_CD', _$SortOrderEnumMap[instance.colCd]);
  writeNotNull('COL_NM', _$SortOrderEnumMap[instance.colNm]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

STBOARDCOLUMNDFTMinOrderByAggregateInput
    _$STBOARDCOLUMNDFTMinOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDCOLUMNDFTMinOrderByAggregateInput(
          boardTy: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_TY']),
          sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
          colCd: $enumDecodeNullable(_$SortOrderEnumMap, json['COL_CD']),
          colNm: $enumDecodeNullable(_$SortOrderEnumMap, json['COL_NM']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$STBOARDCOLUMNDFTMinOrderByAggregateInputToJson(
    STBOARDCOLUMNDFTMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_TY', _$SortOrderEnumMap[instance.boardTy]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('COL_CD', _$SortOrderEnumMap[instance.colCd]);
  writeNotNull('COL_NM', _$SortOrderEnumMap[instance.colNm]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

STBOARDCOLUMNDFTSumOrderByAggregateInput
    _$STBOARDCOLUMNDFTSumOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDCOLUMNDFTSumOrderByAggregateInput(
          sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
        );

Map<String, dynamic> _$STBOARDCOLUMNDFTSumOrderByAggregateInputToJson(
    STBOARDCOLUMNDFTSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  return val;
}

STBOARDCOMMENTSEQMSEQBOARDCDCompoundUniqueInput
    _$STBOARDCOMMENTSEQMSEQBOARDCDCompoundUniqueInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDCOMMENTSEQMSEQBOARDCDCompoundUniqueInput(
          seq: json['SEQ'] as int,
          mseq: json['MSEQ'] as int,
          boardCd: json['BOARD_CD'] as String,
        );

Map<String, dynamic> _$STBOARDCOMMENTSEQMSEQBOARDCDCompoundUniqueInputToJson(
        STBOARDCOMMENTSEQMSEQBOARDCDCompoundUniqueInput instance) =>
    <String, dynamic>{
      'SEQ': instance.seq,
      'MSEQ': instance.mseq,
      'BOARD_CD': instance.boardCd,
    };

STBOARDCOMMENTCountOrderByAggregateInput
    _$STBOARDCOMMENTCountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDCOMMENTCountOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          boardCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_CD']),
          cnts: $enumDecodeNullable(_$SortOrderEnumMap, json['CNTS']),
          upperSeq: $enumDecodeNullable(_$SortOrderEnumMap, json['UPPER_SEQ']),
          replyYn: $enumDecodeNullable(_$SortOrderEnumMap, json['REPLY_YN']),
          regAdminYn:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ADMIN_YN']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$STBOARDCOMMENTCountOrderByAggregateInputToJson(
    STBOARDCOMMENTCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('BOARD_CD', _$SortOrderEnumMap[instance.boardCd]);
  writeNotNull('CNTS', _$SortOrderEnumMap[instance.cnts]);
  writeNotNull('UPPER_SEQ', _$SortOrderEnumMap[instance.upperSeq]);
  writeNotNull('REPLY_YN', _$SortOrderEnumMap[instance.replyYn]);
  writeNotNull('REG_ADMIN_YN', _$SortOrderEnumMap[instance.regAdminYn]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STBOARDCOMMENTAvgOrderByAggregateInput
    _$STBOARDCOMMENTAvgOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDCOMMENTAvgOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          upperSeq: $enumDecodeNullable(_$SortOrderEnumMap, json['UPPER_SEQ']),
        );

Map<String, dynamic> _$STBOARDCOMMENTAvgOrderByAggregateInputToJson(
    STBOARDCOMMENTAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('UPPER_SEQ', _$SortOrderEnumMap[instance.upperSeq]);
  return val;
}

STBOARDCOMMENTMaxOrderByAggregateInput
    _$STBOARDCOMMENTMaxOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDCOMMENTMaxOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          boardCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_CD']),
          cnts: $enumDecodeNullable(_$SortOrderEnumMap, json['CNTS']),
          upperSeq: $enumDecodeNullable(_$SortOrderEnumMap, json['UPPER_SEQ']),
          replyYn: $enumDecodeNullable(_$SortOrderEnumMap, json['REPLY_YN']),
          regAdminYn:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ADMIN_YN']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$STBOARDCOMMENTMaxOrderByAggregateInputToJson(
    STBOARDCOMMENTMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('BOARD_CD', _$SortOrderEnumMap[instance.boardCd]);
  writeNotNull('CNTS', _$SortOrderEnumMap[instance.cnts]);
  writeNotNull('UPPER_SEQ', _$SortOrderEnumMap[instance.upperSeq]);
  writeNotNull('REPLY_YN', _$SortOrderEnumMap[instance.replyYn]);
  writeNotNull('REG_ADMIN_YN', _$SortOrderEnumMap[instance.regAdminYn]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STBOARDCOMMENTMinOrderByAggregateInput
    _$STBOARDCOMMENTMinOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDCOMMENTMinOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          boardCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_CD']),
          cnts: $enumDecodeNullable(_$SortOrderEnumMap, json['CNTS']),
          upperSeq: $enumDecodeNullable(_$SortOrderEnumMap, json['UPPER_SEQ']),
          replyYn: $enumDecodeNullable(_$SortOrderEnumMap, json['REPLY_YN']),
          regAdminYn:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ADMIN_YN']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$STBOARDCOMMENTMinOrderByAggregateInputToJson(
    STBOARDCOMMENTMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('BOARD_CD', _$SortOrderEnumMap[instance.boardCd]);
  writeNotNull('CNTS', _$SortOrderEnumMap[instance.cnts]);
  writeNotNull('UPPER_SEQ', _$SortOrderEnumMap[instance.upperSeq]);
  writeNotNull('REPLY_YN', _$SortOrderEnumMap[instance.replyYn]);
  writeNotNull('REG_ADMIN_YN', _$SortOrderEnumMap[instance.regAdminYn]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STBOARDCOMMENTSumOrderByAggregateInput
    _$STBOARDCOMMENTSumOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDCOMMENTSumOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          upperSeq: $enumDecodeNullable(_$SortOrderEnumMap, json['UPPER_SEQ']),
        );

Map<String, dynamic> _$STBOARDCOMMENTSumOrderByAggregateInputToJson(
    STBOARDCOMMENTSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('UPPER_SEQ', _$SortOrderEnumMap[instance.upperSeq]);
  return val;
}

STBOARDFILESEQMSEQBOARDCDCompoundUniqueInput
    _$STBOARDFILESEQMSEQBOARDCDCompoundUniqueInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDFILESEQMSEQBOARDCDCompoundUniqueInput(
          seq: json['SEQ'] as int,
          mseq: json['MSEQ'] as int,
          boardCd: json['BOARD_CD'] as String,
        );

Map<String, dynamic> _$STBOARDFILESEQMSEQBOARDCDCompoundUniqueInputToJson(
        STBOARDFILESEQMSEQBOARDCDCompoundUniqueInput instance) =>
    <String, dynamic>{
      'SEQ': instance.seq,
      'MSEQ': instance.mseq,
      'BOARD_CD': instance.boardCd,
    };

STBOARDFILECountOrderByAggregateInput
    _$STBOARDFILECountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDFILECountOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          boardCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_CD']),
          fileTp: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_TP']),
          flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
          orginalFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ORGINAL_FILE_NM']),
          streFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['STRE_FILE_NM']),
          fileSize: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_SIZE']),
          repreYn: $enumDecodeNullable(_$SortOrderEnumMap, json['REPRE_YN']),
          dwldCo: $enumDecodeNullable(_$SortOrderEnumMap, json['DWLD_CO']),
        );

Map<String, dynamic> _$STBOARDFILECountOrderByAggregateInputToJson(
    STBOARDFILECountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('BOARD_CD', _$SortOrderEnumMap[instance.boardCd]);
  writeNotNull('FILE_TP', _$SortOrderEnumMap[instance.fileTp]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('ORGINAL_FILE_NM', _$SortOrderEnumMap[instance.orginalFileNm]);
  writeNotNull('STRE_FILE_NM', _$SortOrderEnumMap[instance.streFileNm]);
  writeNotNull('FILE_SIZE', _$SortOrderEnumMap[instance.fileSize]);
  writeNotNull('REPRE_YN', _$SortOrderEnumMap[instance.repreYn]);
  writeNotNull('DWLD_CO', _$SortOrderEnumMap[instance.dwldCo]);
  return val;
}

STBOARDFILEAvgOrderByAggregateInput
    _$STBOARDFILEAvgOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        STBOARDFILEAvgOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          fileSize: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_SIZE']),
          dwldCo: $enumDecodeNullable(_$SortOrderEnumMap, json['DWLD_CO']),
        );

Map<String, dynamic> _$STBOARDFILEAvgOrderByAggregateInputToJson(
    STBOARDFILEAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('FILE_SIZE', _$SortOrderEnumMap[instance.fileSize]);
  writeNotNull('DWLD_CO', _$SortOrderEnumMap[instance.dwldCo]);
  return val;
}

STBOARDFILEMaxOrderByAggregateInput
    _$STBOARDFILEMaxOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        STBOARDFILEMaxOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          boardCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_CD']),
          fileTp: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_TP']),
          flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
          orginalFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ORGINAL_FILE_NM']),
          streFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['STRE_FILE_NM']),
          fileSize: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_SIZE']),
          repreYn: $enumDecodeNullable(_$SortOrderEnumMap, json['REPRE_YN']),
          dwldCo: $enumDecodeNullable(_$SortOrderEnumMap, json['DWLD_CO']),
        );

Map<String, dynamic> _$STBOARDFILEMaxOrderByAggregateInputToJson(
    STBOARDFILEMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('BOARD_CD', _$SortOrderEnumMap[instance.boardCd]);
  writeNotNull('FILE_TP', _$SortOrderEnumMap[instance.fileTp]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('ORGINAL_FILE_NM', _$SortOrderEnumMap[instance.orginalFileNm]);
  writeNotNull('STRE_FILE_NM', _$SortOrderEnumMap[instance.streFileNm]);
  writeNotNull('FILE_SIZE', _$SortOrderEnumMap[instance.fileSize]);
  writeNotNull('REPRE_YN', _$SortOrderEnumMap[instance.repreYn]);
  writeNotNull('DWLD_CO', _$SortOrderEnumMap[instance.dwldCo]);
  return val;
}

STBOARDFILEMinOrderByAggregateInput
    _$STBOARDFILEMinOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        STBOARDFILEMinOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          boardCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_CD']),
          fileTp: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_TP']),
          flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
          orginalFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ORGINAL_FILE_NM']),
          streFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['STRE_FILE_NM']),
          fileSize: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_SIZE']),
          repreYn: $enumDecodeNullable(_$SortOrderEnumMap, json['REPRE_YN']),
          dwldCo: $enumDecodeNullable(_$SortOrderEnumMap, json['DWLD_CO']),
        );

Map<String, dynamic> _$STBOARDFILEMinOrderByAggregateInputToJson(
    STBOARDFILEMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('BOARD_CD', _$SortOrderEnumMap[instance.boardCd]);
  writeNotNull('FILE_TP', _$SortOrderEnumMap[instance.fileTp]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('ORGINAL_FILE_NM', _$SortOrderEnumMap[instance.orginalFileNm]);
  writeNotNull('STRE_FILE_NM', _$SortOrderEnumMap[instance.streFileNm]);
  writeNotNull('FILE_SIZE', _$SortOrderEnumMap[instance.fileSize]);
  writeNotNull('REPRE_YN', _$SortOrderEnumMap[instance.repreYn]);
  writeNotNull('DWLD_CO', _$SortOrderEnumMap[instance.dwldCo]);
  return val;
}

STBOARDFILESumOrderByAggregateInput
    _$STBOARDFILESumOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        STBOARDFILESumOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          fileSize: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_SIZE']),
          dwldCo: $enumDecodeNullable(_$SortOrderEnumMap, json['DWLD_CO']),
        );

Map<String, dynamic> _$STBOARDFILESumOrderByAggregateInputToJson(
    STBOARDFILESumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('FILE_SIZE', _$SortOrderEnumMap[instance.fileSize]);
  writeNotNull('DWLD_CO', _$SortOrderEnumMap[instance.dwldCo]);
  return val;
}

STBOARDMSTSEQBOARDCDCompoundUniqueInput
    _$STBOARDMSTSEQBOARDCDCompoundUniqueInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDMSTSEQBOARDCDCompoundUniqueInput(
          seq: json['SEQ'] as int,
          boardCd: json['BOARD_CD'] as String,
        );

Map<String, dynamic> _$STBOARDMSTSEQBOARDCDCompoundUniqueInputToJson(
        STBOARDMSTSEQBOARDCDCompoundUniqueInput instance) =>
    <String, dynamic>{
      'SEQ': instance.seq,
      'BOARD_CD': instance.boardCd,
    };

STBOARDMSTCountOrderByAggregateInput
    _$STBOARDMSTCountOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        STBOARDMSTCountOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          boardCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_CD']),
          clsCd: $enumDecodeNullable(_$SortOrderEnumMap, json['CLS_CD']),
          ttl: $enumDecodeNullable(_$SortOrderEnumMap, json['TTL']),
          cnts: $enumDecodeNullable(_$SortOrderEnumMap, json['CNTS']),
          fileYn: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_YN']),
          imageYn: $enumDecodeNullable(_$SortOrderEnumMap, json['IMAGE_YN']),
          noticeYn: $enumDecodeNullable(_$SortOrderEnumMap, json['NOTICE_YN']),
          lkUrl: $enumDecodeNullable(_$SortOrderEnumMap, json['LK_URL']),
          lkTarget: $enumDecodeNullable(_$SortOrderEnumMap, json['LK_TARGET']),
          readCnt: $enumDecodeNullable(_$SortOrderEnumMap, json['READ_CNT']),
          regAdminYn:
              $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ADMIN_YN']),
          replyYn: $enumDecodeNullable(_$SortOrderEnumMap, json['REPLY_YN']),
          upperSeq: $enumDecodeNullable(_$SortOrderEnumMap, json['UPPER_SEQ']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$STBOARDMSTCountOrderByAggregateInputToJson(
    STBOARDMSTCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('BOARD_CD', _$SortOrderEnumMap[instance.boardCd]);
  writeNotNull('CLS_CD', _$SortOrderEnumMap[instance.clsCd]);
  writeNotNull('TTL', _$SortOrderEnumMap[instance.ttl]);
  writeNotNull('CNTS', _$SortOrderEnumMap[instance.cnts]);
  writeNotNull('FILE_YN', _$SortOrderEnumMap[instance.fileYn]);
  writeNotNull('IMAGE_YN', _$SortOrderEnumMap[instance.imageYn]);
  writeNotNull('NOTICE_YN', _$SortOrderEnumMap[instance.noticeYn]);
  writeNotNull('LK_URL', _$SortOrderEnumMap[instance.lkUrl]);
  writeNotNull('LK_TARGET', _$SortOrderEnumMap[instance.lkTarget]);
  writeNotNull('READ_CNT', _$SortOrderEnumMap[instance.readCnt]);
  writeNotNull('REG_ADMIN_YN', _$SortOrderEnumMap[instance.regAdminYn]);
  writeNotNull('REPLY_YN', _$SortOrderEnumMap[instance.replyYn]);
  writeNotNull('UPPER_SEQ', _$SortOrderEnumMap[instance.upperSeq]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STBOARDMSTAvgOrderByAggregateInput _$STBOARDMSTAvgOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDMSTAvgOrderByAggregateInput(
      seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
      readCnt: $enumDecodeNullable(_$SortOrderEnumMap, json['READ_CNT']),
      upperSeq: $enumDecodeNullable(_$SortOrderEnumMap, json['UPPER_SEQ']),
    );

Map<String, dynamic> _$STBOARDMSTAvgOrderByAggregateInputToJson(
    STBOARDMSTAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('READ_CNT', _$SortOrderEnumMap[instance.readCnt]);
  writeNotNull('UPPER_SEQ', _$SortOrderEnumMap[instance.upperSeq]);
  return val;
}

STBOARDMSTMaxOrderByAggregateInput _$STBOARDMSTMaxOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDMSTMaxOrderByAggregateInput(
      seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
      boardCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_CD']),
      clsCd: $enumDecodeNullable(_$SortOrderEnumMap, json['CLS_CD']),
      ttl: $enumDecodeNullable(_$SortOrderEnumMap, json['TTL']),
      cnts: $enumDecodeNullable(_$SortOrderEnumMap, json['CNTS']),
      fileYn: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_YN']),
      imageYn: $enumDecodeNullable(_$SortOrderEnumMap, json['IMAGE_YN']),
      noticeYn: $enumDecodeNullable(_$SortOrderEnumMap, json['NOTICE_YN']),
      lkUrl: $enumDecodeNullable(_$SortOrderEnumMap, json['LK_URL']),
      lkTarget: $enumDecodeNullable(_$SortOrderEnumMap, json['LK_TARGET']),
      readCnt: $enumDecodeNullable(_$SortOrderEnumMap, json['READ_CNT']),
      regAdminYn: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ADMIN_YN']),
      replyYn: $enumDecodeNullable(_$SortOrderEnumMap, json['REPLY_YN']),
      upperSeq: $enumDecodeNullable(_$SortOrderEnumMap, json['UPPER_SEQ']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STBOARDMSTMaxOrderByAggregateInputToJson(
    STBOARDMSTMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('BOARD_CD', _$SortOrderEnumMap[instance.boardCd]);
  writeNotNull('CLS_CD', _$SortOrderEnumMap[instance.clsCd]);
  writeNotNull('TTL', _$SortOrderEnumMap[instance.ttl]);
  writeNotNull('CNTS', _$SortOrderEnumMap[instance.cnts]);
  writeNotNull('FILE_YN', _$SortOrderEnumMap[instance.fileYn]);
  writeNotNull('IMAGE_YN', _$SortOrderEnumMap[instance.imageYn]);
  writeNotNull('NOTICE_YN', _$SortOrderEnumMap[instance.noticeYn]);
  writeNotNull('LK_URL', _$SortOrderEnumMap[instance.lkUrl]);
  writeNotNull('LK_TARGET', _$SortOrderEnumMap[instance.lkTarget]);
  writeNotNull('READ_CNT', _$SortOrderEnumMap[instance.readCnt]);
  writeNotNull('REG_ADMIN_YN', _$SortOrderEnumMap[instance.regAdminYn]);
  writeNotNull('REPLY_YN', _$SortOrderEnumMap[instance.replyYn]);
  writeNotNull('UPPER_SEQ', _$SortOrderEnumMap[instance.upperSeq]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STBOARDMSTMinOrderByAggregateInput _$STBOARDMSTMinOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDMSTMinOrderByAggregateInput(
      seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
      boardCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_CD']),
      clsCd: $enumDecodeNullable(_$SortOrderEnumMap, json['CLS_CD']),
      ttl: $enumDecodeNullable(_$SortOrderEnumMap, json['TTL']),
      cnts: $enumDecodeNullable(_$SortOrderEnumMap, json['CNTS']),
      fileYn: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_YN']),
      imageYn: $enumDecodeNullable(_$SortOrderEnumMap, json['IMAGE_YN']),
      noticeYn: $enumDecodeNullable(_$SortOrderEnumMap, json['NOTICE_YN']),
      lkUrl: $enumDecodeNullable(_$SortOrderEnumMap, json['LK_URL']),
      lkTarget: $enumDecodeNullable(_$SortOrderEnumMap, json['LK_TARGET']),
      readCnt: $enumDecodeNullable(_$SortOrderEnumMap, json['READ_CNT']),
      regAdminYn: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ADMIN_YN']),
      replyYn: $enumDecodeNullable(_$SortOrderEnumMap, json['REPLY_YN']),
      upperSeq: $enumDecodeNullable(_$SortOrderEnumMap, json['UPPER_SEQ']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STBOARDMSTMinOrderByAggregateInputToJson(
    STBOARDMSTMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('BOARD_CD', _$SortOrderEnumMap[instance.boardCd]);
  writeNotNull('CLS_CD', _$SortOrderEnumMap[instance.clsCd]);
  writeNotNull('TTL', _$SortOrderEnumMap[instance.ttl]);
  writeNotNull('CNTS', _$SortOrderEnumMap[instance.cnts]);
  writeNotNull('FILE_YN', _$SortOrderEnumMap[instance.fileYn]);
  writeNotNull('IMAGE_YN', _$SortOrderEnumMap[instance.imageYn]);
  writeNotNull('NOTICE_YN', _$SortOrderEnumMap[instance.noticeYn]);
  writeNotNull('LK_URL', _$SortOrderEnumMap[instance.lkUrl]);
  writeNotNull('LK_TARGET', _$SortOrderEnumMap[instance.lkTarget]);
  writeNotNull('READ_CNT', _$SortOrderEnumMap[instance.readCnt]);
  writeNotNull('REG_ADMIN_YN', _$SortOrderEnumMap[instance.regAdminYn]);
  writeNotNull('REPLY_YN', _$SortOrderEnumMap[instance.replyYn]);
  writeNotNull('UPPER_SEQ', _$SortOrderEnumMap[instance.upperSeq]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STBOARDMSTSumOrderByAggregateInput _$STBOARDMSTSumOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STBOARDMSTSumOrderByAggregateInput(
      seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
      readCnt: $enumDecodeNullable(_$SortOrderEnumMap, json['READ_CNT']),
      upperSeq: $enumDecodeNullable(_$SortOrderEnumMap, json['UPPER_SEQ']),
    );

Map<String, dynamic> _$STBOARDMSTSumOrderByAggregateInputToJson(
    STBOARDMSTSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('READ_CNT', _$SortOrderEnumMap[instance.readCnt]);
  writeNotNull('UPPER_SEQ', _$SortOrderEnumMap[instance.upperSeq]);
  return val;
}

STBOARDSTNGCountOrderByAggregateInput
    _$STBOARDSTNGCountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        STBOARDSTNGCountOrderByAggregateInput(
          boardCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_CD']),
          boardNm: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_NM']),
          boardTy: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_TY']),
          editorYn: $enumDecodeNullable(_$SortOrderEnumMap, json['EDITOR_YN']),
          rlsYn: $enumDecodeNullable(_$SortOrderEnumMap, json['RLS_YN']),
          cclSeq: $enumDecodeNullable(_$SortOrderEnumMap, json['CCL_SEQ']),
          listCnt: $enumDecodeNullable(_$SortOrderEnumMap, json['LIST_CNT']),
          writeYn: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITE_YN']),
          commentYn:
              $enumDecodeNullable(_$SortOrderEnumMap, json['COMMENT_YN']),
          replyYn: $enumDecodeNullable(_$SortOrderEnumMap, json['REPLY_YN']),
          attachYn: $enumDecodeNullable(_$SortOrderEnumMap, json['ATTACH_YN']),
          attachSize:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ATTACH_SIZE']),
          attachCnt:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ATTACH_CNT']),
          attachExt:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ATTACH_EXT']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$STBOARDSTNGCountOrderByAggregateInputToJson(
    STBOARDSTNGCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_CD', _$SortOrderEnumMap[instance.boardCd]);
  writeNotNull('BOARD_NM', _$SortOrderEnumMap[instance.boardNm]);
  writeNotNull('BOARD_TY', _$SortOrderEnumMap[instance.boardTy]);
  writeNotNull('EDITOR_YN', _$SortOrderEnumMap[instance.editorYn]);
  writeNotNull('RLS_YN', _$SortOrderEnumMap[instance.rlsYn]);
  writeNotNull('CCL_SEQ', _$SortOrderEnumMap[instance.cclSeq]);
  writeNotNull('LIST_CNT', _$SortOrderEnumMap[instance.listCnt]);
  writeNotNull('WRITE_YN', _$SortOrderEnumMap[instance.writeYn]);
  writeNotNull('COMMENT_YN', _$SortOrderEnumMap[instance.commentYn]);
  writeNotNull('REPLY_YN', _$SortOrderEnumMap[instance.replyYn]);
  writeNotNull('ATTACH_YN', _$SortOrderEnumMap[instance.attachYn]);
  writeNotNull('ATTACH_SIZE', _$SortOrderEnumMap[instance.attachSize]);
  writeNotNull('ATTACH_CNT', _$SortOrderEnumMap[instance.attachCnt]);
  writeNotNull('ATTACH_EXT', _$SortOrderEnumMap[instance.attachExt]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STBOARDSTNGAvgOrderByAggregateInput
    _$STBOARDSTNGAvgOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        STBOARDSTNGAvgOrderByAggregateInput(
          cclSeq: $enumDecodeNullable(_$SortOrderEnumMap, json['CCL_SEQ']),
          listCnt: $enumDecodeNullable(_$SortOrderEnumMap, json['LIST_CNT']),
        );

Map<String, dynamic> _$STBOARDSTNGAvgOrderByAggregateInputToJson(
    STBOARDSTNGAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CCL_SEQ', _$SortOrderEnumMap[instance.cclSeq]);
  writeNotNull('LIST_CNT', _$SortOrderEnumMap[instance.listCnt]);
  return val;
}

STBOARDSTNGMaxOrderByAggregateInput
    _$STBOARDSTNGMaxOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        STBOARDSTNGMaxOrderByAggregateInput(
          boardCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_CD']),
          boardNm: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_NM']),
          boardTy: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_TY']),
          editorYn: $enumDecodeNullable(_$SortOrderEnumMap, json['EDITOR_YN']),
          rlsYn: $enumDecodeNullable(_$SortOrderEnumMap, json['RLS_YN']),
          cclSeq: $enumDecodeNullable(_$SortOrderEnumMap, json['CCL_SEQ']),
          listCnt: $enumDecodeNullable(_$SortOrderEnumMap, json['LIST_CNT']),
          writeYn: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITE_YN']),
          commentYn:
              $enumDecodeNullable(_$SortOrderEnumMap, json['COMMENT_YN']),
          replyYn: $enumDecodeNullable(_$SortOrderEnumMap, json['REPLY_YN']),
          attachYn: $enumDecodeNullable(_$SortOrderEnumMap, json['ATTACH_YN']),
          attachSize:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ATTACH_SIZE']),
          attachCnt:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ATTACH_CNT']),
          attachExt:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ATTACH_EXT']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$STBOARDSTNGMaxOrderByAggregateInputToJson(
    STBOARDSTNGMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_CD', _$SortOrderEnumMap[instance.boardCd]);
  writeNotNull('BOARD_NM', _$SortOrderEnumMap[instance.boardNm]);
  writeNotNull('BOARD_TY', _$SortOrderEnumMap[instance.boardTy]);
  writeNotNull('EDITOR_YN', _$SortOrderEnumMap[instance.editorYn]);
  writeNotNull('RLS_YN', _$SortOrderEnumMap[instance.rlsYn]);
  writeNotNull('CCL_SEQ', _$SortOrderEnumMap[instance.cclSeq]);
  writeNotNull('LIST_CNT', _$SortOrderEnumMap[instance.listCnt]);
  writeNotNull('WRITE_YN', _$SortOrderEnumMap[instance.writeYn]);
  writeNotNull('COMMENT_YN', _$SortOrderEnumMap[instance.commentYn]);
  writeNotNull('REPLY_YN', _$SortOrderEnumMap[instance.replyYn]);
  writeNotNull('ATTACH_YN', _$SortOrderEnumMap[instance.attachYn]);
  writeNotNull('ATTACH_SIZE', _$SortOrderEnumMap[instance.attachSize]);
  writeNotNull('ATTACH_CNT', _$SortOrderEnumMap[instance.attachCnt]);
  writeNotNull('ATTACH_EXT', _$SortOrderEnumMap[instance.attachExt]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STBOARDSTNGMinOrderByAggregateInput
    _$STBOARDSTNGMinOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        STBOARDSTNGMinOrderByAggregateInput(
          boardCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_CD']),
          boardNm: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_NM']),
          boardTy: $enumDecodeNullable(_$SortOrderEnumMap, json['BOARD_TY']),
          editorYn: $enumDecodeNullable(_$SortOrderEnumMap, json['EDITOR_YN']),
          rlsYn: $enumDecodeNullable(_$SortOrderEnumMap, json['RLS_YN']),
          cclSeq: $enumDecodeNullable(_$SortOrderEnumMap, json['CCL_SEQ']),
          listCnt: $enumDecodeNullable(_$SortOrderEnumMap, json['LIST_CNT']),
          writeYn: $enumDecodeNullable(_$SortOrderEnumMap, json['WRITE_YN']),
          commentYn:
              $enumDecodeNullable(_$SortOrderEnumMap, json['COMMENT_YN']),
          replyYn: $enumDecodeNullable(_$SortOrderEnumMap, json['REPLY_YN']),
          attachYn: $enumDecodeNullable(_$SortOrderEnumMap, json['ATTACH_YN']),
          attachSize:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ATTACH_SIZE']),
          attachCnt:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ATTACH_CNT']),
          attachExt:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ATTACH_EXT']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$STBOARDSTNGMinOrderByAggregateInputToJson(
    STBOARDSTNGMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_CD', _$SortOrderEnumMap[instance.boardCd]);
  writeNotNull('BOARD_NM', _$SortOrderEnumMap[instance.boardNm]);
  writeNotNull('BOARD_TY', _$SortOrderEnumMap[instance.boardTy]);
  writeNotNull('EDITOR_YN', _$SortOrderEnumMap[instance.editorYn]);
  writeNotNull('RLS_YN', _$SortOrderEnumMap[instance.rlsYn]);
  writeNotNull('CCL_SEQ', _$SortOrderEnumMap[instance.cclSeq]);
  writeNotNull('LIST_CNT', _$SortOrderEnumMap[instance.listCnt]);
  writeNotNull('WRITE_YN', _$SortOrderEnumMap[instance.writeYn]);
  writeNotNull('COMMENT_YN', _$SortOrderEnumMap[instance.commentYn]);
  writeNotNull('REPLY_YN', _$SortOrderEnumMap[instance.replyYn]);
  writeNotNull('ATTACH_YN', _$SortOrderEnumMap[instance.attachYn]);
  writeNotNull('ATTACH_SIZE', _$SortOrderEnumMap[instance.attachSize]);
  writeNotNull('ATTACH_CNT', _$SortOrderEnumMap[instance.attachCnt]);
  writeNotNull('ATTACH_EXT', _$SortOrderEnumMap[instance.attachExt]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STBOARDSTNGSumOrderByAggregateInput
    _$STBOARDSTNGSumOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        STBOARDSTNGSumOrderByAggregateInput(
          cclSeq: $enumDecodeNullable(_$SortOrderEnumMap, json['CCL_SEQ']),
          listCnt: $enumDecodeNullable(_$SortOrderEnumMap, json['LIST_CNT']),
        );

Map<String, dynamic> _$STBOARDSTNGSumOrderByAggregateInputToJson(
    STBOARDSTNGSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CCL_SEQ', _$SortOrderEnumMap[instance.cclSeq]);
  writeNotNull('LIST_CNT', _$SortOrderEnumMap[instance.listCnt]);
  return val;
}

STCCLCountOrderByAggregateInput _$STCCLCountOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STCCLCountOrderByAggregateInput(
      seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
      cclType: $enumDecodeNullable(_$SortOrderEnumMap, json['CCL_TYPE']),
      cclNm: $enumDecodeNullable(_$SortOrderEnumMap, json['CCL_NM']),
      flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
      orginalFileNm:
          $enumDecodeNullable(_$SortOrderEnumMap, json['ORGINAL_FILE_NM']),
      streFileNm: $enumDecodeNullable(_$SortOrderEnumMap, json['STRE_FILE_NM']),
      fileExtsn: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_EXTSN']),
      fileSize: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_SIZE']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STCCLCountOrderByAggregateInputToJson(
    STCCLCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('CCL_TYPE', _$SortOrderEnumMap[instance.cclType]);
  writeNotNull('CCL_NM', _$SortOrderEnumMap[instance.cclNm]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('ORGINAL_FILE_NM', _$SortOrderEnumMap[instance.orginalFileNm]);
  writeNotNull('STRE_FILE_NM', _$SortOrderEnumMap[instance.streFileNm]);
  writeNotNull('FILE_EXTSN', _$SortOrderEnumMap[instance.fileExtsn]);
  writeNotNull('FILE_SIZE', _$SortOrderEnumMap[instance.fileSize]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STCCLAvgOrderByAggregateInput _$STCCLAvgOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STCCLAvgOrderByAggregateInput(
      seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
      fileSize: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_SIZE']),
    );

Map<String, dynamic> _$STCCLAvgOrderByAggregateInputToJson(
    STCCLAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('FILE_SIZE', _$SortOrderEnumMap[instance.fileSize]);
  return val;
}

STCCLMaxOrderByAggregateInput _$STCCLMaxOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STCCLMaxOrderByAggregateInput(
      seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
      cclType: $enumDecodeNullable(_$SortOrderEnumMap, json['CCL_TYPE']),
      cclNm: $enumDecodeNullable(_$SortOrderEnumMap, json['CCL_NM']),
      flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
      orginalFileNm:
          $enumDecodeNullable(_$SortOrderEnumMap, json['ORGINAL_FILE_NM']),
      streFileNm: $enumDecodeNullable(_$SortOrderEnumMap, json['STRE_FILE_NM']),
      fileExtsn: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_EXTSN']),
      fileSize: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_SIZE']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STCCLMaxOrderByAggregateInputToJson(
    STCCLMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('CCL_TYPE', _$SortOrderEnumMap[instance.cclType]);
  writeNotNull('CCL_NM', _$SortOrderEnumMap[instance.cclNm]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('ORGINAL_FILE_NM', _$SortOrderEnumMap[instance.orginalFileNm]);
  writeNotNull('STRE_FILE_NM', _$SortOrderEnumMap[instance.streFileNm]);
  writeNotNull('FILE_EXTSN', _$SortOrderEnumMap[instance.fileExtsn]);
  writeNotNull('FILE_SIZE', _$SortOrderEnumMap[instance.fileSize]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STCCLMinOrderByAggregateInput _$STCCLMinOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STCCLMinOrderByAggregateInput(
      seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
      cclType: $enumDecodeNullable(_$SortOrderEnumMap, json['CCL_TYPE']),
      cclNm: $enumDecodeNullable(_$SortOrderEnumMap, json['CCL_NM']),
      flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
      orginalFileNm:
          $enumDecodeNullable(_$SortOrderEnumMap, json['ORGINAL_FILE_NM']),
      streFileNm: $enumDecodeNullable(_$SortOrderEnumMap, json['STRE_FILE_NM']),
      fileExtsn: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_EXTSN']),
      fileSize: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_SIZE']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STCCLMinOrderByAggregateInputToJson(
    STCCLMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('CCL_TYPE', _$SortOrderEnumMap[instance.cclType]);
  writeNotNull('CCL_NM', _$SortOrderEnumMap[instance.cclNm]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('ORGINAL_FILE_NM', _$SortOrderEnumMap[instance.orginalFileNm]);
  writeNotNull('STRE_FILE_NM', _$SortOrderEnumMap[instance.streFileNm]);
  writeNotNull('FILE_EXTSN', _$SortOrderEnumMap[instance.fileExtsn]);
  writeNotNull('FILE_SIZE', _$SortOrderEnumMap[instance.fileSize]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STCCLSumOrderByAggregateInput _$STCCLSumOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STCCLSumOrderByAggregateInput(
      seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
      fileSize: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_SIZE']),
    );

Map<String, dynamic> _$STCCLSumOrderByAggregateInputToJson(
    STCCLSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('FILE_SIZE', _$SortOrderEnumMap[instance.fileSize]);
  return val;
}

STCODEMSTCDGRPCDKEYCompoundUniqueInput
    _$STCODEMSTCDGRPCDKEYCompoundUniqueInputFromJson(
            Map<String, dynamic> json) =>
        STCODEMSTCDGRPCDKEYCompoundUniqueInput(
          cdGrp: json['CD_GRP'] as String,
          cdKey: json['CD_KEY'] as String,
        );

Map<String, dynamic> _$STCODEMSTCDGRPCDKEYCompoundUniqueInputToJson(
        STCODEMSTCDGRPCDKEYCompoundUniqueInput instance) =>
    <String, dynamic>{
      'CD_GRP': instance.cdGrp,
      'CD_KEY': instance.cdKey,
    };

STCODEMSTCountOrderByAggregateInput
    _$STCODEMSTCountOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        STCODEMSTCountOrderByAggregateInput(
          cdGrp: $enumDecodeNullable(_$SortOrderEnumMap, json['CD_GRP']),
          cdKey: $enumDecodeNullable(_$SortOrderEnumMap, json['CD_KEY']),
          cdVal: $enumDecodeNullable(_$SortOrderEnumMap, json['CD_VAL']),
          cdDesc: $enumDecodeNullable(_$SortOrderEnumMap, json['CD_DESC']),
          cdSrt: $enumDecodeNullable(_$SortOrderEnumMap, json['CD_SRT']),
          depth: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPTH']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$STCODEMSTCountOrderByAggregateInputToJson(
    STCODEMSTCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CD_GRP', _$SortOrderEnumMap[instance.cdGrp]);
  writeNotNull('CD_KEY', _$SortOrderEnumMap[instance.cdKey]);
  writeNotNull('CD_VAL', _$SortOrderEnumMap[instance.cdVal]);
  writeNotNull('CD_DESC', _$SortOrderEnumMap[instance.cdDesc]);
  writeNotNull('CD_SRT', _$SortOrderEnumMap[instance.cdSrt]);
  writeNotNull('DEPTH', _$SortOrderEnumMap[instance.depth]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STCODEMSTAvgOrderByAggregateInput _$STCODEMSTAvgOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STCODEMSTAvgOrderByAggregateInput(
      cdSrt: $enumDecodeNullable(_$SortOrderEnumMap, json['CD_SRT']),
      depth: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPTH']),
    );

Map<String, dynamic> _$STCODEMSTAvgOrderByAggregateInputToJson(
    STCODEMSTAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CD_SRT', _$SortOrderEnumMap[instance.cdSrt]);
  writeNotNull('DEPTH', _$SortOrderEnumMap[instance.depth]);
  return val;
}

STCODEMSTMaxOrderByAggregateInput _$STCODEMSTMaxOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STCODEMSTMaxOrderByAggregateInput(
      cdGrp: $enumDecodeNullable(_$SortOrderEnumMap, json['CD_GRP']),
      cdKey: $enumDecodeNullable(_$SortOrderEnumMap, json['CD_KEY']),
      cdVal: $enumDecodeNullable(_$SortOrderEnumMap, json['CD_VAL']),
      cdDesc: $enumDecodeNullable(_$SortOrderEnumMap, json['CD_DESC']),
      cdSrt: $enumDecodeNullable(_$SortOrderEnumMap, json['CD_SRT']),
      depth: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPTH']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STCODEMSTMaxOrderByAggregateInputToJson(
    STCODEMSTMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CD_GRP', _$SortOrderEnumMap[instance.cdGrp]);
  writeNotNull('CD_KEY', _$SortOrderEnumMap[instance.cdKey]);
  writeNotNull('CD_VAL', _$SortOrderEnumMap[instance.cdVal]);
  writeNotNull('CD_DESC', _$SortOrderEnumMap[instance.cdDesc]);
  writeNotNull('CD_SRT', _$SortOrderEnumMap[instance.cdSrt]);
  writeNotNull('DEPTH', _$SortOrderEnumMap[instance.depth]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STCODEMSTMinOrderByAggregateInput _$STCODEMSTMinOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STCODEMSTMinOrderByAggregateInput(
      cdGrp: $enumDecodeNullable(_$SortOrderEnumMap, json['CD_GRP']),
      cdKey: $enumDecodeNullable(_$SortOrderEnumMap, json['CD_KEY']),
      cdVal: $enumDecodeNullable(_$SortOrderEnumMap, json['CD_VAL']),
      cdDesc: $enumDecodeNullable(_$SortOrderEnumMap, json['CD_DESC']),
      cdSrt: $enumDecodeNullable(_$SortOrderEnumMap, json['CD_SRT']),
      depth: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPTH']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STCODEMSTMinOrderByAggregateInputToJson(
    STCODEMSTMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CD_GRP', _$SortOrderEnumMap[instance.cdGrp]);
  writeNotNull('CD_KEY', _$SortOrderEnumMap[instance.cdKey]);
  writeNotNull('CD_VAL', _$SortOrderEnumMap[instance.cdVal]);
  writeNotNull('CD_DESC', _$SortOrderEnumMap[instance.cdDesc]);
  writeNotNull('CD_SRT', _$SortOrderEnumMap[instance.cdSrt]);
  writeNotNull('DEPTH', _$SortOrderEnumMap[instance.depth]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STCODEMSTSumOrderByAggregateInput _$STCODEMSTSumOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STCODEMSTSumOrderByAggregateInput(
      cdSrt: $enumDecodeNullable(_$SortOrderEnumMap, json['CD_SRT']),
      depth: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPTH']),
    );

Map<String, dynamic> _$STCODEMSTSumOrderByAggregateInputToJson(
    STCODEMSTSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CD_SRT', _$SortOrderEnumMap[instance.cdSrt]);
  writeNotNull('DEPTH', _$SortOrderEnumMap[instance.depth]);
  return val;
}

STCONNECTLOGCountOrderByAggregateInput
    _$STCONNECTLOGCountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        STCONNECTLOGCountOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
          connType: $enumDecodeNullable(_$SortOrderEnumMap, json['CONN_TYPE']),
          osType: $enumDecodeNullable(_$SortOrderEnumMap, json['OS_TYPE']),
          browserType:
              $enumDecodeNullable(_$SortOrderEnumMap, json['BROWSER_TYPE']),
          conneIp: $enumDecodeNullable(_$SortOrderEnumMap, json['CONNE_IP']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
        );

Map<String, dynamic> _$STCONNECTLOGCountOrderByAggregateInputToJson(
    STCONNECTLOGCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('CONN_TYPE', _$SortOrderEnumMap[instance.connType]);
  writeNotNull('OS_TYPE', _$SortOrderEnumMap[instance.osType]);
  writeNotNull('BROWSER_TYPE', _$SortOrderEnumMap[instance.browserType]);
  writeNotNull('CONNE_IP', _$SortOrderEnumMap[instance.conneIp]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  return val;
}

STCONNECTLOGAvgOrderByAggregateInput
    _$STCONNECTLOGAvgOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        STCONNECTLOGAvgOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
        );

Map<String, dynamic> _$STCONNECTLOGAvgOrderByAggregateInputToJson(
    STCONNECTLOGAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  return val;
}

STCONNECTLOGMaxOrderByAggregateInput
    _$STCONNECTLOGMaxOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        STCONNECTLOGMaxOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
          connType: $enumDecodeNullable(_$SortOrderEnumMap, json['CONN_TYPE']),
          osType: $enumDecodeNullable(_$SortOrderEnumMap, json['OS_TYPE']),
          browserType:
              $enumDecodeNullable(_$SortOrderEnumMap, json['BROWSER_TYPE']),
          conneIp: $enumDecodeNullable(_$SortOrderEnumMap, json['CONNE_IP']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
        );

Map<String, dynamic> _$STCONNECTLOGMaxOrderByAggregateInputToJson(
    STCONNECTLOGMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('CONN_TYPE', _$SortOrderEnumMap[instance.connType]);
  writeNotNull('OS_TYPE', _$SortOrderEnumMap[instance.osType]);
  writeNotNull('BROWSER_TYPE', _$SortOrderEnumMap[instance.browserType]);
  writeNotNull('CONNE_IP', _$SortOrderEnumMap[instance.conneIp]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  return val;
}

STCONNECTLOGMinOrderByAggregateInput
    _$STCONNECTLOGMinOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        STCONNECTLOGMinOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
          connType: $enumDecodeNullable(_$SortOrderEnumMap, json['CONN_TYPE']),
          osType: $enumDecodeNullable(_$SortOrderEnumMap, json['OS_TYPE']),
          browserType:
              $enumDecodeNullable(_$SortOrderEnumMap, json['BROWSER_TYPE']),
          conneIp: $enumDecodeNullable(_$SortOrderEnumMap, json['CONNE_IP']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
        );

Map<String, dynamic> _$STCONNECTLOGMinOrderByAggregateInputToJson(
    STCONNECTLOGMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('CONN_TYPE', _$SortOrderEnumMap[instance.connType]);
  writeNotNull('OS_TYPE', _$SortOrderEnumMap[instance.osType]);
  writeNotNull('BROWSER_TYPE', _$SortOrderEnumMap[instance.browserType]);
  writeNotNull('CONNE_IP', _$SortOrderEnumMap[instance.conneIp]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  return val;
}

STCONNECTLOGSumOrderByAggregateInput
    _$STCONNECTLOGSumOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        STCONNECTLOGSumOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
        );

Map<String, dynamic> _$STCONNECTLOGSumOrderByAggregateInputToJson(
    STCONNECTLOGSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  return val;
}

STCONTENTSFILECountOrderByAggregateInput
    _$STCONTENTSFILECountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        STCONTENTSFILECountOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          fileTp: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_TP']),
          flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
          orginalFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ORGINAL_FILE_NM']),
          streFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['STRE_FILE_NM']),
          fileSize: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_SIZE']),
        );

Map<String, dynamic> _$STCONTENTSFILECountOrderByAggregateInputToJson(
    STCONTENTSFILECountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('FILE_TP', _$SortOrderEnumMap[instance.fileTp]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('ORGINAL_FILE_NM', _$SortOrderEnumMap[instance.orginalFileNm]);
  writeNotNull('STRE_FILE_NM', _$SortOrderEnumMap[instance.streFileNm]);
  writeNotNull('FILE_SIZE', _$SortOrderEnumMap[instance.fileSize]);
  return val;
}

STCONTENTSFILEAvgOrderByAggregateInput
    _$STCONTENTSFILEAvgOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        STCONTENTSFILEAvgOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          fileSize: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_SIZE']),
        );

Map<String, dynamic> _$STCONTENTSFILEAvgOrderByAggregateInputToJson(
    STCONTENTSFILEAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('FILE_SIZE', _$SortOrderEnumMap[instance.fileSize]);
  return val;
}

STCONTENTSFILEMaxOrderByAggregateInput
    _$STCONTENTSFILEMaxOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        STCONTENTSFILEMaxOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          fileTp: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_TP']),
          flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
          orginalFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ORGINAL_FILE_NM']),
          streFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['STRE_FILE_NM']),
          fileSize: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_SIZE']),
        );

Map<String, dynamic> _$STCONTENTSFILEMaxOrderByAggregateInputToJson(
    STCONTENTSFILEMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('FILE_TP', _$SortOrderEnumMap[instance.fileTp]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('ORGINAL_FILE_NM', _$SortOrderEnumMap[instance.orginalFileNm]);
  writeNotNull('STRE_FILE_NM', _$SortOrderEnumMap[instance.streFileNm]);
  writeNotNull('FILE_SIZE', _$SortOrderEnumMap[instance.fileSize]);
  return val;
}

STCONTENTSFILEMinOrderByAggregateInput
    _$STCONTENTSFILEMinOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        STCONTENTSFILEMinOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          fileTp: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_TP']),
          flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
          orginalFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['ORGINAL_FILE_NM']),
          streFileNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['STRE_FILE_NM']),
          fileSize: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_SIZE']),
        );

Map<String, dynamic> _$STCONTENTSFILEMinOrderByAggregateInputToJson(
    STCONTENTSFILEMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('FILE_TP', _$SortOrderEnumMap[instance.fileTp]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('ORGINAL_FILE_NM', _$SortOrderEnumMap[instance.orginalFileNm]);
  writeNotNull('STRE_FILE_NM', _$SortOrderEnumMap[instance.streFileNm]);
  writeNotNull('FILE_SIZE', _$SortOrderEnumMap[instance.fileSize]);
  return val;
}

STCONTENTSFILESumOrderByAggregateInput
    _$STCONTENTSFILESumOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        STCONTENTSFILESumOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          fileSize: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_SIZE']),
        );

Map<String, dynamic> _$STCONTENTSFILESumOrderByAggregateInputToJson(
    STCONTENTSFILESumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('FILE_SIZE', _$SortOrderEnumMap[instance.fileSize]);
  return val;
}

STCONTENTSMSTCountOrderByAggregateInput
    _$STCONTENTSMSTCountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        STCONTENTSMSTCountOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          cntsNm: $enumDecodeNullable(_$SortOrderEnumMap, json['CNTS_NM']),
          pubDate: $enumDecodeNullable(_$SortOrderEnumMap, json['PUB_DATE']),
          pubState: $enumDecodeNullable(_$SortOrderEnumMap, json['PUB_STATE']),
          cn: $enumDecodeNullable(_$SortOrderEnumMap, json['CN']),
          srchYn: $enumDecodeNullable(_$SortOrderEnumMap, json['SRCH_YN']),
          fileYn: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_YN']),
          imageYn: $enumDecodeNullable(_$SortOrderEnumMap, json['IMAGE_YN']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$STCONTENTSMSTCountOrderByAggregateInputToJson(
    STCONTENTSMSTCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('CNTS_NM', _$SortOrderEnumMap[instance.cntsNm]);
  writeNotNull('PUB_DATE', _$SortOrderEnumMap[instance.pubDate]);
  writeNotNull('PUB_STATE', _$SortOrderEnumMap[instance.pubState]);
  writeNotNull('CN', _$SortOrderEnumMap[instance.cn]);
  writeNotNull('SRCH_YN', _$SortOrderEnumMap[instance.srchYn]);
  writeNotNull('FILE_YN', _$SortOrderEnumMap[instance.fileYn]);
  writeNotNull('IMAGE_YN', _$SortOrderEnumMap[instance.imageYn]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STCONTENTSMSTAvgOrderByAggregateInput
    _$STCONTENTSMSTAvgOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        STCONTENTSMSTAvgOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
        );

Map<String, dynamic> _$STCONTENTSMSTAvgOrderByAggregateInputToJson(
    STCONTENTSMSTAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  return val;
}

STCONTENTSMSTMaxOrderByAggregateInput
    _$STCONTENTSMSTMaxOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        STCONTENTSMSTMaxOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          cntsNm: $enumDecodeNullable(_$SortOrderEnumMap, json['CNTS_NM']),
          pubDate: $enumDecodeNullable(_$SortOrderEnumMap, json['PUB_DATE']),
          pubState: $enumDecodeNullable(_$SortOrderEnumMap, json['PUB_STATE']),
          cn: $enumDecodeNullable(_$SortOrderEnumMap, json['CN']),
          srchYn: $enumDecodeNullable(_$SortOrderEnumMap, json['SRCH_YN']),
          fileYn: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_YN']),
          imageYn: $enumDecodeNullable(_$SortOrderEnumMap, json['IMAGE_YN']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$STCONTENTSMSTMaxOrderByAggregateInputToJson(
    STCONTENTSMSTMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('CNTS_NM', _$SortOrderEnumMap[instance.cntsNm]);
  writeNotNull('PUB_DATE', _$SortOrderEnumMap[instance.pubDate]);
  writeNotNull('PUB_STATE', _$SortOrderEnumMap[instance.pubState]);
  writeNotNull('CN', _$SortOrderEnumMap[instance.cn]);
  writeNotNull('SRCH_YN', _$SortOrderEnumMap[instance.srchYn]);
  writeNotNull('FILE_YN', _$SortOrderEnumMap[instance.fileYn]);
  writeNotNull('IMAGE_YN', _$SortOrderEnumMap[instance.imageYn]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STCONTENTSMSTMinOrderByAggregateInput
    _$STCONTENTSMSTMinOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        STCONTENTSMSTMinOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          cntsNm: $enumDecodeNullable(_$SortOrderEnumMap, json['CNTS_NM']),
          pubDate: $enumDecodeNullable(_$SortOrderEnumMap, json['PUB_DATE']),
          pubState: $enumDecodeNullable(_$SortOrderEnumMap, json['PUB_STATE']),
          cn: $enumDecodeNullable(_$SortOrderEnumMap, json['CN']),
          srchYn: $enumDecodeNullable(_$SortOrderEnumMap, json['SRCH_YN']),
          fileYn: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_YN']),
          imageYn: $enumDecodeNullable(_$SortOrderEnumMap, json['IMAGE_YN']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$STCONTENTSMSTMinOrderByAggregateInputToJson(
    STCONTENTSMSTMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('CNTS_NM', _$SortOrderEnumMap[instance.cntsNm]);
  writeNotNull('PUB_DATE', _$SortOrderEnumMap[instance.pubDate]);
  writeNotNull('PUB_STATE', _$SortOrderEnumMap[instance.pubState]);
  writeNotNull('CN', _$SortOrderEnumMap[instance.cn]);
  writeNotNull('SRCH_YN', _$SortOrderEnumMap[instance.srchYn]);
  writeNotNull('FILE_YN', _$SortOrderEnumMap[instance.fileYn]);
  writeNotNull('IMAGE_YN', _$SortOrderEnumMap[instance.imageYn]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STCONTENTSMSTSumOrderByAggregateInput
    _$STCONTENTSMSTSumOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        STCONTENTSMSTSumOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
        );

Map<String, dynamic> _$STCONTENTSMSTSumOrderByAggregateInputToJson(
    STCONTENTSMSTSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  return val;
}

STDEPTCountOrderByAggregateInput _$STDEPTCountOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STDEPTCountOrderByAggregateInput(
      deptCd: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT_CD']),
      deptNm: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT_NM']),
      upperDeptCd:
          $enumDecodeNullable(_$SortOrderEnumMap, json['UPPER_DEPT_CD']),
      upperDeptNm:
          $enumDecodeNullable(_$SortOrderEnumMap, json['UPPER_DEPT_NM']),
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
      mainYn: $enumDecodeNullable(_$SortOrderEnumMap, json['MAIN_YN']),
      deptDesc: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT_DESC']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STDEPTCountOrderByAggregateInputToJson(
    STDEPTCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('DEPT_CD', _$SortOrderEnumMap[instance.deptCd]);
  writeNotNull('DEPT_NM', _$SortOrderEnumMap[instance.deptNm]);
  writeNotNull('UPPER_DEPT_CD', _$SortOrderEnumMap[instance.upperDeptCd]);
  writeNotNull('UPPER_DEPT_NM', _$SortOrderEnumMap[instance.upperDeptNm]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('MAIN_YN', _$SortOrderEnumMap[instance.mainYn]);
  writeNotNull('DEPT_DESC', _$SortOrderEnumMap[instance.deptDesc]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STDEPTAvgOrderByAggregateInput _$STDEPTAvgOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STDEPTAvgOrderByAggregateInput(
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
    );

Map<String, dynamic> _$STDEPTAvgOrderByAggregateInputToJson(
    STDEPTAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  return val;
}

STDEPTMaxOrderByAggregateInput _$STDEPTMaxOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STDEPTMaxOrderByAggregateInput(
      deptCd: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT_CD']),
      deptNm: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT_NM']),
      upperDeptCd:
          $enumDecodeNullable(_$SortOrderEnumMap, json['UPPER_DEPT_CD']),
      upperDeptNm:
          $enumDecodeNullable(_$SortOrderEnumMap, json['UPPER_DEPT_NM']),
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
      mainYn: $enumDecodeNullable(_$SortOrderEnumMap, json['MAIN_YN']),
      deptDesc: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT_DESC']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STDEPTMaxOrderByAggregateInputToJson(
    STDEPTMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('DEPT_CD', _$SortOrderEnumMap[instance.deptCd]);
  writeNotNull('DEPT_NM', _$SortOrderEnumMap[instance.deptNm]);
  writeNotNull('UPPER_DEPT_CD', _$SortOrderEnumMap[instance.upperDeptCd]);
  writeNotNull('UPPER_DEPT_NM', _$SortOrderEnumMap[instance.upperDeptNm]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('MAIN_YN', _$SortOrderEnumMap[instance.mainYn]);
  writeNotNull('DEPT_DESC', _$SortOrderEnumMap[instance.deptDesc]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STDEPTMinOrderByAggregateInput _$STDEPTMinOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STDEPTMinOrderByAggregateInput(
      deptCd: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT_CD']),
      deptNm: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT_NM']),
      upperDeptCd:
          $enumDecodeNullable(_$SortOrderEnumMap, json['UPPER_DEPT_CD']),
      upperDeptNm:
          $enumDecodeNullable(_$SortOrderEnumMap, json['UPPER_DEPT_NM']),
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
      mainYn: $enumDecodeNullable(_$SortOrderEnumMap, json['MAIN_YN']),
      deptDesc: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT_DESC']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STDEPTMinOrderByAggregateInputToJson(
    STDEPTMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('DEPT_CD', _$SortOrderEnumMap[instance.deptCd]);
  writeNotNull('DEPT_NM', _$SortOrderEnumMap[instance.deptNm]);
  writeNotNull('UPPER_DEPT_CD', _$SortOrderEnumMap[instance.upperDeptCd]);
  writeNotNull('UPPER_DEPT_NM', _$SortOrderEnumMap[instance.upperDeptNm]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('MAIN_YN', _$SortOrderEnumMap[instance.mainYn]);
  writeNotNull('DEPT_DESC', _$SortOrderEnumMap[instance.deptDesc]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STDEPTSumOrderByAggregateInput _$STDEPTSumOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STDEPTSumOrderByAggregateInput(
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
    );

Map<String, dynamic> _$STDEPTSumOrderByAggregateInputToJson(
    STDEPTSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  return val;
}

STDEPTEMPCountOrderByAggregateInput
    _$STDEPTEMPCountOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        STDEPTEMPCountOrderByAggregateInput(
          empNo: $enumDecodeNullable(_$SortOrderEnumMap, json['EMP_NO']),
          empNm: $enumDecodeNullable(_$SortOrderEnumMap, json['EMP_NM']),
          deptCd: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT_CD']),
          deptNm: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT_NM']),
          fctnCd: $enumDecodeNullable(_$SortOrderEnumMap, json['FCTN_CD']),
          fctnNm: $enumDecodeNullable(_$SortOrderEnumMap, json['FCTN_NM']),
          ofcpCd: $enumDecodeNullable(_$SortOrderEnumMap, json['OFCP_CD']),
          ofcpNm: $enumDecodeNullable(_$SortOrderEnumMap, json['OFCP_NM']),
          emailAddr:
              $enumDecodeNullable(_$SortOrderEnumMap, json['EMAIL_ADDR']),
          offmTelno:
              $enumDecodeNullable(_$SortOrderEnumMap, json['OFFM_TELNO']),
          htelTelno:
              $enumDecodeNullable(_$SortOrderEnumMap, json['HTEL_TELNO']),
          deptYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT_YN']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$STDEPTEMPCountOrderByAggregateInputToJson(
    STDEPTEMPCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('EMP_NO', _$SortOrderEnumMap[instance.empNo]);
  writeNotNull('EMP_NM', _$SortOrderEnumMap[instance.empNm]);
  writeNotNull('DEPT_CD', _$SortOrderEnumMap[instance.deptCd]);
  writeNotNull('DEPT_NM', _$SortOrderEnumMap[instance.deptNm]);
  writeNotNull('FCTN_CD', _$SortOrderEnumMap[instance.fctnCd]);
  writeNotNull('FCTN_NM', _$SortOrderEnumMap[instance.fctnNm]);
  writeNotNull('OFCP_CD', _$SortOrderEnumMap[instance.ofcpCd]);
  writeNotNull('OFCP_NM', _$SortOrderEnumMap[instance.ofcpNm]);
  writeNotNull('EMAIL_ADDR', _$SortOrderEnumMap[instance.emailAddr]);
  writeNotNull('OFFM_TELNO', _$SortOrderEnumMap[instance.offmTelno]);
  writeNotNull('HTEL_TELNO', _$SortOrderEnumMap[instance.htelTelno]);
  writeNotNull('DEPT_YN', _$SortOrderEnumMap[instance.deptYn]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STDEPTEMPMaxOrderByAggregateInput _$STDEPTEMPMaxOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STDEPTEMPMaxOrderByAggregateInput(
      empNo: $enumDecodeNullable(_$SortOrderEnumMap, json['EMP_NO']),
      empNm: $enumDecodeNullable(_$SortOrderEnumMap, json['EMP_NM']),
      deptCd: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT_CD']),
      deptNm: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT_NM']),
      fctnCd: $enumDecodeNullable(_$SortOrderEnumMap, json['FCTN_CD']),
      fctnNm: $enumDecodeNullable(_$SortOrderEnumMap, json['FCTN_NM']),
      ofcpCd: $enumDecodeNullable(_$SortOrderEnumMap, json['OFCP_CD']),
      ofcpNm: $enumDecodeNullable(_$SortOrderEnumMap, json['OFCP_NM']),
      emailAddr: $enumDecodeNullable(_$SortOrderEnumMap, json['EMAIL_ADDR']),
      offmTelno: $enumDecodeNullable(_$SortOrderEnumMap, json['OFFM_TELNO']),
      htelTelno: $enumDecodeNullable(_$SortOrderEnumMap, json['HTEL_TELNO']),
      deptYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT_YN']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STDEPTEMPMaxOrderByAggregateInputToJson(
    STDEPTEMPMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('EMP_NO', _$SortOrderEnumMap[instance.empNo]);
  writeNotNull('EMP_NM', _$SortOrderEnumMap[instance.empNm]);
  writeNotNull('DEPT_CD', _$SortOrderEnumMap[instance.deptCd]);
  writeNotNull('DEPT_NM', _$SortOrderEnumMap[instance.deptNm]);
  writeNotNull('FCTN_CD', _$SortOrderEnumMap[instance.fctnCd]);
  writeNotNull('FCTN_NM', _$SortOrderEnumMap[instance.fctnNm]);
  writeNotNull('OFCP_CD', _$SortOrderEnumMap[instance.ofcpCd]);
  writeNotNull('OFCP_NM', _$SortOrderEnumMap[instance.ofcpNm]);
  writeNotNull('EMAIL_ADDR', _$SortOrderEnumMap[instance.emailAddr]);
  writeNotNull('OFFM_TELNO', _$SortOrderEnumMap[instance.offmTelno]);
  writeNotNull('HTEL_TELNO', _$SortOrderEnumMap[instance.htelTelno]);
  writeNotNull('DEPT_YN', _$SortOrderEnumMap[instance.deptYn]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STDEPTEMPMinOrderByAggregateInput _$STDEPTEMPMinOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STDEPTEMPMinOrderByAggregateInput(
      empNo: $enumDecodeNullable(_$SortOrderEnumMap, json['EMP_NO']),
      empNm: $enumDecodeNullable(_$SortOrderEnumMap, json['EMP_NM']),
      deptCd: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT_CD']),
      deptNm: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT_NM']),
      fctnCd: $enumDecodeNullable(_$SortOrderEnumMap, json['FCTN_CD']),
      fctnNm: $enumDecodeNullable(_$SortOrderEnumMap, json['FCTN_NM']),
      ofcpCd: $enumDecodeNullable(_$SortOrderEnumMap, json['OFCP_CD']),
      ofcpNm: $enumDecodeNullable(_$SortOrderEnumMap, json['OFCP_NM']),
      emailAddr: $enumDecodeNullable(_$SortOrderEnumMap, json['EMAIL_ADDR']),
      offmTelno: $enumDecodeNullable(_$SortOrderEnumMap, json['OFFM_TELNO']),
      htelTelno: $enumDecodeNullable(_$SortOrderEnumMap, json['HTEL_TELNO']),
      deptYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT_YN']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STDEPTEMPMinOrderByAggregateInputToJson(
    STDEPTEMPMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('EMP_NO', _$SortOrderEnumMap[instance.empNo]);
  writeNotNull('EMP_NM', _$SortOrderEnumMap[instance.empNm]);
  writeNotNull('DEPT_CD', _$SortOrderEnumMap[instance.deptCd]);
  writeNotNull('DEPT_NM', _$SortOrderEnumMap[instance.deptNm]);
  writeNotNull('FCTN_CD', _$SortOrderEnumMap[instance.fctnCd]);
  writeNotNull('FCTN_NM', _$SortOrderEnumMap[instance.fctnNm]);
  writeNotNull('OFCP_CD', _$SortOrderEnumMap[instance.ofcpCd]);
  writeNotNull('OFCP_NM', _$SortOrderEnumMap[instance.ofcpNm]);
  writeNotNull('EMAIL_ADDR', _$SortOrderEnumMap[instance.emailAddr]);
  writeNotNull('OFFM_TELNO', _$SortOrderEnumMap[instance.offmTelno]);
  writeNotNull('HTEL_TELNO', _$SortOrderEnumMap[instance.htelTelno]);
  writeNotNull('DEPT_YN', _$SortOrderEnumMap[instance.deptYn]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STMENUCountOrderByAggregateInput _$STMENUCountOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STMENUCountOrderByAggregateInput(
      menuCd: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_CD']),
      menuNm: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_NM']),
      menuPath: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_PATH']),
      menuMapping:
          $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_MAPPING']),
      menuSrt: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_SRT']),
      menuDeps: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_DEPS']),
      menuIcon: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_ICON']),
      menuTp: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_TP']),
      mainExpsrYn:
          $enumDecodeNullable(_$SortOrderEnumMap, json['MAIN_EXPSR_YN']),
      subExpsrYn: $enumDecodeNullable(_$SortOrderEnumMap, json['SUB_EXPSR_YN']),
      upendClas: $enumDecodeNullable(_$SortOrderEnumMap, json['UPEND_CLAS']),
      upendCn: $enumDecodeNullable(_$SortOrderEnumMap, json['UPEND_CN']),
      cclType: $enumDecodeNullable(_$SortOrderEnumMap, json['CCL_TYPE']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STMENUCountOrderByAggregateInputToJson(
    STMENUCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_CD', _$SortOrderEnumMap[instance.menuCd]);
  writeNotNull('MENU_NM', _$SortOrderEnumMap[instance.menuNm]);
  writeNotNull('MENU_PATH', _$SortOrderEnumMap[instance.menuPath]);
  writeNotNull('MENU_MAPPING', _$SortOrderEnumMap[instance.menuMapping]);
  writeNotNull('MENU_SRT', _$SortOrderEnumMap[instance.menuSrt]);
  writeNotNull('MENU_DEPS', _$SortOrderEnumMap[instance.menuDeps]);
  writeNotNull('MENU_ICON', _$SortOrderEnumMap[instance.menuIcon]);
  writeNotNull('MENU_TP', _$SortOrderEnumMap[instance.menuTp]);
  writeNotNull('MAIN_EXPSR_YN', _$SortOrderEnumMap[instance.mainExpsrYn]);
  writeNotNull('SUB_EXPSR_YN', _$SortOrderEnumMap[instance.subExpsrYn]);
  writeNotNull('UPEND_CLAS', _$SortOrderEnumMap[instance.upendClas]);
  writeNotNull('UPEND_CN', _$SortOrderEnumMap[instance.upendCn]);
  writeNotNull('CCL_TYPE', _$SortOrderEnumMap[instance.cclType]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STMENUAvgOrderByAggregateInput _$STMENUAvgOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STMENUAvgOrderByAggregateInput(
      menuSrt: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_SRT']),
      menuDeps: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_DEPS']),
    );

Map<String, dynamic> _$STMENUAvgOrderByAggregateInputToJson(
    STMENUAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_SRT', _$SortOrderEnumMap[instance.menuSrt]);
  writeNotNull('MENU_DEPS', _$SortOrderEnumMap[instance.menuDeps]);
  return val;
}

STMENUMaxOrderByAggregateInput _$STMENUMaxOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STMENUMaxOrderByAggregateInput(
      menuCd: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_CD']),
      menuNm: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_NM']),
      menuPath: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_PATH']),
      menuMapping:
          $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_MAPPING']),
      menuSrt: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_SRT']),
      menuDeps: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_DEPS']),
      menuIcon: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_ICON']),
      menuTp: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_TP']),
      mainExpsrYn:
          $enumDecodeNullable(_$SortOrderEnumMap, json['MAIN_EXPSR_YN']),
      subExpsrYn: $enumDecodeNullable(_$SortOrderEnumMap, json['SUB_EXPSR_YN']),
      upendClas: $enumDecodeNullable(_$SortOrderEnumMap, json['UPEND_CLAS']),
      upendCn: $enumDecodeNullable(_$SortOrderEnumMap, json['UPEND_CN']),
      cclType: $enumDecodeNullable(_$SortOrderEnumMap, json['CCL_TYPE']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STMENUMaxOrderByAggregateInputToJson(
    STMENUMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_CD', _$SortOrderEnumMap[instance.menuCd]);
  writeNotNull('MENU_NM', _$SortOrderEnumMap[instance.menuNm]);
  writeNotNull('MENU_PATH', _$SortOrderEnumMap[instance.menuPath]);
  writeNotNull('MENU_MAPPING', _$SortOrderEnumMap[instance.menuMapping]);
  writeNotNull('MENU_SRT', _$SortOrderEnumMap[instance.menuSrt]);
  writeNotNull('MENU_DEPS', _$SortOrderEnumMap[instance.menuDeps]);
  writeNotNull('MENU_ICON', _$SortOrderEnumMap[instance.menuIcon]);
  writeNotNull('MENU_TP', _$SortOrderEnumMap[instance.menuTp]);
  writeNotNull('MAIN_EXPSR_YN', _$SortOrderEnumMap[instance.mainExpsrYn]);
  writeNotNull('SUB_EXPSR_YN', _$SortOrderEnumMap[instance.subExpsrYn]);
  writeNotNull('UPEND_CLAS', _$SortOrderEnumMap[instance.upendClas]);
  writeNotNull('UPEND_CN', _$SortOrderEnumMap[instance.upendCn]);
  writeNotNull('CCL_TYPE', _$SortOrderEnumMap[instance.cclType]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STMENUMinOrderByAggregateInput _$STMENUMinOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STMENUMinOrderByAggregateInput(
      menuCd: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_CD']),
      menuNm: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_NM']),
      menuPath: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_PATH']),
      menuMapping:
          $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_MAPPING']),
      menuSrt: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_SRT']),
      menuDeps: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_DEPS']),
      menuIcon: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_ICON']),
      menuTp: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_TP']),
      mainExpsrYn:
          $enumDecodeNullable(_$SortOrderEnumMap, json['MAIN_EXPSR_YN']),
      subExpsrYn: $enumDecodeNullable(_$SortOrderEnumMap, json['SUB_EXPSR_YN']),
      upendClas: $enumDecodeNullable(_$SortOrderEnumMap, json['UPEND_CLAS']),
      upendCn: $enumDecodeNullable(_$SortOrderEnumMap, json['UPEND_CN']),
      cclType: $enumDecodeNullable(_$SortOrderEnumMap, json['CCL_TYPE']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STMENUMinOrderByAggregateInputToJson(
    STMENUMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_CD', _$SortOrderEnumMap[instance.menuCd]);
  writeNotNull('MENU_NM', _$SortOrderEnumMap[instance.menuNm]);
  writeNotNull('MENU_PATH', _$SortOrderEnumMap[instance.menuPath]);
  writeNotNull('MENU_MAPPING', _$SortOrderEnumMap[instance.menuMapping]);
  writeNotNull('MENU_SRT', _$SortOrderEnumMap[instance.menuSrt]);
  writeNotNull('MENU_DEPS', _$SortOrderEnumMap[instance.menuDeps]);
  writeNotNull('MENU_ICON', _$SortOrderEnumMap[instance.menuIcon]);
  writeNotNull('MENU_TP', _$SortOrderEnumMap[instance.menuTp]);
  writeNotNull('MAIN_EXPSR_YN', _$SortOrderEnumMap[instance.mainExpsrYn]);
  writeNotNull('SUB_EXPSR_YN', _$SortOrderEnumMap[instance.subExpsrYn]);
  writeNotNull('UPEND_CLAS', _$SortOrderEnumMap[instance.upendClas]);
  writeNotNull('UPEND_CN', _$SortOrderEnumMap[instance.upendCn]);
  writeNotNull('CCL_TYPE', _$SortOrderEnumMap[instance.cclType]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STMENUSumOrderByAggregateInput _$STMENUSumOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STMENUSumOrderByAggregateInput(
      menuSrt: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_SRT']),
      menuDeps: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_DEPS']),
    );

Map<String, dynamic> _$STMENUSumOrderByAggregateInputToJson(
    STMENUSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_SRT', _$SortOrderEnumMap[instance.menuSrt]);
  writeNotNull('MENU_DEPS', _$SortOrderEnumMap[instance.menuDeps]);
  return val;
}

STMESSAGETMPLATMSGDIVCDMSGCDCompoundUniqueInput
    _$STMESSAGETMPLATMSGDIVCDMSGCDCompoundUniqueInputFromJson(
            Map<String, dynamic> json) =>
        STMESSAGETMPLATMSGDIVCDMSGCDCompoundUniqueInput(
          msgDivCd: json['MSG_DIV_CD'] as String,
          msgCd: json['MSG_CD'] as String,
        );

Map<String, dynamic> _$STMESSAGETMPLATMSGDIVCDMSGCDCompoundUniqueInputToJson(
        STMESSAGETMPLATMSGDIVCDMSGCDCompoundUniqueInput instance) =>
    <String, dynamic>{
      'MSG_DIV_CD': instance.msgDivCd,
      'MSG_CD': instance.msgCd,
    };

STMESSAGETMPLATCountOrderByAggregateInput
    _$STMESSAGETMPLATCountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        STMESSAGETMPLATCountOrderByAggregateInput(
          msgDivCd: $enumDecodeNullable(_$SortOrderEnumMap, json['MSG_DIV_CD']),
          msgCd: $enumDecodeNullable(_$SortOrderEnumMap, json['MSG_CD']),
          msgNm: $enumDecodeNullable(_$SortOrderEnumMap, json['MSG_NM']),
          msgTmplat:
              $enumDecodeNullable(_$SortOrderEnumMap, json['MSG_TMPLAT']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
        );

Map<String, dynamic> _$STMESSAGETMPLATCountOrderByAggregateInputToJson(
    STMESSAGETMPLATCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MSG_DIV_CD', _$SortOrderEnumMap[instance.msgDivCd]);
  writeNotNull('MSG_CD', _$SortOrderEnumMap[instance.msgCd]);
  writeNotNull('MSG_NM', _$SortOrderEnumMap[instance.msgNm]);
  writeNotNull('MSG_TMPLAT', _$SortOrderEnumMap[instance.msgTmplat]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  return val;
}

STMESSAGETMPLATMaxOrderByAggregateInput
    _$STMESSAGETMPLATMaxOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        STMESSAGETMPLATMaxOrderByAggregateInput(
          msgDivCd: $enumDecodeNullable(_$SortOrderEnumMap, json['MSG_DIV_CD']),
          msgCd: $enumDecodeNullable(_$SortOrderEnumMap, json['MSG_CD']),
          msgNm: $enumDecodeNullable(_$SortOrderEnumMap, json['MSG_NM']),
          msgTmplat:
              $enumDecodeNullable(_$SortOrderEnumMap, json['MSG_TMPLAT']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
        );

Map<String, dynamic> _$STMESSAGETMPLATMaxOrderByAggregateInputToJson(
    STMESSAGETMPLATMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MSG_DIV_CD', _$SortOrderEnumMap[instance.msgDivCd]);
  writeNotNull('MSG_CD', _$SortOrderEnumMap[instance.msgCd]);
  writeNotNull('MSG_NM', _$SortOrderEnumMap[instance.msgNm]);
  writeNotNull('MSG_TMPLAT', _$SortOrderEnumMap[instance.msgTmplat]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  return val;
}

STMESSAGETMPLATMinOrderByAggregateInput
    _$STMESSAGETMPLATMinOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        STMESSAGETMPLATMinOrderByAggregateInput(
          msgDivCd: $enumDecodeNullable(_$SortOrderEnumMap, json['MSG_DIV_CD']),
          msgCd: $enumDecodeNullable(_$SortOrderEnumMap, json['MSG_CD']),
          msgNm: $enumDecodeNullable(_$SortOrderEnumMap, json['MSG_NM']),
          msgTmplat:
              $enumDecodeNullable(_$SortOrderEnumMap, json['MSG_TMPLAT']),
          useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
        );

Map<String, dynamic> _$STMESSAGETMPLATMinOrderByAggregateInputToJson(
    STMESSAGETMPLATMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MSG_DIV_CD', _$SortOrderEnumMap[instance.msgDivCd]);
  writeNotNull('MSG_CD', _$SortOrderEnumMap[instance.msgCd]);
  writeNotNull('MSG_NM', _$SortOrderEnumMap[instance.msgNm]);
  writeNotNull('MSG_TMPLAT', _$SortOrderEnumMap[instance.msgTmplat]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  return val;
}

STMIMETYPECountOrderByAggregateInput
    _$STMIMETYPECountOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        STMIMETYPECountOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          extnNm: $enumDecodeNullable(_$SortOrderEnumMap, json['EXTN_NM']),
          fileMt: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_MT']),
        );

Map<String, dynamic> _$STMIMETYPECountOrderByAggregateInputToJson(
    STMIMETYPECountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('EXTN_NM', _$SortOrderEnumMap[instance.extnNm]);
  writeNotNull('FILE_MT', _$SortOrderEnumMap[instance.fileMt]);
  return val;
}

STMIMETYPEAvgOrderByAggregateInput _$STMIMETYPEAvgOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STMIMETYPEAvgOrderByAggregateInput(
      seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
    );

Map<String, dynamic> _$STMIMETYPEAvgOrderByAggregateInputToJson(
    STMIMETYPEAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  return val;
}

STMIMETYPEMaxOrderByAggregateInput _$STMIMETYPEMaxOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STMIMETYPEMaxOrderByAggregateInput(
      seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
      extnNm: $enumDecodeNullable(_$SortOrderEnumMap, json['EXTN_NM']),
      fileMt: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_MT']),
    );

Map<String, dynamic> _$STMIMETYPEMaxOrderByAggregateInputToJson(
    STMIMETYPEMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('EXTN_NM', _$SortOrderEnumMap[instance.extnNm]);
  writeNotNull('FILE_MT', _$SortOrderEnumMap[instance.fileMt]);
  return val;
}

STMIMETYPEMinOrderByAggregateInput _$STMIMETYPEMinOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STMIMETYPEMinOrderByAggregateInput(
      seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
      extnNm: $enumDecodeNullable(_$SortOrderEnumMap, json['EXTN_NM']),
      fileMt: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_MT']),
    );

Map<String, dynamic> _$STMIMETYPEMinOrderByAggregateInputToJson(
    STMIMETYPEMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('EXTN_NM', _$SortOrderEnumMap[instance.extnNm]);
  writeNotNull('FILE_MT', _$SortOrderEnumMap[instance.fileMt]);
  return val;
}

STMIMETYPESumOrderByAggregateInput _$STMIMETYPESumOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STMIMETYPESumOrderByAggregateInput(
      seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
    );

Map<String, dynamic> _$STMIMETYPESumOrderByAggregateInputToJson(
    STMIMETYPESumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  return val;
}

STMNGRGRPCountOrderByAggregateInput
    _$STMNGRGRPCountOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        STMNGRGRPCountOrderByAggregateInput(
          grpCd: $enumDecodeNullable(_$SortOrderEnumMap, json['GRP_CD']),
          grpNm: $enumDecodeNullable(_$SortOrderEnumMap, json['GRP_NM']),
          grpDesc: $enumDecodeNullable(_$SortOrderEnumMap, json['GRP_DESC']),
          sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$STMNGRGRPCountOrderByAggregateInputToJson(
    STMNGRGRPCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('GRP_CD', _$SortOrderEnumMap[instance.grpCd]);
  writeNotNull('GRP_NM', _$SortOrderEnumMap[instance.grpNm]);
  writeNotNull('GRP_DESC', _$SortOrderEnumMap[instance.grpDesc]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STMNGRGRPAvgOrderByAggregateInput _$STMNGRGRPAvgOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STMNGRGRPAvgOrderByAggregateInput(
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
    );

Map<String, dynamic> _$STMNGRGRPAvgOrderByAggregateInputToJson(
    STMNGRGRPAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  return val;
}

STMNGRGRPMaxOrderByAggregateInput _$STMNGRGRPMaxOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STMNGRGRPMaxOrderByAggregateInput(
      grpCd: $enumDecodeNullable(_$SortOrderEnumMap, json['GRP_CD']),
      grpNm: $enumDecodeNullable(_$SortOrderEnumMap, json['GRP_NM']),
      grpDesc: $enumDecodeNullable(_$SortOrderEnumMap, json['GRP_DESC']),
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STMNGRGRPMaxOrderByAggregateInputToJson(
    STMNGRGRPMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('GRP_CD', _$SortOrderEnumMap[instance.grpCd]);
  writeNotNull('GRP_NM', _$SortOrderEnumMap[instance.grpNm]);
  writeNotNull('GRP_DESC', _$SortOrderEnumMap[instance.grpDesc]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STMNGRGRPMinOrderByAggregateInput _$STMNGRGRPMinOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STMNGRGRPMinOrderByAggregateInput(
      grpCd: $enumDecodeNullable(_$SortOrderEnumMap, json['GRP_CD']),
      grpNm: $enumDecodeNullable(_$SortOrderEnumMap, json['GRP_NM']),
      grpDesc: $enumDecodeNullable(_$SortOrderEnumMap, json['GRP_DESC']),
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STMNGRGRPMinOrderByAggregateInputToJson(
    STMNGRGRPMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('GRP_CD', _$SortOrderEnumMap[instance.grpCd]);
  writeNotNull('GRP_NM', _$SortOrderEnumMap[instance.grpNm]);
  writeNotNull('GRP_DESC', _$SortOrderEnumMap[instance.grpDesc]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STMNGRGRPSumOrderByAggregateInput _$STMNGRGRPSumOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STMNGRGRPSumOrderByAggregateInput(
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
    );

Map<String, dynamic> _$STMNGRGRPSumOrderByAggregateInputToJson(
    STMNGRGRPSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  return val;
}

STMNGRMSTCountOrderByAggregateInput
    _$STMNGRMSTCountOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        STMNGRMSTCountOrderByAggregateInput(
          mngrId: $enumDecodeNullable(_$SortOrderEnumMap, json['MNGR_ID']),
          mngrNm: $enumDecodeNullable(_$SortOrderEnumMap, json['MNGR_NM']),
          mngrPw: $enumDecodeNullable(_$SortOrderEnumMap, json['MNGR_PW']),
          grpCd: $enumDecodeNullable(_$SortOrderEnumMap, json['GRP_CD']),
          grade: $enumDecodeNullable(_$SortOrderEnumMap, json['GRADE']),
          permCd: $enumDecodeNullable(_$SortOrderEnumMap, json['PERM_CD']),
          acsYn: $enumDecodeNullable(_$SortOrderEnumMap, json['ACS_YN']),
          clph: $enumDecodeNullable(_$SortOrderEnumMap, json['CLPH']),
          empNo: $enumDecodeNullable(_$SortOrderEnumMap, json['EMP_NO']),
          joinDate: $enumDecodeNullable(_$SortOrderEnumMap, json['JOIN_DATE']),
          retireDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['RETIRE_DATE']),
          pwdChgDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PWD_CHG_DATE']),
          pwdWrongCnt:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PWD_WRONG_CNT']),
          pwdWrongDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PWD_WRONG_DATE']),
          lstLoginDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['LST_LOGIN_DATE']),
          flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
          fileNm: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_NM']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$STMNGRMSTCountOrderByAggregateInputToJson(
    STMNGRMSTCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MNGR_ID', _$SortOrderEnumMap[instance.mngrId]);
  writeNotNull('MNGR_NM', _$SortOrderEnumMap[instance.mngrNm]);
  writeNotNull('MNGR_PW', _$SortOrderEnumMap[instance.mngrPw]);
  writeNotNull('GRP_CD', _$SortOrderEnumMap[instance.grpCd]);
  writeNotNull('GRADE', _$SortOrderEnumMap[instance.grade]);
  writeNotNull('PERM_CD', _$SortOrderEnumMap[instance.permCd]);
  writeNotNull('ACS_YN', _$SortOrderEnumMap[instance.acsYn]);
  writeNotNull('CLPH', _$SortOrderEnumMap[instance.clph]);
  writeNotNull('EMP_NO', _$SortOrderEnumMap[instance.empNo]);
  writeNotNull('JOIN_DATE', _$SortOrderEnumMap[instance.joinDate]);
  writeNotNull('RETIRE_DATE', _$SortOrderEnumMap[instance.retireDate]);
  writeNotNull('PWD_CHG_DATE', _$SortOrderEnumMap[instance.pwdChgDate]);
  writeNotNull('PWD_WRONG_CNT', _$SortOrderEnumMap[instance.pwdWrongCnt]);
  writeNotNull('PWD_WRONG_DATE', _$SortOrderEnumMap[instance.pwdWrongDate]);
  writeNotNull('LST_LOGIN_DATE', _$SortOrderEnumMap[instance.lstLoginDate]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('FILE_NM', _$SortOrderEnumMap[instance.fileNm]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STMNGRMSTAvgOrderByAggregateInput _$STMNGRMSTAvgOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STMNGRMSTAvgOrderByAggregateInput(
      pwdWrongCnt:
          $enumDecodeNullable(_$SortOrderEnumMap, json['PWD_WRONG_CNT']),
    );

Map<String, dynamic> _$STMNGRMSTAvgOrderByAggregateInputToJson(
    STMNGRMSTAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('PWD_WRONG_CNT', _$SortOrderEnumMap[instance.pwdWrongCnt]);
  return val;
}

STMNGRMSTMaxOrderByAggregateInput _$STMNGRMSTMaxOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STMNGRMSTMaxOrderByAggregateInput(
      mngrId: $enumDecodeNullable(_$SortOrderEnumMap, json['MNGR_ID']),
      mngrNm: $enumDecodeNullable(_$SortOrderEnumMap, json['MNGR_NM']),
      mngrPw: $enumDecodeNullable(_$SortOrderEnumMap, json['MNGR_PW']),
      grpCd: $enumDecodeNullable(_$SortOrderEnumMap, json['GRP_CD']),
      grade: $enumDecodeNullable(_$SortOrderEnumMap, json['GRADE']),
      permCd: $enumDecodeNullable(_$SortOrderEnumMap, json['PERM_CD']),
      acsYn: $enumDecodeNullable(_$SortOrderEnumMap, json['ACS_YN']),
      clph: $enumDecodeNullable(_$SortOrderEnumMap, json['CLPH']),
      empNo: $enumDecodeNullable(_$SortOrderEnumMap, json['EMP_NO']),
      joinDate: $enumDecodeNullable(_$SortOrderEnumMap, json['JOIN_DATE']),
      retireDate: $enumDecodeNullable(_$SortOrderEnumMap, json['RETIRE_DATE']),
      pwdChgDate: $enumDecodeNullable(_$SortOrderEnumMap, json['PWD_CHG_DATE']),
      pwdWrongCnt:
          $enumDecodeNullable(_$SortOrderEnumMap, json['PWD_WRONG_CNT']),
      pwdWrongDate:
          $enumDecodeNullable(_$SortOrderEnumMap, json['PWD_WRONG_DATE']),
      lstLoginDate:
          $enumDecodeNullable(_$SortOrderEnumMap, json['LST_LOGIN_DATE']),
      flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
      fileNm: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_NM']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STMNGRMSTMaxOrderByAggregateInputToJson(
    STMNGRMSTMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MNGR_ID', _$SortOrderEnumMap[instance.mngrId]);
  writeNotNull('MNGR_NM', _$SortOrderEnumMap[instance.mngrNm]);
  writeNotNull('MNGR_PW', _$SortOrderEnumMap[instance.mngrPw]);
  writeNotNull('GRP_CD', _$SortOrderEnumMap[instance.grpCd]);
  writeNotNull('GRADE', _$SortOrderEnumMap[instance.grade]);
  writeNotNull('PERM_CD', _$SortOrderEnumMap[instance.permCd]);
  writeNotNull('ACS_YN', _$SortOrderEnumMap[instance.acsYn]);
  writeNotNull('CLPH', _$SortOrderEnumMap[instance.clph]);
  writeNotNull('EMP_NO', _$SortOrderEnumMap[instance.empNo]);
  writeNotNull('JOIN_DATE', _$SortOrderEnumMap[instance.joinDate]);
  writeNotNull('RETIRE_DATE', _$SortOrderEnumMap[instance.retireDate]);
  writeNotNull('PWD_CHG_DATE', _$SortOrderEnumMap[instance.pwdChgDate]);
  writeNotNull('PWD_WRONG_CNT', _$SortOrderEnumMap[instance.pwdWrongCnt]);
  writeNotNull('PWD_WRONG_DATE', _$SortOrderEnumMap[instance.pwdWrongDate]);
  writeNotNull('LST_LOGIN_DATE', _$SortOrderEnumMap[instance.lstLoginDate]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('FILE_NM', _$SortOrderEnumMap[instance.fileNm]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STMNGRMSTMinOrderByAggregateInput _$STMNGRMSTMinOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STMNGRMSTMinOrderByAggregateInput(
      mngrId: $enumDecodeNullable(_$SortOrderEnumMap, json['MNGR_ID']),
      mngrNm: $enumDecodeNullable(_$SortOrderEnumMap, json['MNGR_NM']),
      mngrPw: $enumDecodeNullable(_$SortOrderEnumMap, json['MNGR_PW']),
      grpCd: $enumDecodeNullable(_$SortOrderEnumMap, json['GRP_CD']),
      grade: $enumDecodeNullable(_$SortOrderEnumMap, json['GRADE']),
      permCd: $enumDecodeNullable(_$SortOrderEnumMap, json['PERM_CD']),
      acsYn: $enumDecodeNullable(_$SortOrderEnumMap, json['ACS_YN']),
      clph: $enumDecodeNullable(_$SortOrderEnumMap, json['CLPH']),
      empNo: $enumDecodeNullable(_$SortOrderEnumMap, json['EMP_NO']),
      joinDate: $enumDecodeNullable(_$SortOrderEnumMap, json['JOIN_DATE']),
      retireDate: $enumDecodeNullable(_$SortOrderEnumMap, json['RETIRE_DATE']),
      pwdChgDate: $enumDecodeNullable(_$SortOrderEnumMap, json['PWD_CHG_DATE']),
      pwdWrongCnt:
          $enumDecodeNullable(_$SortOrderEnumMap, json['PWD_WRONG_CNT']),
      pwdWrongDate:
          $enumDecodeNullable(_$SortOrderEnumMap, json['PWD_WRONG_DATE']),
      lstLoginDate:
          $enumDecodeNullable(_$SortOrderEnumMap, json['LST_LOGIN_DATE']),
      flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
      fileNm: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_NM']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STMNGRMSTMinOrderByAggregateInputToJson(
    STMNGRMSTMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MNGR_ID', _$SortOrderEnumMap[instance.mngrId]);
  writeNotNull('MNGR_NM', _$SortOrderEnumMap[instance.mngrNm]);
  writeNotNull('MNGR_PW', _$SortOrderEnumMap[instance.mngrPw]);
  writeNotNull('GRP_CD', _$SortOrderEnumMap[instance.grpCd]);
  writeNotNull('GRADE', _$SortOrderEnumMap[instance.grade]);
  writeNotNull('PERM_CD', _$SortOrderEnumMap[instance.permCd]);
  writeNotNull('ACS_YN', _$SortOrderEnumMap[instance.acsYn]);
  writeNotNull('CLPH', _$SortOrderEnumMap[instance.clph]);
  writeNotNull('EMP_NO', _$SortOrderEnumMap[instance.empNo]);
  writeNotNull('JOIN_DATE', _$SortOrderEnumMap[instance.joinDate]);
  writeNotNull('RETIRE_DATE', _$SortOrderEnumMap[instance.retireDate]);
  writeNotNull('PWD_CHG_DATE', _$SortOrderEnumMap[instance.pwdChgDate]);
  writeNotNull('PWD_WRONG_CNT', _$SortOrderEnumMap[instance.pwdWrongCnt]);
  writeNotNull('PWD_WRONG_DATE', _$SortOrderEnumMap[instance.pwdWrongDate]);
  writeNotNull('LST_LOGIN_DATE', _$SortOrderEnumMap[instance.lstLoginDate]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('FILE_NM', _$SortOrderEnumMap[instance.fileNm]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STMNGRMSTSumOrderByAggregateInput _$STMNGRMSTSumOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STMNGRMSTSumOrderByAggregateInput(
      pwdWrongCnt:
          $enumDecodeNullable(_$SortOrderEnumMap, json['PWD_WRONG_CNT']),
    );

Map<String, dynamic> _$STMNGRMSTSumOrderByAggregateInputToJson(
    STMNGRMSTSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('PWD_WRONG_CNT', _$SortOrderEnumMap[instance.pwdWrongCnt]);
  return val;
}

STMYSTNGUSERIDSTNGCDUSERDIVCompoundUniqueInput
    _$STMYSTNGUSERIDSTNGCDUSERDIVCompoundUniqueInputFromJson(
            Map<String, dynamic> json) =>
        STMYSTNGUSERIDSTNGCDUSERDIVCompoundUniqueInput(
          userId: json['USER_ID'] as String,
          stngCd: json['STNG_CD'] as String,
          userDiv: json['USER_DIV'] as String,
        );

Map<String, dynamic> _$STMYSTNGUSERIDSTNGCDUSERDIVCompoundUniqueInputToJson(
        STMYSTNGUSERIDSTNGCDUSERDIVCompoundUniqueInput instance) =>
    <String, dynamic>{
      'USER_ID': instance.userId,
      'STNG_CD': instance.stngCd,
      'USER_DIV': instance.userDiv,
    };

STMYSTNGCountOrderByAggregateInput _$STMYSTNGCountOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STMYSTNGCountOrderByAggregateInput(
      userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
      stngCd: $enumDecodeNullable(_$SortOrderEnumMap, json['STNG_CD']),
      userDiv: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_DIV']),
      stngData: $enumDecodeNullable(_$SortOrderEnumMap, json['STNG_DATA']),
    );

Map<String, dynamic> _$STMYSTNGCountOrderByAggregateInputToJson(
    STMYSTNGCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('STNG_CD', _$SortOrderEnumMap[instance.stngCd]);
  writeNotNull('USER_DIV', _$SortOrderEnumMap[instance.userDiv]);
  writeNotNull('STNG_DATA', _$SortOrderEnumMap[instance.stngData]);
  return val;
}

STMYSTNGMaxOrderByAggregateInput _$STMYSTNGMaxOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STMYSTNGMaxOrderByAggregateInput(
      userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
      stngCd: $enumDecodeNullable(_$SortOrderEnumMap, json['STNG_CD']),
      userDiv: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_DIV']),
      stngData: $enumDecodeNullable(_$SortOrderEnumMap, json['STNG_DATA']),
    );

Map<String, dynamic> _$STMYSTNGMaxOrderByAggregateInputToJson(
    STMYSTNGMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('STNG_CD', _$SortOrderEnumMap[instance.stngCd]);
  writeNotNull('USER_DIV', _$SortOrderEnumMap[instance.userDiv]);
  writeNotNull('STNG_DATA', _$SortOrderEnumMap[instance.stngData]);
  return val;
}

STMYSTNGMinOrderByAggregateInput _$STMYSTNGMinOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STMYSTNGMinOrderByAggregateInput(
      userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
      stngCd: $enumDecodeNullable(_$SortOrderEnumMap, json['STNG_CD']),
      userDiv: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_DIV']),
      stngData: $enumDecodeNullable(_$SortOrderEnumMap, json['STNG_DATA']),
    );

Map<String, dynamic> _$STMYSTNGMinOrderByAggregateInputToJson(
    STMYSTNGMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('STNG_CD', _$SortOrderEnumMap[instance.stngCd]);
  writeNotNull('USER_DIV', _$SortOrderEnumMap[instance.userDiv]);
  writeNotNull('STNG_DATA', _$SortOrderEnumMap[instance.stngData]);
  return val;
}

STPERMDTLPERMCDMENUCDCompoundUniqueInput
    _$STPERMDTLPERMCDMENUCDCompoundUniqueInputFromJson(
            Map<String, dynamic> json) =>
        STPERMDTLPERMCDMENUCDCompoundUniqueInput(
          permCd: json['PERM_CD'] as String,
          menuCd: json['MENU_CD'] as String,
        );

Map<String, dynamic> _$STPERMDTLPERMCDMENUCDCompoundUniqueInputToJson(
        STPERMDTLPERMCDMENUCDCompoundUniqueInput instance) =>
    <String, dynamic>{
      'PERM_CD': instance.permCd,
      'MENU_CD': instance.menuCd,
    };

STPERMDTLCountOrderByAggregateInput
    _$STPERMDTLCountOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        STPERMDTLCountOrderByAggregateInput(
          permCd: $enumDecodeNullable(_$SortOrderEnumMap, json['PERM_CD']),
          menuCd: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_CD']),
          readYn: $enumDecodeNullable(_$SortOrderEnumMap, json['READ_YN']),
          regYn: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_YN']),
          mdfcnYn: $enumDecodeNullable(_$SortOrderEnumMap, json['MDFCN_YN']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
          manageYn: $enumDecodeNullable(_$SortOrderEnumMap, json['MANAGE_YN']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
        );

Map<String, dynamic> _$STPERMDTLCountOrderByAggregateInputToJson(
    STPERMDTLCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('PERM_CD', _$SortOrderEnumMap[instance.permCd]);
  writeNotNull('MENU_CD', _$SortOrderEnumMap[instance.menuCd]);
  writeNotNull('READ_YN', _$SortOrderEnumMap[instance.readYn]);
  writeNotNull('REG_YN', _$SortOrderEnumMap[instance.regYn]);
  writeNotNull('MDFCN_YN', _$SortOrderEnumMap[instance.mdfcnYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('MANAGE_YN', _$SortOrderEnumMap[instance.manageYn]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  return val;
}

STPERMDTLMaxOrderByAggregateInput _$STPERMDTLMaxOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STPERMDTLMaxOrderByAggregateInput(
      permCd: $enumDecodeNullable(_$SortOrderEnumMap, json['PERM_CD']),
      menuCd: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_CD']),
      readYn: $enumDecodeNullable(_$SortOrderEnumMap, json['READ_YN']),
      regYn: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_YN']),
      mdfcnYn: $enumDecodeNullable(_$SortOrderEnumMap, json['MDFCN_YN']),
      delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
      manageYn: $enumDecodeNullable(_$SortOrderEnumMap, json['MANAGE_YN']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
    );

Map<String, dynamic> _$STPERMDTLMaxOrderByAggregateInputToJson(
    STPERMDTLMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('PERM_CD', _$SortOrderEnumMap[instance.permCd]);
  writeNotNull('MENU_CD', _$SortOrderEnumMap[instance.menuCd]);
  writeNotNull('READ_YN', _$SortOrderEnumMap[instance.readYn]);
  writeNotNull('REG_YN', _$SortOrderEnumMap[instance.regYn]);
  writeNotNull('MDFCN_YN', _$SortOrderEnumMap[instance.mdfcnYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('MANAGE_YN', _$SortOrderEnumMap[instance.manageYn]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  return val;
}

STPERMDTLMinOrderByAggregateInput _$STPERMDTLMinOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STPERMDTLMinOrderByAggregateInput(
      permCd: $enumDecodeNullable(_$SortOrderEnumMap, json['PERM_CD']),
      menuCd: $enumDecodeNullable(_$SortOrderEnumMap, json['MENU_CD']),
      readYn: $enumDecodeNullable(_$SortOrderEnumMap, json['READ_YN']),
      regYn: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_YN']),
      mdfcnYn: $enumDecodeNullable(_$SortOrderEnumMap, json['MDFCN_YN']),
      delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
      manageYn: $enumDecodeNullable(_$SortOrderEnumMap, json['MANAGE_YN']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
    );

Map<String, dynamic> _$STPERMDTLMinOrderByAggregateInputToJson(
    STPERMDTLMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('PERM_CD', _$SortOrderEnumMap[instance.permCd]);
  writeNotNull('MENU_CD', _$SortOrderEnumMap[instance.menuCd]);
  writeNotNull('READ_YN', _$SortOrderEnumMap[instance.readYn]);
  writeNotNull('REG_YN', _$SortOrderEnumMap[instance.regYn]);
  writeNotNull('MDFCN_YN', _$SortOrderEnumMap[instance.mdfcnYn]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  writeNotNull('MANAGE_YN', _$SortOrderEnumMap[instance.manageYn]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  return val;
}

STPERMMSTCountOrderByAggregateInput
    _$STPERMMSTCountOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        STPERMMSTCountOrderByAggregateInput(
          permCd: $enumDecodeNullable(_$SortOrderEnumMap, json['PERM_CD']),
          permNm: $enumDecodeNullable(_$SortOrderEnumMap, json['PERM_NM']),
          sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$STPERMMSTCountOrderByAggregateInputToJson(
    STPERMMSTCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('PERM_CD', _$SortOrderEnumMap[instance.permCd]);
  writeNotNull('PERM_NM', _$SortOrderEnumMap[instance.permNm]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STPERMMSTMaxOrderByAggregateInput _$STPERMMSTMaxOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STPERMMSTMaxOrderByAggregateInput(
      permCd: $enumDecodeNullable(_$SortOrderEnumMap, json['PERM_CD']),
      permNm: $enumDecodeNullable(_$SortOrderEnumMap, json['PERM_NM']),
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STPERMMSTMaxOrderByAggregateInputToJson(
    STPERMMSTMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('PERM_CD', _$SortOrderEnumMap[instance.permCd]);
  writeNotNull('PERM_NM', _$SortOrderEnumMap[instance.permNm]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STPERMMSTMinOrderByAggregateInput _$STPERMMSTMinOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STPERMMSTMinOrderByAggregateInput(
      permCd: $enumDecodeNullable(_$SortOrderEnumMap, json['PERM_CD']),
      permNm: $enumDecodeNullable(_$SortOrderEnumMap, json['PERM_NM']),
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STPERMMSTMinOrderByAggregateInputToJson(
    STPERMMSTMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('PERM_CD', _$SortOrderEnumMap[instance.permCd]);
  writeNotNull('PERM_NM', _$SortOrderEnumMap[instance.permNm]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STPOPUPCountOrderByAggregateInput _$STPOPUPCountOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STPOPUPCountOrderByAggregateInput(
      popCd: $enumDecodeNullable(_$SortOrderEnumMap, json['POP_CD']),
      popNm: $enumDecodeNullable(_$SortOrderEnumMap, json['POP_NM']),
      popTy: $enumDecodeNullable(_$SortOrderEnumMap, json['POP_TY']),
      imgText: $enumDecodeNullable(_$SortOrderEnumMap, json['IMG_TEXT']),
      lkUrl: $enumDecodeNullable(_$SortOrderEnumMap, json['LK_URL']),
      lkTarget: $enumDecodeNullable(_$SortOrderEnumMap, json['LK_TARGET']),
      bgngDate: $enumDecodeNullable(_$SortOrderEnumMap, json['BGNG_DATE']),
      endDate: $enumDecodeNullable(_$SortOrderEnumMap, json['END_DATE']),
      spwgPred: $enumDecodeNullable(_$SortOrderEnumMap, json['SPWG_PRED']),
      flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
      fileNm: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_NM']),
      useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
      beforeCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BEFORE_CD']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STPOPUPCountOrderByAggregateInputToJson(
    STPOPUPCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('POP_CD', _$SortOrderEnumMap[instance.popCd]);
  writeNotNull('POP_NM', _$SortOrderEnumMap[instance.popNm]);
  writeNotNull('POP_TY', _$SortOrderEnumMap[instance.popTy]);
  writeNotNull('IMG_TEXT', _$SortOrderEnumMap[instance.imgText]);
  writeNotNull('LK_URL', _$SortOrderEnumMap[instance.lkUrl]);
  writeNotNull('LK_TARGET', _$SortOrderEnumMap[instance.lkTarget]);
  writeNotNull('BGNG_DATE', _$SortOrderEnumMap[instance.bgngDate]);
  writeNotNull('END_DATE', _$SortOrderEnumMap[instance.endDate]);
  writeNotNull('SPWG_PRED', _$SortOrderEnumMap[instance.spwgPred]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('FILE_NM', _$SortOrderEnumMap[instance.fileNm]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('BEFORE_CD', _$SortOrderEnumMap[instance.beforeCd]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STPOPUPMaxOrderByAggregateInput _$STPOPUPMaxOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STPOPUPMaxOrderByAggregateInput(
      popCd: $enumDecodeNullable(_$SortOrderEnumMap, json['POP_CD']),
      popNm: $enumDecodeNullable(_$SortOrderEnumMap, json['POP_NM']),
      popTy: $enumDecodeNullable(_$SortOrderEnumMap, json['POP_TY']),
      imgText: $enumDecodeNullable(_$SortOrderEnumMap, json['IMG_TEXT']),
      lkUrl: $enumDecodeNullable(_$SortOrderEnumMap, json['LK_URL']),
      lkTarget: $enumDecodeNullable(_$SortOrderEnumMap, json['LK_TARGET']),
      bgngDate: $enumDecodeNullable(_$SortOrderEnumMap, json['BGNG_DATE']),
      endDate: $enumDecodeNullable(_$SortOrderEnumMap, json['END_DATE']),
      spwgPred: $enumDecodeNullable(_$SortOrderEnumMap, json['SPWG_PRED']),
      flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
      fileNm: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_NM']),
      useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
      beforeCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BEFORE_CD']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STPOPUPMaxOrderByAggregateInputToJson(
    STPOPUPMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('POP_CD', _$SortOrderEnumMap[instance.popCd]);
  writeNotNull('POP_NM', _$SortOrderEnumMap[instance.popNm]);
  writeNotNull('POP_TY', _$SortOrderEnumMap[instance.popTy]);
  writeNotNull('IMG_TEXT', _$SortOrderEnumMap[instance.imgText]);
  writeNotNull('LK_URL', _$SortOrderEnumMap[instance.lkUrl]);
  writeNotNull('LK_TARGET', _$SortOrderEnumMap[instance.lkTarget]);
  writeNotNull('BGNG_DATE', _$SortOrderEnumMap[instance.bgngDate]);
  writeNotNull('END_DATE', _$SortOrderEnumMap[instance.endDate]);
  writeNotNull('SPWG_PRED', _$SortOrderEnumMap[instance.spwgPred]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('FILE_NM', _$SortOrderEnumMap[instance.fileNm]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('BEFORE_CD', _$SortOrderEnumMap[instance.beforeCd]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STPOPUPMinOrderByAggregateInput _$STPOPUPMinOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STPOPUPMinOrderByAggregateInput(
      popCd: $enumDecodeNullable(_$SortOrderEnumMap, json['POP_CD']),
      popNm: $enumDecodeNullable(_$SortOrderEnumMap, json['POP_NM']),
      popTy: $enumDecodeNullable(_$SortOrderEnumMap, json['POP_TY']),
      imgText: $enumDecodeNullable(_$SortOrderEnumMap, json['IMG_TEXT']),
      lkUrl: $enumDecodeNullable(_$SortOrderEnumMap, json['LK_URL']),
      lkTarget: $enumDecodeNullable(_$SortOrderEnumMap, json['LK_TARGET']),
      bgngDate: $enumDecodeNullable(_$SortOrderEnumMap, json['BGNG_DATE']),
      endDate: $enumDecodeNullable(_$SortOrderEnumMap, json['END_DATE']),
      spwgPred: $enumDecodeNullable(_$SortOrderEnumMap, json['SPWG_PRED']),
      flpth: $enumDecodeNullable(_$SortOrderEnumMap, json['FLPTH']),
      fileNm: $enumDecodeNullable(_$SortOrderEnumMap, json['FILE_NM']),
      useYn: $enumDecodeNullable(_$SortOrderEnumMap, json['USE_YN']),
      beforeCd: $enumDecodeNullable(_$SortOrderEnumMap, json['BEFORE_CD']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STPOPUPMinOrderByAggregateInputToJson(
    STPOPUPMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('POP_CD', _$SortOrderEnumMap[instance.popCd]);
  writeNotNull('POP_NM', _$SortOrderEnumMap[instance.popNm]);
  writeNotNull('POP_TY', _$SortOrderEnumMap[instance.popTy]);
  writeNotNull('IMG_TEXT', _$SortOrderEnumMap[instance.imgText]);
  writeNotNull('LK_URL', _$SortOrderEnumMap[instance.lkUrl]);
  writeNotNull('LK_TARGET', _$SortOrderEnumMap[instance.lkTarget]);
  writeNotNull('BGNG_DATE', _$SortOrderEnumMap[instance.bgngDate]);
  writeNotNull('END_DATE', _$SortOrderEnumMap[instance.endDate]);
  writeNotNull('SPWG_PRED', _$SortOrderEnumMap[instance.spwgPred]);
  writeNotNull('FLPTH', _$SortOrderEnumMap[instance.flpth]);
  writeNotNull('FILE_NM', _$SortOrderEnumMap[instance.fileNm]);
  writeNotNull('USE_YN', _$SortOrderEnumMap[instance.useYn]);
  writeNotNull('BEFORE_CD', _$SortOrderEnumMap[instance.beforeCd]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STSTNGCountOrderByAggregateInput _$STSTNGCountOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STSTNGCountOrderByAggregateInput(
      stngCd: $enumDecodeNullable(_$SortOrderEnumMap, json['STNG_CD']),
      stngData: $enumDecodeNullable(_$SortOrderEnumMap, json['STNG_DATA']),
      title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
      descCn: $enumDecodeNullable(_$SortOrderEnumMap, json['DESC_CN']),
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
    );

Map<String, dynamic> _$STSTNGCountOrderByAggregateInputToJson(
    STSTNGCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('STNG_CD', _$SortOrderEnumMap[instance.stngCd]);
  writeNotNull('STNG_DATA', _$SortOrderEnumMap[instance.stngData]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull('DESC_CN', _$SortOrderEnumMap[instance.descCn]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  return val;
}

STSTNGAvgOrderByAggregateInput _$STSTNGAvgOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STSTNGAvgOrderByAggregateInput(
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
    );

Map<String, dynamic> _$STSTNGAvgOrderByAggregateInputToJson(
    STSTNGAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  return val;
}

STSTNGMaxOrderByAggregateInput _$STSTNGMaxOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STSTNGMaxOrderByAggregateInput(
      stngCd: $enumDecodeNullable(_$SortOrderEnumMap, json['STNG_CD']),
      stngData: $enumDecodeNullable(_$SortOrderEnumMap, json['STNG_DATA']),
      title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
      descCn: $enumDecodeNullable(_$SortOrderEnumMap, json['DESC_CN']),
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
    );

Map<String, dynamic> _$STSTNGMaxOrderByAggregateInputToJson(
    STSTNGMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('STNG_CD', _$SortOrderEnumMap[instance.stngCd]);
  writeNotNull('STNG_DATA', _$SortOrderEnumMap[instance.stngData]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull('DESC_CN', _$SortOrderEnumMap[instance.descCn]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  return val;
}

STSTNGMinOrderByAggregateInput _$STSTNGMinOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STSTNGMinOrderByAggregateInput(
      stngCd: $enumDecodeNullable(_$SortOrderEnumMap, json['STNG_CD']),
      stngData: $enumDecodeNullable(_$SortOrderEnumMap, json['STNG_DATA']),
      title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
      descCn: $enumDecodeNullable(_$SortOrderEnumMap, json['DESC_CN']),
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
    );

Map<String, dynamic> _$STSTNGMinOrderByAggregateInputToJson(
    STSTNGMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('STNG_CD', _$SortOrderEnumMap[instance.stngCd]);
  writeNotNull('STNG_DATA', _$SortOrderEnumMap[instance.stngData]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull('DESC_CN', _$SortOrderEnumMap[instance.descCn]);
  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  return val;
}

STSTNGSumOrderByAggregateInput _$STSTNGSumOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STSTNGSumOrderByAggregateInput(
      sort: $enumDecodeNullable(_$SortOrderEnumMap, json['SORT']),
    );

Map<String, dynamic> _$STSTNGSumOrderByAggregateInputToJson(
    STSTNGSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SORT', _$SortOrderEnumMap[instance.sort]);
  return val;
}

STUSERMSTCountOrderByAggregateInput
    _$STUSERMSTCountOrderByAggregateInputFromJson(Map<String, dynamic> json) =>
        STUSERMSTCountOrderByAggregateInput(
          userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
          userNm: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_NM']),
          userPw: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_PW']),
          userDiv: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_DIV']),
          status: $enumDecodeNullable(_$SortOrderEnumMap, json['STATUS']),
          prevLoginYn:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PREV_LOGIN_YN']),
          withdrawnYn:
              $enumDecodeNullable(_$SortOrderEnumMap, json['WITHDRAWN_YN']),
          clph: $enumDecodeNullable(_$SortOrderEnumMap, json['CLPH']),
          email: $enumDecodeNullable(_$SortOrderEnumMap, json['EMAIL']),
          lstLoginDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['LST_LOGIN_DATE']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$STUSERMSTCountOrderByAggregateInputToJson(
    STUSERMSTCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('USER_NM', _$SortOrderEnumMap[instance.userNm]);
  writeNotNull('USER_PW', _$SortOrderEnumMap[instance.userPw]);
  writeNotNull('USER_DIV', _$SortOrderEnumMap[instance.userDiv]);
  writeNotNull('STATUS', _$SortOrderEnumMap[instance.status]);
  writeNotNull('PREV_LOGIN_YN', _$SortOrderEnumMap[instance.prevLoginYn]);
  writeNotNull('WITHDRAWN_YN', _$SortOrderEnumMap[instance.withdrawnYn]);
  writeNotNull('CLPH', _$SortOrderEnumMap[instance.clph]);
  writeNotNull('EMAIL', _$SortOrderEnumMap[instance.email]);
  writeNotNull('LST_LOGIN_DATE', _$SortOrderEnumMap[instance.lstLoginDate]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STUSERMSTMaxOrderByAggregateInput _$STUSERMSTMaxOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STUSERMSTMaxOrderByAggregateInput(
      userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
      userNm: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_NM']),
      userPw: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_PW']),
      userDiv: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_DIV']),
      status: $enumDecodeNullable(_$SortOrderEnumMap, json['STATUS']),
      prevLoginYn:
          $enumDecodeNullable(_$SortOrderEnumMap, json['PREV_LOGIN_YN']),
      withdrawnYn:
          $enumDecodeNullable(_$SortOrderEnumMap, json['WITHDRAWN_YN']),
      clph: $enumDecodeNullable(_$SortOrderEnumMap, json['CLPH']),
      email: $enumDecodeNullable(_$SortOrderEnumMap, json['EMAIL']),
      lstLoginDate:
          $enumDecodeNullable(_$SortOrderEnumMap, json['LST_LOGIN_DATE']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STUSERMSTMaxOrderByAggregateInputToJson(
    STUSERMSTMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('USER_NM', _$SortOrderEnumMap[instance.userNm]);
  writeNotNull('USER_PW', _$SortOrderEnumMap[instance.userPw]);
  writeNotNull('USER_DIV', _$SortOrderEnumMap[instance.userDiv]);
  writeNotNull('STATUS', _$SortOrderEnumMap[instance.status]);
  writeNotNull('PREV_LOGIN_YN', _$SortOrderEnumMap[instance.prevLoginYn]);
  writeNotNull('WITHDRAWN_YN', _$SortOrderEnumMap[instance.withdrawnYn]);
  writeNotNull('CLPH', _$SortOrderEnumMap[instance.clph]);
  writeNotNull('EMAIL', _$SortOrderEnumMap[instance.email]);
  writeNotNull('LST_LOGIN_DATE', _$SortOrderEnumMap[instance.lstLoginDate]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

STUSERMSTMinOrderByAggregateInput _$STUSERMSTMinOrderByAggregateInputFromJson(
        Map<String, dynamic> json) =>
    STUSERMSTMinOrderByAggregateInput(
      userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
      userNm: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_NM']),
      userPw: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_PW']),
      userDiv: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_DIV']),
      status: $enumDecodeNullable(_$SortOrderEnumMap, json['STATUS']),
      prevLoginYn:
          $enumDecodeNullable(_$SortOrderEnumMap, json['PREV_LOGIN_YN']),
      withdrawnYn:
          $enumDecodeNullable(_$SortOrderEnumMap, json['WITHDRAWN_YN']),
      clph: $enumDecodeNullable(_$SortOrderEnumMap, json['CLPH']),
      email: $enumDecodeNullable(_$SortOrderEnumMap, json['EMAIL']),
      lstLoginDate:
          $enumDecodeNullable(_$SortOrderEnumMap, json['LST_LOGIN_DATE']),
      regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
      regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
      editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
      editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
      delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
      delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
    );

Map<String, dynamic> _$STUSERMSTMinOrderByAggregateInputToJson(
    STUSERMSTMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('USER_NM', _$SortOrderEnumMap[instance.userNm]);
  writeNotNull('USER_PW', _$SortOrderEnumMap[instance.userPw]);
  writeNotNull('USER_DIV', _$SortOrderEnumMap[instance.userDiv]);
  writeNotNull('STATUS', _$SortOrderEnumMap[instance.status]);
  writeNotNull('PREV_LOGIN_YN', _$SortOrderEnumMap[instance.prevLoginYn]);
  writeNotNull('WITHDRAWN_YN', _$SortOrderEnumMap[instance.withdrawnYn]);
  writeNotNull('CLPH', _$SortOrderEnumMap[instance.clph]);
  writeNotNull('EMAIL', _$SortOrderEnumMap[instance.email]);
  writeNotNull('LST_LOGIN_DATE', _$SortOrderEnumMap[instance.lstLoginDate]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

WORKREPORTDETAILTBLSEQREPORTIDCompoundUniqueInput
    _$WORKREPORTDETAILTBLSEQREPORTIDCompoundUniqueInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTDETAILTBLSEQREPORTIDCompoundUniqueInput(
          seq: BigInt.parse(json['SEQ'] as String),
          reportId: json['REPORT_ID'] as String,
        );

Map<String, dynamic> _$WORKREPORTDETAILTBLSEQREPORTIDCompoundUniqueInputToJson(
        WORKREPORTDETAILTBLSEQREPORTIDCompoundUniqueInput instance) =>
    <String, dynamic>{
      'SEQ': instance.seq.toString(),
      'REPORT_ID': instance.reportId,
    };

WORKREPORTDETAILTBLCountOrderByAggregateInput
    _$WORKREPORTDETAILTBLCountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTDETAILTBLCountOrderByAggregateInput(
          reportId: $enumDecodeNullable(_$SortOrderEnumMap, json['REPORT_ID']),
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          projectNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PROJECT_NM']),
          projectSubNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PROJECT_SUB_NM']),
          detailContent:
              $enumDecodeNullable(_$SortOrderEnumMap, json['DETAIL_CONTENT']),
          worker: $enumDecodeNullable(_$SortOrderEnumMap, json['WORKER']),
          grade: $enumDecodeNullable(_$SortOrderEnumMap, json['GRADE']),
          processRate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PROCESS_RATE']),
          workDate: $enumDecodeNullable(_$SortOrderEnumMap, json['WORK_DATE']),
          processType:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PROCESS_TYPE']),
          subjectYn:
              $enumDecodeNullable(_$SortOrderEnumMap, json['SUBJECT_YN']),
          regUser: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_USER']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          completeDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['COMPLETE_DATE']),
        );

Map<String, dynamic> _$WORKREPORTDETAILTBLCountOrderByAggregateInputToJson(
    WORKREPORTDETAILTBLCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', _$SortOrderEnumMap[instance.reportId]);
  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('PROJECT_NM', _$SortOrderEnumMap[instance.projectNm]);
  writeNotNull('PROJECT_SUB_NM', _$SortOrderEnumMap[instance.projectSubNm]);
  writeNotNull('DETAIL_CONTENT', _$SortOrderEnumMap[instance.detailContent]);
  writeNotNull('WORKER', _$SortOrderEnumMap[instance.worker]);
  writeNotNull('GRADE', _$SortOrderEnumMap[instance.grade]);
  writeNotNull('PROCESS_RATE', _$SortOrderEnumMap[instance.processRate]);
  writeNotNull('WORK_DATE', _$SortOrderEnumMap[instance.workDate]);
  writeNotNull('PROCESS_TYPE', _$SortOrderEnumMap[instance.processType]);
  writeNotNull('SUBJECT_YN', _$SortOrderEnumMap[instance.subjectYn]);
  writeNotNull('REG_USER', _$SortOrderEnumMap[instance.regUser]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('COMPLETE_DATE', _$SortOrderEnumMap[instance.completeDate]);
  return val;
}

WORKREPORTDETAILTBLAvgOrderByAggregateInput
    _$WORKREPORTDETAILTBLAvgOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTDETAILTBLAvgOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
        );

Map<String, dynamic> _$WORKREPORTDETAILTBLAvgOrderByAggregateInputToJson(
    WORKREPORTDETAILTBLAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  return val;
}

WORKREPORTDETAILTBLMaxOrderByAggregateInput
    _$WORKREPORTDETAILTBLMaxOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTDETAILTBLMaxOrderByAggregateInput(
          reportId: $enumDecodeNullable(_$SortOrderEnumMap, json['REPORT_ID']),
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          projectNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PROJECT_NM']),
          projectSubNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PROJECT_SUB_NM']),
          detailContent:
              $enumDecodeNullable(_$SortOrderEnumMap, json['DETAIL_CONTENT']),
          worker: $enumDecodeNullable(_$SortOrderEnumMap, json['WORKER']),
          grade: $enumDecodeNullable(_$SortOrderEnumMap, json['GRADE']),
          processRate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PROCESS_RATE']),
          workDate: $enumDecodeNullable(_$SortOrderEnumMap, json['WORK_DATE']),
          processType:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PROCESS_TYPE']),
          subjectYn:
              $enumDecodeNullable(_$SortOrderEnumMap, json['SUBJECT_YN']),
          regUser: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_USER']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          completeDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['COMPLETE_DATE']),
        );

Map<String, dynamic> _$WORKREPORTDETAILTBLMaxOrderByAggregateInputToJson(
    WORKREPORTDETAILTBLMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', _$SortOrderEnumMap[instance.reportId]);
  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('PROJECT_NM', _$SortOrderEnumMap[instance.projectNm]);
  writeNotNull('PROJECT_SUB_NM', _$SortOrderEnumMap[instance.projectSubNm]);
  writeNotNull('DETAIL_CONTENT', _$SortOrderEnumMap[instance.detailContent]);
  writeNotNull('WORKER', _$SortOrderEnumMap[instance.worker]);
  writeNotNull('GRADE', _$SortOrderEnumMap[instance.grade]);
  writeNotNull('PROCESS_RATE', _$SortOrderEnumMap[instance.processRate]);
  writeNotNull('WORK_DATE', _$SortOrderEnumMap[instance.workDate]);
  writeNotNull('PROCESS_TYPE', _$SortOrderEnumMap[instance.processType]);
  writeNotNull('SUBJECT_YN', _$SortOrderEnumMap[instance.subjectYn]);
  writeNotNull('REG_USER', _$SortOrderEnumMap[instance.regUser]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('COMPLETE_DATE', _$SortOrderEnumMap[instance.completeDate]);
  return val;
}

WORKREPORTDETAILTBLMinOrderByAggregateInput
    _$WORKREPORTDETAILTBLMinOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTDETAILTBLMinOrderByAggregateInput(
          reportId: $enumDecodeNullable(_$SortOrderEnumMap, json['REPORT_ID']),
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          projectNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PROJECT_NM']),
          projectSubNm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PROJECT_SUB_NM']),
          detailContent:
              $enumDecodeNullable(_$SortOrderEnumMap, json['DETAIL_CONTENT']),
          worker: $enumDecodeNullable(_$SortOrderEnumMap, json['WORKER']),
          grade: $enumDecodeNullable(_$SortOrderEnumMap, json['GRADE']),
          processRate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PROCESS_RATE']),
          workDate: $enumDecodeNullable(_$SortOrderEnumMap, json['WORK_DATE']),
          processType:
              $enumDecodeNullable(_$SortOrderEnumMap, json['PROCESS_TYPE']),
          subjectYn:
              $enumDecodeNullable(_$SortOrderEnumMap, json['SUBJECT_YN']),
          regUser: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_USER']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          completeDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['COMPLETE_DATE']),
        );

Map<String, dynamic> _$WORKREPORTDETAILTBLMinOrderByAggregateInputToJson(
    WORKREPORTDETAILTBLMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', _$SortOrderEnumMap[instance.reportId]);
  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('PROJECT_NM', _$SortOrderEnumMap[instance.projectNm]);
  writeNotNull('PROJECT_SUB_NM', _$SortOrderEnumMap[instance.projectSubNm]);
  writeNotNull('DETAIL_CONTENT', _$SortOrderEnumMap[instance.detailContent]);
  writeNotNull('WORKER', _$SortOrderEnumMap[instance.worker]);
  writeNotNull('GRADE', _$SortOrderEnumMap[instance.grade]);
  writeNotNull('PROCESS_RATE', _$SortOrderEnumMap[instance.processRate]);
  writeNotNull('WORK_DATE', _$SortOrderEnumMap[instance.workDate]);
  writeNotNull('PROCESS_TYPE', _$SortOrderEnumMap[instance.processType]);
  writeNotNull('SUBJECT_YN', _$SortOrderEnumMap[instance.subjectYn]);
  writeNotNull('REG_USER', _$SortOrderEnumMap[instance.regUser]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('COMPLETE_DATE', _$SortOrderEnumMap[instance.completeDate]);
  return val;
}

WORKREPORTDETAILTBLSumOrderByAggregateInput
    _$WORKREPORTDETAILTBLSumOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTDETAILTBLSumOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
        );

Map<String, dynamic> _$WORKREPORTDETAILTBLSumOrderByAggregateInputToJson(
    WORKREPORTDETAILTBLSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  return val;
}

WORKREPORTHTMLTBLREPORTIDUSERIDCompoundUniqueInput
    _$WORKREPORTHTMLTBLREPORTIDUSERIDCompoundUniqueInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTHTMLTBLREPORTIDUSERIDCompoundUniqueInput(
          reportId: json['REPORT_ID'] as String,
          userId: json['USER_ID'] as String,
        );

Map<String, dynamic> _$WORKREPORTHTMLTBLREPORTIDUSERIDCompoundUniqueInputToJson(
        WORKREPORTHTMLTBLREPORTIDUSERIDCompoundUniqueInput instance) =>
    <String, dynamic>{
      'REPORT_ID': instance.reportId,
      'USER_ID': instance.userId,
    };

WORKREPORTHTMLTBLCountOrderByAggregateInput
    _$WORKREPORTHTMLTBLCountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTHTMLTBLCountOrderByAggregateInput(
          reportId: $enumDecodeNullable(_$SortOrderEnumMap, json['REPORT_ID']),
          userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
          title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
          htmlContent:
              $enumDecodeNullable(_$SortOrderEnumMap, json['HTML_CONTENT']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$WORKREPORTHTMLTBLCountOrderByAggregateInputToJson(
    WORKREPORTHTMLTBLCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', _$SortOrderEnumMap[instance.reportId]);
  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull('HTML_CONTENT', _$SortOrderEnumMap[instance.htmlContent]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

WORKREPORTHTMLTBLMaxOrderByAggregateInput
    _$WORKREPORTHTMLTBLMaxOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTHTMLTBLMaxOrderByAggregateInput(
          reportId: $enumDecodeNullable(_$SortOrderEnumMap, json['REPORT_ID']),
          userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
          title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
          htmlContent:
              $enumDecodeNullable(_$SortOrderEnumMap, json['HTML_CONTENT']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$WORKREPORTHTMLTBLMaxOrderByAggregateInputToJson(
    WORKREPORTHTMLTBLMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', _$SortOrderEnumMap[instance.reportId]);
  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull('HTML_CONTENT', _$SortOrderEnumMap[instance.htmlContent]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

WORKREPORTHTMLTBLMinOrderByAggregateInput
    _$WORKREPORTHTMLTBLMinOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTHTMLTBLMinOrderByAggregateInput(
          reportId: $enumDecodeNullable(_$SortOrderEnumMap, json['REPORT_ID']),
          userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
          title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
          htmlContent:
              $enumDecodeNullable(_$SortOrderEnumMap, json['HTML_CONTENT']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$WORKREPORTHTMLTBLMinOrderByAggregateInputToJson(
    WORKREPORTHTMLTBLMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', _$SortOrderEnumMap[instance.reportId]);
  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull('HTML_CONTENT', _$SortOrderEnumMap[instance.htmlContent]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

WORKREPORTHTMLTBLBACKREPORTIDUSERIDCompoundUniqueInput
    _$WORKREPORTHTMLTBLBACKREPORTIDUSERIDCompoundUniqueInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTHTMLTBLBACKREPORTIDUSERIDCompoundUniqueInput(
          reportId: json['REPORT_ID'] as String,
          userId: json['USER_ID'] as String,
        );

Map<String, dynamic>
    _$WORKREPORTHTMLTBLBACKREPORTIDUSERIDCompoundUniqueInputToJson(
            WORKREPORTHTMLTBLBACKREPORTIDUSERIDCompoundUniqueInput instance) =>
        <String, dynamic>{
          'REPORT_ID': instance.reportId,
          'USER_ID': instance.userId,
        };

WORKREPORTHTMLTBLBACKCountOrderByAggregateInput
    _$WORKREPORTHTMLTBLBACKCountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTHTMLTBLBACKCountOrderByAggregateInput(
          reportId: $enumDecodeNullable(_$SortOrderEnumMap, json['REPORT_ID']),
          userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
          title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
          htmlContent:
              $enumDecodeNullable(_$SortOrderEnumMap, json['HTML_CONTENT']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$WORKREPORTHTMLTBLBACKCountOrderByAggregateInputToJson(
    WORKREPORTHTMLTBLBACKCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', _$SortOrderEnumMap[instance.reportId]);
  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull('HTML_CONTENT', _$SortOrderEnumMap[instance.htmlContent]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

WORKREPORTHTMLTBLBACKMaxOrderByAggregateInput
    _$WORKREPORTHTMLTBLBACKMaxOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTHTMLTBLBACKMaxOrderByAggregateInput(
          reportId: $enumDecodeNullable(_$SortOrderEnumMap, json['REPORT_ID']),
          userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
          title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
          htmlContent:
              $enumDecodeNullable(_$SortOrderEnumMap, json['HTML_CONTENT']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$WORKREPORTHTMLTBLBACKMaxOrderByAggregateInputToJson(
    WORKREPORTHTMLTBLBACKMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', _$SortOrderEnumMap[instance.reportId]);
  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull('HTML_CONTENT', _$SortOrderEnumMap[instance.htmlContent]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

WORKREPORTHTMLTBLBACKMinOrderByAggregateInput
    _$WORKREPORTHTMLTBLBACKMinOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTHTMLTBLBACKMinOrderByAggregateInput(
          reportId: $enumDecodeNullable(_$SortOrderEnumMap, json['REPORT_ID']),
          userId: $enumDecodeNullable(_$SortOrderEnumMap, json['USER_ID']),
          title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
          htmlContent:
              $enumDecodeNullable(_$SortOrderEnumMap, json['HTML_CONTENT']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$WORKREPORTHTMLTBLBACKMinOrderByAggregateInputToJson(
    WORKREPORTHTMLTBLBACKMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', _$SortOrderEnumMap[instance.reportId]);
  writeNotNull('USER_ID', _$SortOrderEnumMap[instance.userId]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull('HTML_CONTENT', _$SortOrderEnumMap[instance.htmlContent]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

WORKREPORTMASTERTBLCountOrderByAggregateInput
    _$WORKREPORTMASTERTBLCountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTMASTERTBLCountOrderByAggregateInput(
          reportId: $enumDecodeNullable(_$SortOrderEnumMap, json['REPORT_ID']),
          title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
          dept: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$WORKREPORTMASTERTBLCountOrderByAggregateInputToJson(
    WORKREPORTMASTERTBLCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', _$SortOrderEnumMap[instance.reportId]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull('DEPT', _$SortOrderEnumMap[instance.dept]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

WORKREPORTMASTERTBLMaxOrderByAggregateInput
    _$WORKREPORTMASTERTBLMaxOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTMASTERTBLMaxOrderByAggregateInput(
          reportId: $enumDecodeNullable(_$SortOrderEnumMap, json['REPORT_ID']),
          title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
          dept: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$WORKREPORTMASTERTBLMaxOrderByAggregateInputToJson(
    WORKREPORTMASTERTBLMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', _$SortOrderEnumMap[instance.reportId]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull('DEPT', _$SortOrderEnumMap[instance.dept]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

WORKREPORTMASTERTBLMinOrderByAggregateInput
    _$WORKREPORTMASTERTBLMinOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTMASTERTBLMinOrderByAggregateInput(
          reportId: $enumDecodeNullable(_$SortOrderEnumMap, json['REPORT_ID']),
          title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
          dept: $enumDecodeNullable(_$SortOrderEnumMap, json['DEPT']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          updDate: $enumDecodeNullable(_$SortOrderEnumMap, json['UPD_DATE']),
          delYn: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_YN']),
        );

Map<String, dynamic> _$WORKREPORTMASTERTBLMinOrderByAggregateInputToJson(
    WORKREPORTMASTERTBLMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', _$SortOrderEnumMap[instance.reportId]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull('DEPT', _$SortOrderEnumMap[instance.dept]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('UPD_DATE', _$SortOrderEnumMap[instance.updDate]);
  writeNotNull('DEL_YN', _$SortOrderEnumMap[instance.delYn]);
  return val;
}

WORKREQUESTMSTCountOrderByAggregateInput
    _$WORKREQUESTMSTCountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        WORKREQUESTMSTCountOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          rqstrDpnm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['RQSTR_DPNM']),
          rqstrNm: $enumDecodeNullable(_$SortOrderEnumMap, json['RQSTR_NM']),
          rqstrId: $enumDecodeNullable(_$SortOrderEnumMap, json['RQSTR_ID']),
          rqstrDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['RQSTR_DATE']),
          hopeDate: $enumDecodeNullable(_$SortOrderEnumMap, json['HOPE_DATE']),
          chrDprNm: $enumDecodeNullable(_$SortOrderEnumMap, json['CHR_DPR_NM']),
          chrNm: $enumDecodeNullable(_$SortOrderEnumMap, json['CHR_NM']),
          chrId: $enumDecodeNullable(_$SortOrderEnumMap, json['CHR_ID']),
          chrChk: $enumDecodeNullable(_$SortOrderEnumMap, json['CHR_CHK']),
          title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
          cn: $enumDecodeNullable(_$SortOrderEnumMap, json['CN']),
          etc: $enumDecodeNullable(_$SortOrderEnumMap, json['ETC']),
          doc: $enumDecodeNullable(_$SortOrderEnumMap, json['DOC']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$WORKREQUESTMSTCountOrderByAggregateInputToJson(
    WORKREQUESTMSTCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('RQSTR_DPNM', _$SortOrderEnumMap[instance.rqstrDpnm]);
  writeNotNull('RQSTR_NM', _$SortOrderEnumMap[instance.rqstrNm]);
  writeNotNull('RQSTR_ID', _$SortOrderEnumMap[instance.rqstrId]);
  writeNotNull('RQSTR_DATE', _$SortOrderEnumMap[instance.rqstrDate]);
  writeNotNull('HOPE_DATE', _$SortOrderEnumMap[instance.hopeDate]);
  writeNotNull('CHR_DPR_NM', _$SortOrderEnumMap[instance.chrDprNm]);
  writeNotNull('CHR_NM', _$SortOrderEnumMap[instance.chrNm]);
  writeNotNull('CHR_ID', _$SortOrderEnumMap[instance.chrId]);
  writeNotNull('CHR_CHK', _$SortOrderEnumMap[instance.chrChk]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull('CN', _$SortOrderEnumMap[instance.cn]);
  writeNotNull('ETC', _$SortOrderEnumMap[instance.etc]);
  writeNotNull('DOC', _$SortOrderEnumMap[instance.doc]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

WORKREQUESTMSTAvgOrderByAggregateInput
    _$WORKREQUESTMSTAvgOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        WORKREQUESTMSTAvgOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
        );

Map<String, dynamic> _$WORKREQUESTMSTAvgOrderByAggregateInputToJson(
    WORKREQUESTMSTAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  return val;
}

WORKREQUESTMSTMaxOrderByAggregateInput
    _$WORKREQUESTMSTMaxOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        WORKREQUESTMSTMaxOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          rqstrDpnm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['RQSTR_DPNM']),
          rqstrNm: $enumDecodeNullable(_$SortOrderEnumMap, json['RQSTR_NM']),
          rqstrId: $enumDecodeNullable(_$SortOrderEnumMap, json['RQSTR_ID']),
          rqstrDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['RQSTR_DATE']),
          hopeDate: $enumDecodeNullable(_$SortOrderEnumMap, json['HOPE_DATE']),
          chrDprNm: $enumDecodeNullable(_$SortOrderEnumMap, json['CHR_DPR_NM']),
          chrNm: $enumDecodeNullable(_$SortOrderEnumMap, json['CHR_NM']),
          chrId: $enumDecodeNullable(_$SortOrderEnumMap, json['CHR_ID']),
          chrChk: $enumDecodeNullable(_$SortOrderEnumMap, json['CHR_CHK']),
          title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
          cn: $enumDecodeNullable(_$SortOrderEnumMap, json['CN']),
          etc: $enumDecodeNullable(_$SortOrderEnumMap, json['ETC']),
          doc: $enumDecodeNullable(_$SortOrderEnumMap, json['DOC']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$WORKREQUESTMSTMaxOrderByAggregateInputToJson(
    WORKREQUESTMSTMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('RQSTR_DPNM', _$SortOrderEnumMap[instance.rqstrDpnm]);
  writeNotNull('RQSTR_NM', _$SortOrderEnumMap[instance.rqstrNm]);
  writeNotNull('RQSTR_ID', _$SortOrderEnumMap[instance.rqstrId]);
  writeNotNull('RQSTR_DATE', _$SortOrderEnumMap[instance.rqstrDate]);
  writeNotNull('HOPE_DATE', _$SortOrderEnumMap[instance.hopeDate]);
  writeNotNull('CHR_DPR_NM', _$SortOrderEnumMap[instance.chrDprNm]);
  writeNotNull('CHR_NM', _$SortOrderEnumMap[instance.chrNm]);
  writeNotNull('CHR_ID', _$SortOrderEnumMap[instance.chrId]);
  writeNotNull('CHR_CHK', _$SortOrderEnumMap[instance.chrChk]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull('CN', _$SortOrderEnumMap[instance.cn]);
  writeNotNull('ETC', _$SortOrderEnumMap[instance.etc]);
  writeNotNull('DOC', _$SortOrderEnumMap[instance.doc]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

WORKREQUESTMSTMinOrderByAggregateInput
    _$WORKREQUESTMSTMinOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        WORKREQUESTMSTMinOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          rqstrDpnm:
              $enumDecodeNullable(_$SortOrderEnumMap, json['RQSTR_DPNM']),
          rqstrNm: $enumDecodeNullable(_$SortOrderEnumMap, json['RQSTR_NM']),
          rqstrId: $enumDecodeNullable(_$SortOrderEnumMap, json['RQSTR_ID']),
          rqstrDate:
              $enumDecodeNullable(_$SortOrderEnumMap, json['RQSTR_DATE']),
          hopeDate: $enumDecodeNullable(_$SortOrderEnumMap, json['HOPE_DATE']),
          chrDprNm: $enumDecodeNullable(_$SortOrderEnumMap, json['CHR_DPR_NM']),
          chrNm: $enumDecodeNullable(_$SortOrderEnumMap, json['CHR_NM']),
          chrId: $enumDecodeNullable(_$SortOrderEnumMap, json['CHR_ID']),
          chrChk: $enumDecodeNullable(_$SortOrderEnumMap, json['CHR_CHK']),
          title: $enumDecodeNullable(_$SortOrderEnumMap, json['TITLE']),
          cn: $enumDecodeNullable(_$SortOrderEnumMap, json['CN']),
          etc: $enumDecodeNullable(_$SortOrderEnumMap, json['ETC']),
          doc: $enumDecodeNullable(_$SortOrderEnumMap, json['DOC']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$WORKREQUESTMSTMinOrderByAggregateInputToJson(
    WORKREQUESTMSTMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('RQSTR_DPNM', _$SortOrderEnumMap[instance.rqstrDpnm]);
  writeNotNull('RQSTR_NM', _$SortOrderEnumMap[instance.rqstrNm]);
  writeNotNull('RQSTR_ID', _$SortOrderEnumMap[instance.rqstrId]);
  writeNotNull('RQSTR_DATE', _$SortOrderEnumMap[instance.rqstrDate]);
  writeNotNull('HOPE_DATE', _$SortOrderEnumMap[instance.hopeDate]);
  writeNotNull('CHR_DPR_NM', _$SortOrderEnumMap[instance.chrDprNm]);
  writeNotNull('CHR_NM', _$SortOrderEnumMap[instance.chrNm]);
  writeNotNull('CHR_ID', _$SortOrderEnumMap[instance.chrId]);
  writeNotNull('CHR_CHK', _$SortOrderEnumMap[instance.chrChk]);
  writeNotNull('TITLE', _$SortOrderEnumMap[instance.title]);
  writeNotNull('CN', _$SortOrderEnumMap[instance.cn]);
  writeNotNull('ETC', _$SortOrderEnumMap[instance.etc]);
  writeNotNull('DOC', _$SortOrderEnumMap[instance.doc]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

WORKREQUESTMSTSumOrderByAggregateInput
    _$WORKREQUESTMSTSumOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        WORKREQUESTMSTSumOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
        );

Map<String, dynamic> _$WORKREQUESTMSTSumOrderByAggregateInputToJson(
    WORKREQUESTMSTSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  return val;
}

WORKREQUESTREFCountOrderByAggregateInput
    _$WORKREQUESTREFCountOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        WORKREQUESTREFCountOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          refId: $enumDecodeNullable(_$SortOrderEnumMap, json['REF_ID']),
          refNm: $enumDecodeNullable(_$SortOrderEnumMap, json['REF_NM']),
          refDep: $enumDecodeNullable(_$SortOrderEnumMap, json['REF_DEP']),
          refGrade: $enumDecodeNullable(_$SortOrderEnumMap, json['REF_GRADE']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$WORKREQUESTREFCountOrderByAggregateInputToJson(
    WORKREQUESTREFCountOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('REF_ID', _$SortOrderEnumMap[instance.refId]);
  writeNotNull('REF_NM', _$SortOrderEnumMap[instance.refNm]);
  writeNotNull('REF_DEP', _$SortOrderEnumMap[instance.refDep]);
  writeNotNull('REF_GRADE', _$SortOrderEnumMap[instance.refGrade]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

WORKREQUESTREFAvgOrderByAggregateInput
    _$WORKREQUESTREFAvgOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        WORKREQUESTREFAvgOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
        );

Map<String, dynamic> _$WORKREQUESTREFAvgOrderByAggregateInputToJson(
    WORKREQUESTREFAvgOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  return val;
}

WORKREQUESTREFMaxOrderByAggregateInput
    _$WORKREQUESTREFMaxOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        WORKREQUESTREFMaxOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          refId: $enumDecodeNullable(_$SortOrderEnumMap, json['REF_ID']),
          refNm: $enumDecodeNullable(_$SortOrderEnumMap, json['REF_NM']),
          refDep: $enumDecodeNullable(_$SortOrderEnumMap, json['REF_DEP']),
          refGrade: $enumDecodeNullable(_$SortOrderEnumMap, json['REF_GRADE']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$WORKREQUESTREFMaxOrderByAggregateInputToJson(
    WORKREQUESTREFMaxOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('REF_ID', _$SortOrderEnumMap[instance.refId]);
  writeNotNull('REF_NM', _$SortOrderEnumMap[instance.refNm]);
  writeNotNull('REF_DEP', _$SortOrderEnumMap[instance.refDep]);
  writeNotNull('REF_GRADE', _$SortOrderEnumMap[instance.refGrade]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

WORKREQUESTREFMinOrderByAggregateInput
    _$WORKREQUESTREFMinOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        WORKREQUESTREFMinOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
          refId: $enumDecodeNullable(_$SortOrderEnumMap, json['REF_ID']),
          refNm: $enumDecodeNullable(_$SortOrderEnumMap, json['REF_NM']),
          refDep: $enumDecodeNullable(_$SortOrderEnumMap, json['REF_DEP']),
          refGrade: $enumDecodeNullable(_$SortOrderEnumMap, json['REF_GRADE']),
          regId: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_ID']),
          regDate: $enumDecodeNullable(_$SortOrderEnumMap, json['REG_DATE']),
          editId: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_ID']),
          editDate: $enumDecodeNullable(_$SortOrderEnumMap, json['EDIT_DATE']),
          delId: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_ID']),
          delDate: $enumDecodeNullable(_$SortOrderEnumMap, json['DEL_DATE']),
        );

Map<String, dynamic> _$WORKREQUESTREFMinOrderByAggregateInputToJson(
    WORKREQUESTREFMinOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  writeNotNull('REF_ID', _$SortOrderEnumMap[instance.refId]);
  writeNotNull('REF_NM', _$SortOrderEnumMap[instance.refNm]);
  writeNotNull('REF_DEP', _$SortOrderEnumMap[instance.refDep]);
  writeNotNull('REF_GRADE', _$SortOrderEnumMap[instance.refGrade]);
  writeNotNull('REG_ID', _$SortOrderEnumMap[instance.regId]);
  writeNotNull('REG_DATE', _$SortOrderEnumMap[instance.regDate]);
  writeNotNull('EDIT_ID', _$SortOrderEnumMap[instance.editId]);
  writeNotNull('EDIT_DATE', _$SortOrderEnumMap[instance.editDate]);
  writeNotNull('DEL_ID', _$SortOrderEnumMap[instance.delId]);
  writeNotNull('DEL_DATE', _$SortOrderEnumMap[instance.delDate]);
  return val;
}

WORKREQUESTREFSumOrderByAggregateInput
    _$WORKREQUESTREFSumOrderByAggregateInputFromJson(
            Map<String, dynamic> json) =>
        WORKREQUESTREFSumOrderByAggregateInput(
          seq: $enumDecodeNullable(_$SortOrderEnumMap, json['SEQ']),
          mseq: $enumDecodeNullable(_$SortOrderEnumMap, json['MSEQ']),
        );

Map<String, dynamic> _$WORKREQUESTREFSumOrderByAggregateInputToJson(
    WORKREQUESTREFSumOrderByAggregateInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', _$SortOrderEnumMap[instance.seq]);
  writeNotNull('MSEQ', _$SortOrderEnumMap[instance.mseq]);
  return val;
}

StringFieldUpdateOperationsInput _$StringFieldUpdateOperationsInputFromJson(
        Map<String, dynamic> json) =>
    StringFieldUpdateOperationsInput(
      set: json['set'] as String?,
    );

Map<String, dynamic> _$StringFieldUpdateOperationsInputToJson(
    StringFieldUpdateOperationsInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('set', instance.set);
  return val;
}

NullableStringFieldUpdateOperationsInput
    _$NullableStringFieldUpdateOperationsInputFromJson(
            Map<String, dynamic> json) =>
        NullableStringFieldUpdateOperationsInput(
          set: json['set'] as String?,
        );

Map<String, dynamic> _$NullableStringFieldUpdateOperationsInputToJson(
    NullableStringFieldUpdateOperationsInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('set', instance.set);
  return val;
}

NullableIntFieldUpdateOperationsInput
    _$NullableIntFieldUpdateOperationsInputFromJson(
            Map<String, dynamic> json) =>
        NullableIntFieldUpdateOperationsInput(
          set: json['set'] as int?,
          increment: json['increment'] as int?,
          decrement: json['decrement'] as int?,
          multiply: json['multiply'] as int?,
          divide: json['divide'] as int?,
        );

Map<String, dynamic> _$NullableIntFieldUpdateOperationsInputToJson(
    NullableIntFieldUpdateOperationsInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('set', instance.set);
  writeNotNull('increment', instance.increment);
  writeNotNull('decrement', instance.decrement);
  writeNotNull('multiply', instance.multiply);
  writeNotNull('divide', instance.divide);
  return val;
}

DateTimeFieldUpdateOperationsInput _$DateTimeFieldUpdateOperationsInputFromJson(
        Map<String, dynamic> json) =>
    DateTimeFieldUpdateOperationsInput(
      set: _$JsonConverterFromJson<String, DateTime>(
          json['set'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$DateTimeFieldUpdateOperationsInputToJson(
    DateTimeFieldUpdateOperationsInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull(
      'set',
      _$JsonConverterToJson<String, DateTime>(
          instance.set, const DateTimeJsonConverter().toJson));
  return val;
}

DecimalFieldUpdateOperationsInput _$DecimalFieldUpdateOperationsInputFromJson(
        Map<String, dynamic> json) =>
    DecimalFieldUpdateOperationsInput(
      set: (json['set'] as num?)?.toDouble(),
      increment: (json['increment'] as num?)?.toDouble(),
      decrement: (json['decrement'] as num?)?.toDouble(),
      multiply: (json['multiply'] as num?)?.toDouble(),
      divide: (json['divide'] as num?)?.toDouble(),
    );

Map<String, dynamic> _$DecimalFieldUpdateOperationsInputToJson(
    DecimalFieldUpdateOperationsInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('set', instance.set);
  writeNotNull('increment', instance.increment);
  writeNotNull('decrement', instance.decrement);
  writeNotNull('multiply', instance.multiply);
  writeNotNull('divide', instance.divide);
  return val;
}

BigIntFieldUpdateOperationsInput _$BigIntFieldUpdateOperationsInputFromJson(
        Map<String, dynamic> json) =>
    BigIntFieldUpdateOperationsInput(
      set: json['set'] == null ? null : BigInt.parse(json['set'] as String),
      increment: json['increment'] == null
          ? null
          : BigInt.parse(json['increment'] as String),
      decrement: json['decrement'] == null
          ? null
          : BigInt.parse(json['decrement'] as String),
      multiply: json['multiply'] == null
          ? null
          : BigInt.parse(json['multiply'] as String),
      divide: json['divide'] == null
          ? null
          : BigInt.parse(json['divide'] as String),
    );

Map<String, dynamic> _$BigIntFieldUpdateOperationsInputToJson(
    BigIntFieldUpdateOperationsInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('set', instance.set?.toString());
  writeNotNull('increment', instance.increment?.toString());
  writeNotNull('decrement', instance.decrement?.toString());
  writeNotNull('multiply', instance.multiply?.toString());
  writeNotNull('divide', instance.divide?.toString());
  return val;
}

NullableDateTimeFieldUpdateOperationsInput
    _$NullableDateTimeFieldUpdateOperationsInputFromJson(
            Map<String, dynamic> json) =>
        NullableDateTimeFieldUpdateOperationsInput(
          set: _$JsonConverterFromJson<String, DateTime>(
              json['set'], const DateTimeJsonConverter().fromJson),
        );

Map<String, dynamic> _$NullableDateTimeFieldUpdateOperationsInputToJson(
    NullableDateTimeFieldUpdateOperationsInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull(
      'set',
      _$JsonConverterToJson<String, DateTime>(
          instance.set, const DateTimeJsonConverter().toJson));
  return val;
}

IntFieldUpdateOperationsInput _$IntFieldUpdateOperationsInputFromJson(
        Map<String, dynamic> json) =>
    IntFieldUpdateOperationsInput(
      set: json['set'] as int?,
      increment: json['increment'] as int?,
      decrement: json['decrement'] as int?,
      multiply: json['multiply'] as int?,
      divide: json['divide'] as int?,
    );

Map<String, dynamic> _$IntFieldUpdateOperationsInputToJson(
    IntFieldUpdateOperationsInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('set', instance.set);
  writeNotNull('increment', instance.increment);
  writeNotNull('decrement', instance.decrement);
  writeNotNull('multiply', instance.multiply);
  writeNotNull('divide', instance.divide);
  return val;
}

NullableDecimalFieldUpdateOperationsInput
    _$NullableDecimalFieldUpdateOperationsInputFromJson(
            Map<String, dynamic> json) =>
        NullableDecimalFieldUpdateOperationsInput(
          set: (json['set'] as num?)?.toDouble(),
          increment: (json['increment'] as num?)?.toDouble(),
          decrement: (json['decrement'] as num?)?.toDouble(),
          multiply: (json['multiply'] as num?)?.toDouble(),
          divide: (json['divide'] as num?)?.toDouble(),
        );

Map<String, dynamic> _$NullableDecimalFieldUpdateOperationsInputToJson(
    NullableDecimalFieldUpdateOperationsInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('set', instance.set);
  writeNotNull('increment', instance.increment);
  writeNotNull('decrement', instance.decrement);
  writeNotNull('multiply', instance.multiply);
  writeNotNull('divide', instance.divide);
  return val;
}

NullableBigIntFieldUpdateOperationsInput
    _$NullableBigIntFieldUpdateOperationsInputFromJson(
            Map<String, dynamic> json) =>
        NullableBigIntFieldUpdateOperationsInput(
          set: json['set'] == null ? null : BigInt.parse(json['set'] as String),
          increment: json['increment'] == null
              ? null
              : BigInt.parse(json['increment'] as String),
          decrement: json['decrement'] == null
              ? null
              : BigInt.parse(json['decrement'] as String),
          multiply: json['multiply'] == null
              ? null
              : BigInt.parse(json['multiply'] as String),
          divide: json['divide'] == null
              ? null
              : BigInt.parse(json['divide'] as String),
        );

Map<String, dynamic> _$NullableBigIntFieldUpdateOperationsInputToJson(
    NullableBigIntFieldUpdateOperationsInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('set', instance.set?.toString());
  writeNotNull('increment', instance.increment?.toString());
  writeNotNull('decrement', instance.decrement?.toString());
  writeNotNull('multiply', instance.multiply?.toString());
  writeNotNull('divide', instance.divide?.toString());
  return val;
}

MENUTBLCreateNestedManyWithoutMEMBERTBLInput
    _$MENUTBLCreateNestedManyWithoutMEMBERTBLInputFromJson(
            Map<String, dynamic> json) =>
        MENUTBLCreateNestedManyWithoutMEMBERTBLInput(
          create: (json['create'] as List<dynamic>?)?.map((e) =>
              MENUTBLCreateWithoutMEMBERTBLInput.fromJson(
                  e as Map<String, dynamic>)),
          connectOrCreate: (json['connectOrCreate'] as List<dynamic>?)?.map(
              (e) => MENUTBLCreateOrConnectWithoutMEMBERTBLInput.fromJson(
                  e as Map<String, dynamic>)),
          createMany: json['createMany'] == null
              ? null
              : MENUTBLCreateManyMEMBERTBLInputEnvelope.fromJson(
                  json['createMany'] as Map<String, dynamic>),
          connect: (json['connect'] as List<dynamic>?)?.map((e) =>
              MENUTBLWhereUniqueInput.fromJson(e as Map<String, dynamic>)),
        );

Map<String, dynamic> _$MENUTBLCreateNestedManyWithoutMEMBERTBLInputToJson(
    MENUTBLCreateNestedManyWithoutMEMBERTBLInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('create', instance.create?.map((e) => e.toJson()).toList());
  writeNotNull('connectOrCreate',
      instance.connectOrCreate?.map((e) => e.toJson()).toList());
  writeNotNull('createMany', instance.createMany?.toJson());
  writeNotNull('connect', instance.connect?.map((e) => e.toJson()).toList());
  return val;
}

MENUTBLUncheckedCreateNestedManyWithoutMEMBERTBLInput
    _$MENUTBLUncheckedCreateNestedManyWithoutMEMBERTBLInputFromJson(
            Map<String, dynamic> json) =>
        MENUTBLUncheckedCreateNestedManyWithoutMEMBERTBLInput(
          create: (json['create'] as List<dynamic>?)?.map((e) =>
              MENUTBLCreateWithoutMEMBERTBLInput.fromJson(
                  e as Map<String, dynamic>)),
          connectOrCreate: (json['connectOrCreate'] as List<dynamic>?)?.map(
              (e) => MENUTBLCreateOrConnectWithoutMEMBERTBLInput.fromJson(
                  e as Map<String, dynamic>)),
          createMany: json['createMany'] == null
              ? null
              : MENUTBLCreateManyMEMBERTBLInputEnvelope.fromJson(
                  json['createMany'] as Map<String, dynamic>),
          connect: (json['connect'] as List<dynamic>?)?.map((e) =>
              MENUTBLWhereUniqueInput.fromJson(e as Map<String, dynamic>)),
        );

Map<String, dynamic>
    _$MENUTBLUncheckedCreateNestedManyWithoutMEMBERTBLInputToJson(
        MENUTBLUncheckedCreateNestedManyWithoutMEMBERTBLInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('create', instance.create?.map((e) => e.toJson()).toList());
  writeNotNull('connectOrCreate',
      instance.connectOrCreate?.map((e) => e.toJson()).toList());
  writeNotNull('createMany', instance.createMany?.toJson());
  writeNotNull('connect', instance.connect?.map((e) => e.toJson()).toList());
  return val;
}

MENUTBLUpdateManyWithoutMEMBERTBLNestedInput
    _$MENUTBLUpdateManyWithoutMEMBERTBLNestedInputFromJson(
            Map<String, dynamic> json) =>
        MENUTBLUpdateManyWithoutMEMBERTBLNestedInput(
          create: (json['create'] as List<dynamic>?)?.map((e) =>
              MENUTBLCreateWithoutMEMBERTBLInput.fromJson(
                  e as Map<String, dynamic>)),
          connectOrCreate: (json['connectOrCreate'] as List<dynamic>?)?.map(
              (e) => MENUTBLCreateOrConnectWithoutMEMBERTBLInput.fromJson(
                  e as Map<String, dynamic>)),
          upsert: (json['upsert'] as List<dynamic>?)?.map((e) =>
              MENUTBLUpsertWithWhereUniqueWithoutMEMBERTBLInput.fromJson(
                  e as Map<String, dynamic>)),
          createMany: json['createMany'] == null
              ? null
              : MENUTBLCreateManyMEMBERTBLInputEnvelope.fromJson(
                  json['createMany'] as Map<String, dynamic>),
          set: (json['set'] as List<dynamic>?)?.map((e) =>
              MENUTBLWhereUniqueInput.fromJson(e as Map<String, dynamic>)),
          disconnect: (json['disconnect'] as List<dynamic>?)?.map((e) =>
              MENUTBLWhereUniqueInput.fromJson(e as Map<String, dynamic>)),
          delete: (json['delete'] as List<dynamic>?)?.map((e) =>
              MENUTBLWhereUniqueInput.fromJson(e as Map<String, dynamic>)),
          connect: (json['connect'] as List<dynamic>?)?.map((e) =>
              MENUTBLWhereUniqueInput.fromJson(e as Map<String, dynamic>)),
          update: (json['update'] as List<dynamic>?)?.map((e) =>
              MENUTBLUpdateWithWhereUniqueWithoutMEMBERTBLInput.fromJson(
                  e as Map<String, dynamic>)),
          updateMany: (json['updateMany'] as List<dynamic>?)?.map((e) =>
              MENUTBLUpdateManyWithWhereWithoutMEMBERTBLInput.fromJson(
                  e as Map<String, dynamic>)),
          deleteMany: (json['deleteMany'] as List<dynamic>?)?.map((e) =>
              MENUTBLScalarWhereInput.fromJson(e as Map<String, dynamic>)),
        );

Map<String, dynamic> _$MENUTBLUpdateManyWithoutMEMBERTBLNestedInputToJson(
    MENUTBLUpdateManyWithoutMEMBERTBLNestedInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('create', instance.create?.map((e) => e.toJson()).toList());
  writeNotNull('connectOrCreate',
      instance.connectOrCreate?.map((e) => e.toJson()).toList());
  writeNotNull('upsert', instance.upsert?.map((e) => e.toJson()).toList());
  writeNotNull('createMany', instance.createMany?.toJson());
  writeNotNull('set', instance.set?.map((e) => e.toJson()).toList());
  writeNotNull(
      'disconnect', instance.disconnect?.map((e) => e.toJson()).toList());
  writeNotNull('delete', instance.delete?.map((e) => e.toJson()).toList());
  writeNotNull('connect', instance.connect?.map((e) => e.toJson()).toList());
  writeNotNull('update', instance.update?.map((e) => e.toJson()).toList());
  writeNotNull(
      'updateMany', instance.updateMany?.map((e) => e.toJson()).toList());
  writeNotNull(
      'deleteMany', instance.deleteMany?.map((e) => e.toJson()).toList());
  return val;
}

MENUTBLUncheckedUpdateManyWithoutMEMBERTBLNestedInput
    _$MENUTBLUncheckedUpdateManyWithoutMEMBERTBLNestedInputFromJson(
            Map<String, dynamic> json) =>
        MENUTBLUncheckedUpdateManyWithoutMEMBERTBLNestedInput(
          create: (json['create'] as List<dynamic>?)?.map((e) =>
              MENUTBLCreateWithoutMEMBERTBLInput.fromJson(
                  e as Map<String, dynamic>)),
          connectOrCreate: (json['connectOrCreate'] as List<dynamic>?)?.map(
              (e) => MENUTBLCreateOrConnectWithoutMEMBERTBLInput.fromJson(
                  e as Map<String, dynamic>)),
          upsert: (json['upsert'] as List<dynamic>?)?.map((e) =>
              MENUTBLUpsertWithWhereUniqueWithoutMEMBERTBLInput.fromJson(
                  e as Map<String, dynamic>)),
          createMany: json['createMany'] == null
              ? null
              : MENUTBLCreateManyMEMBERTBLInputEnvelope.fromJson(
                  json['createMany'] as Map<String, dynamic>),
          set: (json['set'] as List<dynamic>?)?.map((e) =>
              MENUTBLWhereUniqueInput.fromJson(e as Map<String, dynamic>)),
          disconnect: (json['disconnect'] as List<dynamic>?)?.map((e) =>
              MENUTBLWhereUniqueInput.fromJson(e as Map<String, dynamic>)),
          delete: (json['delete'] as List<dynamic>?)?.map((e) =>
              MENUTBLWhereUniqueInput.fromJson(e as Map<String, dynamic>)),
          connect: (json['connect'] as List<dynamic>?)?.map((e) =>
              MENUTBLWhereUniqueInput.fromJson(e as Map<String, dynamic>)),
          update: (json['update'] as List<dynamic>?)?.map((e) =>
              MENUTBLUpdateWithWhereUniqueWithoutMEMBERTBLInput.fromJson(
                  e as Map<String, dynamic>)),
          updateMany: (json['updateMany'] as List<dynamic>?)?.map((e) =>
              MENUTBLUpdateManyWithWhereWithoutMEMBERTBLInput.fromJson(
                  e as Map<String, dynamic>)),
          deleteMany: (json['deleteMany'] as List<dynamic>?)?.map((e) =>
              MENUTBLScalarWhereInput.fromJson(e as Map<String, dynamic>)),
        );

Map<String, dynamic>
    _$MENUTBLUncheckedUpdateManyWithoutMEMBERTBLNestedInputToJson(
        MENUTBLUncheckedUpdateManyWithoutMEMBERTBLNestedInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('create', instance.create?.map((e) => e.toJson()).toList());
  writeNotNull('connectOrCreate',
      instance.connectOrCreate?.map((e) => e.toJson()).toList());
  writeNotNull('upsert', instance.upsert?.map((e) => e.toJson()).toList());
  writeNotNull('createMany', instance.createMany?.toJson());
  writeNotNull('set', instance.set?.map((e) => e.toJson()).toList());
  writeNotNull(
      'disconnect', instance.disconnect?.map((e) => e.toJson()).toList());
  writeNotNull('delete', instance.delete?.map((e) => e.toJson()).toList());
  writeNotNull('connect', instance.connect?.map((e) => e.toJson()).toList());
  writeNotNull('update', instance.update?.map((e) => e.toJson()).toList());
  writeNotNull(
      'updateMany', instance.updateMany?.map((e) => e.toJson()).toList());
  writeNotNull(
      'deleteMany', instance.deleteMany?.map((e) => e.toJson()).toList());
  return val;
}

MEMBERTBLCreateNestedOneWithoutMENUTBLInput
    _$MEMBERTBLCreateNestedOneWithoutMENUTBLInputFromJson(
            Map<String, dynamic> json) =>
        MEMBERTBLCreateNestedOneWithoutMENUTBLInput(
          create: json['create'] == null
              ? null
              : MEMBERTBLCreateWithoutMENUTBLInput.fromJson(
                  json['create'] as Map<String, dynamic>),
          connectOrCreate: json['connectOrCreate'] == null
              ? null
              : MEMBERTBLCreateOrConnectWithoutMENUTBLInput.fromJson(
                  json['connectOrCreate'] as Map<String, dynamic>),
          connect: json['connect'] == null
              ? null
              : MEMBERTBLWhereUniqueInput.fromJson(
                  json['connect'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$MEMBERTBLCreateNestedOneWithoutMENUTBLInputToJson(
    MEMBERTBLCreateNestedOneWithoutMENUTBLInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('create', instance.create?.toJson());
  writeNotNull('connectOrCreate', instance.connectOrCreate?.toJson());
  writeNotNull('connect', instance.connect?.toJson());
  return val;
}

MEMBERTBLUpdateOneWithoutMENUTBLNestedInput
    _$MEMBERTBLUpdateOneWithoutMENUTBLNestedInputFromJson(
            Map<String, dynamic> json) =>
        MEMBERTBLUpdateOneWithoutMENUTBLNestedInput(
          create: json['create'] == null
              ? null
              : MEMBERTBLCreateWithoutMENUTBLInput.fromJson(
                  json['create'] as Map<String, dynamic>),
          connectOrCreate: json['connectOrCreate'] == null
              ? null
              : MEMBERTBLCreateOrConnectWithoutMENUTBLInput.fromJson(
                  json['connectOrCreate'] as Map<String, dynamic>),
          upsert: json['upsert'] == null
              ? null
              : MEMBERTBLUpsertWithoutMENUTBLInput.fromJson(
                  json['upsert'] as Map<String, dynamic>),
          disconnect: json['disconnect'] as bool?,
          delete: json['delete'] as bool?,
          connect: json['connect'] == null
              ? null
              : MEMBERTBLWhereUniqueInput.fromJson(
                  json['connect'] as Map<String, dynamic>),
          update: json['update'] == null
              ? null
              : MEMBERTBLUpdateWithoutMENUTBLInput.fromJson(
                  json['update'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$MEMBERTBLUpdateOneWithoutMENUTBLNestedInputToJson(
    MEMBERTBLUpdateOneWithoutMENUTBLNestedInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('create', instance.create?.toJson());
  writeNotNull('connectOrCreate', instance.connectOrCreate?.toJson());
  writeNotNull('upsert', instance.upsert?.toJson());
  writeNotNull('disconnect', instance.disconnect);
  writeNotNull('delete', instance.delete);
  writeNotNull('connect', instance.connect?.toJson());
  writeNotNull('update', instance.update?.toJson());
  return val;
}

NestedStringFilter _$NestedStringFilterFromJson(Map<String, dynamic> json) =>
    NestedStringFilter(
      equals: json['equals'] as String?,
      $in: (json['in'] as List<dynamic>?)?.map((e) => e as String),
      notIn: (json['notIn'] as List<dynamic>?)?.map((e) => e as String),
      lt: json['lt'] as String?,
      lte: json['lte'] as String?,
      gt: json['gt'] as String?,
      gte: json['gte'] as String?,
      contains: json['contains'] as String?,
      startsWith: json['startsWith'] as String?,
      endsWith: json['endsWith'] as String?,
      not: json['not'] == null
          ? null
          : NestedStringFilter.fromJson(json['not'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$NestedStringFilterToJson(NestedStringFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals);
  writeNotNull('in', instance.$in?.toList());
  writeNotNull('notIn', instance.notIn?.toList());
  writeNotNull('lt', instance.lt);
  writeNotNull('lte', instance.lte);
  writeNotNull('gt', instance.gt);
  writeNotNull('gte', instance.gte);
  writeNotNull('contains', instance.contains);
  writeNotNull('startsWith', instance.startsWith);
  writeNotNull('endsWith', instance.endsWith);
  writeNotNull('not', instance.not?.toJson());
  return val;
}

NestedStringNullableFilter _$NestedStringNullableFilterFromJson(
        Map<String, dynamic> json) =>
    NestedStringNullableFilter(
      equals: json['equals'] as String?,
      $in: (json['in'] as List<dynamic>?)?.map((e) => e as String),
      notIn: (json['notIn'] as List<dynamic>?)?.map((e) => e as String),
      lt: json['lt'] as String?,
      lte: json['lte'] as String?,
      gt: json['gt'] as String?,
      gte: json['gte'] as String?,
      contains: json['contains'] as String?,
      startsWith: json['startsWith'] as String?,
      endsWith: json['endsWith'] as String?,
      not: json['not'] == null
          ? null
          : NestedStringNullableFilter.fromJson(
              json['not'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$NestedStringNullableFilterToJson(
    NestedStringNullableFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals);
  writeNotNull('in', instance.$in?.toList());
  writeNotNull('notIn', instance.notIn?.toList());
  writeNotNull('lt', instance.lt);
  writeNotNull('lte', instance.lte);
  writeNotNull('gt', instance.gt);
  writeNotNull('gte', instance.gte);
  writeNotNull('contains', instance.contains);
  writeNotNull('startsWith', instance.startsWith);
  writeNotNull('endsWith', instance.endsWith);
  writeNotNull('not', instance.not?.toJson());
  return val;
}

NestedIntNullableFilter _$NestedIntNullableFilterFromJson(
        Map<String, dynamic> json) =>
    NestedIntNullableFilter(
      equals: json['equals'] as int?,
      $in: (json['in'] as List<dynamic>?)?.map((e) => e as int),
      notIn: (json['notIn'] as List<dynamic>?)?.map((e) => e as int),
      lt: json['lt'] as int?,
      lte: json['lte'] as int?,
      gt: json['gt'] as int?,
      gte: json['gte'] as int?,
      not: json['not'] == null
          ? null
          : NestedIntNullableFilter.fromJson(
              json['not'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$NestedIntNullableFilterToJson(
    NestedIntNullableFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals);
  writeNotNull('in', instance.$in?.toList());
  writeNotNull('notIn', instance.notIn?.toList());
  writeNotNull('lt', instance.lt);
  writeNotNull('lte', instance.lte);
  writeNotNull('gt', instance.gt);
  writeNotNull('gte', instance.gte);
  writeNotNull('not', instance.not?.toJson());
  return val;
}

NestedDateTimeFilter _$NestedDateTimeFilterFromJson(
        Map<String, dynamic> json) =>
    NestedDateTimeFilter(
      equals: _$JsonConverterFromJson<String, DateTime>(
          json['equals'], const DateTimeJsonConverter().fromJson),
      $in: (json['in'] as List<dynamic>?)
          ?.map((e) => const DateTimeJsonConverter().fromJson(e as String)),
      notIn: (json['notIn'] as List<dynamic>?)
          ?.map((e) => const DateTimeJsonConverter().fromJson(e as String)),
      lt: _$JsonConverterFromJson<String, DateTime>(
          json['lt'], const DateTimeJsonConverter().fromJson),
      lte: _$JsonConverterFromJson<String, DateTime>(
          json['lte'], const DateTimeJsonConverter().fromJson),
      gt: _$JsonConverterFromJson<String, DateTime>(
          json['gt'], const DateTimeJsonConverter().fromJson),
      gte: _$JsonConverterFromJson<String, DateTime>(
          json['gte'], const DateTimeJsonConverter().fromJson),
      not: json['not'] == null
          ? null
          : NestedDateTimeFilter.fromJson(json['not'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$NestedDateTimeFilterToJson(
    NestedDateTimeFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull(
      'equals',
      _$JsonConverterToJson<String, DateTime>(
          instance.equals, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'in', instance.$in?.map(const DateTimeJsonConverter().toJson).toList());
  writeNotNull('notIn',
      instance.notIn?.map(const DateTimeJsonConverter().toJson).toList());
  writeNotNull(
      'lt',
      _$JsonConverterToJson<String, DateTime>(
          instance.lt, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'lte',
      _$JsonConverterToJson<String, DateTime>(
          instance.lte, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'gt',
      _$JsonConverterToJson<String, DateTime>(
          instance.gt, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'gte',
      _$JsonConverterToJson<String, DateTime>(
          instance.gte, const DateTimeJsonConverter().toJson));
  writeNotNull('not', instance.not?.toJson());
  return val;
}

NestedStringWithAggregatesFilter _$NestedStringWithAggregatesFilterFromJson(
        Map<String, dynamic> json) =>
    NestedStringWithAggregatesFilter(
      equals: json['equals'] as String?,
      $in: (json['in'] as List<dynamic>?)?.map((e) => e as String),
      notIn: (json['notIn'] as List<dynamic>?)?.map((e) => e as String),
      lt: json['lt'] as String?,
      lte: json['lte'] as String?,
      gt: json['gt'] as String?,
      gte: json['gte'] as String?,
      contains: json['contains'] as String?,
      startsWith: json['startsWith'] as String?,
      endsWith: json['endsWith'] as String?,
      not: json['not'] == null
          ? null
          : NestedStringWithAggregatesFilter.fromJson(
              json['not'] as Map<String, dynamic>),
      $count: json['_count'] == null
          ? null
          : NestedIntFilter.fromJson(json['_count'] as Map<String, dynamic>),
      $min: json['_min'] == null
          ? null
          : NestedStringFilter.fromJson(json['_min'] as Map<String, dynamic>),
      $max: json['_max'] == null
          ? null
          : NestedStringFilter.fromJson(json['_max'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$NestedStringWithAggregatesFilterToJson(
    NestedStringWithAggregatesFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals);
  writeNotNull('in', instance.$in?.toList());
  writeNotNull('notIn', instance.notIn?.toList());
  writeNotNull('lt', instance.lt);
  writeNotNull('lte', instance.lte);
  writeNotNull('gt', instance.gt);
  writeNotNull('gte', instance.gte);
  writeNotNull('contains', instance.contains);
  writeNotNull('startsWith', instance.startsWith);
  writeNotNull('endsWith', instance.endsWith);
  writeNotNull('not', instance.not?.toJson());
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  return val;
}

NestedIntFilter _$NestedIntFilterFromJson(Map<String, dynamic> json) =>
    NestedIntFilter(
      equals: json['equals'] as int?,
      $in: (json['in'] as List<dynamic>?)?.map((e) => e as int),
      notIn: (json['notIn'] as List<dynamic>?)?.map((e) => e as int),
      lt: json['lt'] as int?,
      lte: json['lte'] as int?,
      gt: json['gt'] as int?,
      gte: json['gte'] as int?,
      not: json['not'] == null
          ? null
          : NestedIntFilter.fromJson(json['not'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$NestedIntFilterToJson(NestedIntFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals);
  writeNotNull('in', instance.$in?.toList());
  writeNotNull('notIn', instance.notIn?.toList());
  writeNotNull('lt', instance.lt);
  writeNotNull('lte', instance.lte);
  writeNotNull('gt', instance.gt);
  writeNotNull('gte', instance.gte);
  writeNotNull('not', instance.not?.toJson());
  return val;
}

NestedStringNullableWithAggregatesFilter
    _$NestedStringNullableWithAggregatesFilterFromJson(
            Map<String, dynamic> json) =>
        NestedStringNullableWithAggregatesFilter(
          equals: json['equals'] as String?,
          $in: (json['in'] as List<dynamic>?)?.map((e) => e as String),
          notIn: (json['notIn'] as List<dynamic>?)?.map((e) => e as String),
          lt: json['lt'] as String?,
          lte: json['lte'] as String?,
          gt: json['gt'] as String?,
          gte: json['gte'] as String?,
          contains: json['contains'] as String?,
          startsWith: json['startsWith'] as String?,
          endsWith: json['endsWith'] as String?,
          not: json['not'] == null
              ? null
              : NestedStringNullableWithAggregatesFilter.fromJson(
                  json['not'] as Map<String, dynamic>),
          $count: json['_count'] == null
              ? null
              : NestedIntNullableFilter.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : NestedStringNullableFilter.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : NestedStringNullableFilter.fromJson(
                  json['_max'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$NestedStringNullableWithAggregatesFilterToJson(
    NestedStringNullableWithAggregatesFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals);
  writeNotNull('in', instance.$in?.toList());
  writeNotNull('notIn', instance.notIn?.toList());
  writeNotNull('lt', instance.lt);
  writeNotNull('lte', instance.lte);
  writeNotNull('gt', instance.gt);
  writeNotNull('gte', instance.gte);
  writeNotNull('contains', instance.contains);
  writeNotNull('startsWith', instance.startsWith);
  writeNotNull('endsWith', instance.endsWith);
  writeNotNull('not', instance.not?.toJson());
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  return val;
}

NestedIntNullableWithAggregatesFilter
    _$NestedIntNullableWithAggregatesFilterFromJson(
            Map<String, dynamic> json) =>
        NestedIntNullableWithAggregatesFilter(
          equals: json['equals'] as int?,
          $in: (json['in'] as List<dynamic>?)?.map((e) => e as int),
          notIn: (json['notIn'] as List<dynamic>?)?.map((e) => e as int),
          lt: json['lt'] as int?,
          lte: json['lte'] as int?,
          gt: json['gt'] as int?,
          gte: json['gte'] as int?,
          not: json['not'] == null
              ? null
              : NestedIntNullableWithAggregatesFilter.fromJson(
                  json['not'] as Map<String, dynamic>),
          $count: json['_count'] == null
              ? null
              : NestedIntNullableFilter.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : NestedFloatNullableFilter.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : NestedIntNullableFilter.fromJson(
                  json['_sum'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : NestedIntNullableFilter.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : NestedIntNullableFilter.fromJson(
                  json['_max'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$NestedIntNullableWithAggregatesFilterToJson(
    NestedIntNullableWithAggregatesFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals);
  writeNotNull('in', instance.$in?.toList());
  writeNotNull('notIn', instance.notIn?.toList());
  writeNotNull('lt', instance.lt);
  writeNotNull('lte', instance.lte);
  writeNotNull('gt', instance.gt);
  writeNotNull('gte', instance.gte);
  writeNotNull('not', instance.not?.toJson());
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  return val;
}

NestedFloatNullableFilter _$NestedFloatNullableFilterFromJson(
        Map<String, dynamic> json) =>
    NestedFloatNullableFilter(
      equals: (json['equals'] as num?)?.toDouble(),
      $in: (json['in'] as List<dynamic>?)?.map((e) => (e as num).toDouble()),
      notIn:
          (json['notIn'] as List<dynamic>?)?.map((e) => (e as num).toDouble()),
      lt: (json['lt'] as num?)?.toDouble(),
      lte: (json['lte'] as num?)?.toDouble(),
      gt: (json['gt'] as num?)?.toDouble(),
      gte: (json['gte'] as num?)?.toDouble(),
      not: json['not'] == null
          ? null
          : NestedFloatNullableFilter.fromJson(
              json['not'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$NestedFloatNullableFilterToJson(
    NestedFloatNullableFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals);
  writeNotNull('in', instance.$in?.toList());
  writeNotNull('notIn', instance.notIn?.toList());
  writeNotNull('lt', instance.lt);
  writeNotNull('lte', instance.lte);
  writeNotNull('gt', instance.gt);
  writeNotNull('gte', instance.gte);
  writeNotNull('not', instance.not?.toJson());
  return val;
}

NestedDateTimeWithAggregatesFilter _$NestedDateTimeWithAggregatesFilterFromJson(
        Map<String, dynamic> json) =>
    NestedDateTimeWithAggregatesFilter(
      equals: _$JsonConverterFromJson<String, DateTime>(
          json['equals'], const DateTimeJsonConverter().fromJson),
      $in: (json['in'] as List<dynamic>?)
          ?.map((e) => const DateTimeJsonConverter().fromJson(e as String)),
      notIn: (json['notIn'] as List<dynamic>?)
          ?.map((e) => const DateTimeJsonConverter().fromJson(e as String)),
      lt: _$JsonConverterFromJson<String, DateTime>(
          json['lt'], const DateTimeJsonConverter().fromJson),
      lte: _$JsonConverterFromJson<String, DateTime>(
          json['lte'], const DateTimeJsonConverter().fromJson),
      gt: _$JsonConverterFromJson<String, DateTime>(
          json['gt'], const DateTimeJsonConverter().fromJson),
      gte: _$JsonConverterFromJson<String, DateTime>(
          json['gte'], const DateTimeJsonConverter().fromJson),
      not: json['not'] == null
          ? null
          : NestedDateTimeWithAggregatesFilter.fromJson(
              json['not'] as Map<String, dynamic>),
      $count: json['_count'] == null
          ? null
          : NestedIntFilter.fromJson(json['_count'] as Map<String, dynamic>),
      $min: json['_min'] == null
          ? null
          : NestedDateTimeFilter.fromJson(json['_min'] as Map<String, dynamic>),
      $max: json['_max'] == null
          ? null
          : NestedDateTimeFilter.fromJson(json['_max'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$NestedDateTimeWithAggregatesFilterToJson(
    NestedDateTimeWithAggregatesFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull(
      'equals',
      _$JsonConverterToJson<String, DateTime>(
          instance.equals, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'in', instance.$in?.map(const DateTimeJsonConverter().toJson).toList());
  writeNotNull('notIn',
      instance.notIn?.map(const DateTimeJsonConverter().toJson).toList());
  writeNotNull(
      'lt',
      _$JsonConverterToJson<String, DateTime>(
          instance.lt, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'lte',
      _$JsonConverterToJson<String, DateTime>(
          instance.lte, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'gt',
      _$JsonConverterToJson<String, DateTime>(
          instance.gt, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'gte',
      _$JsonConverterToJson<String, DateTime>(
          instance.gte, const DateTimeJsonConverter().toJson));
  writeNotNull('not', instance.not?.toJson());
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  return val;
}

NestedDecimalFilter _$NestedDecimalFilterFromJson(Map<String, dynamic> json) =>
    NestedDecimalFilter(
      equals: (json['equals'] as num?)?.toDouble(),
      $in: (json['in'] as List<dynamic>?)?.map((e) => (e as num).toDouble()),
      notIn:
          (json['notIn'] as List<dynamic>?)?.map((e) => (e as num).toDouble()),
      lt: (json['lt'] as num?)?.toDouble(),
      lte: (json['lte'] as num?)?.toDouble(),
      gt: (json['gt'] as num?)?.toDouble(),
      gte: (json['gte'] as num?)?.toDouble(),
      not: json['not'] == null
          ? null
          : NestedDecimalFilter.fromJson(json['not'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$NestedDecimalFilterToJson(NestedDecimalFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals);
  writeNotNull('in', instance.$in?.toList());
  writeNotNull('notIn', instance.notIn?.toList());
  writeNotNull('lt', instance.lt);
  writeNotNull('lte', instance.lte);
  writeNotNull('gt', instance.gt);
  writeNotNull('gte', instance.gte);
  writeNotNull('not', instance.not?.toJson());
  return val;
}

NestedDecimalWithAggregatesFilter _$NestedDecimalWithAggregatesFilterFromJson(
        Map<String, dynamic> json) =>
    NestedDecimalWithAggregatesFilter(
      equals: (json['equals'] as num?)?.toDouble(),
      $in: (json['in'] as List<dynamic>?)?.map((e) => (e as num).toDouble()),
      notIn:
          (json['notIn'] as List<dynamic>?)?.map((e) => (e as num).toDouble()),
      lt: (json['lt'] as num?)?.toDouble(),
      lte: (json['lte'] as num?)?.toDouble(),
      gt: (json['gt'] as num?)?.toDouble(),
      gte: (json['gte'] as num?)?.toDouble(),
      not: json['not'] == null
          ? null
          : NestedDecimalWithAggregatesFilter.fromJson(
              json['not'] as Map<String, dynamic>),
      $count: json['_count'] == null
          ? null
          : NestedIntFilter.fromJson(json['_count'] as Map<String, dynamic>),
      $avg: json['_avg'] == null
          ? null
          : NestedDecimalFilter.fromJson(json['_avg'] as Map<String, dynamic>),
      $sum: json['_sum'] == null
          ? null
          : NestedDecimalFilter.fromJson(json['_sum'] as Map<String, dynamic>),
      $min: json['_min'] == null
          ? null
          : NestedDecimalFilter.fromJson(json['_min'] as Map<String, dynamic>),
      $max: json['_max'] == null
          ? null
          : NestedDecimalFilter.fromJson(json['_max'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$NestedDecimalWithAggregatesFilterToJson(
    NestedDecimalWithAggregatesFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals);
  writeNotNull('in', instance.$in?.toList());
  writeNotNull('notIn', instance.notIn?.toList());
  writeNotNull('lt', instance.lt);
  writeNotNull('lte', instance.lte);
  writeNotNull('gt', instance.gt);
  writeNotNull('gte', instance.gte);
  writeNotNull('not', instance.not?.toJson());
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  return val;
}

NestedBigIntFilter _$NestedBigIntFilterFromJson(Map<String, dynamic> json) =>
    NestedBigIntFilter(
      equals: json['equals'] == null
          ? null
          : BigInt.parse(json['equals'] as String),
      $in:
          (json['in'] as List<dynamic>?)?.map((e) => BigInt.parse(e as String)),
      notIn: (json['notIn'] as List<dynamic>?)
          ?.map((e) => BigInt.parse(e as String)),
      lt: json['lt'] == null ? null : BigInt.parse(json['lt'] as String),
      lte: json['lte'] == null ? null : BigInt.parse(json['lte'] as String),
      gt: json['gt'] == null ? null : BigInt.parse(json['gt'] as String),
      gte: json['gte'] == null ? null : BigInt.parse(json['gte'] as String),
      not: json['not'] == null
          ? null
          : NestedBigIntFilter.fromJson(json['not'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$NestedBigIntFilterToJson(NestedBigIntFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals?.toString());
  writeNotNull('in', instance.$in?.map((e) => e.toString()).toList());
  writeNotNull('notIn', instance.notIn?.map((e) => e.toString()).toList());
  writeNotNull('lt', instance.lt?.toString());
  writeNotNull('lte', instance.lte?.toString());
  writeNotNull('gt', instance.gt?.toString());
  writeNotNull('gte', instance.gte?.toString());
  writeNotNull('not', instance.not?.toJson());
  return val;
}

NestedDateTimeNullableFilter _$NestedDateTimeNullableFilterFromJson(
        Map<String, dynamic> json) =>
    NestedDateTimeNullableFilter(
      equals: _$JsonConverterFromJson<String, DateTime>(
          json['equals'], const DateTimeJsonConverter().fromJson),
      $in: (json['in'] as List<dynamic>?)
          ?.map((e) => const DateTimeJsonConverter().fromJson(e as String)),
      notIn: (json['notIn'] as List<dynamic>?)
          ?.map((e) => const DateTimeJsonConverter().fromJson(e as String)),
      lt: _$JsonConverterFromJson<String, DateTime>(
          json['lt'], const DateTimeJsonConverter().fromJson),
      lte: _$JsonConverterFromJson<String, DateTime>(
          json['lte'], const DateTimeJsonConverter().fromJson),
      gt: _$JsonConverterFromJson<String, DateTime>(
          json['gt'], const DateTimeJsonConverter().fromJson),
      gte: _$JsonConverterFromJson<String, DateTime>(
          json['gte'], const DateTimeJsonConverter().fromJson),
      not: json['not'] == null
          ? null
          : NestedDateTimeNullableFilter.fromJson(
              json['not'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$NestedDateTimeNullableFilterToJson(
    NestedDateTimeNullableFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull(
      'equals',
      _$JsonConverterToJson<String, DateTime>(
          instance.equals, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'in', instance.$in?.map(const DateTimeJsonConverter().toJson).toList());
  writeNotNull('notIn',
      instance.notIn?.map(const DateTimeJsonConverter().toJson).toList());
  writeNotNull(
      'lt',
      _$JsonConverterToJson<String, DateTime>(
          instance.lt, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'lte',
      _$JsonConverterToJson<String, DateTime>(
          instance.lte, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'gt',
      _$JsonConverterToJson<String, DateTime>(
          instance.gt, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'gte',
      _$JsonConverterToJson<String, DateTime>(
          instance.gte, const DateTimeJsonConverter().toJson));
  writeNotNull('not', instance.not?.toJson());
  return val;
}

NestedBigIntWithAggregatesFilter _$NestedBigIntWithAggregatesFilterFromJson(
        Map<String, dynamic> json) =>
    NestedBigIntWithAggregatesFilter(
      equals: json['equals'] == null
          ? null
          : BigInt.parse(json['equals'] as String),
      $in:
          (json['in'] as List<dynamic>?)?.map((e) => BigInt.parse(e as String)),
      notIn: (json['notIn'] as List<dynamic>?)
          ?.map((e) => BigInt.parse(e as String)),
      lt: json['lt'] == null ? null : BigInt.parse(json['lt'] as String),
      lte: json['lte'] == null ? null : BigInt.parse(json['lte'] as String),
      gt: json['gt'] == null ? null : BigInt.parse(json['gt'] as String),
      gte: json['gte'] == null ? null : BigInt.parse(json['gte'] as String),
      not: json['not'] == null
          ? null
          : NestedBigIntWithAggregatesFilter.fromJson(
              json['not'] as Map<String, dynamic>),
      $count: json['_count'] == null
          ? null
          : NestedIntFilter.fromJson(json['_count'] as Map<String, dynamic>),
      $avg: json['_avg'] == null
          ? null
          : NestedFloatFilter.fromJson(json['_avg'] as Map<String, dynamic>),
      $sum: json['_sum'] == null
          ? null
          : NestedBigIntFilter.fromJson(json['_sum'] as Map<String, dynamic>),
      $min: json['_min'] == null
          ? null
          : NestedBigIntFilter.fromJson(json['_min'] as Map<String, dynamic>),
      $max: json['_max'] == null
          ? null
          : NestedBigIntFilter.fromJson(json['_max'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$NestedBigIntWithAggregatesFilterToJson(
    NestedBigIntWithAggregatesFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals?.toString());
  writeNotNull('in', instance.$in?.map((e) => e.toString()).toList());
  writeNotNull('notIn', instance.notIn?.map((e) => e.toString()).toList());
  writeNotNull('lt', instance.lt?.toString());
  writeNotNull('lte', instance.lte?.toString());
  writeNotNull('gt', instance.gt?.toString());
  writeNotNull('gte', instance.gte?.toString());
  writeNotNull('not', instance.not?.toJson());
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  return val;
}

NestedFloatFilter _$NestedFloatFilterFromJson(Map<String, dynamic> json) =>
    NestedFloatFilter(
      equals: (json['equals'] as num?)?.toDouble(),
      $in: (json['in'] as List<dynamic>?)?.map((e) => (e as num).toDouble()),
      notIn:
          (json['notIn'] as List<dynamic>?)?.map((e) => (e as num).toDouble()),
      lt: (json['lt'] as num?)?.toDouble(),
      lte: (json['lte'] as num?)?.toDouble(),
      gt: (json['gt'] as num?)?.toDouble(),
      gte: (json['gte'] as num?)?.toDouble(),
      not: json['not'] == null
          ? null
          : NestedFloatFilter.fromJson(json['not'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$NestedFloatFilterToJson(NestedFloatFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals);
  writeNotNull('in', instance.$in?.toList());
  writeNotNull('notIn', instance.notIn?.toList());
  writeNotNull('lt', instance.lt);
  writeNotNull('lte', instance.lte);
  writeNotNull('gt', instance.gt);
  writeNotNull('gte', instance.gte);
  writeNotNull('not', instance.not?.toJson());
  return val;
}

NestedDateTimeNullableWithAggregatesFilter
    _$NestedDateTimeNullableWithAggregatesFilterFromJson(
            Map<String, dynamic> json) =>
        NestedDateTimeNullableWithAggregatesFilter(
          equals: _$JsonConverterFromJson<String, DateTime>(
              json['equals'], const DateTimeJsonConverter().fromJson),
          $in: (json['in'] as List<dynamic>?)
              ?.map((e) => const DateTimeJsonConverter().fromJson(e as String)),
          notIn: (json['notIn'] as List<dynamic>?)
              ?.map((e) => const DateTimeJsonConverter().fromJson(e as String)),
          lt: _$JsonConverterFromJson<String, DateTime>(
              json['lt'], const DateTimeJsonConverter().fromJson),
          lte: _$JsonConverterFromJson<String, DateTime>(
              json['lte'], const DateTimeJsonConverter().fromJson),
          gt: _$JsonConverterFromJson<String, DateTime>(
              json['gt'], const DateTimeJsonConverter().fromJson),
          gte: _$JsonConverterFromJson<String, DateTime>(
              json['gte'], const DateTimeJsonConverter().fromJson),
          not: json['not'] == null
              ? null
              : NestedDateTimeNullableWithAggregatesFilter.fromJson(
                  json['not'] as Map<String, dynamic>),
          $count: json['_count'] == null
              ? null
              : NestedIntNullableFilter.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : NestedDateTimeNullableFilter.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : NestedDateTimeNullableFilter.fromJson(
                  json['_max'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$NestedDateTimeNullableWithAggregatesFilterToJson(
    NestedDateTimeNullableWithAggregatesFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull(
      'equals',
      _$JsonConverterToJson<String, DateTime>(
          instance.equals, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'in', instance.$in?.map(const DateTimeJsonConverter().toJson).toList());
  writeNotNull('notIn',
      instance.notIn?.map(const DateTimeJsonConverter().toJson).toList());
  writeNotNull(
      'lt',
      _$JsonConverterToJson<String, DateTime>(
          instance.lt, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'lte',
      _$JsonConverterToJson<String, DateTime>(
          instance.lte, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'gt',
      _$JsonConverterToJson<String, DateTime>(
          instance.gt, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'gte',
      _$JsonConverterToJson<String, DateTime>(
          instance.gte, const DateTimeJsonConverter().toJson));
  writeNotNull('not', instance.not?.toJson());
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  return val;
}

NestedIntWithAggregatesFilter _$NestedIntWithAggregatesFilterFromJson(
        Map<String, dynamic> json) =>
    NestedIntWithAggregatesFilter(
      equals: json['equals'] as int?,
      $in: (json['in'] as List<dynamic>?)?.map((e) => e as int),
      notIn: (json['notIn'] as List<dynamic>?)?.map((e) => e as int),
      lt: json['lt'] as int?,
      lte: json['lte'] as int?,
      gt: json['gt'] as int?,
      gte: json['gte'] as int?,
      not: json['not'] == null
          ? null
          : NestedIntWithAggregatesFilter.fromJson(
              json['not'] as Map<String, dynamic>),
      $count: json['_count'] == null
          ? null
          : NestedIntFilter.fromJson(json['_count'] as Map<String, dynamic>),
      $avg: json['_avg'] == null
          ? null
          : NestedFloatFilter.fromJson(json['_avg'] as Map<String, dynamic>),
      $sum: json['_sum'] == null
          ? null
          : NestedIntFilter.fromJson(json['_sum'] as Map<String, dynamic>),
      $min: json['_min'] == null
          ? null
          : NestedIntFilter.fromJson(json['_min'] as Map<String, dynamic>),
      $max: json['_max'] == null
          ? null
          : NestedIntFilter.fromJson(json['_max'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$NestedIntWithAggregatesFilterToJson(
    NestedIntWithAggregatesFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals);
  writeNotNull('in', instance.$in?.toList());
  writeNotNull('notIn', instance.notIn?.toList());
  writeNotNull('lt', instance.lt);
  writeNotNull('lte', instance.lte);
  writeNotNull('gt', instance.gt);
  writeNotNull('gte', instance.gte);
  writeNotNull('not', instance.not?.toJson());
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  return val;
}

NestedDecimalNullableFilter _$NestedDecimalNullableFilterFromJson(
        Map<String, dynamic> json) =>
    NestedDecimalNullableFilter(
      equals: (json['equals'] as num?)?.toDouble(),
      $in: (json['in'] as List<dynamic>?)?.map((e) => (e as num).toDouble()),
      notIn:
          (json['notIn'] as List<dynamic>?)?.map((e) => (e as num).toDouble()),
      lt: (json['lt'] as num?)?.toDouble(),
      lte: (json['lte'] as num?)?.toDouble(),
      gt: (json['gt'] as num?)?.toDouble(),
      gte: (json['gte'] as num?)?.toDouble(),
      not: json['not'] == null
          ? null
          : NestedDecimalNullableFilter.fromJson(
              json['not'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$NestedDecimalNullableFilterToJson(
    NestedDecimalNullableFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals);
  writeNotNull('in', instance.$in?.toList());
  writeNotNull('notIn', instance.notIn?.toList());
  writeNotNull('lt', instance.lt);
  writeNotNull('lte', instance.lte);
  writeNotNull('gt', instance.gt);
  writeNotNull('gte', instance.gte);
  writeNotNull('not', instance.not?.toJson());
  return val;
}

NestedDecimalNullableWithAggregatesFilter
    _$NestedDecimalNullableWithAggregatesFilterFromJson(
            Map<String, dynamic> json) =>
        NestedDecimalNullableWithAggregatesFilter(
          equals: (json['equals'] as num?)?.toDouble(),
          $in:
              (json['in'] as List<dynamic>?)?.map((e) => (e as num).toDouble()),
          notIn: (json['notIn'] as List<dynamic>?)
              ?.map((e) => (e as num).toDouble()),
          lt: (json['lt'] as num?)?.toDouble(),
          lte: (json['lte'] as num?)?.toDouble(),
          gt: (json['gt'] as num?)?.toDouble(),
          gte: (json['gte'] as num?)?.toDouble(),
          not: json['not'] == null
              ? null
              : NestedDecimalNullableWithAggregatesFilter.fromJson(
                  json['not'] as Map<String, dynamic>),
          $count: json['_count'] == null
              ? null
              : NestedIntNullableFilter.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : NestedDecimalNullableFilter.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : NestedDecimalNullableFilter.fromJson(
                  json['_sum'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : NestedDecimalNullableFilter.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : NestedDecimalNullableFilter.fromJson(
                  json['_max'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$NestedDecimalNullableWithAggregatesFilterToJson(
    NestedDecimalNullableWithAggregatesFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals);
  writeNotNull('in', instance.$in?.toList());
  writeNotNull('notIn', instance.notIn?.toList());
  writeNotNull('lt', instance.lt);
  writeNotNull('lte', instance.lte);
  writeNotNull('gt', instance.gt);
  writeNotNull('gte', instance.gte);
  writeNotNull('not', instance.not?.toJson());
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  return val;
}

NestedBigIntNullableFilter _$NestedBigIntNullableFilterFromJson(
        Map<String, dynamic> json) =>
    NestedBigIntNullableFilter(
      equals: json['equals'] == null
          ? null
          : BigInt.parse(json['equals'] as String),
      $in:
          (json['in'] as List<dynamic>?)?.map((e) => BigInt.parse(e as String)),
      notIn: (json['notIn'] as List<dynamic>?)
          ?.map((e) => BigInt.parse(e as String)),
      lt: json['lt'] == null ? null : BigInt.parse(json['lt'] as String),
      lte: json['lte'] == null ? null : BigInt.parse(json['lte'] as String),
      gt: json['gt'] == null ? null : BigInt.parse(json['gt'] as String),
      gte: json['gte'] == null ? null : BigInt.parse(json['gte'] as String),
      not: json['not'] == null
          ? null
          : NestedBigIntNullableFilter.fromJson(
              json['not'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$NestedBigIntNullableFilterToJson(
    NestedBigIntNullableFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals?.toString());
  writeNotNull('in', instance.$in?.map((e) => e.toString()).toList());
  writeNotNull('notIn', instance.notIn?.map((e) => e.toString()).toList());
  writeNotNull('lt', instance.lt?.toString());
  writeNotNull('lte', instance.lte?.toString());
  writeNotNull('gt', instance.gt?.toString());
  writeNotNull('gte', instance.gte?.toString());
  writeNotNull('not', instance.not?.toJson());
  return val;
}

NestedBigIntNullableWithAggregatesFilter
    _$NestedBigIntNullableWithAggregatesFilterFromJson(
            Map<String, dynamic> json) =>
        NestedBigIntNullableWithAggregatesFilter(
          equals: json['equals'] == null
              ? null
              : BigInt.parse(json['equals'] as String),
          $in: (json['in'] as List<dynamic>?)
              ?.map((e) => BigInt.parse(e as String)),
          notIn: (json['notIn'] as List<dynamic>?)
              ?.map((e) => BigInt.parse(e as String)),
          lt: json['lt'] == null ? null : BigInt.parse(json['lt'] as String),
          lte: json['lte'] == null ? null : BigInt.parse(json['lte'] as String),
          gt: json['gt'] == null ? null : BigInt.parse(json['gt'] as String),
          gte: json['gte'] == null ? null : BigInt.parse(json['gte'] as String),
          not: json['not'] == null
              ? null
              : NestedBigIntNullableWithAggregatesFilter.fromJson(
                  json['not'] as Map<String, dynamic>),
          $count: json['_count'] == null
              ? null
              : NestedIntNullableFilter.fromJson(
                  json['_count'] as Map<String, dynamic>),
          $avg: json['_avg'] == null
              ? null
              : NestedFloatNullableFilter.fromJson(
                  json['_avg'] as Map<String, dynamic>),
          $sum: json['_sum'] == null
              ? null
              : NestedBigIntNullableFilter.fromJson(
                  json['_sum'] as Map<String, dynamic>),
          $min: json['_min'] == null
              ? null
              : NestedBigIntNullableFilter.fromJson(
                  json['_min'] as Map<String, dynamic>),
          $max: json['_max'] == null
              ? null
              : NestedBigIntNullableFilter.fromJson(
                  json['_max'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$NestedBigIntNullableWithAggregatesFilterToJson(
    NestedBigIntNullableWithAggregatesFilter instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('equals', instance.equals?.toString());
  writeNotNull('in', instance.$in?.map((e) => e.toString()).toList());
  writeNotNull('notIn', instance.notIn?.map((e) => e.toString()).toList());
  writeNotNull('lt', instance.lt?.toString());
  writeNotNull('lte', instance.lte?.toString());
  writeNotNull('gt', instance.gt?.toString());
  writeNotNull('gte', instance.gte?.toString());
  writeNotNull('not', instance.not?.toJson());
  writeNotNull('_count', instance.$count?.toJson());
  writeNotNull('_avg', instance.$avg?.toJson());
  writeNotNull('_sum', instance.$sum?.toJson());
  writeNotNull('_min', instance.$min?.toJson());
  writeNotNull('_max', instance.$max?.toJson());
  return val;
}

MENUTBLCreateWithoutMEMBERTBLInput _$MENUTBLCreateWithoutMEMBERTBLInputFromJson(
        Map<String, dynamic> json) =>
    MENUTBLCreateWithoutMEMBERTBLInput(
      menuId: json['MENU_ID'] as String,
      menuNm: json['MENU_NM'] as String,
      depth: json['DEPTH'] as int,
      sort: json['SORT'] as int,
      ownerId: json['OWNER_ID'] as String?,
      url: json['URL'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      dispYn: json['DISP_YN'] as String?,
      menuIcon: json['MENU_ICON'] as String?,
    );

Map<String, dynamic> _$MENUTBLCreateWithoutMEMBERTBLInputToJson(
    MENUTBLCreateWithoutMEMBERTBLInput instance) {
  final val = <String, dynamic>{
    'MENU_ID': instance.menuId,
    'MENU_NM': instance.menuNm,
    'DEPTH': instance.depth,
    'SORT': instance.sort,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('OWNER_ID', instance.ownerId);
  writeNotNull('URL', instance.url);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull('DISP_YN', instance.dispYn);
  writeNotNull('MENU_ICON', instance.menuIcon);
  return val;
}

MENUTBLUncheckedCreateWithoutMEMBERTBLInput
    _$MENUTBLUncheckedCreateWithoutMEMBERTBLInputFromJson(
            Map<String, dynamic> json) =>
        MENUTBLUncheckedCreateWithoutMEMBERTBLInput(
          menuId: json['MENU_ID'] as String,
          menuNm: json['MENU_NM'] as String,
          depth: json['DEPTH'] as int,
          sort: json['SORT'] as int,
          ownerId: json['OWNER_ID'] as String?,
          url: json['URL'] as String?,
          regDate: _$JsonConverterFromJson<String, DateTime>(
              json['REG_DATE'], const DateTimeJsonConverter().fromJson),
          updDate: _$JsonConverterFromJson<String, DateTime>(
              json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
          useYn: json['USE_YN'] as String?,
          delYn: json['DEL_YN'] as String?,
          dispYn: json['DISP_YN'] as String?,
          menuIcon: json['MENU_ICON'] as String?,
        );

Map<String, dynamic> _$MENUTBLUncheckedCreateWithoutMEMBERTBLInputToJson(
    MENUTBLUncheckedCreateWithoutMEMBERTBLInput instance) {
  final val = <String, dynamic>{
    'MENU_ID': instance.menuId,
    'MENU_NM': instance.menuNm,
    'DEPTH': instance.depth,
    'SORT': instance.sort,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('OWNER_ID', instance.ownerId);
  writeNotNull('URL', instance.url);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull('DISP_YN', instance.dispYn);
  writeNotNull('MENU_ICON', instance.menuIcon);
  return val;
}

MENUTBLCreateOrConnectWithoutMEMBERTBLInput
    _$MENUTBLCreateOrConnectWithoutMEMBERTBLInputFromJson(
            Map<String, dynamic> json) =>
        MENUTBLCreateOrConnectWithoutMEMBERTBLInput(
          where: MENUTBLWhereUniqueInput.fromJson(
              json['where'] as Map<String, dynamic>),
          create: MENUTBLCreateWithoutMEMBERTBLInput.fromJson(
              json['create'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$MENUTBLCreateOrConnectWithoutMEMBERTBLInputToJson(
        MENUTBLCreateOrConnectWithoutMEMBERTBLInput instance) =>
    <String, dynamic>{
      'where': instance.where.toJson(),
      'create': instance.create.toJson(),
    };

MENUTBLCreateManyMEMBERTBLInputEnvelope
    _$MENUTBLCreateManyMEMBERTBLInputEnvelopeFromJson(
            Map<String, dynamic> json) =>
        MENUTBLCreateManyMEMBERTBLInputEnvelope(
          data: (json['data'] as List<dynamic>).map((e) =>
              MENUTBLCreateManyMEMBERTBLInput.fromJson(
                  e as Map<String, dynamic>)),
          skipDuplicates: json['skipDuplicates'] as bool?,
        );

Map<String, dynamic> _$MENUTBLCreateManyMEMBERTBLInputEnvelopeToJson(
    MENUTBLCreateManyMEMBERTBLInputEnvelope instance) {
  final val = <String, dynamic>{
    'data': instance.data.map((e) => e.toJson()).toList(),
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('skipDuplicates', instance.skipDuplicates);
  return val;
}

MENUTBLUpsertWithWhereUniqueWithoutMEMBERTBLInput
    _$MENUTBLUpsertWithWhereUniqueWithoutMEMBERTBLInputFromJson(
            Map<String, dynamic> json) =>
        MENUTBLUpsertWithWhereUniqueWithoutMEMBERTBLInput(
          where: MENUTBLWhereUniqueInput.fromJson(
              json['where'] as Map<String, dynamic>),
          update: MENUTBLUpdateWithoutMEMBERTBLInput.fromJson(
              json['update'] as Map<String, dynamic>),
          create: MENUTBLCreateWithoutMEMBERTBLInput.fromJson(
              json['create'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$MENUTBLUpsertWithWhereUniqueWithoutMEMBERTBLInputToJson(
        MENUTBLUpsertWithWhereUniqueWithoutMEMBERTBLInput instance) =>
    <String, dynamic>{
      'where': instance.where.toJson(),
      'update': instance.update.toJson(),
      'create': instance.create.toJson(),
    };

MENUTBLUpdateWithWhereUniqueWithoutMEMBERTBLInput
    _$MENUTBLUpdateWithWhereUniqueWithoutMEMBERTBLInputFromJson(
            Map<String, dynamic> json) =>
        MENUTBLUpdateWithWhereUniqueWithoutMEMBERTBLInput(
          where: MENUTBLWhereUniqueInput.fromJson(
              json['where'] as Map<String, dynamic>),
          data: MENUTBLUpdateWithoutMEMBERTBLInput.fromJson(
              json['data'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$MENUTBLUpdateWithWhereUniqueWithoutMEMBERTBLInputToJson(
        MENUTBLUpdateWithWhereUniqueWithoutMEMBERTBLInput instance) =>
    <String, dynamic>{
      'where': instance.where.toJson(),
      'data': instance.data.toJson(),
    };

MENUTBLUpdateManyWithWhereWithoutMEMBERTBLInput
    _$MENUTBLUpdateManyWithWhereWithoutMEMBERTBLInputFromJson(
            Map<String, dynamic> json) =>
        MENUTBLUpdateManyWithWhereWithoutMEMBERTBLInput(
          where: MENUTBLScalarWhereInput.fromJson(
              json['where'] as Map<String, dynamic>),
          data: MENUTBLUpdateManyMutationInput.fromJson(
              json['data'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$MENUTBLUpdateManyWithWhereWithoutMEMBERTBLInputToJson(
        MENUTBLUpdateManyWithWhereWithoutMEMBERTBLInput instance) =>
    <String, dynamic>{
      'where': instance.where.toJson(),
      'data': instance.data.toJson(),
    };

MENUTBLScalarWhereInput _$MENUTBLScalarWhereInputFromJson(
        Map<String, dynamic> json) =>
    MENUTBLScalarWhereInput(
      AND: (json['AND'] as List<dynamic>?)?.map(
          (e) => MENUTBLScalarWhereInput.fromJson(e as Map<String, dynamic>)),
      OR: (json['OR'] as List<dynamic>?)?.map(
          (e) => MENUTBLScalarWhereInput.fromJson(e as Map<String, dynamic>)),
      NOT: (json['NOT'] as List<dynamic>?)?.map(
          (e) => MENUTBLScalarWhereInput.fromJson(e as Map<String, dynamic>)),
      menuId: json['MENU_ID'] == null
          ? null
          : StringFilter.fromJson(json['MENU_ID'] as Map<String, dynamic>),
      menuNm: json['MENU_NM'] == null
          ? null
          : StringFilter.fromJson(json['MENU_NM'] as Map<String, dynamic>),
      depth: json['DEPTH'] == null
          ? null
          : IntFilter.fromJson(json['DEPTH'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : IntFilter.fromJson(json['SORT'] as Map<String, dynamic>),
      ownerId: json['OWNER_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['OWNER_ID'] as Map<String, dynamic>),
      url: json['URL'] == null
          ? null
          : StringNullableFilter.fromJson(json['URL'] as Map<String, dynamic>),
      writerId: json['WRITER_ID'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['WRITER_ID'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFilter.fromJson(json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : DateTimeNullableFilter.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      dispYn: json['DISP_YN'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['DISP_YN'] as Map<String, dynamic>),
      menuIcon: json['MENU_ICON'] == null
          ? null
          : StringNullableFilter.fromJson(
              json['MENU_ICON'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$MENUTBLScalarWhereInputToJson(
    MENUTBLScalarWhereInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('AND', instance.AND?.map((e) => e.toJson()).toList());
  writeNotNull('OR', instance.OR?.map((e) => e.toJson()).toList());
  writeNotNull('NOT', instance.NOT?.map((e) => e.toJson()).toList());
  writeNotNull('MENU_ID', instance.menuId?.toJson());
  writeNotNull('MENU_NM', instance.menuNm?.toJson());
  writeNotNull('DEPTH', instance.depth?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('OWNER_ID', instance.ownerId?.toJson());
  writeNotNull('URL', instance.url?.toJson());
  writeNotNull('WRITER_ID', instance.writerId?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('DISP_YN', instance.dispYn?.toJson());
  writeNotNull('MENU_ICON', instance.menuIcon?.toJson());
  return val;
}

MEMBERTBLCreateWithoutMENUTBLInput _$MEMBERTBLCreateWithoutMENUTBLInputFromJson(
        Map<String, dynamic> json) =>
    MEMBERTBLCreateWithoutMENUTBLInput(
      userId: json['USER_ID'] as String,
      passwd: json['PASSWD'] as String,
      userNm: json['USER_NM'] as String,
      dept: json['DEPT'] as String?,
      grade: json['GRADE'] as String?,
      joinDate: _$JsonConverterFromJson<String, DateTime>(
          json['JOIN_DATE'], const DateTimeJsonConverter().fromJson),
      retireDate: _$JsonConverterFromJson<String, DateTime>(
          json['RETIRE_DATE'], const DateTimeJsonConverter().fromJson),
      pwdChgDate: _$JsonConverterFromJson<String, DateTime>(
          json['PWD_CHG_DATE'], const DateTimeJsonConverter().fromJson),
      pwdWrongCnt: json['PWD_WRONG_CNT'] as int?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      lastLoginDate: _$JsonConverterFromJson<String, DateTime>(
          json['LAST_LOGIN_DATE'], const DateTimeJsonConverter().fromJson),
      memo: json['MEMO'] as String?,
    );

Map<String, dynamic> _$MEMBERTBLCreateWithoutMENUTBLInputToJson(
    MEMBERTBLCreateWithoutMENUTBLInput instance) {
  final val = <String, dynamic>{
    'USER_ID': instance.userId,
    'PASSWD': instance.passwd,
    'USER_NM': instance.userNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('DEPT', instance.dept);
  writeNotNull('GRADE', instance.grade);
  writeNotNull(
      'JOIN_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.joinDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'RETIRE_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.retireDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'PWD_CHG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.pwdChgDate, const DateTimeJsonConverter().toJson));
  writeNotNull('PWD_WRONG_CNT', instance.pwdWrongCnt);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'LAST_LOGIN_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.lastLoginDate, const DateTimeJsonConverter().toJson));
  writeNotNull('MEMO', instance.memo);
  return val;
}

MEMBERTBLUncheckedCreateWithoutMENUTBLInput
    _$MEMBERTBLUncheckedCreateWithoutMENUTBLInputFromJson(
            Map<String, dynamic> json) =>
        MEMBERTBLUncheckedCreateWithoutMENUTBLInput(
          userId: json['USER_ID'] as String,
          passwd: json['PASSWD'] as String,
          userNm: json['USER_NM'] as String,
          dept: json['DEPT'] as String?,
          grade: json['GRADE'] as String?,
          joinDate: _$JsonConverterFromJson<String, DateTime>(
              json['JOIN_DATE'], const DateTimeJsonConverter().fromJson),
          retireDate: _$JsonConverterFromJson<String, DateTime>(
              json['RETIRE_DATE'], const DateTimeJsonConverter().fromJson),
          pwdChgDate: _$JsonConverterFromJson<String, DateTime>(
              json['PWD_CHG_DATE'], const DateTimeJsonConverter().fromJson),
          pwdWrongCnt: json['PWD_WRONG_CNT'] as int?,
          useYn: json['USE_YN'] as String?,
          delYn: json['DEL_YN'] as String?,
          regDate: _$JsonConverterFromJson<String, DateTime>(
              json['REG_DATE'], const DateTimeJsonConverter().fromJson),
          updDate: _$JsonConverterFromJson<String, DateTime>(
              json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
          lastLoginDate: _$JsonConverterFromJson<String, DateTime>(
              json['LAST_LOGIN_DATE'], const DateTimeJsonConverter().fromJson),
          memo: json['MEMO'] as String?,
        );

Map<String, dynamic> _$MEMBERTBLUncheckedCreateWithoutMENUTBLInputToJson(
    MEMBERTBLUncheckedCreateWithoutMENUTBLInput instance) {
  final val = <String, dynamic>{
    'USER_ID': instance.userId,
    'PASSWD': instance.passwd,
    'USER_NM': instance.userNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('DEPT', instance.dept);
  writeNotNull('GRADE', instance.grade);
  writeNotNull(
      'JOIN_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.joinDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'RETIRE_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.retireDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'PWD_CHG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.pwdChgDate, const DateTimeJsonConverter().toJson));
  writeNotNull('PWD_WRONG_CNT', instance.pwdWrongCnt);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'LAST_LOGIN_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.lastLoginDate, const DateTimeJsonConverter().toJson));
  writeNotNull('MEMO', instance.memo);
  return val;
}

MEMBERTBLCreateOrConnectWithoutMENUTBLInput
    _$MEMBERTBLCreateOrConnectWithoutMENUTBLInputFromJson(
            Map<String, dynamic> json) =>
        MEMBERTBLCreateOrConnectWithoutMENUTBLInput(
          where: MEMBERTBLWhereUniqueInput.fromJson(
              json['where'] as Map<String, dynamic>),
          create: MEMBERTBLCreateWithoutMENUTBLInput.fromJson(
              json['create'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$MEMBERTBLCreateOrConnectWithoutMENUTBLInputToJson(
        MEMBERTBLCreateOrConnectWithoutMENUTBLInput instance) =>
    <String, dynamic>{
      'where': instance.where.toJson(),
      'create': instance.create.toJson(),
    };

MEMBERTBLUpsertWithoutMENUTBLInput _$MEMBERTBLUpsertWithoutMENUTBLInputFromJson(
        Map<String, dynamic> json) =>
    MEMBERTBLUpsertWithoutMENUTBLInput(
      update: MEMBERTBLUpdateWithoutMENUTBLInput.fromJson(
          json['update'] as Map<String, dynamic>),
      create: MEMBERTBLCreateWithoutMENUTBLInput.fromJson(
          json['create'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$MEMBERTBLUpsertWithoutMENUTBLInputToJson(
        MEMBERTBLUpsertWithoutMENUTBLInput instance) =>
    <String, dynamic>{
      'update': instance.update.toJson(),
      'create': instance.create.toJson(),
    };

MEMBERTBLUpdateWithoutMENUTBLInput _$MEMBERTBLUpdateWithoutMENUTBLInputFromJson(
        Map<String, dynamic> json) =>
    MEMBERTBLUpdateWithoutMENUTBLInput(
      userId: json['USER_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_ID'] as Map<String, dynamic>),
      passwd: json['PASSWD'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['PASSWD'] as Map<String, dynamic>),
      userNm: json['USER_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['USER_NM'] as Map<String, dynamic>),
      dept: json['DEPT'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEPT'] as Map<String, dynamic>),
      grade: json['GRADE'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['GRADE'] as Map<String, dynamic>),
      joinDate: json['JOIN_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['JOIN_DATE'] as Map<String, dynamic>),
      retireDate: json['RETIRE_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['RETIRE_DATE'] as Map<String, dynamic>),
      pwdChgDate: json['PWD_CHG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['PWD_CHG_DATE'] as Map<String, dynamic>),
      pwdWrongCnt: json['PWD_WRONG_CNT'] == null
          ? null
          : NullableIntFieldUpdateOperationsInput.fromJson(
              json['PWD_WRONG_CNT'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : NullableDateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
      lastLoginDate: json['LAST_LOGIN_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['LAST_LOGIN_DATE'] as Map<String, dynamic>),
      memo: json['MEMO'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MEMO'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$MEMBERTBLUpdateWithoutMENUTBLInputToJson(
    MEMBERTBLUpdateWithoutMENUTBLInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('PASSWD', instance.passwd?.toJson());
  writeNotNull('USER_NM', instance.userNm?.toJson());
  writeNotNull('DEPT', instance.dept?.toJson());
  writeNotNull('GRADE', instance.grade?.toJson());
  writeNotNull('JOIN_DATE', instance.joinDate?.toJson());
  writeNotNull('RETIRE_DATE', instance.retireDate?.toJson());
  writeNotNull('PWD_CHG_DATE', instance.pwdChgDate?.toJson());
  writeNotNull('PWD_WRONG_CNT', instance.pwdWrongCnt?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('LAST_LOGIN_DATE', instance.lastLoginDate?.toJson());
  writeNotNull('MEMO', instance.memo?.toJson());
  return val;
}

MEMBERTBLUncheckedUpdateWithoutMENUTBLInput
    _$MEMBERTBLUncheckedUpdateWithoutMENUTBLInputFromJson(
            Map<String, dynamic> json) =>
        MEMBERTBLUncheckedUpdateWithoutMENUTBLInput(
          userId: json['USER_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['USER_ID'] as Map<String, dynamic>),
          passwd: json['PASSWD'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['PASSWD'] as Map<String, dynamic>),
          userNm: json['USER_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['USER_NM'] as Map<String, dynamic>),
          dept: json['DEPT'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEPT'] as Map<String, dynamic>),
          grade: json['GRADE'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['GRADE'] as Map<String, dynamic>),
          joinDate: json['JOIN_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['JOIN_DATE'] as Map<String, dynamic>),
          retireDate: json['RETIRE_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['RETIRE_DATE'] as Map<String, dynamic>),
          pwdChgDate: json['PWD_CHG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['PWD_CHG_DATE'] as Map<String, dynamic>),
          pwdWrongCnt: json['PWD_WRONG_CNT'] == null
              ? null
              : NullableIntFieldUpdateOperationsInput.fromJson(
                  json['PWD_WRONG_CNT'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : NullableDateTimeFieldUpdateOperationsInput.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
          lastLoginDate: json['LAST_LOGIN_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['LAST_LOGIN_DATE'] as Map<String, dynamic>),
          memo: json['MEMO'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['MEMO'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$MEMBERTBLUncheckedUpdateWithoutMENUTBLInputToJson(
    MEMBERTBLUncheckedUpdateWithoutMENUTBLInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', instance.userId?.toJson());
  writeNotNull('PASSWD', instance.passwd?.toJson());
  writeNotNull('USER_NM', instance.userNm?.toJson());
  writeNotNull('DEPT', instance.dept?.toJson());
  writeNotNull('GRADE', instance.grade?.toJson());
  writeNotNull('JOIN_DATE', instance.joinDate?.toJson());
  writeNotNull('RETIRE_DATE', instance.retireDate?.toJson());
  writeNotNull('PWD_CHG_DATE', instance.pwdChgDate?.toJson());
  writeNotNull('PWD_WRONG_CNT', instance.pwdWrongCnt?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('LAST_LOGIN_DATE', instance.lastLoginDate?.toJson());
  writeNotNull('MEMO', instance.memo?.toJson());
  return val;
}

MENUTBLCreateManyMEMBERTBLInput _$MENUTBLCreateManyMEMBERTBLInputFromJson(
        Map<String, dynamic> json) =>
    MENUTBLCreateManyMEMBERTBLInput(
      menuId: json['MENU_ID'] as String,
      menuNm: json['MENU_NM'] as String,
      depth: json['DEPTH'] as int,
      sort: json['SORT'] as int,
      ownerId: json['OWNER_ID'] as String?,
      url: json['URL'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      dispYn: json['DISP_YN'] as String?,
      menuIcon: json['MENU_ICON'] as String?,
    );

Map<String, dynamic> _$MENUTBLCreateManyMEMBERTBLInputToJson(
    MENUTBLCreateManyMEMBERTBLInput instance) {
  final val = <String, dynamic>{
    'MENU_ID': instance.menuId,
    'MENU_NM': instance.menuNm,
    'DEPTH': instance.depth,
    'SORT': instance.sort,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('OWNER_ID', instance.ownerId);
  writeNotNull('URL', instance.url);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull('DISP_YN', instance.dispYn);
  writeNotNull('MENU_ICON', instance.menuIcon);
  return val;
}

MENUTBLUpdateWithoutMEMBERTBLInput _$MENUTBLUpdateWithoutMEMBERTBLInputFromJson(
        Map<String, dynamic> json) =>
    MENUTBLUpdateWithoutMEMBERTBLInput(
      menuId: json['MENU_ID'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_ID'] as Map<String, dynamic>),
      menuNm: json['MENU_NM'] == null
          ? null
          : StringFieldUpdateOperationsInput.fromJson(
              json['MENU_NM'] as Map<String, dynamic>),
      depth: json['DEPTH'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['DEPTH'] as Map<String, dynamic>),
      sort: json['SORT'] == null
          ? null
          : IntFieldUpdateOperationsInput.fromJson(
              json['SORT'] as Map<String, dynamic>),
      ownerId: json['OWNER_ID'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['OWNER_ID'] as Map<String, dynamic>),
      url: json['URL'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['URL'] as Map<String, dynamic>),
      regDate: json['REG_DATE'] == null
          ? null
          : DateTimeFieldUpdateOperationsInput.fromJson(
              json['REG_DATE'] as Map<String, dynamic>),
      updDate: json['UPD_DATE'] == null
          ? null
          : NullableDateTimeFieldUpdateOperationsInput.fromJson(
              json['UPD_DATE'] as Map<String, dynamic>),
      useYn: json['USE_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['USE_YN'] as Map<String, dynamic>),
      delYn: json['DEL_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DEL_YN'] as Map<String, dynamic>),
      dispYn: json['DISP_YN'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['DISP_YN'] as Map<String, dynamic>),
      menuIcon: json['MENU_ICON'] == null
          ? null
          : NullableStringFieldUpdateOperationsInput.fromJson(
              json['MENU_ICON'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$MENUTBLUpdateWithoutMEMBERTBLInputToJson(
    MENUTBLUpdateWithoutMEMBERTBLInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_ID', instance.menuId?.toJson());
  writeNotNull('MENU_NM', instance.menuNm?.toJson());
  writeNotNull('DEPTH', instance.depth?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('OWNER_ID', instance.ownerId?.toJson());
  writeNotNull('URL', instance.url?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('DISP_YN', instance.dispYn?.toJson());
  writeNotNull('MENU_ICON', instance.menuIcon?.toJson());
  return val;
}

MENUTBLUncheckedUpdateWithoutMEMBERTBLInput
    _$MENUTBLUncheckedUpdateWithoutMEMBERTBLInputFromJson(
            Map<String, dynamic> json) =>
        MENUTBLUncheckedUpdateWithoutMEMBERTBLInput(
          menuId: json['MENU_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['MENU_ID'] as Map<String, dynamic>),
          menuNm: json['MENU_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['MENU_NM'] as Map<String, dynamic>),
          depth: json['DEPTH'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['DEPTH'] as Map<String, dynamic>),
          sort: json['SORT'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['SORT'] as Map<String, dynamic>),
          ownerId: json['OWNER_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['OWNER_ID'] as Map<String, dynamic>),
          url: json['URL'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['URL'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : NullableDateTimeFieldUpdateOperationsInput.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
          dispYn: json['DISP_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DISP_YN'] as Map<String, dynamic>),
          menuIcon: json['MENU_ICON'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['MENU_ICON'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$MENUTBLUncheckedUpdateWithoutMEMBERTBLInputToJson(
    MENUTBLUncheckedUpdateWithoutMEMBERTBLInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_ID', instance.menuId?.toJson());
  writeNotNull('MENU_NM', instance.menuNm?.toJson());
  writeNotNull('DEPTH', instance.depth?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('OWNER_ID', instance.ownerId?.toJson());
  writeNotNull('URL', instance.url?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('DISP_YN', instance.dispYn?.toJson());
  writeNotNull('MENU_ICON', instance.menuIcon?.toJson());
  return val;
}

MENUTBLUncheckedUpdateManyWithoutMENUTBLInput
    _$MENUTBLUncheckedUpdateManyWithoutMENUTBLInputFromJson(
            Map<String, dynamic> json) =>
        MENUTBLUncheckedUpdateManyWithoutMENUTBLInput(
          menuId: json['MENU_ID'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['MENU_ID'] as Map<String, dynamic>),
          menuNm: json['MENU_NM'] == null
              ? null
              : StringFieldUpdateOperationsInput.fromJson(
                  json['MENU_NM'] as Map<String, dynamic>),
          depth: json['DEPTH'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['DEPTH'] as Map<String, dynamic>),
          sort: json['SORT'] == null
              ? null
              : IntFieldUpdateOperationsInput.fromJson(
                  json['SORT'] as Map<String, dynamic>),
          ownerId: json['OWNER_ID'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['OWNER_ID'] as Map<String, dynamic>),
          url: json['URL'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['URL'] as Map<String, dynamic>),
          regDate: json['REG_DATE'] == null
              ? null
              : DateTimeFieldUpdateOperationsInput.fromJson(
                  json['REG_DATE'] as Map<String, dynamic>),
          updDate: json['UPD_DATE'] == null
              ? null
              : NullableDateTimeFieldUpdateOperationsInput.fromJson(
                  json['UPD_DATE'] as Map<String, dynamic>),
          useYn: json['USE_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['USE_YN'] as Map<String, dynamic>),
          delYn: json['DEL_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DEL_YN'] as Map<String, dynamic>),
          dispYn: json['DISP_YN'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['DISP_YN'] as Map<String, dynamic>),
          menuIcon: json['MENU_ICON'] == null
              ? null
              : NullableStringFieldUpdateOperationsInput.fromJson(
                  json['MENU_ICON'] as Map<String, dynamic>),
        );

Map<String, dynamic> _$MENUTBLUncheckedUpdateManyWithoutMENUTBLInputToJson(
    MENUTBLUncheckedUpdateManyWithoutMENUTBLInput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_ID', instance.menuId?.toJson());
  writeNotNull('MENU_NM', instance.menuNm?.toJson());
  writeNotNull('DEPTH', instance.depth?.toJson());
  writeNotNull('SORT', instance.sort?.toJson());
  writeNotNull('OWNER_ID', instance.ownerId?.toJson());
  writeNotNull('URL', instance.url?.toJson());
  writeNotNull('REG_DATE', instance.regDate?.toJson());
  writeNotNull('UPD_DATE', instance.updDate?.toJson());
  writeNotNull('USE_YN', instance.useYn?.toJson());
  writeNotNull('DEL_YN', instance.delYn?.toJson());
  writeNotNull('DISP_YN', instance.dispYn?.toJson());
  writeNotNull('MENU_ICON', instance.menuIcon?.toJson());
  return val;
}

AllCodeTbl _$AllCodeTblFromJson(Map<String, dynamic> json) => AllCodeTbl(
      codeType: json['CODE_TYPE'] as String,
      codeName: json['CODE_NAME'] as String?,
      unitType: json['UNIT_TYPE'] as String,
      unitName: json['UNIT_NAME'] as String?,
      sort: json['SORT'] as int?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate:
          const DateTimeJsonConverter().fromJson(json['REG_DATE'] as String),
      updDate:
          const DateTimeJsonConverter().fromJson(json['UPD_DATE'] as String),
    );

Map<String, dynamic> _$AllCodeTblToJson(AllCodeTbl instance) {
  final val = <String, dynamic>{
    'CODE_TYPE': instance.codeType,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CODE_NAME', instance.codeName);
  val['UNIT_TYPE'] = instance.unitType;
  writeNotNull('UNIT_NAME', instance.unitName);
  writeNotNull('SORT', instance.sort);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  val['REG_DATE'] = const DateTimeJsonConverter().toJson(instance.regDate);
  val['UPD_DATE'] = const DateTimeJsonConverter().toJson(instance.updDate);
  return val;
}

ApprovalAttachfileTbl _$ApprovalAttachfileTblFromJson(
        Map<String, dynamic> json) =>
    ApprovalAttachfileTbl(
      approvalId: json['APPROVAL_ID'] as String,
      seq: (json['SEQ'] as num).toDouble(),
      oriFileNm: json['ORI_FILE_NM'] as String?,
      saveFileNm: json['SAVE_FILE_NM'] as String?,
      fileSize: json['FILE_SIZE'] as int?,
      regDate:
          const DateTimeJsonConverter().fromJson(json['REG_DATE'] as String),
    );

Map<String, dynamic> _$ApprovalAttachfileTblToJson(
    ApprovalAttachfileTbl instance) {
  final val = <String, dynamic>{
    'APPROVAL_ID': instance.approvalId,
    'SEQ': instance.seq,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('ORI_FILE_NM', instance.oriFileNm);
  writeNotNull('SAVE_FILE_NM', instance.saveFileNm);
  writeNotNull('FILE_SIZE', instance.fileSize);
  val['REG_DATE'] = const DateTimeJsonConverter().toJson(instance.regDate);
  return val;
}

ApprovalDocInfoTbl _$ApprovalDocInfoTblFromJson(Map<String, dynamic> json) =>
    ApprovalDocInfoTbl(
      seq: BigInt.parse(json['SEQ'] as String),
      docType: json['DOC_TYPE'] as String?,
      docNm: json['DOC_NM'] as String?,
      title: json['TITLE'] as String,
      approvalLineType: json['APPROVAL_LINE_TYPE'] as String?,
      approvalLineContent: json['APPROVAL_LINE_CONTENT'] as String?,
      approvalLineContentBak: json['APPROVAL_LINE_CONTENT_BAK'] as String?,
      content: json['CONTENT'] as String?,
      writerId: json['WRITER_ID'] as String?,
      userNm: json['USER_NM'] as String?,
      regDate:
          const DateTimeJsonConverter().fromJson(json['REG_DATE'] as String),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$ApprovalDocInfoTblToJson(ApprovalDocInfoTbl instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq.toString(),
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('DOC_TYPE', instance.docType);
  writeNotNull('DOC_NM', instance.docNm);
  val['TITLE'] = instance.title;
  writeNotNull('APPROVAL_LINE_TYPE', instance.approvalLineType);
  writeNotNull('APPROVAL_LINE_CONTENT', instance.approvalLineContent);
  writeNotNull('APPROVAL_LINE_CONTENT_BAK', instance.approvalLineContentBak);
  writeNotNull('CONTENT', instance.content);
  writeNotNull('WRITER_ID', instance.writerId);
  writeNotNull('USER_NM', instance.userNm);
  val['REG_DATE'] = const DateTimeJsonConverter().toJson(instance.regDate);
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

ApprovalHistoryTbl _$ApprovalHistoryTblFromJson(Map<String, dynamic> json) =>
    ApprovalHistoryTbl(
      seq: BigInt.parse(json['SEQ'] as String),
      approvalId: json['APPROVAL_ID'] as String,
      writerId: json['WRITER_ID'] as String,
      writerNm: json['WRITER_NM'] as String,
      docType: json['DOC_TYPE'] as String,
      keepPriod: json['KEEP_PRIOD'] as int,
      keepDate:
          const DateTimeJsonConverter().fromJson(json['KEEP_DATE'] as String),
      grade: json['GRADE'] as String,
      status: json['STATUS'] as String?,
      content: json['CONTENT'] as String?,
      regDate:
          const DateTimeJsonConverter().fromJson(json['REG_DATE'] as String),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$ApprovalHistoryTblToJson(ApprovalHistoryTbl instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq.toString(),
    'APPROVAL_ID': instance.approvalId,
    'WRITER_ID': instance.writerId,
    'WRITER_NM': instance.writerNm,
    'DOC_TYPE': instance.docType,
    'KEEP_PRIOD': instance.keepPriod,
    'KEEP_DATE': const DateTimeJsonConverter().toJson(instance.keepDate),
    'GRADE': instance.grade,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('STATUS', instance.status);
  writeNotNull('CONTENT', instance.content);
  val['REG_DATE'] = const DateTimeJsonConverter().toJson(instance.regDate);
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

ApprovalMasterTbl _$ApprovalMasterTblFromJson(Map<String, dynamic> json) =>
    ApprovalMasterTbl(
      approvalId: json['APPROVAL_ID'] as String,
      writerId: json['WRITER_ID'] as String,
      writerNm: json['WRITER_NM'] as String,
      docType: json['DOC_TYPE'] as String,
      keepPriod: json['KEEP_PRIOD'] as int,
      keepDate:
          const DateTimeJsonConverter().fromJson(json['KEEP_DATE'] as String),
      grade: json['GRADE'] as String,
      status: json['STATUS'] as String?,
      title: json['TITLE'] as String?,
      header: json['HEADER'] as String?,
      content: json['CONTENT'] as String?,
      m1: (json['M1'] as num?)?.toDouble(),
      m2: (json['M2'] as num?)?.toDouble(),
      m3: (json['M3'] as num?)?.toDouble(),
      m4: (json['M4'] as num?)?.toDouble(),
      m5: (json['M5'] as num?)?.toDouble(),
      m6: (json['M6'] as num?)?.toDouble(),
      m7: (json['M7'] as num?)?.toDouble(),
      m8: (json['M8'] as num?)?.toDouble(),
      m9: (json['M9'] as num?)?.toDouble(),
      m10: (json['M10'] as num?)?.toDouble(),
      m11: (json['M11'] as num?)?.toDouble(),
      m12: (json['M12'] as num?)?.toDouble(),
      regDate:
          const DateTimeJsonConverter().fromJson(json['REG_DATE'] as String),
      completeDate: const DateTimeJsonConverter()
          .fromJson(json['COMPLETE_DATE'] as String),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$ApprovalMasterTblToJson(ApprovalMasterTbl instance) {
  final val = <String, dynamic>{
    'APPROVAL_ID': instance.approvalId,
    'WRITER_ID': instance.writerId,
    'WRITER_NM': instance.writerNm,
    'DOC_TYPE': instance.docType,
    'KEEP_PRIOD': instance.keepPriod,
    'KEEP_DATE': const DateTimeJsonConverter().toJson(instance.keepDate),
    'GRADE': instance.grade,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('STATUS', instance.status);
  writeNotNull('TITLE', instance.title);
  writeNotNull('HEADER', instance.header);
  writeNotNull('CONTENT', instance.content);
  writeNotNull('M1', instance.m1);
  writeNotNull('M2', instance.m2);
  writeNotNull('M3', instance.m3);
  writeNotNull('M4', instance.m4);
  writeNotNull('M5', instance.m5);
  writeNotNull('M6', instance.m6);
  writeNotNull('M7', instance.m7);
  writeNotNull('M8', instance.m8);
  writeNotNull('M9', instance.m9);
  writeNotNull('M10', instance.m10);
  writeNotNull('M11', instance.m11);
  writeNotNull('M12', instance.m12);
  val['REG_DATE'] = const DateTimeJsonConverter().toJson(instance.regDate);
  val['COMPLETE_DATE'] =
      const DateTimeJsonConverter().toJson(instance.completeDate);
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

ApprovalMemoTbl _$ApprovalMemoTblFromJson(Map<String, dynamic> json) =>
    ApprovalMemoTbl(
      seq: BigInt.parse(json['SEQ'] as String),
      approvalId: json['APPROVAL_ID'] as String,
      writerId: json['WRITER_ID'] as String,
      writerNm: json['WRITER_NM'] as String,
      content: json['CONTENT'] as String?,
      regDate:
          const DateTimeJsonConverter().fromJson(json['REG_DATE'] as String),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$ApprovalMemoTblToJson(ApprovalMemoTbl instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq.toString(),
    'APPROVAL_ID': instance.approvalId,
    'WRITER_ID': instance.writerId,
    'WRITER_NM': instance.writerNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CONTENT', instance.content);
  val['REG_DATE'] = const DateTimeJsonConverter().toJson(instance.regDate);
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

ApprovalTypeTbl _$ApprovalTypeTblFromJson(Map<String, dynamic> json) =>
    ApprovalTypeTbl(
      type: json['TYPE'] as String,
      content: json['CONTENT'] as String?,
      contentBak: json['CONTENT_BAK'] as String?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$ApprovalTypeTblToJson(ApprovalTypeTbl instance) {
  final val = <String, dynamic>{
    'TYPE': instance.type,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CONTENT', instance.content);
  writeNotNull('CONTENT_BAK', instance.contentBak);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

ApprovalUserTbl _$ApprovalUserTblFromJson(Map<String, dynamic> json) =>
    ApprovalUserTbl(
      approvalId: json['APPROVAL_ID'] as String,
      approvalUsrId: json['APPROVAL_USR_ID'] as String,
      approvalUsrGradeCd: json['APPROVAL_USR_GRADE_CD'] as String?,
      approvalUsrType: json['APPROVAL_USR_TYPE'] as String,
      approvalUsrSort: json['APPROVAL_USR_SORT'] as int,
      approvalProcUserYn: json['APPROVAL_PROC_USER_YN'] as String?,
      approvalProcYn: json['APPROVAL_PROC_YN'] as String,
      approvalProcDate: const DateTimeJsonConverter()
          .fromJson(json['APPROVAL_PROC_DATE'] as String),
      regDate:
          const DateTimeJsonConverter().fromJson(json['REG_DATE'] as String),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$ApprovalUserTblToJson(ApprovalUserTbl instance) {
  final val = <String, dynamic>{
    'APPROVAL_ID': instance.approvalId,
    'APPROVAL_USR_ID': instance.approvalUsrId,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_USR_GRADE_CD', instance.approvalUsrGradeCd);
  val['APPROVAL_USR_TYPE'] = instance.approvalUsrType;
  val['APPROVAL_USR_SORT'] = instance.approvalUsrSort;
  writeNotNull('APPROVAL_PROC_USER_YN', instance.approvalProcUserYn);
  val['APPROVAL_PROC_YN'] = instance.approvalProcYn;
  val['APPROVAL_PROC_DATE'] =
      const DateTimeJsonConverter().toJson(instance.approvalProcDate);
  val['REG_DATE'] = const DateTimeJsonConverter().toJson(instance.regDate);
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

BookAssetTbl _$BookAssetTblFromJson(Map<String, dynamic> json) => BookAssetTbl(
      seq: BigInt.parse(json['SEQ'] as String),
      assetNo: json['ASSET_NO'] as String,
      bookNm: json['BOOK_NM'] as String?,
      cnt: json['CNT'] as int?,
      publisher: json['PUBLISHER'] as String?,
      amount: json['AMOUNT'] as int?,
      buyDate: json['BUY_DATE'] as String?,
      mngDept: json['MNG_DEPT'] as String?,
      rentYn: json['RENT_YN'] as String?,
      rentUser: json['RENT_USER'] as String?,
      remarks: json['REMARKS'] as String?,
      useYn: json['USE_YN'] as String,
      delYn: json['DEL_YN'] as String,
      regDate:
          const DateTimeJsonConverter().fromJson(json['REG_DATE'] as String),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$BookAssetTblToJson(BookAssetTbl instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq.toString(),
    'ASSET_NO': instance.assetNo,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOOK_NM', instance.bookNm);
  writeNotNull('CNT', instance.cnt);
  writeNotNull('PUBLISHER', instance.publisher);
  writeNotNull('AMOUNT', instance.amount);
  writeNotNull('BUY_DATE', instance.buyDate);
  writeNotNull('MNG_DEPT', instance.mngDept);
  writeNotNull('RENT_YN', instance.rentYn);
  writeNotNull('RENT_USER', instance.rentUser);
  writeNotNull('REMARKS', instance.remarks);
  val['USE_YN'] = instance.useYn;
  val['DEL_YN'] = instance.delYn;
  val['REG_DATE'] = const DateTimeJsonConverter().toJson(instance.regDate);
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

CarAssetInsurTbl _$CarAssetInsurTblFromJson(Map<String, dynamic> json) =>
    CarAssetInsurTbl(
      seq: BigInt.parse(json['SEQ'] as String),
      mseq: BigInt.parse(json['MSEQ'] as String),
      guarantee: json['GUARANTEE'] as String,
    );

Map<String, dynamic> _$CarAssetInsurTblToJson(CarAssetInsurTbl instance) =>
    <String, dynamic>{
      'SEQ': instance.seq.toString(),
      'MSEQ': instance.mseq.toString(),
      'GUARANTEE': instance.guarantee,
    };

CarAssetTbl _$CarAssetTblFromJson(Map<String, dynamic> json) => CarAssetTbl(
      seq: BigInt.parse(json['SEQ'] as String),
      assetNo: json['ASSET_NO'] as String,
      modelNo: json['MODEL_NO'] as String?,
      carNo: json['CAR_NO'] as String?,
      owner: json['OWNER'] as String?,
      ownerType: json['OWNER_TYPE'] as String?,
      amount: json['AMOUNT'] as int?,
      buyDate: json['BUY_DATE'] as String?,
      seller: json['SELLER'] as String?,
      remarks: json['REMARKS'] as String?,
      mngrNm: json['MNGR_NM'] as String?,
      fuel: json['FUEL'] as String?,
      manuDt: json['MANU_DT'] as String?,
      effic: json['EFFIC'] as String?,
      insur: json['INSUR'] as String?,
      insurMngr: json['INSUR_MNGR'] as String?,
      emgTel: json['EMG_TEL'] as String?,
      storeNm: json['STORE_NM'] as String?,
      storeTel: json['STORE_TEL'] as String?,
      useYn: json['USE_YN'] as String,
      delYn: json['DEL_YN'] as String,
      regDate:
          const DateTimeJsonConverter().fromJson(json['REG_DATE'] as String),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$CarAssetTblToJson(CarAssetTbl instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq.toString(),
    'ASSET_NO': instance.assetNo,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MODEL_NO', instance.modelNo);
  writeNotNull('CAR_NO', instance.carNo);
  writeNotNull('OWNER', instance.owner);
  writeNotNull('OWNER_TYPE', instance.ownerType);
  writeNotNull('AMOUNT', instance.amount);
  writeNotNull('BUY_DATE', instance.buyDate);
  writeNotNull('SELLER', instance.seller);
  writeNotNull('REMARKS', instance.remarks);
  writeNotNull('MNGR_NM', instance.mngrNm);
  writeNotNull('FUEL', instance.fuel);
  writeNotNull('MANU_DT', instance.manuDt);
  writeNotNull('EFFIC', instance.effic);
  writeNotNull('INSUR', instance.insur);
  writeNotNull('INSUR_MNGR', instance.insurMngr);
  writeNotNull('EMG_TEL', instance.emgTel);
  writeNotNull('STORE_NM', instance.storeNm);
  writeNotNull('STORE_TEL', instance.storeTel);
  val['USE_YN'] = instance.useYn;
  val['DEL_YN'] = instance.delYn;
  val['REG_DATE'] = const DateTimeJsonConverter().toJson(instance.regDate);
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

CarChargeTbl _$CarChargeTblFromJson(Map<String, dynamic> json) => CarChargeTbl(
      seq: BigInt.parse(json['SEQ'] as String),
      item: json['ITEM'] as String,
      charge: BigInt.parse(json['CHARGE'] as String),
      writerId: json['WRITER_ID'] as String,
      memo: json['MEMO'] as String,
      regDate: json['REG_DATE'] as String,
    );

Map<String, dynamic> _$CarChargeTblToJson(CarChargeTbl instance) =>
    <String, dynamic>{
      'SEQ': instance.seq.toString(),
      'ITEM': instance.item,
      'CHARGE': instance.charge.toString(),
      'WRITER_ID': instance.writerId,
      'MEMO': instance.memo,
      'REG_DATE': instance.regDate,
    };

CarInfoTbl _$CarInfoTblFromJson(Map<String, dynamic> json) => CarInfoTbl(
      sort: BigInt.parse(json['SORT'] as String),
      carManageNo: json['CAR_MANAGE_NO'] as String,
      model: json['MODEL'] as String,
      userId: json['USER_ID'] as String,
      regDate: json['REG_DATE'] as String,
      disusedYn: json['DISUSED_YN'] as String,
    );

Map<String, dynamic> _$CarInfoTblToJson(CarInfoTbl instance) =>
    <String, dynamic>{
      'SORT': instance.sort.toString(),
      'CAR_MANAGE_NO': instance.carManageNo,
      'MODEL': instance.model,
      'USER_ID': instance.userId,
      'REG_DATE': instance.regDate,
      'DISUSED_YN': instance.disusedYn,
    };

CarMileageTbl _$CarMileageTblFromJson(Map<String, dynamic> json) =>
    CarMileageTbl(
      seq: BigInt.parse(json['SEQ'] as String),
      carManageNo: json['CAR_MANAGE_NO'] as String,
      forUse: json['FOR_USE'] as String,
      stPoint: json['ST_POINT'] as String,
      destination: json['DESTINATION'] as String,
      mileage: BigInt.parse(json['MILEAGE'] as String),
      totalMileage: BigInt.parse(json['TOTAL_MILEAGE'] as String),
      recordDate: json['RECORD_DATE'] as String,
      writerId: json['WRITER_ID'] as String,
      editorId: json['EDITOR_ID'] as String,
      regDate: json['REG_DATE'] as String,
      apprYn: json['APPR_YN'] as String,
    );

Map<String, dynamic> _$CarMileageTblToJson(CarMileageTbl instance) =>
    <String, dynamic>{
      'SEQ': instance.seq.toString(),
      'CAR_MANAGE_NO': instance.carManageNo,
      'FOR_USE': instance.forUse,
      'ST_POINT': instance.stPoint,
      'DESTINATION': instance.destination,
      'MILEAGE': instance.mileage.toString(),
      'TOTAL_MILEAGE': instance.totalMileage.toString(),
      'RECORD_DATE': instance.recordDate,
      'WRITER_ID': instance.writerId,
      'EDITOR_ID': instance.editorId,
      'REG_DATE': instance.regDate,
      'APPR_YN': instance.apprYn,
    };

CarPartReplaceTbl _$CarPartReplaceTblFromJson(Map<String, dynamic> json) =>
    CarPartReplaceTbl(
      seq: BigInt.parse(json['SEQ'] as String),
      partNm: json['PART_NM'] as String,
      replacePeriod: BigInt.parse(json['REPLACE_PERIOD'] as String),
      reTotalMileage: BigInt.parse(json['RE_TOTAL_MILEAGE'] as String),
      nowTotalMileage: BigInt.parse(json['NOW_TOTAL_MILEAGE'] as String),
      remainMileage: BigInt.parse(json['REMAIN_MILEAGE'] as String),
      replaceCount: BigInt.parse(json['REPLACE_COUNT'] as String),
      partReDate: json['PART_RE_DATE'] as String,
      writerId: json['WRITER_ID'] as String,
      regDate: json['REG_DATE'] as String,
    );

Map<String, dynamic> _$CarPartReplaceTblToJson(CarPartReplaceTbl instance) =>
    <String, dynamic>{
      'SEQ': instance.seq.toString(),
      'PART_NM': instance.partNm,
      'REPLACE_PERIOD': instance.replacePeriod.toString(),
      'RE_TOTAL_MILEAGE': instance.reTotalMileage.toString(),
      'NOW_TOTAL_MILEAGE': instance.nowTotalMileage.toString(),
      'REMAIN_MILEAGE': instance.remainMileage.toString(),
      'REPLACE_COUNT': instance.replaceCount.toString(),
      'PART_RE_DATE': instance.partReDate,
      'WRITER_ID': instance.writerId,
      'REG_DATE': instance.regDate,
    };

CarRepairLog _$CarRepairLogFromJson(Map<String, dynamic> json) => CarRepairLog(
      seq: BigInt.parse(json['SEQ'] as String),
      mseq: json['MSEQ'] == null ? null : BigInt.parse(json['MSEQ'] as String),
      assetNo: json['ASSET_NO'] as String?,
      repairDe: json['REPAIR_DE'] as String?,
      repairAmount: json['REPAIR_AMOUNT'] as String?,
      repairStore: json['REPAIR_STORE'] as String?,
      repairLog: json['REPAIR_LOG'] as String?,
      repairOwner: json['REPAIR_OWNER'] as String?,
      fileTp: json['FILE_TP'] as String?,
      flpth: json['FLPTH'] as String?,
      orginalFileNm: json['ORGINAL_FILE_NM'] as String?,
      streFileNm: json['STRE_FILE_NM'] as String?,
      regId: json['REG_ID'] as String?,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$CarRepairLogToJson(CarRepairLog instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq.toString(),
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MSEQ', instance.mseq?.toString());
  writeNotNull('ASSET_NO', instance.assetNo);
  writeNotNull('REPAIR_DE', instance.repairDe);
  writeNotNull('REPAIR_AMOUNT', instance.repairAmount);
  writeNotNull('REPAIR_STORE', instance.repairStore);
  writeNotNull('REPAIR_LOG', instance.repairLog);
  writeNotNull('REPAIR_OWNER', instance.repairOwner);
  writeNotNull('FILE_TP', instance.fileTp);
  writeNotNull('FLPTH', instance.flpth);
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm);
  writeNotNull('STRE_FILE_NM', instance.streFileNm);
  writeNotNull('REG_ID', instance.regId);
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

CarUseManageTbl _$CarUseManageTblFromJson(Map<String, dynamic> json) =>
    CarUseManageTbl(
      seq: BigInt.parse(json['SEQ'] as String),
      carNo: json['CAR_NO'] as String,
      carType: json['CAR_TYPE'] as String,
      destination: json['DESTINATION'] as String,
      purpose: json['PURPOSE'] as String?,
      users: json['USERS'] as String,
      useStartDate: const DateTimeJsonConverter()
          .fromJson(json['USE_START_DATE'] as String),
      useEndDate: const DateTimeJsonConverter()
          .fromJson(json['USE_END_DATE'] as String),
      useBeforeDistance: (json['USE_BEFORE_DISTANCE'] as num?)?.toDouble(),
      useAfterDistance: (json['USE_AFTER_DISTANCE'] as num?)?.toDouble(),
      remarks: json['REMARKS'] as String?,
      acceptYn: json['ACCEPT_YN'] as String?,
      regUser: json['REG_USER'] as String?,
      regDate:
          const DateTimeJsonConverter().fromJson(json['REG_DATE'] as String),
      useStartHour: json['USE_START_HOUR'] as String?,
      useEndHour: json['USE_END_HOUR'] as String?,
      cardApply: json['CARD_APPLY'] as String,
    );

Map<String, dynamic> _$CarUseManageTblToJson(CarUseManageTbl instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq.toString(),
    'CAR_NO': instance.carNo,
    'CAR_TYPE': instance.carType,
    'DESTINATION': instance.destination,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('PURPOSE', instance.purpose);
  val['USERS'] = instance.users;
  val['USE_START_DATE'] =
      const DateTimeJsonConverter().toJson(instance.useStartDate);
  val['USE_END_DATE'] =
      const DateTimeJsonConverter().toJson(instance.useEndDate);
  writeNotNull('USE_BEFORE_DISTANCE', instance.useBeforeDistance);
  writeNotNull('USE_AFTER_DISTANCE', instance.useAfterDistance);
  writeNotNull('REMARKS', instance.remarks);
  writeNotNull('ACCEPT_YN', instance.acceptYn);
  writeNotNull('REG_USER', instance.regUser);
  val['REG_DATE'] = const DateTimeJsonConverter().toJson(instance.regDate);
  writeNotNull('USE_START_HOUR', instance.useStartHour);
  writeNotNull('USE_END_HOUR', instance.useEndHour);
  val['CARD_APPLY'] = instance.cardApply;
  return val;
}

HolidayTbl _$HolidayTblFromJson(Map<String, dynamic> json) => HolidayTbl(
      userId: json['USER_ID'] as String,
      stdYear: json['STD_YEAR'] as String,
      m1: (json['M1'] as num?)?.toDouble(),
      m2: (json['M2'] as num?)?.toDouble(),
      m3: (json['M3'] as num?)?.toDouble(),
      m4: (json['M4'] as num?)?.toDouble(),
      m5: (json['M5'] as num?)?.toDouble(),
      m6: (json['M6'] as num?)?.toDouble(),
      m7: (json['M7'] as num?)?.toDouble(),
      m8: (json['M8'] as num?)?.toDouble(),
      m9: (json['M9'] as num?)?.toDouble(),
      m10: (json['M10'] as num?)?.toDouble(),
      m11: (json['M11'] as num?)?.toDouble(),
      m12: (json['M12'] as num?)?.toDouble(),
      useYn: json['USE_YN'] as String,
      delYn: json['DEL_YN'] as String,
      regDate:
          const DateTimeJsonConverter().fromJson(json['REG_DATE'] as String),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$HolidayTblToJson(HolidayTbl instance) {
  final val = <String, dynamic>{
    'USER_ID': instance.userId,
    'STD_YEAR': instance.stdYear,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('M1', instance.m1);
  writeNotNull('M2', instance.m2);
  writeNotNull('M3', instance.m3);
  writeNotNull('M4', instance.m4);
  writeNotNull('M5', instance.m5);
  writeNotNull('M6', instance.m6);
  writeNotNull('M7', instance.m7);
  writeNotNull('M8', instance.m8);
  writeNotNull('M9', instance.m9);
  writeNotNull('M10', instance.m10);
  writeNotNull('M11', instance.m11);
  writeNotNull('M12', instance.m12);
  val['USE_YN'] = instance.useYn;
  val['DEL_YN'] = instance.delYn;
  val['REG_DATE'] = const DateTimeJsonConverter().toJson(instance.regDate);
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

MemberTbl _$MemberTblFromJson(Map<String, dynamic> json) => MemberTbl(
      userId: json['USER_ID'] as String,
      passwd: json['PASSWD'] as String,
      userNm: json['USER_NM'] as String,
      dept: json['DEPT'] as String?,
      grade: json['GRADE'] as String?,
      joinDate:
          const DateTimeJsonConverter().fromJson(json['JOIN_DATE'] as String),
      retireDate:
          const DateTimeJsonConverter().fromJson(json['RETIRE_DATE'] as String),
      pwdChgDate: const DateTimeJsonConverter()
          .fromJson(json['PWD_CHG_DATE'] as String),
      pwdWrongCnt: json['PWD_WRONG_CNT'] as int?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate:
          const DateTimeJsonConverter().fromJson(json['REG_DATE'] as String),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      lastLoginDate: const DateTimeJsonConverter()
          .fromJson(json['LAST_LOGIN_DATE'] as String),
      memo: json['MEMO'] as String?,
    );

Map<String, dynamic> _$MemberTblToJson(MemberTbl instance) {
  final val = <String, dynamic>{
    'USER_ID': instance.userId,
    'PASSWD': instance.passwd,
    'USER_NM': instance.userNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('DEPT', instance.dept);
  writeNotNull('GRADE', instance.grade);
  val['JOIN_DATE'] = const DateTimeJsonConverter().toJson(instance.joinDate);
  val['RETIRE_DATE'] =
      const DateTimeJsonConverter().toJson(instance.retireDate);
  val['PWD_CHG_DATE'] =
      const DateTimeJsonConverter().toJson(instance.pwdChgDate);
  writeNotNull('PWD_WRONG_CNT', instance.pwdWrongCnt);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  val['REG_DATE'] = const DateTimeJsonConverter().toJson(instance.regDate);
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  val['LAST_LOGIN_DATE'] =
      const DateTimeJsonConverter().toJson(instance.lastLoginDate);
  writeNotNull('MEMO', instance.memo);
  return val;
}

MenuAuthTbl _$MenuAuthTblFromJson(Map<String, dynamic> json) => MenuAuthTbl(
      userId: json['USER_ID'] as String,
      menuId: json['MENU_ID'] as String,
      readYn: json['READ_YN'] as String?,
      writeYn: json['WRITE_YN'] as String?,
      regId: json['REG_ID'] as String?,
      updId: json['UPD_ID'] as String?,
      regDate:
          const DateTimeJsonConverter().fromJson(json['REG_DATE'] as String),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$MenuAuthTblToJson(MenuAuthTbl instance) {
  final val = <String, dynamic>{
    'USER_ID': instance.userId,
    'MENU_ID': instance.menuId,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('READ_YN', instance.readYn);
  writeNotNull('WRITE_YN', instance.writeYn);
  writeNotNull('REG_ID', instance.regId);
  writeNotNull('UPD_ID', instance.updId);
  val['REG_DATE'] = const DateTimeJsonConverter().toJson(instance.regDate);
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

MenuTbl _$MenuTblFromJson(Map<String, dynamic> json) => MenuTbl(
      menuId: json['MENU_ID'] as String,
      menuNm: json['MENU_NM'] as String,
      depth: json['DEPTH'] as int,
      sort: json['SORT'] as int,
      ownerId: json['OWNER_ID'] as String?,
      url: json['URL'] as String?,
      writerId: json['WRITER_ID'] as String?,
      regDate:
          const DateTimeJsonConverter().fromJson(json['REG_DATE'] as String),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      dispYn: json['DISP_YN'] as String?,
      menuIcon: json['MENU_ICON'] as String?,
    );

Map<String, dynamic> _$MenuTblToJson(MenuTbl instance) {
  final val = <String, dynamic>{
    'MENU_ID': instance.menuId,
    'MENU_NM': instance.menuNm,
    'DEPTH': instance.depth,
    'SORT': instance.sort,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('OWNER_ID', instance.ownerId);
  writeNotNull('URL', instance.url);
  writeNotNull('WRITER_ID', instance.writerId);
  val['REG_DATE'] = const DateTimeJsonConverter().toJson(instance.regDate);
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull('DISP_YN', instance.dispYn);
  writeNotNull('MENU_ICON', instance.menuIcon);
  return val;
}

OfficeAssetTbl _$OfficeAssetTblFromJson(Map<String, dynamic> json) =>
    OfficeAssetTbl(
      seq: BigInt.parse(json['SEQ'] as String),
      assetNo: json['ASSET_NO'] as String,
      assetType: json['ASSET_TYPE'] as String,
      seller: json['SELLER'] as String?,
      buyDate: json['BUY_DATE'] as String?,
      modelNo: json['MODEL_NO'] as String?,
      serialNo: json['SERIAL_NO'] as String?,
      amount: json['AMOUNT'] as int?,
      keepYear: (json['KEEP_YEAR'] as num?)?.toDouble(),
      mngDept: json['MNG_DEPT'] as String?,
      assetAccount: json['ASSET_ACCOUNT'] as String?,
      remarks: json['REMARKS'] as String?,
      carryOut: json['CARRY_OUT'] as String?,
      useYn: json['USE_YN'] as String,
      delYn: json['DEL_YN'] as String,
      regDate:
          const DateTimeJsonConverter().fromJson(json['REG_DATE'] as String),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$OfficeAssetTblToJson(OfficeAssetTbl instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq.toString(),
    'ASSET_NO': instance.assetNo,
    'ASSET_TYPE': instance.assetType,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SELLER', instance.seller);
  writeNotNull('BUY_DATE', instance.buyDate);
  writeNotNull('MODEL_NO', instance.modelNo);
  writeNotNull('SERIAL_NO', instance.serialNo);
  writeNotNull('AMOUNT', instance.amount);
  writeNotNull('KEEP_YEAR', instance.keepYear);
  writeNotNull('MNG_DEPT', instance.mngDept);
  writeNotNull('ASSET_ACCOUNT', instance.assetAccount);
  writeNotNull('REMARKS', instance.remarks);
  writeNotNull('CARRY_OUT', instance.carryOut);
  val['USE_YN'] = instance.useYn;
  val['DEL_YN'] = instance.delYn;
  val['REG_DATE'] = const DateTimeJsonConverter().toJson(instance.regDate);
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

ServerAssetTbl _$ServerAssetTblFromJson(Map<String, dynamic> json) =>
    ServerAssetTbl(
      seq: BigInt.parse(json['SEQ'] as String),
      assetNo: json['ASSET_NO'] as String,
      assetType: json['ASSET_TYPE'] as String,
      maker: json['MAKER'] as String?,
      cnt: (json['CNT'] as num?)?.toDouble(),
      amount: json['AMOUNT'] as int?,
      buyDate: json['BUY_DATE'] as String?,
      seller: json['SELLER'] as String?,
      modelNo: json['MODEL_NO'] as String?,
      serialNo: json['SERIAL_NO'] as String?,
      hostname: json['HOSTNAME'] as String?,
      builtLoc: json['BUILT_LOC'] as String?,
      useDesc: json['USE_DESC'] as String?,
      osInfo: json['OS_INFO'] as String?,
      cpuInfo: json['CPU_INFO'] as String?,
      ramInfo: json['RAM_INFO'] as String?,
      hddInfo: json['HDD_INFO'] as String?,
      ssdInfo: json['SSD_INFO'] as String?,
      odd: json['ODD'] as String?,
      remarks: json['REMARKS'] as String?,
      carryOut: json['CARRY_OUT'] as String?,
      useYn: json['USE_YN'] as String,
      delYn: json['DEL_YN'] as String,
      regDate:
          const DateTimeJsonConverter().fromJson(json['REG_DATE'] as String),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$ServerAssetTblToJson(ServerAssetTbl instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq.toString(),
    'ASSET_NO': instance.assetNo,
    'ASSET_TYPE': instance.assetType,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MAKER', instance.maker);
  writeNotNull('CNT', instance.cnt);
  writeNotNull('AMOUNT', instance.amount);
  writeNotNull('BUY_DATE', instance.buyDate);
  writeNotNull('SELLER', instance.seller);
  writeNotNull('MODEL_NO', instance.modelNo);
  writeNotNull('SERIAL_NO', instance.serialNo);
  writeNotNull('HOSTNAME', instance.hostname);
  writeNotNull('BUILT_LOC', instance.builtLoc);
  writeNotNull('USE_DESC', instance.useDesc);
  writeNotNull('OS_INFO', instance.osInfo);
  writeNotNull('CPU_INFO', instance.cpuInfo);
  writeNotNull('RAM_INFO', instance.ramInfo);
  writeNotNull('HDD_INFO', instance.hddInfo);
  writeNotNull('SSD_INFO', instance.ssdInfo);
  writeNotNull('ODD', instance.odd);
  writeNotNull('REMARKS', instance.remarks);
  writeNotNull('CARRY_OUT', instance.carryOut);
  val['USE_YN'] = instance.useYn;
  val['DEL_YN'] = instance.delYn;
  val['REG_DATE'] = const DateTimeJsonConverter().toJson(instance.regDate);
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

SoftwareAssetTbl _$SoftwareAssetTblFromJson(Map<String, dynamic> json) =>
    SoftwareAssetTbl(
      seq: BigInt.parse(json['SEQ'] as String),
      assetNo: json['ASSET_NO'] as String,
      softwareNm: json['SOFTWARE_NM'] as String,
      versionNm: json['VERSION_NM'] as String?,
      cnt: (json['CNT'] as num?)?.toDouble(),
      amount: json['AMOUNT'] as int?,
      buyDate: json['BUY_DATE'] as String?,
      serialNo: json['SERIAL_NO'] as String?,
      licenseNo: json['LICENSE_NO'] as String?,
      userNm: json['USER_NM'] as String?,
      remarks: json['REMARKS'] as String?,
      useYn: json['USE_YN'] as String,
      delYn: json['DEL_YN'] as String,
      regDate:
          const DateTimeJsonConverter().fromJson(json['REG_DATE'] as String),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$SoftwareAssetTblToJson(SoftwareAssetTbl instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq.toString(),
    'ASSET_NO': instance.assetNo,
    'SOFTWARE_NM': instance.softwareNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('VERSION_NM', instance.versionNm);
  writeNotNull('CNT', instance.cnt);
  writeNotNull('AMOUNT', instance.amount);
  writeNotNull('BUY_DATE', instance.buyDate);
  writeNotNull('SERIAL_NO', instance.serialNo);
  writeNotNull('LICENSE_NO', instance.licenseNo);
  writeNotNull('USER_NM', instance.userNm);
  writeNotNull('REMARKS', instance.remarks);
  val['USE_YN'] = instance.useYn;
  val['DEL_YN'] = instance.delYn;
  val['REG_DATE'] = const DateTimeJsonConverter().toJson(instance.regDate);
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

StAdminMenu _$StAdminMenuFromJson(Map<String, dynamic> json) => StAdminMenu(
      menuCd: json['MENU_CD'] as String,
      menuNm: json['MENU_NM'] as String,
      menuPath: json['MENU_PATH'] as String?,
      menuSrt: json['MENU_SRT'] as int,
      menuDeps: json['MENU_DEPS'] as int,
      menuIcon: json['MENU_ICON'] as String?,
      menuTp: json['MENU_TP'] as String,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$StAdminMenuToJson(StAdminMenu instance) {
  final val = <String, dynamic>{
    'MENU_CD': instance.menuCd,
    'MENU_NM': instance.menuNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_PATH', instance.menuPath);
  val['MENU_SRT'] = instance.menuSrt;
  val['MENU_DEPS'] = instance.menuDeps;
  writeNotNull('MENU_ICON', instance.menuIcon);
  val['MENU_TP'] = instance.menuTp;
  val['REG_ID'] = instance.regId;
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

StAlarm _$StAlarmFromJson(Map<String, dynamic> json) => StAlarm(
      seq: json['SEQ'] as int,
      msgCd: json['MSG_CD'] as String?,
      msgCnts: json['MSG_CNTS'] as String?,
      sendDate: json['SEND_DATE'] as String?,
      sendDiv: json['SEND_DIV'] as String?,
      sendDeptCd: json['SEND_DEPT_CD'] as String?,
      sendId: json['SEND_ID'] as String?,
      recvId: json['RECV_ID'] as String?,
      popYn: json['POP_YN'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
    );

Map<String, dynamic> _$StAlarmToJson(StAlarm instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MSG_CD', instance.msgCd);
  writeNotNull('MSG_CNTS', instance.msgCnts);
  writeNotNull('SEND_DATE', instance.sendDate);
  writeNotNull('SEND_DIV', instance.sendDiv);
  writeNotNull('SEND_DEPT_CD', instance.sendDeptCd);
  writeNotNull('SEND_ID', instance.sendId);
  writeNotNull('RECV_ID', instance.recvId);
  writeNotNull('POP_YN', instance.popYn);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  return val;
}

StAuditLog _$StAuditLogFromJson(Map<String, dynamic> json) => StAuditLog(
      seq: json['SEQ'] as int,
      logCode: json['LOG_CODE'] as String,
      logCnts: json['LOG_CNTS'] as String,
      errCode: json['ERR_CODE'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$StAuditLogToJson(StAuditLog instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'LOG_CODE': instance.logCode,
    'LOG_CNTS': instance.logCnts,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('ERR_CODE', instance.errCode);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

StBanner _$StBannerFromJson(Map<String, dynamic> json) => StBanner(
      bannerCd: json['BANNER_CD'] as String,
      lkUrl: json['LK_URL'] as String?,
      lkTarget: json['LK_TARGET'] as String?,
      flpth: json['FLPTH'] as String?,
      fileNm: json['FILE_NM'] as String?,
      useYn: json['USE_YN'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$StBannerToJson(StBanner instance) {
  final val = <String, dynamic>{
    'BANNER_CD': instance.bannerCd,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('LK_URL', instance.lkUrl);
  writeNotNull('LK_TARGET', instance.lkTarget);
  writeNotNull('FLPTH', instance.flpth);
  writeNotNull('FILE_NM', instance.fileNm);
  writeNotNull('USE_YN', instance.useYn);
  val['REG_ID'] = instance.regId;
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

StBoardColumn _$StBoardColumnFromJson(Map<String, dynamic> json) =>
    StBoardColumn(
      boardCd: json['BOARD_CD'] as String,
      sort: json['SORT'] as int,
      colCd: json['COL_CD'] as String,
      colNm: json['COL_NM'] as String,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
    );

Map<String, dynamic> _$StBoardColumnToJson(StBoardColumn instance) =>
    <String, dynamic>{
      'BOARD_CD': instance.boardCd,
      'SORT': instance.sort,
      'COL_CD': instance.colCd,
      'COL_NM': instance.colNm,
      'REG_ID': instance.regId,
      'REG_DATE': instance.regDate,
    };

StBoardColumnDft _$StBoardColumnDftFromJson(Map<String, dynamic> json) =>
    StBoardColumnDft(
      boardTy: json['BOARD_TY'] as String,
      sort: json['SORT'] as int,
      colCd: json['COL_CD'] as String,
      colNm: json['COL_NM'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delYn: json['DEL_YN'] as String,
    );

Map<String, dynamic> _$StBoardColumnDftToJson(StBoardColumnDft instance) {
  final val = <String, dynamic>{
    'BOARD_TY': instance.boardTy,
    'SORT': instance.sort,
    'COL_CD': instance.colCd,
    'COL_NM': instance.colNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  val['DEL_YN'] = instance.delYn;
  return val;
}

StBoardComment _$StBoardCommentFromJson(Map<String, dynamic> json) =>
    StBoardComment(
      seq: json['SEQ'] as int,
      mseq: json['MSEQ'] as int,
      boardCd: json['BOARD_CD'] as String,
      cnts: json['CNTS'] as String?,
      upperSeq: json['UPPER_SEQ'] as int?,
      replyYn: json['REPLY_YN'] as String?,
      regAdminYn: json['REG_ADMIN_YN'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$StBoardCommentToJson(StBoardComment instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'MSEQ': instance.mseq,
    'BOARD_CD': instance.boardCd,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CNTS', instance.cnts);
  writeNotNull('UPPER_SEQ', instance.upperSeq);
  writeNotNull('REPLY_YN', instance.replyYn);
  writeNotNull('REG_ADMIN_YN', instance.regAdminYn);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

StBoardFile _$StBoardFileFromJson(Map<String, dynamic> json) => StBoardFile(
      seq: json['SEQ'] as int,
      mseq: json['MSEQ'] as int,
      boardCd: json['BOARD_CD'] as String,
      fileTp: json['FILE_TP'] as String?,
      flpth: json['FLPTH'] as String?,
      orginalFileNm: json['ORGINAL_FILE_NM'] as String?,
      streFileNm: json['STRE_FILE_NM'] as String?,
      fileSize: json['FILE_SIZE'] as int?,
      repreYn: json['REPRE_YN'] as String?,
      dwldCo: json['DWLD_CO'] as int?,
    );

Map<String, dynamic> _$StBoardFileToJson(StBoardFile instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'MSEQ': instance.mseq,
    'BOARD_CD': instance.boardCd,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('FILE_TP', instance.fileTp);
  writeNotNull('FLPTH', instance.flpth);
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm);
  writeNotNull('STRE_FILE_NM', instance.streFileNm);
  writeNotNull('FILE_SIZE', instance.fileSize);
  writeNotNull('REPRE_YN', instance.repreYn);
  writeNotNull('DWLD_CO', instance.dwldCo);
  return val;
}

StBoardMst _$StBoardMstFromJson(Map<String, dynamic> json) => StBoardMst(
      seq: json['SEQ'] as int,
      boardCd: json['BOARD_CD'] as String,
      clsCd: json['CLS_CD'] as String?,
      ttl: json['TTL'] as String,
      cnts: json['CNTS'] as String,
      fileYn: json['FILE_YN'] as String?,
      imageYn: json['IMAGE_YN'] as String?,
      noticeYn: json['NOTICE_YN'] as String?,
      lkUrl: json['LK_URL'] as String?,
      lkTarget: json['LK_TARGET'] as String?,
      readCnt: json['READ_CNT'] as int?,
      regAdminYn: json['REG_ADMIN_YN'] as String?,
      replyYn: json['REPLY_YN'] as String?,
      upperSeq: json['UPPER_SEQ'] as int?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$StBoardMstToJson(StBoardMst instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'BOARD_CD': instance.boardCd,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CLS_CD', instance.clsCd);
  val['TTL'] = instance.ttl;
  val['CNTS'] = instance.cnts;
  writeNotNull('FILE_YN', instance.fileYn);
  writeNotNull('IMAGE_YN', instance.imageYn);
  writeNotNull('NOTICE_YN', instance.noticeYn);
  writeNotNull('LK_URL', instance.lkUrl);
  writeNotNull('LK_TARGET', instance.lkTarget);
  writeNotNull('READ_CNT', instance.readCnt);
  writeNotNull('REG_ADMIN_YN', instance.regAdminYn);
  writeNotNull('REPLY_YN', instance.replyYn);
  writeNotNull('UPPER_SEQ', instance.upperSeq);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

StBoardStng _$StBoardStngFromJson(Map<String, dynamic> json) => StBoardStng(
      boardCd: json['BOARD_CD'] as String,
      boardNm: json['BOARD_NM'] as String,
      boardTy: json['BOARD_TY'] as String,
      editorYn: json['EDITOR_YN'] as String,
      rlsYn: json['RLS_YN'] as String,
      cclSeq: json['CCL_SEQ'] as int?,
      listCnt: json['LIST_CNT'] as int?,
      writeYn: json['WRITE_YN'] as String?,
      commentYn: json['COMMENT_YN'] as String?,
      replyYn: json['REPLY_YN'] as String?,
      attachYn: json['ATTACH_YN'] as String?,
      attachSize: json['ATTACH_SIZE'] as String?,
      attachCnt: json['ATTACH_CNT'] as String?,
      attachExt: json['ATTACH_EXT'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$StBoardStngToJson(StBoardStng instance) {
  final val = <String, dynamic>{
    'BOARD_CD': instance.boardCd,
    'BOARD_NM': instance.boardNm,
    'BOARD_TY': instance.boardTy,
    'EDITOR_YN': instance.editorYn,
    'RLS_YN': instance.rlsYn,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CCL_SEQ', instance.cclSeq);
  writeNotNull('LIST_CNT', instance.listCnt);
  writeNotNull('WRITE_YN', instance.writeYn);
  writeNotNull('COMMENT_YN', instance.commentYn);
  writeNotNull('REPLY_YN', instance.replyYn);
  writeNotNull('ATTACH_YN', instance.attachYn);
  writeNotNull('ATTACH_SIZE', instance.attachSize);
  writeNotNull('ATTACH_CNT', instance.attachCnt);
  writeNotNull('ATTACH_EXT', instance.attachExt);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

StCcl _$StCclFromJson(Map<String, dynamic> json) => StCcl(
      seq: json['SEQ'] as int,
      cclType: json['CCL_TYPE'] as String,
      cclNm: json['CCL_NM'] as String,
      flpth: json['FLPTH'] as String?,
      orginalFileNm: json['ORGINAL_FILE_NM'] as String?,
      streFileNm: json['STRE_FILE_NM'] as String?,
      fileExtsn: json['FILE_EXTSN'] as String?,
      fileSize: json['FILE_SIZE'] as int?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$StCclToJson(StCcl instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'CCL_TYPE': instance.cclType,
    'CCL_NM': instance.cclNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('FLPTH', instance.flpth);
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm);
  writeNotNull('STRE_FILE_NM', instance.streFileNm);
  writeNotNull('FILE_EXTSN', instance.fileExtsn);
  writeNotNull('FILE_SIZE', instance.fileSize);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

StCodeMst _$StCodeMstFromJson(Map<String, dynamic> json) => StCodeMst(
      cdGrp: json['CD_GRP'] as String,
      cdKey: json['CD_KEY'] as String,
      cdVal: json['CD_VAL'] as String,
      cdDesc: json['CD_DESC'] as String?,
      cdSrt: json['CD_SRT'] as int,
      depth: json['DEPTH'] as int?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$StCodeMstToJson(StCodeMst instance) {
  final val = <String, dynamic>{
    'CD_GRP': instance.cdGrp,
    'CD_KEY': instance.cdKey,
    'CD_VAL': instance.cdVal,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CD_DESC', instance.cdDesc);
  val['CD_SRT'] = instance.cdSrt;
  writeNotNull('DEPTH', instance.depth);
  val['REG_ID'] = instance.regId;
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

StConnectLog _$StConnectLogFromJson(Map<String, dynamic> json) => StConnectLog(
      seq: json['SEQ'] as int,
      userId: json['USER_ID'] as String,
      connType: json['CONN_TYPE'] as String?,
      osType: json['OS_TYPE'] as String?,
      browserType: json['BROWSER_TYPE'] as String?,
      conneIp: json['CONNE_IP'] as String?,
      regDate: json['REG_DATE'] as String?,
    );

Map<String, dynamic> _$StConnectLogToJson(StConnectLog instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'USER_ID': instance.userId,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CONN_TYPE', instance.connType);
  writeNotNull('OS_TYPE', instance.osType);
  writeNotNull('BROWSER_TYPE', instance.browserType);
  writeNotNull('CONNE_IP', instance.conneIp);
  writeNotNull('REG_DATE', instance.regDate);
  return val;
}

StContentsFile _$StContentsFileFromJson(Map<String, dynamic> json) =>
    StContentsFile(
      seq: json['SEQ'] as int,
      mseq: json['MSEQ'] as String,
      fileTp: json['FILE_TP'] as String?,
      flpth: json['FLPTH'] as String,
      orginalFileNm: json['ORGINAL_FILE_NM'] as String,
      streFileNm: json['STRE_FILE_NM'] as String,
      fileSize: json['FILE_SIZE'] as int,
    );

Map<String, dynamic> _$StContentsFileToJson(StContentsFile instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'MSEQ': instance.mseq,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('FILE_TP', instance.fileTp);
  val['FLPTH'] = instance.flpth;
  val['ORGINAL_FILE_NM'] = instance.orginalFileNm;
  val['STRE_FILE_NM'] = instance.streFileNm;
  val['FILE_SIZE'] = instance.fileSize;
  return val;
}

StContentsMst _$StContentsMstFromJson(Map<String, dynamic> json) =>
    StContentsMst(
      seq: json['SEQ'] as int,
      cntsNm: json['CNTS_NM'] as String,
      pubDate: json['PUB_DATE'] as String?,
      pubState: json['PUB_STATE'] as String?,
      cn: json['CN'] as String?,
      srchYn: json['SRCH_YN'] as String?,
      fileYn: json['FILE_YN'] as String?,
      imageYn: json['IMAGE_YN'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$StContentsMstToJson(StContentsMst instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'CNTS_NM': instance.cntsNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('PUB_DATE', instance.pubDate);
  writeNotNull('PUB_STATE', instance.pubState);
  writeNotNull('CN', instance.cn);
  writeNotNull('SRCH_YN', instance.srchYn);
  writeNotNull('FILE_YN', instance.fileYn);
  writeNotNull('IMAGE_YN', instance.imageYn);
  val['REG_ID'] = instance.regId;
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

StDept _$StDeptFromJson(Map<String, dynamic> json) => StDept(
      deptCd: json['DEPT_CD'] as String,
      deptNm: json['DEPT_NM'] as String,
      upperDeptCd: json['UPPER_DEPT_CD'] as String?,
      upperDeptNm: json['UPPER_DEPT_NM'] as String?,
      sort: json['SORT'] as int?,
      mainYn: json['MAIN_YN'] as String?,
      deptDesc: json['DEPT_DESC'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$StDeptToJson(StDept instance) {
  final val = <String, dynamic>{
    'DEPT_CD': instance.deptCd,
    'DEPT_NM': instance.deptNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('UPPER_DEPT_CD', instance.upperDeptCd);
  writeNotNull('UPPER_DEPT_NM', instance.upperDeptNm);
  writeNotNull('SORT', instance.sort);
  writeNotNull('MAIN_YN', instance.mainYn);
  writeNotNull('DEPT_DESC', instance.deptDesc);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

StDeptEmp _$StDeptEmpFromJson(Map<String, dynamic> json) => StDeptEmp(
      empNo: json['EMP_NO'] as String,
      empNm: json['EMP_NM'] as String,
      deptCd: json['DEPT_CD'] as String?,
      deptNm: json['DEPT_NM'] as String?,
      fctnCd: json['FCTN_CD'] as String?,
      fctnNm: json['FCTN_NM'] as String?,
      ofcpCd: json['OFCP_CD'] as String?,
      ofcpNm: json['OFCP_NM'] as String?,
      emailAddr: json['EMAIL_ADDR'] as String?,
      offmTelno: json['OFFM_TELNO'] as String?,
      htelTelno: json['HTEL_TELNO'] as String?,
      deptYn: json['DEPT_YN'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$StDeptEmpToJson(StDeptEmp instance) {
  final val = <String, dynamic>{
    'EMP_NO': instance.empNo,
    'EMP_NM': instance.empNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('DEPT_CD', instance.deptCd);
  writeNotNull('DEPT_NM', instance.deptNm);
  writeNotNull('FCTN_CD', instance.fctnCd);
  writeNotNull('FCTN_NM', instance.fctnNm);
  writeNotNull('OFCP_CD', instance.ofcpCd);
  writeNotNull('OFCP_NM', instance.ofcpNm);
  writeNotNull('EMAIL_ADDR', instance.emailAddr);
  writeNotNull('OFFM_TELNO', instance.offmTelno);
  writeNotNull('HTEL_TELNO', instance.htelTelno);
  writeNotNull('DEPT_YN', instance.deptYn);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

StMenu _$StMenuFromJson(Map<String, dynamic> json) => StMenu(
      menuCd: json['MENU_CD'] as String,
      menuNm: json['MENU_NM'] as String,
      menuPath: json['MENU_PATH'] as String?,
      menuMapping: json['MENU_MAPPING'] as String?,
      menuSrt: json['MENU_SRT'] as int,
      menuDeps: json['MENU_DEPS'] as int,
      menuIcon: json['MENU_ICON'] as String?,
      menuTp: json['MENU_TP'] as String,
      mainExpsrYn: json['MAIN_EXPSR_YN'] as String?,
      subExpsrYn: json['SUB_EXPSR_YN'] as String?,
      upendClas: json['UPEND_CLAS'] as String?,
      upendCn: json['UPEND_CN'] as String?,
      cclType: json['CCL_TYPE'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$StMenuToJson(StMenu instance) {
  final val = <String, dynamic>{
    'MENU_CD': instance.menuCd,
    'MENU_NM': instance.menuNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_PATH', instance.menuPath);
  writeNotNull('MENU_MAPPING', instance.menuMapping);
  val['MENU_SRT'] = instance.menuSrt;
  val['MENU_DEPS'] = instance.menuDeps;
  writeNotNull('MENU_ICON', instance.menuIcon);
  val['MENU_TP'] = instance.menuTp;
  writeNotNull('MAIN_EXPSR_YN', instance.mainExpsrYn);
  writeNotNull('SUB_EXPSR_YN', instance.subExpsrYn);
  writeNotNull('UPEND_CLAS', instance.upendClas);
  writeNotNull('UPEND_CN', instance.upendCn);
  writeNotNull('CCL_TYPE', instance.cclType);
  val['REG_ID'] = instance.regId;
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

StMessageTmplat _$StMessageTmplatFromJson(Map<String, dynamic> json) =>
    StMessageTmplat(
      msgDivCd: json['MSG_DIV_CD'] as String,
      msgCd: json['MSG_CD'] as String,
      msgNm: json['MSG_NM'] as String?,
      msgTmplat: json['MSG_TMPLAT'] as String?,
      useYn: json['USE_YN'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
    );

Map<String, dynamic> _$StMessageTmplatToJson(StMessageTmplat instance) {
  final val = <String, dynamic>{
    'MSG_DIV_CD': instance.msgDivCd,
    'MSG_CD': instance.msgCd,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MSG_NM', instance.msgNm);
  writeNotNull('MSG_TMPLAT', instance.msgTmplat);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  return val;
}

StMimeType _$StMimeTypeFromJson(Map<String, dynamic> json) => StMimeType(
      seq: json['SEQ'] as int,
      extnNm: json['EXTN_NM'] as String,
      fileMt: json['FILE_MT'] as String,
    );

Map<String, dynamic> _$StMimeTypeToJson(StMimeType instance) =>
    <String, dynamic>{
      'SEQ': instance.seq,
      'EXTN_NM': instance.extnNm,
      'FILE_MT': instance.fileMt,
    };

StMngrGrp _$StMngrGrpFromJson(Map<String, dynamic> json) => StMngrGrp(
      grpCd: json['GRP_CD'] as String,
      grpNm: json['GRP_NM'] as String?,
      grpDesc: json['GRP_DESC'] as String?,
      sort: json['SORT'] as int?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$StMngrGrpToJson(StMngrGrp instance) {
  final val = <String, dynamic>{
    'GRP_CD': instance.grpCd,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('GRP_NM', instance.grpNm);
  writeNotNull('GRP_DESC', instance.grpDesc);
  writeNotNull('SORT', instance.sort);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

StMngrMst _$StMngrMstFromJson(Map<String, dynamic> json) => StMngrMst(
      mngrId: json['MNGR_ID'] as String,
      mngrNm: json['MNGR_NM'] as String,
      mngrPw: json['MNGR_PW'] as String?,
      grpCd: json['GRP_CD'] as String?,
      grade: json['GRADE'] as String?,
      permCd: json['PERM_CD'] as String,
      acsYn: json['ACS_YN'] as String?,
      clph: json['CLPH'] as String?,
      empNo: json['EMP_NO'] as String?,
      joinDate: json['JOIN_DATE'] as String,
      retireDate:
          const DateTimeJsonConverter().fromJson(json['RETIRE_DATE'] as String),
      pwdChgDate: const DateTimeJsonConverter()
          .fromJson(json['PWD_CHG_DATE'] as String),
      pwdWrongCnt: json['PWD_WRONG_CNT'] as int?,
      pwdWrongDate: json['PWD_WRONG_DATE'] as String?,
      lstLoginDate: json['LST_LOGIN_DATE'] as String?,
      flpth: json['FLPTH'] as String?,
      fileNm: json['FILE_NM'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$StMngrMstToJson(StMngrMst instance) {
  final val = <String, dynamic>{
    'MNGR_ID': instance.mngrId,
    'MNGR_NM': instance.mngrNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MNGR_PW', instance.mngrPw);
  writeNotNull('GRP_CD', instance.grpCd);
  writeNotNull('GRADE', instance.grade);
  val['PERM_CD'] = instance.permCd;
  writeNotNull('ACS_YN', instance.acsYn);
  writeNotNull('CLPH', instance.clph);
  writeNotNull('EMP_NO', instance.empNo);
  val['JOIN_DATE'] = instance.joinDate;
  val['RETIRE_DATE'] =
      const DateTimeJsonConverter().toJson(instance.retireDate);
  val['PWD_CHG_DATE'] =
      const DateTimeJsonConverter().toJson(instance.pwdChgDate);
  writeNotNull('PWD_WRONG_CNT', instance.pwdWrongCnt);
  writeNotNull('PWD_WRONG_DATE', instance.pwdWrongDate);
  writeNotNull('LST_LOGIN_DATE', instance.lstLoginDate);
  writeNotNull('FLPTH', instance.flpth);
  writeNotNull('FILE_NM', instance.fileNm);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

StMyStng _$StMyStngFromJson(Map<String, dynamic> json) => StMyStng(
      userId: json['USER_ID'] as String,
      stngCd: json['STNG_CD'] as String,
      userDiv: json['USER_DIV'] as String,
      stngData: json['STNG_DATA'] as String?,
    );

Map<String, dynamic> _$StMyStngToJson(StMyStng instance) {
  final val = <String, dynamic>{
    'USER_ID': instance.userId,
    'STNG_CD': instance.stngCd,
    'USER_DIV': instance.userDiv,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('STNG_DATA', instance.stngData);
  return val;
}

StPermDtl _$StPermDtlFromJson(Map<String, dynamic> json) => StPermDtl(
      permCd: json['PERM_CD'] as String,
      menuCd: json['MENU_CD'] as String,
      readYn: json['READ_YN'] as String?,
      regYn: json['REG_YN'] as String?,
      mdfcnYn: json['MDFCN_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      manageYn: json['MANAGE_YN'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
    );

Map<String, dynamic> _$StPermDtlToJson(StPermDtl instance) {
  final val = <String, dynamic>{
    'PERM_CD': instance.permCd,
    'MENU_CD': instance.menuCd,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('READ_YN', instance.readYn);
  writeNotNull('REG_YN', instance.regYn);
  writeNotNull('MDFCN_YN', instance.mdfcnYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull('MANAGE_YN', instance.manageYn);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  return val;
}

StPermMst _$StPermMstFromJson(Map<String, dynamic> json) => StPermMst(
      permCd: json['PERM_CD'] as String,
      permNm: json['PERM_NM'] as String,
      sort: json['SORT'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$StPermMstToJson(StPermMst instance) {
  final val = <String, dynamic>{
    'PERM_CD': instance.permCd,
    'PERM_NM': instance.permNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SORT', instance.sort);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

StPopup _$StPopupFromJson(Map<String, dynamic> json) => StPopup(
      popCd: json['POP_CD'] as String,
      popNm: json['POP_NM'] as String,
      popTy: json['POP_TY'] as String,
      imgText: json['IMG_TEXT'] as String?,
      lkUrl: json['LK_URL'] as String?,
      lkTarget: json['LK_TARGET'] as String?,
      bgngDate: json['BGNG_DATE'] as String,
      endDate: json['END_DATE'] as String,
      spwgPred: json['SPWG_PRED'] as String?,
      flpth: json['FLPTH'] as String?,
      fileNm: json['FILE_NM'] as String?,
      useYn: json['USE_YN'] as String?,
      beforeCd: json['BEFORE_CD'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$StPopupToJson(StPopup instance) {
  final val = <String, dynamic>{
    'POP_CD': instance.popCd,
    'POP_NM': instance.popNm,
    'POP_TY': instance.popTy,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('IMG_TEXT', instance.imgText);
  writeNotNull('LK_URL', instance.lkUrl);
  writeNotNull('LK_TARGET', instance.lkTarget);
  val['BGNG_DATE'] = instance.bgngDate;
  val['END_DATE'] = instance.endDate;
  writeNotNull('SPWG_PRED', instance.spwgPred);
  writeNotNull('FLPTH', instance.flpth);
  writeNotNull('FILE_NM', instance.fileNm);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('BEFORE_CD', instance.beforeCd);
  val['REG_ID'] = instance.regId;
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

StStng _$StStngFromJson(Map<String, dynamic> json) => StStng(
      stngCd: json['STNG_CD'] as String,
      stngData: json['STNG_DATA'] as String?,
      title: json['TITLE'] as String?,
      descCn: json['DESC_CN'] as String?,
      sort: json['SORT'] as int?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
    );

Map<String, dynamic> _$StStngToJson(StStng instance) {
  final val = <String, dynamic>{
    'STNG_CD': instance.stngCd,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('STNG_DATA', instance.stngData);
  writeNotNull('TITLE', instance.title);
  writeNotNull('DESC_CN', instance.descCn);
  writeNotNull('SORT', instance.sort);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  return val;
}

StUserMst _$StUserMstFromJson(Map<String, dynamic> json) => StUserMst(
      userId: json['USER_ID'] as String,
      userNm: json['USER_NM'] as String?,
      userPw: json['USER_PW'] as String,
      userDiv: json['USER_DIV'] as String?,
      status: json['STATUS'] as String?,
      prevLoginYn: json['PREV_LOGIN_YN'] as String?,
      withdrawnYn: json['WITHDRAWN_YN'] as String?,
      clph: json['CLPH'] as String?,
      email: json['EMAIL'] as String?,
      lstLoginDate: json['LST_LOGIN_DATE'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$StUserMstToJson(StUserMst instance) {
  final val = <String, dynamic>{
    'USER_ID': instance.userId,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_NM', instance.userNm);
  val['USER_PW'] = instance.userPw;
  writeNotNull('USER_DIV', instance.userDiv);
  writeNotNull('STATUS', instance.status);
  writeNotNull('PREV_LOGIN_YN', instance.prevLoginYn);
  writeNotNull('WITHDRAWN_YN', instance.withdrawnYn);
  writeNotNull('CLPH', instance.clph);
  writeNotNull('EMAIL', instance.email);
  writeNotNull('LST_LOGIN_DATE', instance.lstLoginDate);
  val['REG_ID'] = instance.regId;
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

WorkReportDetailTbl _$WorkReportDetailTblFromJson(Map<String, dynamic> json) =>
    WorkReportDetailTbl(
      reportId: json['REPORT_ID'] as String,
      seq: BigInt.parse(json['SEQ'] as String),
      projectNm: json['PROJECT_NM'] as String,
      projectSubNm: json['PROJECT_SUB_NM'] as String,
      detailContent: json['DETAIL_CONTENT'] as String?,
      worker: json['WORKER'] as String?,
      grade: json['GRADE'] as String?,
      processRate: json['PROCESS_RATE'] as String?,
      workDate: json['WORK_DATE'] as String?,
      processType: json['PROCESS_TYPE'] as String?,
      subjectYn: json['SUBJECT_YN'] as String,
      regUser: json['REG_USER'] as String,
      regDate:
          const DateTimeJsonConverter().fromJson(json['REG_DATE'] as String),
      completeDate: json['COMPLETE_DATE'] as String?,
    );

Map<String, dynamic> _$WorkReportDetailTblToJson(WorkReportDetailTbl instance) {
  final val = <String, dynamic>{
    'REPORT_ID': instance.reportId,
    'SEQ': instance.seq.toString(),
    'PROJECT_NM': instance.projectNm,
    'PROJECT_SUB_NM': instance.projectSubNm,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('DETAIL_CONTENT', instance.detailContent);
  writeNotNull('WORKER', instance.worker);
  writeNotNull('GRADE', instance.grade);
  writeNotNull('PROCESS_RATE', instance.processRate);
  writeNotNull('WORK_DATE', instance.workDate);
  writeNotNull('PROCESS_TYPE', instance.processType);
  val['SUBJECT_YN'] = instance.subjectYn;
  val['REG_USER'] = instance.regUser;
  val['REG_DATE'] = const DateTimeJsonConverter().toJson(instance.regDate);
  writeNotNull('COMPLETE_DATE', instance.completeDate);
  return val;
}

WorkReportHtmlTbl _$WorkReportHtmlTblFromJson(Map<String, dynamic> json) =>
    WorkReportHtmlTbl(
      reportId: json['REPORT_ID'] as String,
      userId: json['USER_ID'] as String,
      title: json['TITLE'] as String,
      htmlContent: json['HTML_CONTENT'] as String?,
      regDate:
          const DateTimeJsonConverter().fromJson(json['REG_DATE'] as String),
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$WorkReportHtmlTblToJson(WorkReportHtmlTbl instance) {
  final val = <String, dynamic>{
    'REPORT_ID': instance.reportId,
    'USER_ID': instance.userId,
    'TITLE': instance.title,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('HTML_CONTENT', instance.htmlContent);
  val['REG_DATE'] = const DateTimeJsonConverter().toJson(instance.regDate);
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

WorkReportHtmlTblBack _$WorkReportHtmlTblBackFromJson(
        Map<String, dynamic> json) =>
    WorkReportHtmlTblBack(
      reportId: json['REPORT_ID'] as String,
      userId: json['USER_ID'] as String,
      title: json['TITLE'] as String,
      htmlContent: json['HTML_CONTENT'] as String?,
      regDate:
          const DateTimeJsonConverter().fromJson(json['REG_DATE'] as String),
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$WorkReportHtmlTblBackToJson(
    WorkReportHtmlTblBack instance) {
  final val = <String, dynamic>{
    'REPORT_ID': instance.reportId,
    'USER_ID': instance.userId,
    'TITLE': instance.title,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('HTML_CONTENT', instance.htmlContent);
  val['REG_DATE'] = const DateTimeJsonConverter().toJson(instance.regDate);
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

WorkReportMasterTbl _$WorkReportMasterTblFromJson(Map<String, dynamic> json) =>
    WorkReportMasterTbl(
      reportId: json['REPORT_ID'] as String,
      title: json['TITLE'] as String,
      dept: json['DEPT'] as String,
      regDate:
          const DateTimeJsonConverter().fromJson(json['REG_DATE'] as String),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$WorkReportMasterTblToJson(WorkReportMasterTbl instance) {
  final val = <String, dynamic>{
    'REPORT_ID': instance.reportId,
    'TITLE': instance.title,
    'DEPT': instance.dept,
    'REG_DATE': const DateTimeJsonConverter().toJson(instance.regDate),
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

WorkRequestMst _$WorkRequestMstFromJson(Map<String, dynamic> json) =>
    WorkRequestMst(
      seq: json['SEQ'] as int,
      rqstrDpnm: json['RQSTR_DPNM'] as String,
      rqstrNm: json['RQSTR_NM'] as String,
      rqstrId: json['RQSTR_ID'] as String,
      rqstrDate: json['RQSTR_DATE'] as String,
      hopeDate: json['HOPE_DATE'] as String,
      chrDprNm: json['CHR_DPR_NM'] as String,
      chrNm: json['CHR_NM'] as String,
      chrId: json['CHR_ID'] as String,
      chrChk: json['CHR_CHK'] as String?,
      title: json['TITLE'] as String,
      cn: json['CN'] as String,
      etc: json['ETC'] as String?,
      doc: json['DOC'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$WorkRequestMstToJson(WorkRequestMst instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'RQSTR_DPNM': instance.rqstrDpnm,
    'RQSTR_NM': instance.rqstrNm,
    'RQSTR_ID': instance.rqstrId,
    'RQSTR_DATE': instance.rqstrDate,
    'HOPE_DATE': instance.hopeDate,
    'CHR_DPR_NM': instance.chrDprNm,
    'CHR_NM': instance.chrNm,
    'CHR_ID': instance.chrId,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CHR_CHK', instance.chrChk);
  val['TITLE'] = instance.title;
  val['CN'] = instance.cn;
  writeNotNull('ETC', instance.etc);
  writeNotNull('DOC', instance.doc);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

WorkRequestRef _$WorkRequestRefFromJson(Map<String, dynamic> json) =>
    WorkRequestRef(
      seq: json['SEQ'] as int,
      mseq: json['MSEQ'] as int,
      refId: json['REF_ID'] as String,
      refNm: json['REF_NM'] as String?,
      refDep: json['REF_DEP'] as String?,
      refGrade: json['REF_GRADE'] as String?,
      regId: json['REG_ID'] as String,
      regDate: json['REG_DATE'] as String,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$WorkRequestRefToJson(WorkRequestRef instance) {
  final val = <String, dynamic>{
    'SEQ': instance.seq,
    'MSEQ': instance.mseq,
    'REF_ID': instance.refId,
  };

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REF_NM', instance.refNm);
  writeNotNull('REF_DEP', instance.refDep);
  writeNotNull('REF_GRADE', instance.refGrade);
  val['REG_ID'] = instance.regId;
  val['REG_DATE'] = instance.regDate;
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

ALLCODETBLGroupByOutputType _$ALLCODETBLGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    ALLCODETBLGroupByOutputType(
      codeType: json['CODE_TYPE'] as String?,
      codeName: json['CODE_NAME'] as String?,
      unitType: json['UNIT_TYPE'] as String?,
      unitName: json['UNIT_NAME'] as String?,
      sort: json['SORT'] as int?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$ALLCODETBLGroupByOutputTypeToJson(
    ALLCODETBLGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CODE_TYPE', instance.codeType);
  writeNotNull('CODE_NAME', instance.codeName);
  writeNotNull('UNIT_TYPE', instance.unitType);
  writeNotNull('UNIT_NAME', instance.unitName);
  writeNotNull('SORT', instance.sort);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

APPROVALATTACHFILETBLGroupByOutputType
    _$APPROVALATTACHFILETBLGroupByOutputTypeFromJson(
            Map<String, dynamic> json) =>
        APPROVALATTACHFILETBLGroupByOutputType(
          approvalId: json['APPROVAL_ID'] as String?,
          seq: (json['SEQ'] as num?)?.toDouble(),
          oriFileNm: json['ORI_FILE_NM'] as String?,
          saveFileNm: json['SAVE_FILE_NM'] as String?,
          fileSize: json['FILE_SIZE'] as int?,
          regDate: _$JsonConverterFromJson<String, DateTime>(
              json['REG_DATE'], const DateTimeJsonConverter().fromJson),
        );

Map<String, dynamic> _$APPROVALATTACHFILETBLGroupByOutputTypeToJson(
    APPROVALATTACHFILETBLGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_ID', instance.approvalId);
  writeNotNull('SEQ', instance.seq);
  writeNotNull('ORI_FILE_NM', instance.oriFileNm);
  writeNotNull('SAVE_FILE_NM', instance.saveFileNm);
  writeNotNull('FILE_SIZE', instance.fileSize);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  return val;
}

APPROVALDOCINFOTBLGroupByOutputType
    _$APPROVALDOCINFOTBLGroupByOutputTypeFromJson(Map<String, dynamic> json) =>
        APPROVALDOCINFOTBLGroupByOutputType(
          seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
          docType: json['DOC_TYPE'] as String?,
          docNm: json['DOC_NM'] as String?,
          title: json['TITLE'] as String?,
          approvalLineType: json['APPROVAL_LINE_TYPE'] as String?,
          approvalLineContent: json['APPROVAL_LINE_CONTENT'] as String?,
          approvalLineContentBak: json['APPROVAL_LINE_CONTENT_BAK'] as String?,
          content: json['CONTENT'] as String?,
          writerId: json['WRITER_ID'] as String?,
          userNm: json['USER_NM'] as String?,
          regDate: _$JsonConverterFromJson<String, DateTime>(
              json['REG_DATE'], const DateTimeJsonConverter().fromJson),
          updDate: _$JsonConverterFromJson<String, DateTime>(
              json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
          useYn: json['USE_YN'] as String?,
          delYn: json['DEL_YN'] as String?,
        );

Map<String, dynamic> _$APPROVALDOCINFOTBLGroupByOutputTypeToJson(
    APPROVALDOCINFOTBLGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  writeNotNull('DOC_TYPE', instance.docType);
  writeNotNull('DOC_NM', instance.docNm);
  writeNotNull('TITLE', instance.title);
  writeNotNull('APPROVAL_LINE_TYPE', instance.approvalLineType);
  writeNotNull('APPROVAL_LINE_CONTENT', instance.approvalLineContent);
  writeNotNull('APPROVAL_LINE_CONTENT_BAK', instance.approvalLineContentBak);
  writeNotNull('CONTENT', instance.content);
  writeNotNull('WRITER_ID', instance.writerId);
  writeNotNull('USER_NM', instance.userNm);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

APPROVALHISTORYTBLGroupByOutputType
    _$APPROVALHISTORYTBLGroupByOutputTypeFromJson(Map<String, dynamic> json) =>
        APPROVALHISTORYTBLGroupByOutputType(
          seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
          approvalId: json['APPROVAL_ID'] as String?,
          writerId: json['WRITER_ID'] as String?,
          writerNm: json['WRITER_NM'] as String?,
          docType: json['DOC_TYPE'] as String?,
          keepPriod: json['KEEP_PRIOD'] as int?,
          keepDate: _$JsonConverterFromJson<String, DateTime>(
              json['KEEP_DATE'], const DateTimeJsonConverter().fromJson),
          grade: json['GRADE'] as String?,
          status: json['STATUS'] as String?,
          content: json['CONTENT'] as String?,
          regDate: _$JsonConverterFromJson<String, DateTime>(
              json['REG_DATE'], const DateTimeJsonConverter().fromJson),
          updDate: _$JsonConverterFromJson<String, DateTime>(
              json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
          delYn: json['DEL_YN'] as String?,
        );

Map<String, dynamic> _$APPROVALHISTORYTBLGroupByOutputTypeToJson(
    APPROVALHISTORYTBLGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  writeNotNull('APPROVAL_ID', instance.approvalId);
  writeNotNull('WRITER_ID', instance.writerId);
  writeNotNull('WRITER_NM', instance.writerNm);
  writeNotNull('DOC_TYPE', instance.docType);
  writeNotNull('KEEP_PRIOD', instance.keepPriod);
  writeNotNull(
      'KEEP_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.keepDate, const DateTimeJsonConverter().toJson));
  writeNotNull('GRADE', instance.grade);
  writeNotNull('STATUS', instance.status);
  writeNotNull('CONTENT', instance.content);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

APPROVALMASTERTBLGroupByOutputType _$APPROVALMASTERTBLGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    APPROVALMASTERTBLGroupByOutputType(
      approvalId: json['APPROVAL_ID'] as String?,
      writerId: json['WRITER_ID'] as String?,
      writerNm: json['WRITER_NM'] as String?,
      docType: json['DOC_TYPE'] as String?,
      keepPriod: json['KEEP_PRIOD'] as int?,
      keepDate: _$JsonConverterFromJson<String, DateTime>(
          json['KEEP_DATE'], const DateTimeJsonConverter().fromJson),
      grade: json['GRADE'] as String?,
      status: json['STATUS'] as String?,
      title: json['TITLE'] as String?,
      header: json['HEADER'] as String?,
      content: json['CONTENT'] as String?,
      m1: (json['M1'] as num?)?.toDouble(),
      m2: (json['M2'] as num?)?.toDouble(),
      m3: (json['M3'] as num?)?.toDouble(),
      m4: (json['M4'] as num?)?.toDouble(),
      m5: (json['M5'] as num?)?.toDouble(),
      m6: (json['M6'] as num?)?.toDouble(),
      m7: (json['M7'] as num?)?.toDouble(),
      m8: (json['M8'] as num?)?.toDouble(),
      m9: (json['M9'] as num?)?.toDouble(),
      m10: (json['M10'] as num?)?.toDouble(),
      m11: (json['M11'] as num?)?.toDouble(),
      m12: (json['M12'] as num?)?.toDouble(),
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      completeDate: _$JsonConverterFromJson<String, DateTime>(
          json['COMPLETE_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$APPROVALMASTERTBLGroupByOutputTypeToJson(
    APPROVALMASTERTBLGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_ID', instance.approvalId);
  writeNotNull('WRITER_ID', instance.writerId);
  writeNotNull('WRITER_NM', instance.writerNm);
  writeNotNull('DOC_TYPE', instance.docType);
  writeNotNull('KEEP_PRIOD', instance.keepPriod);
  writeNotNull(
      'KEEP_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.keepDate, const DateTimeJsonConverter().toJson));
  writeNotNull('GRADE', instance.grade);
  writeNotNull('STATUS', instance.status);
  writeNotNull('TITLE', instance.title);
  writeNotNull('HEADER', instance.header);
  writeNotNull('CONTENT', instance.content);
  writeNotNull('M1', instance.m1);
  writeNotNull('M2', instance.m2);
  writeNotNull('M3', instance.m3);
  writeNotNull('M4', instance.m4);
  writeNotNull('M5', instance.m5);
  writeNotNull('M6', instance.m6);
  writeNotNull('M7', instance.m7);
  writeNotNull('M8', instance.m8);
  writeNotNull('M9', instance.m9);
  writeNotNull('M10', instance.m10);
  writeNotNull('M11', instance.m11);
  writeNotNull('M12', instance.m12);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'COMPLETE_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.completeDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

APPROVALMEMOTBLGroupByOutputType _$APPROVALMEMOTBLGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    APPROVALMEMOTBLGroupByOutputType(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      approvalId: json['APPROVAL_ID'] as String?,
      writerId: json['WRITER_ID'] as String?,
      writerNm: json['WRITER_NM'] as String?,
      content: json['CONTENT'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$APPROVALMEMOTBLGroupByOutputTypeToJson(
    APPROVALMEMOTBLGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  writeNotNull('APPROVAL_ID', instance.approvalId);
  writeNotNull('WRITER_ID', instance.writerId);
  writeNotNull('WRITER_NM', instance.writerNm);
  writeNotNull('CONTENT', instance.content);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

APPROVALTYPETBLGroupByOutputType _$APPROVALTYPETBLGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    APPROVALTYPETBLGroupByOutputType(
      type: json['TYPE'] as String?,
      content: json['CONTENT'] as String?,
      contentBak: json['CONTENT_BAK'] as String?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$APPROVALTYPETBLGroupByOutputTypeToJson(
    APPROVALTYPETBLGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('TYPE', instance.type);
  writeNotNull('CONTENT', instance.content);
  writeNotNull('CONTENT_BAK', instance.contentBak);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

APPROVALUSERTBLGroupByOutputType _$APPROVALUSERTBLGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    APPROVALUSERTBLGroupByOutputType(
      approvalId: json['APPROVAL_ID'] as String?,
      approvalUsrId: json['APPROVAL_USR_ID'] as String?,
      approvalUsrGradeCd: json['APPROVAL_USR_GRADE_CD'] as String?,
      approvalUsrType: json['APPROVAL_USR_TYPE'] as String?,
      approvalUsrSort: json['APPROVAL_USR_SORT'] as int?,
      approvalProcUserYn: json['APPROVAL_PROC_USER_YN'] as String?,
      approvalProcYn: json['APPROVAL_PROC_YN'] as String?,
      approvalProcDate: _$JsonConverterFromJson<String, DateTime>(
          json['APPROVAL_PROC_DATE'], const DateTimeJsonConverter().fromJson),
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$APPROVALUSERTBLGroupByOutputTypeToJson(
    APPROVALUSERTBLGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('APPROVAL_ID', instance.approvalId);
  writeNotNull('APPROVAL_USR_ID', instance.approvalUsrId);
  writeNotNull('APPROVAL_USR_GRADE_CD', instance.approvalUsrGradeCd);
  writeNotNull('APPROVAL_USR_TYPE', instance.approvalUsrType);
  writeNotNull('APPROVAL_USR_SORT', instance.approvalUsrSort);
  writeNotNull('APPROVAL_PROC_USER_YN', instance.approvalProcUserYn);
  writeNotNull('APPROVAL_PROC_YN', instance.approvalProcYn);
  writeNotNull(
      'APPROVAL_PROC_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.approvalProcDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

BOOKASSETTBLGroupByOutputType _$BOOKASSETTBLGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    BOOKASSETTBLGroupByOutputType(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      assetNo: json['ASSET_NO'] as String?,
      bookNm: json['BOOK_NM'] as String?,
      cnt: json['CNT'] as int?,
      publisher: json['PUBLISHER'] as String?,
      amount: json['AMOUNT'] as int?,
      buyDate: json['BUY_DATE'] as String?,
      mngDept: json['MNG_DEPT'] as String?,
      rentYn: json['RENT_YN'] as String?,
      rentUser: json['RENT_USER'] as String?,
      remarks: json['REMARKS'] as String?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$BOOKASSETTBLGroupByOutputTypeToJson(
    BOOKASSETTBLGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  writeNotNull('ASSET_NO', instance.assetNo);
  writeNotNull('BOOK_NM', instance.bookNm);
  writeNotNull('CNT', instance.cnt);
  writeNotNull('PUBLISHER', instance.publisher);
  writeNotNull('AMOUNT', instance.amount);
  writeNotNull('BUY_DATE', instance.buyDate);
  writeNotNull('MNG_DEPT', instance.mngDept);
  writeNotNull('RENT_YN', instance.rentYn);
  writeNotNull('RENT_USER', instance.rentUser);
  writeNotNull('REMARKS', instance.remarks);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

CARASSETINSURTBLGroupByOutputType _$CARASSETINSURTBLGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    CARASSETINSURTBLGroupByOutputType(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      mseq: json['MSEQ'] == null ? null : BigInt.parse(json['MSEQ'] as String),
      guarantee: json['GUARANTEE'] as String?,
    );

Map<String, dynamic> _$CARASSETINSURTBLGroupByOutputTypeToJson(
    CARASSETINSURTBLGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  writeNotNull('MSEQ', instance.mseq?.toString());
  writeNotNull('GUARANTEE', instance.guarantee);
  return val;
}

CARASSETTBLGroupByOutputType _$CARASSETTBLGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    CARASSETTBLGroupByOutputType(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      assetNo: json['ASSET_NO'] as String?,
      modelNo: json['MODEL_NO'] as String?,
      carNo: json['CAR_NO'] as String?,
      owner: json['OWNER'] as String?,
      ownerType: json['OWNER_TYPE'] as String?,
      amount: json['AMOUNT'] as int?,
      buyDate: json['BUY_DATE'] as String?,
      seller: json['SELLER'] as String?,
      remarks: json['REMARKS'] as String?,
      mngrNm: json['MNGR_NM'] as String?,
      fuel: json['FUEL'] as String?,
      manuDt: json['MANU_DT'] as String?,
      effic: json['EFFIC'] as String?,
      insur: json['INSUR'] as String?,
      insurMngr: json['INSUR_MNGR'] as String?,
      emgTel: json['EMG_TEL'] as String?,
      storeNm: json['STORE_NM'] as String?,
      storeTel: json['STORE_TEL'] as String?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$CARASSETTBLGroupByOutputTypeToJson(
    CARASSETTBLGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  writeNotNull('ASSET_NO', instance.assetNo);
  writeNotNull('MODEL_NO', instance.modelNo);
  writeNotNull('CAR_NO', instance.carNo);
  writeNotNull('OWNER', instance.owner);
  writeNotNull('OWNER_TYPE', instance.ownerType);
  writeNotNull('AMOUNT', instance.amount);
  writeNotNull('BUY_DATE', instance.buyDate);
  writeNotNull('SELLER', instance.seller);
  writeNotNull('REMARKS', instance.remarks);
  writeNotNull('MNGR_NM', instance.mngrNm);
  writeNotNull('FUEL', instance.fuel);
  writeNotNull('MANU_DT', instance.manuDt);
  writeNotNull('EFFIC', instance.effic);
  writeNotNull('INSUR', instance.insur);
  writeNotNull('INSUR_MNGR', instance.insurMngr);
  writeNotNull('EMG_TEL', instance.emgTel);
  writeNotNull('STORE_NM', instance.storeNm);
  writeNotNull('STORE_TEL', instance.storeTel);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

CARCHARGETBLGroupByOutputType _$CARCHARGETBLGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    CARCHARGETBLGroupByOutputType(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      item: json['ITEM'] as String?,
      charge: json['CHARGE'] == null
          ? null
          : BigInt.parse(json['CHARGE'] as String),
      writerId: json['WRITER_ID'] as String?,
      memo: json['MEMO'] as String?,
      regDate: json['REG_DATE'] as String?,
    );

Map<String, dynamic> _$CARCHARGETBLGroupByOutputTypeToJson(
    CARCHARGETBLGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  writeNotNull('ITEM', instance.item);
  writeNotNull('CHARGE', instance.charge?.toString());
  writeNotNull('WRITER_ID', instance.writerId);
  writeNotNull('MEMO', instance.memo);
  writeNotNull('REG_DATE', instance.regDate);
  return val;
}

CARINFOTBLGroupByOutputType _$CARINFOTBLGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    CARINFOTBLGroupByOutputType(
      sort: json['SORT'] == null ? null : BigInt.parse(json['SORT'] as String),
      carManageNo: json['CAR_MANAGE_NO'] as String?,
      model: json['MODEL'] as String?,
      userId: json['USER_ID'] as String?,
      regDate: json['REG_DATE'] as String?,
      disusedYn: json['DISUSED_YN'] as String?,
    );

Map<String, dynamic> _$CARINFOTBLGroupByOutputTypeToJson(
    CARINFOTBLGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SORT', instance.sort?.toString());
  writeNotNull('CAR_MANAGE_NO', instance.carManageNo);
  writeNotNull('MODEL', instance.model);
  writeNotNull('USER_ID', instance.userId);
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('DISUSED_YN', instance.disusedYn);
  return val;
}

CARMILEAGETBLGroupByOutputType _$CARMILEAGETBLGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    CARMILEAGETBLGroupByOutputType(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      carManageNo: json['CAR_MANAGE_NO'] as String?,
      forUse: json['FOR_USE'] as String?,
      stPoint: json['ST_POINT'] as String?,
      destination: json['DESTINATION'] as String?,
      mileage: json['MILEAGE'] == null
          ? null
          : BigInt.parse(json['MILEAGE'] as String),
      totalMileage: json['TOTAL_MILEAGE'] == null
          ? null
          : BigInt.parse(json['TOTAL_MILEAGE'] as String),
      recordDate: json['RECORD_DATE'] as String?,
      writerId: json['WRITER_ID'] as String?,
      editorId: json['EDITOR_ID'] as String?,
      regDate: json['REG_DATE'] as String?,
      apprYn: json['APPR_YN'] as String?,
    );

Map<String, dynamic> _$CARMILEAGETBLGroupByOutputTypeToJson(
    CARMILEAGETBLGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  writeNotNull('CAR_MANAGE_NO', instance.carManageNo);
  writeNotNull('FOR_USE', instance.forUse);
  writeNotNull('ST_POINT', instance.stPoint);
  writeNotNull('DESTINATION', instance.destination);
  writeNotNull('MILEAGE', instance.mileage?.toString());
  writeNotNull('TOTAL_MILEAGE', instance.totalMileage?.toString());
  writeNotNull('RECORD_DATE', instance.recordDate);
  writeNotNull('WRITER_ID', instance.writerId);
  writeNotNull('EDITOR_ID', instance.editorId);
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('APPR_YN', instance.apprYn);
  return val;
}

CARPARTREPLACETBLGroupByOutputType _$CARPARTREPLACETBLGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    CARPARTREPLACETBLGroupByOutputType(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      partNm: json['PART_NM'] as String?,
      replacePeriod: json['REPLACE_PERIOD'] == null
          ? null
          : BigInt.parse(json['REPLACE_PERIOD'] as String),
      reTotalMileage: json['RE_TOTAL_MILEAGE'] == null
          ? null
          : BigInt.parse(json['RE_TOTAL_MILEAGE'] as String),
      nowTotalMileage: json['NOW_TOTAL_MILEAGE'] == null
          ? null
          : BigInt.parse(json['NOW_TOTAL_MILEAGE'] as String),
      remainMileage: json['REMAIN_MILEAGE'] == null
          ? null
          : BigInt.parse(json['REMAIN_MILEAGE'] as String),
      replaceCount: json['REPLACE_COUNT'] == null
          ? null
          : BigInt.parse(json['REPLACE_COUNT'] as String),
      partReDate: json['PART_RE_DATE'] as String?,
      writerId: json['WRITER_ID'] as String?,
      regDate: json['REG_DATE'] as String?,
    );

Map<String, dynamic> _$CARPARTREPLACETBLGroupByOutputTypeToJson(
    CARPARTREPLACETBLGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  writeNotNull('PART_NM', instance.partNm);
  writeNotNull('REPLACE_PERIOD', instance.replacePeriod?.toString());
  writeNotNull('RE_TOTAL_MILEAGE', instance.reTotalMileage?.toString());
  writeNotNull('NOW_TOTAL_MILEAGE', instance.nowTotalMileage?.toString());
  writeNotNull('REMAIN_MILEAGE', instance.remainMileage?.toString());
  writeNotNull('REPLACE_COUNT', instance.replaceCount?.toString());
  writeNotNull('PART_RE_DATE', instance.partReDate);
  writeNotNull('WRITER_ID', instance.writerId);
  writeNotNull('REG_DATE', instance.regDate);
  return val;
}

CARREPAIRLOGGroupByOutputType _$CARREPAIRLOGGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    CARREPAIRLOGGroupByOutputType(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      mseq: json['MSEQ'] == null ? null : BigInt.parse(json['MSEQ'] as String),
      assetNo: json['ASSET_NO'] as String?,
      repairDe: json['REPAIR_DE'] as String?,
      repairAmount: json['REPAIR_AMOUNT'] as String?,
      repairStore: json['REPAIR_STORE'] as String?,
      repairLog: json['REPAIR_LOG'] as String?,
      repairOwner: json['REPAIR_OWNER'] as String?,
      fileTp: json['FILE_TP'] as String?,
      flpth: json['FLPTH'] as String?,
      orginalFileNm: json['ORGINAL_FILE_NM'] as String?,
      streFileNm: json['STRE_FILE_NM'] as String?,
      regId: json['REG_ID'] as String?,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$CARREPAIRLOGGroupByOutputTypeToJson(
    CARREPAIRLOGGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  writeNotNull('MSEQ', instance.mseq?.toString());
  writeNotNull('ASSET_NO', instance.assetNo);
  writeNotNull('REPAIR_DE', instance.repairDe);
  writeNotNull('REPAIR_AMOUNT', instance.repairAmount);
  writeNotNull('REPAIR_STORE', instance.repairStore);
  writeNotNull('REPAIR_LOG', instance.repairLog);
  writeNotNull('REPAIR_OWNER', instance.repairOwner);
  writeNotNull('FILE_TP', instance.fileTp);
  writeNotNull('FLPTH', instance.flpth);
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm);
  writeNotNull('STRE_FILE_NM', instance.streFileNm);
  writeNotNull('REG_ID', instance.regId);
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

CARUSEMANAGETBLGroupByOutputType _$CARUSEMANAGETBLGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    CARUSEMANAGETBLGroupByOutputType(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      carNo: json['CAR_NO'] as String?,
      carType: json['CAR_TYPE'] as String?,
      destination: json['DESTINATION'] as String?,
      purpose: json['PURPOSE'] as String?,
      users: json['USERS'] as String?,
      useStartDate: _$JsonConverterFromJson<String, DateTime>(
          json['USE_START_DATE'], const DateTimeJsonConverter().fromJson),
      useEndDate: _$JsonConverterFromJson<String, DateTime>(
          json['USE_END_DATE'], const DateTimeJsonConverter().fromJson),
      useBeforeDistance: (json['USE_BEFORE_DISTANCE'] as num?)?.toDouble(),
      useAfterDistance: (json['USE_AFTER_DISTANCE'] as num?)?.toDouble(),
      remarks: json['REMARKS'] as String?,
      acceptYn: json['ACCEPT_YN'] as String?,
      regUser: json['REG_USER'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      useStartHour: json['USE_START_HOUR'] as String?,
      useEndHour: json['USE_END_HOUR'] as String?,
      cardApply: json['CARD_APPLY'] as String?,
    );

Map<String, dynamic> _$CARUSEMANAGETBLGroupByOutputTypeToJson(
    CARUSEMANAGETBLGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  writeNotNull('CAR_NO', instance.carNo);
  writeNotNull('CAR_TYPE', instance.carType);
  writeNotNull('DESTINATION', instance.destination);
  writeNotNull('PURPOSE', instance.purpose);
  writeNotNull('USERS', instance.users);
  writeNotNull(
      'USE_START_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.useStartDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'USE_END_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.useEndDate, const DateTimeJsonConverter().toJson));
  writeNotNull('USE_BEFORE_DISTANCE', instance.useBeforeDistance);
  writeNotNull('USE_AFTER_DISTANCE', instance.useAfterDistance);
  writeNotNull('REMARKS', instance.remarks);
  writeNotNull('ACCEPT_YN', instance.acceptYn);
  writeNotNull('REG_USER', instance.regUser);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull('USE_START_HOUR', instance.useStartHour);
  writeNotNull('USE_END_HOUR', instance.useEndHour);
  writeNotNull('CARD_APPLY', instance.cardApply);
  return val;
}

HOLIDAYTBLGroupByOutputType _$HOLIDAYTBLGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    HOLIDAYTBLGroupByOutputType(
      userId: json['USER_ID'] as String?,
      stdYear: json['STD_YEAR'] as String?,
      m1: (json['M1'] as num?)?.toDouble(),
      m2: (json['M2'] as num?)?.toDouble(),
      m3: (json['M3'] as num?)?.toDouble(),
      m4: (json['M4'] as num?)?.toDouble(),
      m5: (json['M5'] as num?)?.toDouble(),
      m6: (json['M6'] as num?)?.toDouble(),
      m7: (json['M7'] as num?)?.toDouble(),
      m8: (json['M8'] as num?)?.toDouble(),
      m9: (json['M9'] as num?)?.toDouble(),
      m10: (json['M10'] as num?)?.toDouble(),
      m11: (json['M11'] as num?)?.toDouble(),
      m12: (json['M12'] as num?)?.toDouble(),
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$HOLIDAYTBLGroupByOutputTypeToJson(
    HOLIDAYTBLGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', instance.userId);
  writeNotNull('STD_YEAR', instance.stdYear);
  writeNotNull('M1', instance.m1);
  writeNotNull('M2', instance.m2);
  writeNotNull('M3', instance.m3);
  writeNotNull('M4', instance.m4);
  writeNotNull('M5', instance.m5);
  writeNotNull('M6', instance.m6);
  writeNotNull('M7', instance.m7);
  writeNotNull('M8', instance.m8);
  writeNotNull('M9', instance.m9);
  writeNotNull('M10', instance.m10);
  writeNotNull('M11', instance.m11);
  writeNotNull('M12', instance.m12);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

MEMBERTBLGroupByOutputType _$MEMBERTBLGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    MEMBERTBLGroupByOutputType(
      userId: json['USER_ID'] as String?,
      passwd: json['PASSWD'] as String?,
      userNm: json['USER_NM'] as String?,
      dept: json['DEPT'] as String?,
      grade: json['GRADE'] as String?,
      joinDate: _$JsonConverterFromJson<String, DateTime>(
          json['JOIN_DATE'], const DateTimeJsonConverter().fromJson),
      retireDate: _$JsonConverterFromJson<String, DateTime>(
          json['RETIRE_DATE'], const DateTimeJsonConverter().fromJson),
      pwdChgDate: _$JsonConverterFromJson<String, DateTime>(
          json['PWD_CHG_DATE'], const DateTimeJsonConverter().fromJson),
      pwdWrongCnt: json['PWD_WRONG_CNT'] as int?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      lastLoginDate: _$JsonConverterFromJson<String, DateTime>(
          json['LAST_LOGIN_DATE'], const DateTimeJsonConverter().fromJson),
      memo: json['MEMO'] as String?,
    );

Map<String, dynamic> _$MEMBERTBLGroupByOutputTypeToJson(
    MEMBERTBLGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', instance.userId);
  writeNotNull('PASSWD', instance.passwd);
  writeNotNull('USER_NM', instance.userNm);
  writeNotNull('DEPT', instance.dept);
  writeNotNull('GRADE', instance.grade);
  writeNotNull(
      'JOIN_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.joinDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'RETIRE_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.retireDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'PWD_CHG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.pwdChgDate, const DateTimeJsonConverter().toJson));
  writeNotNull('PWD_WRONG_CNT', instance.pwdWrongCnt);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'LAST_LOGIN_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.lastLoginDate, const DateTimeJsonConverter().toJson));
  writeNotNull('MEMO', instance.memo);
  return val;
}

MENUAUTHTBLGroupByOutputType _$MENUAUTHTBLGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    MENUAUTHTBLGroupByOutputType(
      userId: json['USER_ID'] as String?,
      menuId: json['MENU_ID'] as String?,
      readYn: json['READ_YN'] as String?,
      writeYn: json['WRITE_YN'] as String?,
      regId: json['REG_ID'] as String?,
      updId: json['UPD_ID'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$MENUAUTHTBLGroupByOutputTypeToJson(
    MENUAUTHTBLGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', instance.userId);
  writeNotNull('MENU_ID', instance.menuId);
  writeNotNull('READ_YN', instance.readYn);
  writeNotNull('WRITE_YN', instance.writeYn);
  writeNotNull('REG_ID', instance.regId);
  writeNotNull('UPD_ID', instance.updId);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

MENUTBLGroupByOutputType _$MENUTBLGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    MENUTBLGroupByOutputType(
      menuId: json['MENU_ID'] as String?,
      menuNm: json['MENU_NM'] as String?,
      depth: json['DEPTH'] as int?,
      sort: json['SORT'] as int?,
      ownerId: json['OWNER_ID'] as String?,
      url: json['URL'] as String?,
      writerId: json['WRITER_ID'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      dispYn: json['DISP_YN'] as String?,
      menuIcon: json['MENU_ICON'] as String?,
    );

Map<String, dynamic> _$MENUTBLGroupByOutputTypeToJson(
    MENUTBLGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_ID', instance.menuId);
  writeNotNull('MENU_NM', instance.menuNm);
  writeNotNull('DEPTH', instance.depth);
  writeNotNull('SORT', instance.sort);
  writeNotNull('OWNER_ID', instance.ownerId);
  writeNotNull('URL', instance.url);
  writeNotNull('WRITER_ID', instance.writerId);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull('DISP_YN', instance.dispYn);
  writeNotNull('MENU_ICON', instance.menuIcon);
  return val;
}

OFFICEASSETTBLGroupByOutputType _$OFFICEASSETTBLGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    OFFICEASSETTBLGroupByOutputType(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      assetNo: json['ASSET_NO'] as String?,
      assetType: json['ASSET_TYPE'] as String?,
      seller: json['SELLER'] as String?,
      buyDate: json['BUY_DATE'] as String?,
      modelNo: json['MODEL_NO'] as String?,
      serialNo: json['SERIAL_NO'] as String?,
      amount: json['AMOUNT'] as int?,
      keepYear: (json['KEEP_YEAR'] as num?)?.toDouble(),
      mngDept: json['MNG_DEPT'] as String?,
      assetAccount: json['ASSET_ACCOUNT'] as String?,
      remarks: json['REMARKS'] as String?,
      carryOut: json['CARRY_OUT'] as String?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$OFFICEASSETTBLGroupByOutputTypeToJson(
    OFFICEASSETTBLGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  writeNotNull('ASSET_NO', instance.assetNo);
  writeNotNull('ASSET_TYPE', instance.assetType);
  writeNotNull('SELLER', instance.seller);
  writeNotNull('BUY_DATE', instance.buyDate);
  writeNotNull('MODEL_NO', instance.modelNo);
  writeNotNull('SERIAL_NO', instance.serialNo);
  writeNotNull('AMOUNT', instance.amount);
  writeNotNull('KEEP_YEAR', instance.keepYear);
  writeNotNull('MNG_DEPT', instance.mngDept);
  writeNotNull('ASSET_ACCOUNT', instance.assetAccount);
  writeNotNull('REMARKS', instance.remarks);
  writeNotNull('CARRY_OUT', instance.carryOut);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

SERVERASSETTBLGroupByOutputType _$SERVERASSETTBLGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    SERVERASSETTBLGroupByOutputType(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      assetNo: json['ASSET_NO'] as String?,
      assetType: json['ASSET_TYPE'] as String?,
      maker: json['MAKER'] as String?,
      cnt: (json['CNT'] as num?)?.toDouble(),
      amount: json['AMOUNT'] as int?,
      buyDate: json['BUY_DATE'] as String?,
      seller: json['SELLER'] as String?,
      modelNo: json['MODEL_NO'] as String?,
      serialNo: json['SERIAL_NO'] as String?,
      hostname: json['HOSTNAME'] as String?,
      builtLoc: json['BUILT_LOC'] as String?,
      useDesc: json['USE_DESC'] as String?,
      osInfo: json['OS_INFO'] as String?,
      cpuInfo: json['CPU_INFO'] as String?,
      ramInfo: json['RAM_INFO'] as String?,
      hddInfo: json['HDD_INFO'] as String?,
      ssdInfo: json['SSD_INFO'] as String?,
      odd: json['ODD'] as String?,
      remarks: json['REMARKS'] as String?,
      carryOut: json['CARRY_OUT'] as String?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$SERVERASSETTBLGroupByOutputTypeToJson(
    SERVERASSETTBLGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  writeNotNull('ASSET_NO', instance.assetNo);
  writeNotNull('ASSET_TYPE', instance.assetType);
  writeNotNull('MAKER', instance.maker);
  writeNotNull('CNT', instance.cnt);
  writeNotNull('AMOUNT', instance.amount);
  writeNotNull('BUY_DATE', instance.buyDate);
  writeNotNull('SELLER', instance.seller);
  writeNotNull('MODEL_NO', instance.modelNo);
  writeNotNull('SERIAL_NO', instance.serialNo);
  writeNotNull('HOSTNAME', instance.hostname);
  writeNotNull('BUILT_LOC', instance.builtLoc);
  writeNotNull('USE_DESC', instance.useDesc);
  writeNotNull('OS_INFO', instance.osInfo);
  writeNotNull('CPU_INFO', instance.cpuInfo);
  writeNotNull('RAM_INFO', instance.ramInfo);
  writeNotNull('HDD_INFO', instance.hddInfo);
  writeNotNull('SSD_INFO', instance.ssdInfo);
  writeNotNull('ODD', instance.odd);
  writeNotNull('REMARKS', instance.remarks);
  writeNotNull('CARRY_OUT', instance.carryOut);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

SOFTWAREASSETTBLGroupByOutputType _$SOFTWAREASSETTBLGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    SOFTWAREASSETTBLGroupByOutputType(
      seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
      assetNo: json['ASSET_NO'] as String?,
      softwareNm: json['SOFTWARE_NM'] as String?,
      versionNm: json['VERSION_NM'] as String?,
      cnt: (json['CNT'] as num?)?.toDouble(),
      amount: json['AMOUNT'] as int?,
      buyDate: json['BUY_DATE'] as String?,
      serialNo: json['SERIAL_NO'] as String?,
      licenseNo: json['LICENSE_NO'] as String?,
      userNm: json['USER_NM'] as String?,
      remarks: json['REMARKS'] as String?,
      useYn: json['USE_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      updDate: _$JsonConverterFromJson<String, DateTime>(
          json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
    );

Map<String, dynamic> _$SOFTWAREASSETTBLGroupByOutputTypeToJson(
    SOFTWAREASSETTBLGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq?.toString());
  writeNotNull('ASSET_NO', instance.assetNo);
  writeNotNull('SOFTWARE_NM', instance.softwareNm);
  writeNotNull('VERSION_NM', instance.versionNm);
  writeNotNull('CNT', instance.cnt);
  writeNotNull('AMOUNT', instance.amount);
  writeNotNull('BUY_DATE', instance.buyDate);
  writeNotNull('SERIAL_NO', instance.serialNo);
  writeNotNull('LICENSE_NO', instance.licenseNo);
  writeNotNull('USER_NM', instance.userNm);
  writeNotNull('REMARKS', instance.remarks);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  return val;
}

STADMINMENUGroupByOutputType _$STADMINMENUGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    STADMINMENUGroupByOutputType(
      menuCd: json['MENU_CD'] as String?,
      menuNm: json['MENU_NM'] as String?,
      menuPath: json['MENU_PATH'] as String?,
      menuSrt: json['MENU_SRT'] as int?,
      menuDeps: json['MENU_DEPS'] as int?,
      menuIcon: json['MENU_ICON'] as String?,
      menuTp: json['MENU_TP'] as String?,
      regId: json['REG_ID'] as String?,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STADMINMENUGroupByOutputTypeToJson(
    STADMINMENUGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_CD', instance.menuCd);
  writeNotNull('MENU_NM', instance.menuNm);
  writeNotNull('MENU_PATH', instance.menuPath);
  writeNotNull('MENU_SRT', instance.menuSrt);
  writeNotNull('MENU_DEPS', instance.menuDeps);
  writeNotNull('MENU_ICON', instance.menuIcon);
  writeNotNull('MENU_TP', instance.menuTp);
  writeNotNull('REG_ID', instance.regId);
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STALARMGroupByOutputType _$STALARMGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    STALARMGroupByOutputType(
      seq: json['SEQ'] as int?,
      msgCd: json['MSG_CD'] as String?,
      msgCnts: json['MSG_CNTS'] as String?,
      sendDate: json['SEND_DATE'] as String?,
      sendDiv: json['SEND_DIV'] as String?,
      sendDeptCd: json['SEND_DEPT_CD'] as String?,
      sendId: json['SEND_ID'] as String?,
      recvId: json['RECV_ID'] as String?,
      popYn: json['POP_YN'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
    );

Map<String, dynamic> _$STALARMGroupByOutputTypeToJson(
    STALARMGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq);
  writeNotNull('MSG_CD', instance.msgCd);
  writeNotNull('MSG_CNTS', instance.msgCnts);
  writeNotNull('SEND_DATE', instance.sendDate);
  writeNotNull('SEND_DIV', instance.sendDiv);
  writeNotNull('SEND_DEPT_CD', instance.sendDeptCd);
  writeNotNull('SEND_ID', instance.sendId);
  writeNotNull('RECV_ID', instance.recvId);
  writeNotNull('POP_YN', instance.popYn);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  return val;
}

STAUDITLOGGroupByOutputType _$STAUDITLOGGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    STAUDITLOGGroupByOutputType(
      seq: json['SEQ'] as int?,
      logCode: json['LOG_CODE'] as String?,
      logCnts: json['LOG_CNTS'] as String?,
      errCode: json['ERR_CODE'] as String?,
      regId: json['REG_ID'] as String?,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STAUDITLOGGroupByOutputTypeToJson(
    STAUDITLOGGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq);
  writeNotNull('LOG_CODE', instance.logCode);
  writeNotNull('LOG_CNTS', instance.logCnts);
  writeNotNull('ERR_CODE', instance.errCode);
  writeNotNull('REG_ID', instance.regId);
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STBANNERGroupByOutputType _$STBANNERGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    STBANNERGroupByOutputType(
      bannerCd: json['BANNER_CD'] as String?,
      lkUrl: json['LK_URL'] as String?,
      lkTarget: json['LK_TARGET'] as String?,
      flpth: json['FLPTH'] as String?,
      fileNm: json['FILE_NM'] as String?,
      useYn: json['USE_YN'] as String?,
      regId: json['REG_ID'] as String?,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STBANNERGroupByOutputTypeToJson(
    STBANNERGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BANNER_CD', instance.bannerCd);
  writeNotNull('LK_URL', instance.lkUrl);
  writeNotNull('LK_TARGET', instance.lkTarget);
  writeNotNull('FLPTH', instance.flpth);
  writeNotNull('FILE_NM', instance.fileNm);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('REG_ID', instance.regId);
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STBOARDCOLUMNGroupByOutputType _$STBOARDCOLUMNGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    STBOARDCOLUMNGroupByOutputType(
      boardCd: json['BOARD_CD'] as String?,
      sort: json['SORT'] as int?,
      colCd: json['COL_CD'] as String?,
      colNm: json['COL_NM'] as String?,
      regId: json['REG_ID'] as String?,
      regDate: json['REG_DATE'] as String?,
    );

Map<String, dynamic> _$STBOARDCOLUMNGroupByOutputTypeToJson(
    STBOARDCOLUMNGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_CD', instance.boardCd);
  writeNotNull('SORT', instance.sort);
  writeNotNull('COL_CD', instance.colCd);
  writeNotNull('COL_NM', instance.colNm);
  writeNotNull('REG_ID', instance.regId);
  writeNotNull('REG_DATE', instance.regDate);
  return val;
}

STBOARDCOLUMNDFTGroupByOutputType _$STBOARDCOLUMNDFTGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    STBOARDCOLUMNDFTGroupByOutputType(
      boardTy: json['BOARD_TY'] as String?,
      sort: json['SORT'] as int?,
      colCd: json['COL_CD'] as String?,
      colNm: json['COL_NM'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$STBOARDCOLUMNDFTGroupByOutputTypeToJson(
    STBOARDCOLUMNDFTGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_TY', instance.boardTy);
  writeNotNull('SORT', instance.sort);
  writeNotNull('COL_CD', instance.colCd);
  writeNotNull('COL_NM', instance.colNm);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

STBOARDCOMMENTGroupByOutputType _$STBOARDCOMMENTGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    STBOARDCOMMENTGroupByOutputType(
      seq: json['SEQ'] as int?,
      mseq: json['MSEQ'] as int?,
      boardCd: json['BOARD_CD'] as String?,
      cnts: json['CNTS'] as String?,
      upperSeq: json['UPPER_SEQ'] as int?,
      replyYn: json['REPLY_YN'] as String?,
      regAdminYn: json['REG_ADMIN_YN'] as String?,
      regId: json['REG_ID'] as String?,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STBOARDCOMMENTGroupByOutputTypeToJson(
    STBOARDCOMMENTGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq);
  writeNotNull('MSEQ', instance.mseq);
  writeNotNull('BOARD_CD', instance.boardCd);
  writeNotNull('CNTS', instance.cnts);
  writeNotNull('UPPER_SEQ', instance.upperSeq);
  writeNotNull('REPLY_YN', instance.replyYn);
  writeNotNull('REG_ADMIN_YN', instance.regAdminYn);
  writeNotNull('REG_ID', instance.regId);
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STBOARDFILEGroupByOutputType _$STBOARDFILEGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    STBOARDFILEGroupByOutputType(
      seq: json['SEQ'] as int?,
      mseq: json['MSEQ'] as int?,
      boardCd: json['BOARD_CD'] as String?,
      fileTp: json['FILE_TP'] as String?,
      flpth: json['FLPTH'] as String?,
      orginalFileNm: json['ORGINAL_FILE_NM'] as String?,
      streFileNm: json['STRE_FILE_NM'] as String?,
      fileSize: json['FILE_SIZE'] as int?,
      repreYn: json['REPRE_YN'] as String?,
      dwldCo: json['DWLD_CO'] as int?,
    );

Map<String, dynamic> _$STBOARDFILEGroupByOutputTypeToJson(
    STBOARDFILEGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq);
  writeNotNull('MSEQ', instance.mseq);
  writeNotNull('BOARD_CD', instance.boardCd);
  writeNotNull('FILE_TP', instance.fileTp);
  writeNotNull('FLPTH', instance.flpth);
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm);
  writeNotNull('STRE_FILE_NM', instance.streFileNm);
  writeNotNull('FILE_SIZE', instance.fileSize);
  writeNotNull('REPRE_YN', instance.repreYn);
  writeNotNull('DWLD_CO', instance.dwldCo);
  return val;
}

STBOARDMSTGroupByOutputType _$STBOARDMSTGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    STBOARDMSTGroupByOutputType(
      seq: json['SEQ'] as int?,
      boardCd: json['BOARD_CD'] as String?,
      clsCd: json['CLS_CD'] as String?,
      ttl: json['TTL'] as String?,
      cnts: json['CNTS'] as String?,
      fileYn: json['FILE_YN'] as String?,
      imageYn: json['IMAGE_YN'] as String?,
      noticeYn: json['NOTICE_YN'] as String?,
      lkUrl: json['LK_URL'] as String?,
      lkTarget: json['LK_TARGET'] as String?,
      readCnt: json['READ_CNT'] as int?,
      regAdminYn: json['REG_ADMIN_YN'] as String?,
      replyYn: json['REPLY_YN'] as String?,
      upperSeq: json['UPPER_SEQ'] as int?,
      regId: json['REG_ID'] as String?,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STBOARDMSTGroupByOutputTypeToJson(
    STBOARDMSTGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq);
  writeNotNull('BOARD_CD', instance.boardCd);
  writeNotNull('CLS_CD', instance.clsCd);
  writeNotNull('TTL', instance.ttl);
  writeNotNull('CNTS', instance.cnts);
  writeNotNull('FILE_YN', instance.fileYn);
  writeNotNull('IMAGE_YN', instance.imageYn);
  writeNotNull('NOTICE_YN', instance.noticeYn);
  writeNotNull('LK_URL', instance.lkUrl);
  writeNotNull('LK_TARGET', instance.lkTarget);
  writeNotNull('READ_CNT', instance.readCnt);
  writeNotNull('REG_ADMIN_YN', instance.regAdminYn);
  writeNotNull('REPLY_YN', instance.replyYn);
  writeNotNull('UPPER_SEQ', instance.upperSeq);
  writeNotNull('REG_ID', instance.regId);
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STBOARDSTNGGroupByOutputType _$STBOARDSTNGGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    STBOARDSTNGGroupByOutputType(
      boardCd: json['BOARD_CD'] as String?,
      boardNm: json['BOARD_NM'] as String?,
      boardTy: json['BOARD_TY'] as String?,
      editorYn: json['EDITOR_YN'] as String?,
      rlsYn: json['RLS_YN'] as String?,
      cclSeq: json['CCL_SEQ'] as int?,
      listCnt: json['LIST_CNT'] as int?,
      writeYn: json['WRITE_YN'] as String?,
      commentYn: json['COMMENT_YN'] as String?,
      replyYn: json['REPLY_YN'] as String?,
      attachYn: json['ATTACH_YN'] as String?,
      attachSize: json['ATTACH_SIZE'] as String?,
      attachCnt: json['ATTACH_CNT'] as String?,
      attachExt: json['ATTACH_EXT'] as String?,
      regId: json['REG_ID'] as String?,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STBOARDSTNGGroupByOutputTypeToJson(
    STBOARDSTNGGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('BOARD_CD', instance.boardCd);
  writeNotNull('BOARD_NM', instance.boardNm);
  writeNotNull('BOARD_TY', instance.boardTy);
  writeNotNull('EDITOR_YN', instance.editorYn);
  writeNotNull('RLS_YN', instance.rlsYn);
  writeNotNull('CCL_SEQ', instance.cclSeq);
  writeNotNull('LIST_CNT', instance.listCnt);
  writeNotNull('WRITE_YN', instance.writeYn);
  writeNotNull('COMMENT_YN', instance.commentYn);
  writeNotNull('REPLY_YN', instance.replyYn);
  writeNotNull('ATTACH_YN', instance.attachYn);
  writeNotNull('ATTACH_SIZE', instance.attachSize);
  writeNotNull('ATTACH_CNT', instance.attachCnt);
  writeNotNull('ATTACH_EXT', instance.attachExt);
  writeNotNull('REG_ID', instance.regId);
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STCCLGroupByOutputType _$STCCLGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    STCCLGroupByOutputType(
      seq: json['SEQ'] as int?,
      cclType: json['CCL_TYPE'] as String?,
      cclNm: json['CCL_NM'] as String?,
      flpth: json['FLPTH'] as String?,
      orginalFileNm: json['ORGINAL_FILE_NM'] as String?,
      streFileNm: json['STRE_FILE_NM'] as String?,
      fileExtsn: json['FILE_EXTSN'] as String?,
      fileSize: json['FILE_SIZE'] as int?,
      regId: json['REG_ID'] as String?,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STCCLGroupByOutputTypeToJson(
    STCCLGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq);
  writeNotNull('CCL_TYPE', instance.cclType);
  writeNotNull('CCL_NM', instance.cclNm);
  writeNotNull('FLPTH', instance.flpth);
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm);
  writeNotNull('STRE_FILE_NM', instance.streFileNm);
  writeNotNull('FILE_EXTSN', instance.fileExtsn);
  writeNotNull('FILE_SIZE', instance.fileSize);
  writeNotNull('REG_ID', instance.regId);
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STCODEMSTGroupByOutputType _$STCODEMSTGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    STCODEMSTGroupByOutputType(
      cdGrp: json['CD_GRP'] as String?,
      cdKey: json['CD_KEY'] as String?,
      cdVal: json['CD_VAL'] as String?,
      cdDesc: json['CD_DESC'] as String?,
      cdSrt: json['CD_SRT'] as int?,
      depth: json['DEPTH'] as int?,
      regId: json['REG_ID'] as String?,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STCODEMSTGroupByOutputTypeToJson(
    STCODEMSTGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('CD_GRP', instance.cdGrp);
  writeNotNull('CD_KEY', instance.cdKey);
  writeNotNull('CD_VAL', instance.cdVal);
  writeNotNull('CD_DESC', instance.cdDesc);
  writeNotNull('CD_SRT', instance.cdSrt);
  writeNotNull('DEPTH', instance.depth);
  writeNotNull('REG_ID', instance.regId);
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STCONNECTLOGGroupByOutputType _$STCONNECTLOGGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    STCONNECTLOGGroupByOutputType(
      seq: json['SEQ'] as int?,
      userId: json['USER_ID'] as String?,
      connType: json['CONN_TYPE'] as String?,
      osType: json['OS_TYPE'] as String?,
      browserType: json['BROWSER_TYPE'] as String?,
      conneIp: json['CONNE_IP'] as String?,
      regDate: json['REG_DATE'] as String?,
    );

Map<String, dynamic> _$STCONNECTLOGGroupByOutputTypeToJson(
    STCONNECTLOGGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq);
  writeNotNull('USER_ID', instance.userId);
  writeNotNull('CONN_TYPE', instance.connType);
  writeNotNull('OS_TYPE', instance.osType);
  writeNotNull('BROWSER_TYPE', instance.browserType);
  writeNotNull('CONNE_IP', instance.conneIp);
  writeNotNull('REG_DATE', instance.regDate);
  return val;
}

STCONTENTSFILEGroupByOutputType _$STCONTENTSFILEGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    STCONTENTSFILEGroupByOutputType(
      seq: json['SEQ'] as int?,
      mseq: json['MSEQ'] as String?,
      fileTp: json['FILE_TP'] as String?,
      flpth: json['FLPTH'] as String?,
      orginalFileNm: json['ORGINAL_FILE_NM'] as String?,
      streFileNm: json['STRE_FILE_NM'] as String?,
      fileSize: json['FILE_SIZE'] as int?,
    );

Map<String, dynamic> _$STCONTENTSFILEGroupByOutputTypeToJson(
    STCONTENTSFILEGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq);
  writeNotNull('MSEQ', instance.mseq);
  writeNotNull('FILE_TP', instance.fileTp);
  writeNotNull('FLPTH', instance.flpth);
  writeNotNull('ORGINAL_FILE_NM', instance.orginalFileNm);
  writeNotNull('STRE_FILE_NM', instance.streFileNm);
  writeNotNull('FILE_SIZE', instance.fileSize);
  return val;
}

STCONTENTSMSTGroupByOutputType _$STCONTENTSMSTGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    STCONTENTSMSTGroupByOutputType(
      seq: json['SEQ'] as int?,
      cntsNm: json['CNTS_NM'] as String?,
      pubDate: json['PUB_DATE'] as String?,
      pubState: json['PUB_STATE'] as String?,
      cn: json['CN'] as String?,
      srchYn: json['SRCH_YN'] as String?,
      fileYn: json['FILE_YN'] as String?,
      imageYn: json['IMAGE_YN'] as String?,
      regId: json['REG_ID'] as String?,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STCONTENTSMSTGroupByOutputTypeToJson(
    STCONTENTSMSTGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq);
  writeNotNull('CNTS_NM', instance.cntsNm);
  writeNotNull('PUB_DATE', instance.pubDate);
  writeNotNull('PUB_STATE', instance.pubState);
  writeNotNull('CN', instance.cn);
  writeNotNull('SRCH_YN', instance.srchYn);
  writeNotNull('FILE_YN', instance.fileYn);
  writeNotNull('IMAGE_YN', instance.imageYn);
  writeNotNull('REG_ID', instance.regId);
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STDEPTGroupByOutputType _$STDEPTGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    STDEPTGroupByOutputType(
      deptCd: json['DEPT_CD'] as String?,
      deptNm: json['DEPT_NM'] as String?,
      upperDeptCd: json['UPPER_DEPT_CD'] as String?,
      upperDeptNm: json['UPPER_DEPT_NM'] as String?,
      sort: json['SORT'] as int?,
      mainYn: json['MAIN_YN'] as String?,
      deptDesc: json['DEPT_DESC'] as String?,
      regId: json['REG_ID'] as String?,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STDEPTGroupByOutputTypeToJson(
    STDEPTGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('DEPT_CD', instance.deptCd);
  writeNotNull('DEPT_NM', instance.deptNm);
  writeNotNull('UPPER_DEPT_CD', instance.upperDeptCd);
  writeNotNull('UPPER_DEPT_NM', instance.upperDeptNm);
  writeNotNull('SORT', instance.sort);
  writeNotNull('MAIN_YN', instance.mainYn);
  writeNotNull('DEPT_DESC', instance.deptDesc);
  writeNotNull('REG_ID', instance.regId);
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STDEPTEMPGroupByOutputType _$STDEPTEMPGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    STDEPTEMPGroupByOutputType(
      empNo: json['EMP_NO'] as String?,
      empNm: json['EMP_NM'] as String?,
      deptCd: json['DEPT_CD'] as String?,
      deptNm: json['DEPT_NM'] as String?,
      fctnCd: json['FCTN_CD'] as String?,
      fctnNm: json['FCTN_NM'] as String?,
      ofcpCd: json['OFCP_CD'] as String?,
      ofcpNm: json['OFCP_NM'] as String?,
      emailAddr: json['EMAIL_ADDR'] as String?,
      offmTelno: json['OFFM_TELNO'] as String?,
      htelTelno: json['HTEL_TELNO'] as String?,
      deptYn: json['DEPT_YN'] as String?,
      regId: json['REG_ID'] as String?,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STDEPTEMPGroupByOutputTypeToJson(
    STDEPTEMPGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('EMP_NO', instance.empNo);
  writeNotNull('EMP_NM', instance.empNm);
  writeNotNull('DEPT_CD', instance.deptCd);
  writeNotNull('DEPT_NM', instance.deptNm);
  writeNotNull('FCTN_CD', instance.fctnCd);
  writeNotNull('FCTN_NM', instance.fctnNm);
  writeNotNull('OFCP_CD', instance.ofcpCd);
  writeNotNull('OFCP_NM', instance.ofcpNm);
  writeNotNull('EMAIL_ADDR', instance.emailAddr);
  writeNotNull('OFFM_TELNO', instance.offmTelno);
  writeNotNull('HTEL_TELNO', instance.htelTelno);
  writeNotNull('DEPT_YN', instance.deptYn);
  writeNotNull('REG_ID', instance.regId);
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STMENUGroupByOutputType _$STMENUGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    STMENUGroupByOutputType(
      menuCd: json['MENU_CD'] as String?,
      menuNm: json['MENU_NM'] as String?,
      menuPath: json['MENU_PATH'] as String?,
      menuMapping: json['MENU_MAPPING'] as String?,
      menuSrt: json['MENU_SRT'] as int?,
      menuDeps: json['MENU_DEPS'] as int?,
      menuIcon: json['MENU_ICON'] as String?,
      menuTp: json['MENU_TP'] as String?,
      mainExpsrYn: json['MAIN_EXPSR_YN'] as String?,
      subExpsrYn: json['SUB_EXPSR_YN'] as String?,
      upendClas: json['UPEND_CLAS'] as String?,
      upendCn: json['UPEND_CN'] as String?,
      cclType: json['CCL_TYPE'] as String?,
      regId: json['REG_ID'] as String?,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STMENUGroupByOutputTypeToJson(
    STMENUGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MENU_CD', instance.menuCd);
  writeNotNull('MENU_NM', instance.menuNm);
  writeNotNull('MENU_PATH', instance.menuPath);
  writeNotNull('MENU_MAPPING', instance.menuMapping);
  writeNotNull('MENU_SRT', instance.menuSrt);
  writeNotNull('MENU_DEPS', instance.menuDeps);
  writeNotNull('MENU_ICON', instance.menuIcon);
  writeNotNull('MENU_TP', instance.menuTp);
  writeNotNull('MAIN_EXPSR_YN', instance.mainExpsrYn);
  writeNotNull('SUB_EXPSR_YN', instance.subExpsrYn);
  writeNotNull('UPEND_CLAS', instance.upendClas);
  writeNotNull('UPEND_CN', instance.upendCn);
  writeNotNull('CCL_TYPE', instance.cclType);
  writeNotNull('REG_ID', instance.regId);
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STMESSAGETMPLATGroupByOutputType _$STMESSAGETMPLATGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    STMESSAGETMPLATGroupByOutputType(
      msgDivCd: json['MSG_DIV_CD'] as String?,
      msgCd: json['MSG_CD'] as String?,
      msgNm: json['MSG_NM'] as String?,
      msgTmplat: json['MSG_TMPLAT'] as String?,
      useYn: json['USE_YN'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
    );

Map<String, dynamic> _$STMESSAGETMPLATGroupByOutputTypeToJson(
    STMESSAGETMPLATGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MSG_DIV_CD', instance.msgDivCd);
  writeNotNull('MSG_CD', instance.msgCd);
  writeNotNull('MSG_NM', instance.msgNm);
  writeNotNull('MSG_TMPLAT', instance.msgTmplat);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  return val;
}

STMIMETYPEGroupByOutputType _$STMIMETYPEGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    STMIMETYPEGroupByOutputType(
      seq: json['SEQ'] as int?,
      extnNm: json['EXTN_NM'] as String?,
      fileMt: json['FILE_MT'] as String?,
    );

Map<String, dynamic> _$STMIMETYPEGroupByOutputTypeToJson(
    STMIMETYPEGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq);
  writeNotNull('EXTN_NM', instance.extnNm);
  writeNotNull('FILE_MT', instance.fileMt);
  return val;
}

STMNGRGRPGroupByOutputType _$STMNGRGRPGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    STMNGRGRPGroupByOutputType(
      grpCd: json['GRP_CD'] as String?,
      grpNm: json['GRP_NM'] as String?,
      grpDesc: json['GRP_DESC'] as String?,
      sort: json['SORT'] as int?,
      regId: json['REG_ID'] as String?,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STMNGRGRPGroupByOutputTypeToJson(
    STMNGRGRPGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('GRP_CD', instance.grpCd);
  writeNotNull('GRP_NM', instance.grpNm);
  writeNotNull('GRP_DESC', instance.grpDesc);
  writeNotNull('SORT', instance.sort);
  writeNotNull('REG_ID', instance.regId);
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STMNGRMSTGroupByOutputType _$STMNGRMSTGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    STMNGRMSTGroupByOutputType(
      mngrId: json['MNGR_ID'] as String?,
      mngrNm: json['MNGR_NM'] as String?,
      mngrPw: json['MNGR_PW'] as String?,
      grpCd: json['GRP_CD'] as String?,
      grade: json['GRADE'] as String?,
      permCd: json['PERM_CD'] as String?,
      acsYn: json['ACS_YN'] as String?,
      clph: json['CLPH'] as String?,
      empNo: json['EMP_NO'] as String?,
      joinDate: json['JOIN_DATE'] as String?,
      retireDate: _$JsonConverterFromJson<String, DateTime>(
          json['RETIRE_DATE'], const DateTimeJsonConverter().fromJson),
      pwdChgDate: _$JsonConverterFromJson<String, DateTime>(
          json['PWD_CHG_DATE'], const DateTimeJsonConverter().fromJson),
      pwdWrongCnt: json['PWD_WRONG_CNT'] as int?,
      pwdWrongDate: json['PWD_WRONG_DATE'] as String?,
      lstLoginDate: json['LST_LOGIN_DATE'] as String?,
      flpth: json['FLPTH'] as String?,
      fileNm: json['FILE_NM'] as String?,
      regId: json['REG_ID'] as String?,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STMNGRMSTGroupByOutputTypeToJson(
    STMNGRMSTGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('MNGR_ID', instance.mngrId);
  writeNotNull('MNGR_NM', instance.mngrNm);
  writeNotNull('MNGR_PW', instance.mngrPw);
  writeNotNull('GRP_CD', instance.grpCd);
  writeNotNull('GRADE', instance.grade);
  writeNotNull('PERM_CD', instance.permCd);
  writeNotNull('ACS_YN', instance.acsYn);
  writeNotNull('CLPH', instance.clph);
  writeNotNull('EMP_NO', instance.empNo);
  writeNotNull('JOIN_DATE', instance.joinDate);
  writeNotNull(
      'RETIRE_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.retireDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'PWD_CHG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.pwdChgDate, const DateTimeJsonConverter().toJson));
  writeNotNull('PWD_WRONG_CNT', instance.pwdWrongCnt);
  writeNotNull('PWD_WRONG_DATE', instance.pwdWrongDate);
  writeNotNull('LST_LOGIN_DATE', instance.lstLoginDate);
  writeNotNull('FLPTH', instance.flpth);
  writeNotNull('FILE_NM', instance.fileNm);
  writeNotNull('REG_ID', instance.regId);
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STMYSTNGGroupByOutputType _$STMYSTNGGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    STMYSTNGGroupByOutputType(
      userId: json['USER_ID'] as String?,
      stngCd: json['STNG_CD'] as String?,
      userDiv: json['USER_DIV'] as String?,
      stngData: json['STNG_DATA'] as String?,
    );

Map<String, dynamic> _$STMYSTNGGroupByOutputTypeToJson(
    STMYSTNGGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', instance.userId);
  writeNotNull('STNG_CD', instance.stngCd);
  writeNotNull('USER_DIV', instance.userDiv);
  writeNotNull('STNG_DATA', instance.stngData);
  return val;
}

STPERMDTLGroupByOutputType _$STPERMDTLGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    STPERMDTLGroupByOutputType(
      permCd: json['PERM_CD'] as String?,
      menuCd: json['MENU_CD'] as String?,
      readYn: json['READ_YN'] as String?,
      regYn: json['REG_YN'] as String?,
      mdfcnYn: json['MDFCN_YN'] as String?,
      delYn: json['DEL_YN'] as String?,
      manageYn: json['MANAGE_YN'] as String?,
      regId: json['REG_ID'] as String?,
      regDate: json['REG_DATE'] as String?,
    );

Map<String, dynamic> _$STPERMDTLGroupByOutputTypeToJson(
    STPERMDTLGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('PERM_CD', instance.permCd);
  writeNotNull('MENU_CD', instance.menuCd);
  writeNotNull('READ_YN', instance.readYn);
  writeNotNull('REG_YN', instance.regYn);
  writeNotNull('MDFCN_YN', instance.mdfcnYn);
  writeNotNull('DEL_YN', instance.delYn);
  writeNotNull('MANAGE_YN', instance.manageYn);
  writeNotNull('REG_ID', instance.regId);
  writeNotNull('REG_DATE', instance.regDate);
  return val;
}

STPERMMSTGroupByOutputType _$STPERMMSTGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    STPERMMSTGroupByOutputType(
      permCd: json['PERM_CD'] as String?,
      permNm: json['PERM_NM'] as String?,
      sort: json['SORT'] as String?,
      regId: json['REG_ID'] as String?,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STPERMMSTGroupByOutputTypeToJson(
    STPERMMSTGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('PERM_CD', instance.permCd);
  writeNotNull('PERM_NM', instance.permNm);
  writeNotNull('SORT', instance.sort);
  writeNotNull('REG_ID', instance.regId);
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STPOPUPGroupByOutputType _$STPOPUPGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    STPOPUPGroupByOutputType(
      popCd: json['POP_CD'] as String?,
      popNm: json['POP_NM'] as String?,
      popTy: json['POP_TY'] as String?,
      imgText: json['IMG_TEXT'] as String?,
      lkUrl: json['LK_URL'] as String?,
      lkTarget: json['LK_TARGET'] as String?,
      bgngDate: json['BGNG_DATE'] as String?,
      endDate: json['END_DATE'] as String?,
      spwgPred: json['SPWG_PRED'] as String?,
      flpth: json['FLPTH'] as String?,
      fileNm: json['FILE_NM'] as String?,
      useYn: json['USE_YN'] as String?,
      beforeCd: json['BEFORE_CD'] as String?,
      regId: json['REG_ID'] as String?,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STPOPUPGroupByOutputTypeToJson(
    STPOPUPGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('POP_CD', instance.popCd);
  writeNotNull('POP_NM', instance.popNm);
  writeNotNull('POP_TY', instance.popTy);
  writeNotNull('IMG_TEXT', instance.imgText);
  writeNotNull('LK_URL', instance.lkUrl);
  writeNotNull('LK_TARGET', instance.lkTarget);
  writeNotNull('BGNG_DATE', instance.bgngDate);
  writeNotNull('END_DATE', instance.endDate);
  writeNotNull('SPWG_PRED', instance.spwgPred);
  writeNotNull('FLPTH', instance.flpth);
  writeNotNull('FILE_NM', instance.fileNm);
  writeNotNull('USE_YN', instance.useYn);
  writeNotNull('BEFORE_CD', instance.beforeCd);
  writeNotNull('REG_ID', instance.regId);
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

STSTNGGroupByOutputType _$STSTNGGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    STSTNGGroupByOutputType(
      stngCd: json['STNG_CD'] as String?,
      stngData: json['STNG_DATA'] as String?,
      title: json['TITLE'] as String?,
      descCn: json['DESC_CN'] as String?,
      sort: json['SORT'] as int?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
    );

Map<String, dynamic> _$STSTNGGroupByOutputTypeToJson(
    STSTNGGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('STNG_CD', instance.stngCd);
  writeNotNull('STNG_DATA', instance.stngData);
  writeNotNull('TITLE', instance.title);
  writeNotNull('DESC_CN', instance.descCn);
  writeNotNull('SORT', instance.sort);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  return val;
}

STUSERMSTGroupByOutputType _$STUSERMSTGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    STUSERMSTGroupByOutputType(
      userId: json['USER_ID'] as String?,
      userNm: json['USER_NM'] as String?,
      userPw: json['USER_PW'] as String?,
      userDiv: json['USER_DIV'] as String?,
      status: json['STATUS'] as String?,
      prevLoginYn: json['PREV_LOGIN_YN'] as String?,
      withdrawnYn: json['WITHDRAWN_YN'] as String?,
      clph: json['CLPH'] as String?,
      email: json['EMAIL'] as String?,
      lstLoginDate: json['LST_LOGIN_DATE'] as String?,
      regId: json['REG_ID'] as String?,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$STUSERMSTGroupByOutputTypeToJson(
    STUSERMSTGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('USER_ID', instance.userId);
  writeNotNull('USER_NM', instance.userNm);
  writeNotNull('USER_PW', instance.userPw);
  writeNotNull('USER_DIV', instance.userDiv);
  writeNotNull('STATUS', instance.status);
  writeNotNull('PREV_LOGIN_YN', instance.prevLoginYn);
  writeNotNull('WITHDRAWN_YN', instance.withdrawnYn);
  writeNotNull('CLPH', instance.clph);
  writeNotNull('EMAIL', instance.email);
  writeNotNull('LST_LOGIN_DATE', instance.lstLoginDate);
  writeNotNull('REG_ID', instance.regId);
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

WORKREPORTDETAILTBLGroupByOutputType
    _$WORKREPORTDETAILTBLGroupByOutputTypeFromJson(Map<String, dynamic> json) =>
        WORKREPORTDETAILTBLGroupByOutputType(
          reportId: json['REPORT_ID'] as String?,
          seq: json['SEQ'] == null ? null : BigInt.parse(json['SEQ'] as String),
          projectNm: json['PROJECT_NM'] as String?,
          projectSubNm: json['PROJECT_SUB_NM'] as String?,
          detailContent: json['DETAIL_CONTENT'] as String?,
          worker: json['WORKER'] as String?,
          grade: json['GRADE'] as String?,
          processRate: json['PROCESS_RATE'] as String?,
          workDate: json['WORK_DATE'] as String?,
          processType: json['PROCESS_TYPE'] as String?,
          subjectYn: json['SUBJECT_YN'] as String?,
          regUser: json['REG_USER'] as String?,
          regDate: _$JsonConverterFromJson<String, DateTime>(
              json['REG_DATE'], const DateTimeJsonConverter().fromJson),
          completeDate: json['COMPLETE_DATE'] as String?,
        );

Map<String, dynamic> _$WORKREPORTDETAILTBLGroupByOutputTypeToJson(
    WORKREPORTDETAILTBLGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', instance.reportId);
  writeNotNull('SEQ', instance.seq?.toString());
  writeNotNull('PROJECT_NM', instance.projectNm);
  writeNotNull('PROJECT_SUB_NM', instance.projectSubNm);
  writeNotNull('DETAIL_CONTENT', instance.detailContent);
  writeNotNull('WORKER', instance.worker);
  writeNotNull('GRADE', instance.grade);
  writeNotNull('PROCESS_RATE', instance.processRate);
  writeNotNull('WORK_DATE', instance.workDate);
  writeNotNull('PROCESS_TYPE', instance.processType);
  writeNotNull('SUBJECT_YN', instance.subjectYn);
  writeNotNull('REG_USER', instance.regUser);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull('COMPLETE_DATE', instance.completeDate);
  return val;
}

WORKREPORTHTMLTBLGroupByOutputType _$WORKREPORTHTMLTBLGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    WORKREPORTHTMLTBLGroupByOutputType(
      reportId: json['REPORT_ID'] as String?,
      userId: json['USER_ID'] as String?,
      title: json['TITLE'] as String?,
      htmlContent: json['HTML_CONTENT'] as String?,
      regDate: _$JsonConverterFromJson<String, DateTime>(
          json['REG_DATE'], const DateTimeJsonConverter().fromJson),
      delYn: json['DEL_YN'] as String?,
    );

Map<String, dynamic> _$WORKREPORTHTMLTBLGroupByOutputTypeToJson(
    WORKREPORTHTMLTBLGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', instance.reportId);
  writeNotNull('USER_ID', instance.userId);
  writeNotNull('TITLE', instance.title);
  writeNotNull('HTML_CONTENT', instance.htmlContent);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

WORKREPORTHTMLTBLBACKGroupByOutputType
    _$WORKREPORTHTMLTBLBACKGroupByOutputTypeFromJson(
            Map<String, dynamic> json) =>
        WORKREPORTHTMLTBLBACKGroupByOutputType(
          reportId: json['REPORT_ID'] as String?,
          userId: json['USER_ID'] as String?,
          title: json['TITLE'] as String?,
          htmlContent: json['HTML_CONTENT'] as String?,
          regDate: _$JsonConverterFromJson<String, DateTime>(
              json['REG_DATE'], const DateTimeJsonConverter().fromJson),
          delYn: json['DEL_YN'] as String?,
        );

Map<String, dynamic> _$WORKREPORTHTMLTBLBACKGroupByOutputTypeToJson(
    WORKREPORTHTMLTBLBACKGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', instance.reportId);
  writeNotNull('USER_ID', instance.userId);
  writeNotNull('TITLE', instance.title);
  writeNotNull('HTML_CONTENT', instance.htmlContent);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

WORKREPORTMASTERTBLGroupByOutputType
    _$WORKREPORTMASTERTBLGroupByOutputTypeFromJson(Map<String, dynamic> json) =>
        WORKREPORTMASTERTBLGroupByOutputType(
          reportId: json['REPORT_ID'] as String?,
          title: json['TITLE'] as String?,
          dept: json['DEPT'] as String?,
          regDate: _$JsonConverterFromJson<String, DateTime>(
              json['REG_DATE'], const DateTimeJsonConverter().fromJson),
          updDate: _$JsonConverterFromJson<String, DateTime>(
              json['UPD_DATE'], const DateTimeJsonConverter().fromJson),
          delYn: json['DEL_YN'] as String?,
        );

Map<String, dynamic> _$WORKREPORTMASTERTBLGroupByOutputTypeToJson(
    WORKREPORTMASTERTBLGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('REPORT_ID', instance.reportId);
  writeNotNull('TITLE', instance.title);
  writeNotNull('DEPT', instance.dept);
  writeNotNull(
      'REG_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.regDate, const DateTimeJsonConverter().toJson));
  writeNotNull(
      'UPD_DATE',
      _$JsonConverterToJson<String, DateTime>(
          instance.updDate, const DateTimeJsonConverter().toJson));
  writeNotNull('DEL_YN', instance.delYn);
  return val;
}

WORKREQUESTMSTGroupByOutputType _$WORKREQUESTMSTGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    WORKREQUESTMSTGroupByOutputType(
      seq: json['SEQ'] as int?,
      rqstrDpnm: json['RQSTR_DPNM'] as String?,
      rqstrNm: json['RQSTR_NM'] as String?,
      rqstrId: json['RQSTR_ID'] as String?,
      rqstrDate: json['RQSTR_DATE'] as String?,
      hopeDate: json['HOPE_DATE'] as String?,
      chrDprNm: json['CHR_DPR_NM'] as String?,
      chrNm: json['CHR_NM'] as String?,
      chrId: json['CHR_ID'] as String?,
      chrChk: json['CHR_CHK'] as String?,
      title: json['TITLE'] as String?,
      cn: json['CN'] as String?,
      etc: json['ETC'] as String?,
      doc: json['DOC'] as String?,
      regId: json['REG_ID'] as String?,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$WORKREQUESTMSTGroupByOutputTypeToJson(
    WORKREQUESTMSTGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq);
  writeNotNull('RQSTR_DPNM', instance.rqstrDpnm);
  writeNotNull('RQSTR_NM', instance.rqstrNm);
  writeNotNull('RQSTR_ID', instance.rqstrId);
  writeNotNull('RQSTR_DATE', instance.rqstrDate);
  writeNotNull('HOPE_DATE', instance.hopeDate);
  writeNotNull('CHR_DPR_NM', instance.chrDprNm);
  writeNotNull('CHR_NM', instance.chrNm);
  writeNotNull('CHR_ID', instance.chrId);
  writeNotNull('CHR_CHK', instance.chrChk);
  writeNotNull('TITLE', instance.title);
  writeNotNull('CN', instance.cn);
  writeNotNull('ETC', instance.etc);
  writeNotNull('DOC', instance.doc);
  writeNotNull('REG_ID', instance.regId);
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

WORKREQUESTREFGroupByOutputType _$WORKREQUESTREFGroupByOutputTypeFromJson(
        Map<String, dynamic> json) =>
    WORKREQUESTREFGroupByOutputType(
      seq: json['SEQ'] as int?,
      mseq: json['MSEQ'] as int?,
      refId: json['REF_ID'] as String?,
      refNm: json['REF_NM'] as String?,
      refDep: json['REF_DEP'] as String?,
      refGrade: json['REF_GRADE'] as String?,
      regId: json['REG_ID'] as String?,
      regDate: json['REG_DATE'] as String?,
      editId: json['EDIT_ID'] as String?,
      editDate: json['EDIT_DATE'] as String?,
      delId: json['DEL_ID'] as String?,
      delDate: json['DEL_DATE'] as String?,
    );

Map<String, dynamic> _$WORKREQUESTREFGroupByOutputTypeToJson(
    WORKREQUESTREFGroupByOutputType instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('SEQ', instance.seq);
  writeNotNull('MSEQ', instance.mseq);
  writeNotNull('REF_ID', instance.refId);
  writeNotNull('REF_NM', instance.refNm);
  writeNotNull('REF_DEP', instance.refDep);
  writeNotNull('REF_GRADE', instance.refGrade);
  writeNotNull('REG_ID', instance.regId);
  writeNotNull('REG_DATE', instance.regDate);
  writeNotNull('EDIT_ID', instance.editId);
  writeNotNull('EDIT_DATE', instance.editDate);
  writeNotNull('DEL_ID', instance.delId);
  writeNotNull('DEL_DATE', instance.delDate);
  return val;
}

AffectedRowsOutput _$AffectedRowsOutputFromJson(Map<String, dynamic> json) =>
    AffectedRowsOutput(
      count: json['count'] as int?,
    );

Map<String, dynamic> _$AffectedRowsOutputToJson(AffectedRowsOutput instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('count', instance.count);
  return val;
}

Map<String, dynamic> _$DatasourcesToJson(Datasources instance) {
  final val = <String, dynamic>{};

  void writeNotNull(String key, dynamic value) {
    if (value != null) {
      val[key] = value;
    }
  }

  writeNotNull('db', instance.db);
  return val;
}
