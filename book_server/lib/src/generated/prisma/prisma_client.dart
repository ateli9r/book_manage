// ignore_for_file: no_leading_underscores_for_library_prefixes
import 'package:json_annotation/json_annotation.dart';
import 'package:orm/binary_engine.dart' as _i5;
import 'package:orm/engine_core.dart' as _i3;
import 'package:orm/graphql.dart' as _i2;
import 'package:orm/logger.dart' as _i4;
import 'package:orm/orm.dart' as _i1;
import 'package:orm/orm.dart' show DateTimeJsonConverter;

part 'prisma_client.g.dart';

enum ALLCODETBLScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('CODE_TYPE')
  codeType(r'CODE_TYPE'),
  @JsonValue('CODE_NAME')
  codeName(r'CODE_NAME'),
  @JsonValue('UNIT_TYPE')
  unitType(r'UNIT_TYPE'),
  @JsonValue('UNIT_NAME')
  unitName(r'UNIT_NAME'),
  @JsonValue('SORT')
  sort(r'SORT'),
  @JsonValue('USE_YN')
  useYn(r'USE_YN'),
  @JsonValue('DEL_YN')
  delYn(r'DEL_YN'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('UPD_DATE')
  updDate(r'UPD_DATE');

  const ALLCODETBLScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum APPROVALATTACHFILETBLScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('APPROVAL_ID')
  approvalId(r'APPROVAL_ID'),
  @JsonValue('SEQ')
  seq(r'SEQ'),
  @JsonValue('ORI_FILE_NM')
  oriFileNm(r'ORI_FILE_NM'),
  @JsonValue('SAVE_FILE_NM')
  saveFileNm(r'SAVE_FILE_NM'),
  @JsonValue('FILE_SIZE')
  fileSize(r'FILE_SIZE'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE');

  const APPROVALATTACHFILETBLScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum APPROVALDOCINFOTBLScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('SEQ')
  seq(r'SEQ'),
  @JsonValue('DOC_TYPE')
  docType(r'DOC_TYPE'),
  @JsonValue('DOC_NM')
  docNm(r'DOC_NM'),
  @JsonValue('TITLE')
  title(r'TITLE'),
  @JsonValue('APPROVAL_LINE_TYPE')
  approvalLineType(r'APPROVAL_LINE_TYPE'),
  @JsonValue('APPROVAL_LINE_CONTENT')
  approvalLineContent(r'APPROVAL_LINE_CONTENT'),
  @JsonValue('APPROVAL_LINE_CONTENT_BAK')
  approvalLineContentBak(r'APPROVAL_LINE_CONTENT_BAK'),
  @JsonValue('CONTENT')
  content(r'CONTENT'),
  @JsonValue('WRITER_ID')
  writerId(r'WRITER_ID'),
  @JsonValue('USER_NM')
  userNm(r'USER_NM'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('UPD_DATE')
  updDate(r'UPD_DATE'),
  @JsonValue('USE_YN')
  useYn(r'USE_YN'),
  @JsonValue('DEL_YN')
  delYn(r'DEL_YN');

  const APPROVALDOCINFOTBLScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum APPROVALHISTORYTBLScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('SEQ')
  seq(r'SEQ'),
  @JsonValue('APPROVAL_ID')
  approvalId(r'APPROVAL_ID'),
  @JsonValue('WRITER_ID')
  writerId(r'WRITER_ID'),
  @JsonValue('WRITER_NM')
  writerNm(r'WRITER_NM'),
  @JsonValue('DOC_TYPE')
  docType(r'DOC_TYPE'),
  @JsonValue('KEEP_PRIOD')
  keepPriod(r'KEEP_PRIOD'),
  @JsonValue('KEEP_DATE')
  keepDate(r'KEEP_DATE'),
  @JsonValue('GRADE')
  grade(r'GRADE'),
  @JsonValue('STATUS')
  status(r'STATUS'),
  @JsonValue('CONTENT')
  content(r'CONTENT'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('UPD_DATE')
  updDate(r'UPD_DATE'),
  @JsonValue('DEL_YN')
  delYn(r'DEL_YN');

  const APPROVALHISTORYTBLScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum APPROVALMASTERTBLScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('APPROVAL_ID')
  approvalId(r'APPROVAL_ID'),
  @JsonValue('WRITER_ID')
  writerId(r'WRITER_ID'),
  @JsonValue('WRITER_NM')
  writerNm(r'WRITER_NM'),
  @JsonValue('DOC_TYPE')
  docType(r'DOC_TYPE'),
  @JsonValue('KEEP_PRIOD')
  keepPriod(r'KEEP_PRIOD'),
  @JsonValue('KEEP_DATE')
  keepDate(r'KEEP_DATE'),
  @JsonValue('GRADE')
  grade(r'GRADE'),
  @JsonValue('STATUS')
  status(r'STATUS'),
  @JsonValue('TITLE')
  title(r'TITLE'),
  @JsonValue('HEADER')
  header(r'HEADER'),
  @JsonValue('CONTENT')
  content(r'CONTENT'),
  @JsonValue('M1')
  m1(r'M1'),
  @JsonValue('M2')
  m2(r'M2'),
  @JsonValue('M3')
  m3(r'M3'),
  @JsonValue('M4')
  m4(r'M4'),
  @JsonValue('M5')
  m5(r'M5'),
  @JsonValue('M6')
  m6(r'M6'),
  @JsonValue('M7')
  m7(r'M7'),
  @JsonValue('M8')
  m8(r'M8'),
  @JsonValue('M9')
  m9(r'M9'),
  @JsonValue('M10')
  m10(r'M10'),
  @JsonValue('M11')
  m11(r'M11'),
  @JsonValue('M12')
  m12(r'M12'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('COMPLETE_DATE')
  completeDate(r'COMPLETE_DATE'),
  @JsonValue('UPD_DATE')
  updDate(r'UPD_DATE'),
  @JsonValue('DEL_YN')
  delYn(r'DEL_YN');

  const APPROVALMASTERTBLScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum APPROVALMEMOTBLScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('SEQ')
  seq(r'SEQ'),
  @JsonValue('APPROVAL_ID')
  approvalId(r'APPROVAL_ID'),
  @JsonValue('WRITER_ID')
  writerId(r'WRITER_ID'),
  @JsonValue('WRITER_NM')
  writerNm(r'WRITER_NM'),
  @JsonValue('CONTENT')
  content(r'CONTENT'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('UPD_DATE')
  updDate(r'UPD_DATE'),
  @JsonValue('DEL_YN')
  delYn(r'DEL_YN');

  const APPROVALMEMOTBLScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum APPROVALTYPETBLScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('TYPE')
  type(r'TYPE'),
  @JsonValue('CONTENT')
  content(r'CONTENT'),
  @JsonValue('CONTENT_BAK')
  contentBak(r'CONTENT_BAK'),
  @JsonValue('USE_YN')
  useYn(r'USE_YN'),
  @JsonValue('DEL_YN')
  delYn(r'DEL_YN');

  const APPROVALTYPETBLScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum APPROVALUSERTBLScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('APPROVAL_ID')
  approvalId(r'APPROVAL_ID'),
  @JsonValue('APPROVAL_USR_ID')
  approvalUsrId(r'APPROVAL_USR_ID'),
  @JsonValue('APPROVAL_USR_GRADE_CD')
  approvalUsrGradeCd(r'APPROVAL_USR_GRADE_CD'),
  @JsonValue('APPROVAL_USR_TYPE')
  approvalUsrType(r'APPROVAL_USR_TYPE'),
  @JsonValue('APPROVAL_USR_SORT')
  approvalUsrSort(r'APPROVAL_USR_SORT'),
  @JsonValue('APPROVAL_PROC_USER_YN')
  approvalProcUserYn(r'APPROVAL_PROC_USER_YN'),
  @JsonValue('APPROVAL_PROC_YN')
  approvalProcYn(r'APPROVAL_PROC_YN'),
  @JsonValue('APPROVAL_PROC_DATE')
  approvalProcDate(r'APPROVAL_PROC_DATE'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('UPD_DATE')
  updDate(r'UPD_DATE'),
  @JsonValue('DEL_YN')
  delYn(r'DEL_YN');

  const APPROVALUSERTBLScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum BOOKASSETTBLScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('SEQ')
  seq(r'SEQ'),
  @JsonValue('ASSET_NO')
  assetNo(r'ASSET_NO'),
  @JsonValue('BOOK_NM')
  bookNm(r'BOOK_NM'),
  @JsonValue('CNT')
  cnt(r'CNT'),
  @JsonValue('PUBLISHER')
  publisher(r'PUBLISHER'),
  @JsonValue('AMOUNT')
  amount(r'AMOUNT'),
  @JsonValue('BUY_DATE')
  buyDate(r'BUY_DATE'),
  @JsonValue('MNG_DEPT')
  mngDept(r'MNG_DEPT'),
  @JsonValue('RENT_YN')
  rentYn(r'RENT_YN'),
  @JsonValue('RENT_USER')
  rentUser(r'RENT_USER'),
  @JsonValue('REMARKS')
  remarks(r'REMARKS'),
  @JsonValue('USE_YN')
  useYn(r'USE_YN'),
  @JsonValue('DEL_YN')
  delYn(r'DEL_YN'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('UPD_DATE')
  updDate(r'UPD_DATE');

  const BOOKASSETTBLScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum CARASSETINSURTBLScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('SEQ')
  seq(r'SEQ'),
  @JsonValue('MSEQ')
  mseq(r'MSEQ'),
  @JsonValue('GUARANTEE')
  guarantee(r'GUARANTEE');

  const CARASSETINSURTBLScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum CARASSETTBLScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('SEQ')
  seq(r'SEQ'),
  @JsonValue('ASSET_NO')
  assetNo(r'ASSET_NO'),
  @JsonValue('MODEL_NO')
  modelNo(r'MODEL_NO'),
  @JsonValue('CAR_NO')
  carNo(r'CAR_NO'),
  @JsonValue('OWNER')
  owner(r'OWNER'),
  @JsonValue('OWNER_TYPE')
  ownerType(r'OWNER_TYPE'),
  @JsonValue('AMOUNT')
  amount(r'AMOUNT'),
  @JsonValue('BUY_DATE')
  buyDate(r'BUY_DATE'),
  @JsonValue('SELLER')
  seller(r'SELLER'),
  @JsonValue('REMARKS')
  remarks(r'REMARKS'),
  @JsonValue('MNGR_NM')
  mngrNm(r'MNGR_NM'),
  @JsonValue('FUEL')
  fuel(r'FUEL'),
  @JsonValue('MANU_DT')
  manuDt(r'MANU_DT'),
  @JsonValue('EFFIC')
  effic(r'EFFIC'),
  @JsonValue('INSUR')
  insur(r'INSUR'),
  @JsonValue('INSUR_MNGR')
  insurMngr(r'INSUR_MNGR'),
  @JsonValue('EMG_TEL')
  emgTel(r'EMG_TEL'),
  @JsonValue('STORE_NM')
  storeNm(r'STORE_NM'),
  @JsonValue('STORE_TEL')
  storeTel(r'STORE_TEL'),
  @JsonValue('USE_YN')
  useYn(r'USE_YN'),
  @JsonValue('DEL_YN')
  delYn(r'DEL_YN'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('UPD_DATE')
  updDate(r'UPD_DATE');

  const CARASSETTBLScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum CARCHARGETBLScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('SEQ')
  seq(r'SEQ'),
  @JsonValue('ITEM')
  item(r'ITEM'),
  @JsonValue('CHARGE')
  charge(r'CHARGE'),
  @JsonValue('WRITER_ID')
  writerId(r'WRITER_ID'),
  @JsonValue('MEMO')
  memo(r'MEMO'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE');

  const CARCHARGETBLScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum CARINFOTBLScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('SORT')
  sort(r'SORT'),
  @JsonValue('CAR_MANAGE_NO')
  carManageNo(r'CAR_MANAGE_NO'),
  @JsonValue('MODEL')
  model(r'MODEL'),
  @JsonValue('USER_ID')
  userId(r'USER_ID'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('DISUSED_YN')
  disusedYn(r'DISUSED_YN');

  const CARINFOTBLScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum CARMILEAGETBLScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('SEQ')
  seq(r'SEQ'),
  @JsonValue('CAR_MANAGE_NO')
  carManageNo(r'CAR_MANAGE_NO'),
  @JsonValue('FOR_USE')
  forUse(r'FOR_USE'),
  @JsonValue('ST_POINT')
  stPoint(r'ST_POINT'),
  @JsonValue('DESTINATION')
  destination(r'DESTINATION'),
  @JsonValue('MILEAGE')
  mileage(r'MILEAGE'),
  @JsonValue('TOTAL_MILEAGE')
  totalMileage(r'TOTAL_MILEAGE'),
  @JsonValue('RECORD_DATE')
  recordDate(r'RECORD_DATE'),
  @JsonValue('WRITER_ID')
  writerId(r'WRITER_ID'),
  @JsonValue('EDITOR_ID')
  editorId(r'EDITOR_ID'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('APPR_YN')
  apprYn(r'APPR_YN');

  const CARMILEAGETBLScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum CARPARTREPLACETBLScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('SEQ')
  seq(r'SEQ'),
  @JsonValue('PART_NM')
  partNm(r'PART_NM'),
  @JsonValue('REPLACE_PERIOD')
  replacePeriod(r'REPLACE_PERIOD'),
  @JsonValue('RE_TOTAL_MILEAGE')
  reTotalMileage(r'RE_TOTAL_MILEAGE'),
  @JsonValue('NOW_TOTAL_MILEAGE')
  nowTotalMileage(r'NOW_TOTAL_MILEAGE'),
  @JsonValue('REMAIN_MILEAGE')
  remainMileage(r'REMAIN_MILEAGE'),
  @JsonValue('REPLACE_COUNT')
  replaceCount(r'REPLACE_COUNT'),
  @JsonValue('PART_RE_DATE')
  partReDate(r'PART_RE_DATE'),
  @JsonValue('WRITER_ID')
  writerId(r'WRITER_ID'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE');

  const CARPARTREPLACETBLScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum CARREPAIRLOGScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('SEQ')
  seq(r'SEQ'),
  @JsonValue('MSEQ')
  mseq(r'MSEQ'),
  @JsonValue('ASSET_NO')
  assetNo(r'ASSET_NO'),
  @JsonValue('REPAIR_DE')
  repairDe(r'REPAIR_DE'),
  @JsonValue('REPAIR_AMOUNT')
  repairAmount(r'REPAIR_AMOUNT'),
  @JsonValue('REPAIR_STORE')
  repairStore(r'REPAIR_STORE'),
  @JsonValue('REPAIR_LOG')
  repairLog(r'REPAIR_LOG'),
  @JsonValue('REPAIR_OWNER')
  repairOwner(r'REPAIR_OWNER'),
  @JsonValue('FILE_TP')
  fileTp(r'FILE_TP'),
  @JsonValue('FLPTH')
  flpth(r'FLPTH'),
  @JsonValue('ORGINAL_FILE_NM')
  orginalFileNm(r'ORGINAL_FILE_NM'),
  @JsonValue('STRE_FILE_NM')
  streFileNm(r'STRE_FILE_NM'),
  @JsonValue('REG_ID')
  regId(r'REG_ID'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('EDIT_ID')
  editId(r'EDIT_ID'),
  @JsonValue('EDIT_DATE')
  editDate(r'EDIT_DATE'),
  @JsonValue('DEL_ID')
  delId(r'DEL_ID'),
  @JsonValue('DEL_DATE')
  delDate(r'DEL_DATE');

  const CARREPAIRLOGScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum CARUSEMANAGETBLScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('SEQ')
  seq(r'SEQ'),
  @JsonValue('CAR_NO')
  carNo(r'CAR_NO'),
  @JsonValue('CAR_TYPE')
  carType(r'CAR_TYPE'),
  @JsonValue('DESTINATION')
  destination(r'DESTINATION'),
  @JsonValue('PURPOSE')
  purpose(r'PURPOSE'),
  @JsonValue('USERS')
  users(r'USERS'),
  @JsonValue('USE_START_DATE')
  useStartDate(r'USE_START_DATE'),
  @JsonValue('USE_END_DATE')
  useEndDate(r'USE_END_DATE'),
  @JsonValue('USE_BEFORE_DISTANCE')
  useBeforeDistance(r'USE_BEFORE_DISTANCE'),
  @JsonValue('USE_AFTER_DISTANCE')
  useAfterDistance(r'USE_AFTER_DISTANCE'),
  @JsonValue('REMARKS')
  remarks(r'REMARKS'),
  @JsonValue('ACCEPT_YN')
  acceptYn(r'ACCEPT_YN'),
  @JsonValue('REG_USER')
  regUser(r'REG_USER'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('USE_START_HOUR')
  useStartHour(r'USE_START_HOUR'),
  @JsonValue('USE_END_HOUR')
  useEndHour(r'USE_END_HOUR'),
  @JsonValue('CARD_APPLY')
  cardApply(r'CARD_APPLY');

  const CARUSEMANAGETBLScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum HOLIDAYTBLScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('USER_ID')
  userId(r'USER_ID'),
  @JsonValue('STD_YEAR')
  stdYear(r'STD_YEAR'),
  @JsonValue('M1')
  m1(r'M1'),
  @JsonValue('M2')
  m2(r'M2'),
  @JsonValue('M3')
  m3(r'M3'),
  @JsonValue('M4')
  m4(r'M4'),
  @JsonValue('M5')
  m5(r'M5'),
  @JsonValue('M6')
  m6(r'M6'),
  @JsonValue('M7')
  m7(r'M7'),
  @JsonValue('M8')
  m8(r'M8'),
  @JsonValue('M9')
  m9(r'M9'),
  @JsonValue('M10')
  m10(r'M10'),
  @JsonValue('M11')
  m11(r'M11'),
  @JsonValue('M12')
  m12(r'M12'),
  @JsonValue('USE_YN')
  useYn(r'USE_YN'),
  @JsonValue('DEL_YN')
  delYn(r'DEL_YN'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('UPD_DATE')
  updDate(r'UPD_DATE');

  const HOLIDAYTBLScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum MEMBERTBLScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('USER_ID')
  userId(r'USER_ID'),
  @JsonValue('PASSWD')
  passwd(r'PASSWD'),
  @JsonValue('USER_NM')
  userNm(r'USER_NM'),
  @JsonValue('DEPT')
  dept(r'DEPT'),
  @JsonValue('GRADE')
  grade(r'GRADE'),
  @JsonValue('JOIN_DATE')
  joinDate(r'JOIN_DATE'),
  @JsonValue('RETIRE_DATE')
  retireDate(r'RETIRE_DATE'),
  @JsonValue('PWD_CHG_DATE')
  pwdChgDate(r'PWD_CHG_DATE'),
  @JsonValue('PWD_WRONG_CNT')
  pwdWrongCnt(r'PWD_WRONG_CNT'),
  @JsonValue('USE_YN')
  useYn(r'USE_YN'),
  @JsonValue('DEL_YN')
  delYn(r'DEL_YN'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('UPD_DATE')
  updDate(r'UPD_DATE'),
  @JsonValue('LAST_LOGIN_DATE')
  lastLoginDate(r'LAST_LOGIN_DATE'),
  @JsonValue('MEMO')
  memo(r'MEMO');

  const MEMBERTBLScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum MENUAUTHTBLScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('USER_ID')
  userId(r'USER_ID'),
  @JsonValue('MENU_ID')
  menuId(r'MENU_ID'),
  @JsonValue('READ_YN')
  readYn(r'READ_YN'),
  @JsonValue('WRITE_YN')
  writeYn(r'WRITE_YN'),
  @JsonValue('REG_ID')
  regId(r'REG_ID'),
  @JsonValue('UPD_ID')
  updId(r'UPD_ID'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('UPD_DATE')
  updDate(r'UPD_DATE');

  const MENUAUTHTBLScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum MENUTBLScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('MENU_ID')
  menuId(r'MENU_ID'),
  @JsonValue('MENU_NM')
  menuNm(r'MENU_NM'),
  @JsonValue('DEPTH')
  depth(r'DEPTH'),
  @JsonValue('SORT')
  sort(r'SORT'),
  @JsonValue('OWNER_ID')
  ownerId(r'OWNER_ID'),
  @JsonValue('URL')
  url(r'URL'),
  @JsonValue('WRITER_ID')
  writerId(r'WRITER_ID'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('UPD_DATE')
  updDate(r'UPD_DATE'),
  @JsonValue('USE_YN')
  useYn(r'USE_YN'),
  @JsonValue('DEL_YN')
  delYn(r'DEL_YN'),
  @JsonValue('DISP_YN')
  dispYn(r'DISP_YN'),
  @JsonValue('MENU_ICON')
  menuIcon(r'MENU_ICON');

  const MENUTBLScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum OFFICEASSETTBLScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('SEQ')
  seq(r'SEQ'),
  @JsonValue('ASSET_NO')
  assetNo(r'ASSET_NO'),
  @JsonValue('ASSET_TYPE')
  assetType(r'ASSET_TYPE'),
  @JsonValue('SELLER')
  seller(r'SELLER'),
  @JsonValue('BUY_DATE')
  buyDate(r'BUY_DATE'),
  @JsonValue('MODEL_NO')
  modelNo(r'MODEL_NO'),
  @JsonValue('SERIAL_NO')
  serialNo(r'SERIAL_NO'),
  @JsonValue('AMOUNT')
  amount(r'AMOUNT'),
  @JsonValue('KEEP_YEAR')
  keepYear(r'KEEP_YEAR'),
  @JsonValue('MNG_DEPT')
  mngDept(r'MNG_DEPT'),
  @JsonValue('ASSET_ACCOUNT')
  assetAccount(r'ASSET_ACCOUNT'),
  @JsonValue('REMARKS')
  remarks(r'REMARKS'),
  @JsonValue('CARRY_OUT')
  carryOut(r'CARRY_OUT'),
  @JsonValue('USE_YN')
  useYn(r'USE_YN'),
  @JsonValue('DEL_YN')
  delYn(r'DEL_YN'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('UPD_DATE')
  updDate(r'UPD_DATE');

  const OFFICEASSETTBLScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum SERVERASSETTBLScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('SEQ')
  seq(r'SEQ'),
  @JsonValue('ASSET_NO')
  assetNo(r'ASSET_NO'),
  @JsonValue('ASSET_TYPE')
  assetType(r'ASSET_TYPE'),
  @JsonValue('MAKER')
  maker(r'MAKER'),
  @JsonValue('CNT')
  cnt(r'CNT'),
  @JsonValue('AMOUNT')
  amount(r'AMOUNT'),
  @JsonValue('BUY_DATE')
  buyDate(r'BUY_DATE'),
  @JsonValue('SELLER')
  seller(r'SELLER'),
  @JsonValue('MODEL_NO')
  modelNo(r'MODEL_NO'),
  @JsonValue('SERIAL_NO')
  serialNo(r'SERIAL_NO'),
  @JsonValue('HOSTNAME')
  hostname(r'HOSTNAME'),
  @JsonValue('BUILT_LOC')
  builtLoc(r'BUILT_LOC'),
  @JsonValue('USE_DESC')
  useDesc(r'USE_DESC'),
  @JsonValue('OS_INFO')
  osInfo(r'OS_INFO'),
  @JsonValue('CPU_INFO')
  cpuInfo(r'CPU_INFO'),
  @JsonValue('RAM_INFO')
  ramInfo(r'RAM_INFO'),
  @JsonValue('HDD_INFO')
  hddInfo(r'HDD_INFO'),
  @JsonValue('SSD_INFO')
  ssdInfo(r'SSD_INFO'),
  @JsonValue('ODD')
  odd(r'ODD'),
  @JsonValue('REMARKS')
  remarks(r'REMARKS'),
  @JsonValue('CARRY_OUT')
  carryOut(r'CARRY_OUT'),
  @JsonValue('USE_YN')
  useYn(r'USE_YN'),
  @JsonValue('DEL_YN')
  delYn(r'DEL_YN'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('UPD_DATE')
  updDate(r'UPD_DATE');

  const SERVERASSETTBLScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum SOFTWAREASSETTBLScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('SEQ')
  seq(r'SEQ'),
  @JsonValue('ASSET_NO')
  assetNo(r'ASSET_NO'),
  @JsonValue('SOFTWARE_NM')
  softwareNm(r'SOFTWARE_NM'),
  @JsonValue('VERSION_NM')
  versionNm(r'VERSION_NM'),
  @JsonValue('CNT')
  cnt(r'CNT'),
  @JsonValue('AMOUNT')
  amount(r'AMOUNT'),
  @JsonValue('BUY_DATE')
  buyDate(r'BUY_DATE'),
  @JsonValue('SERIAL_NO')
  serialNo(r'SERIAL_NO'),
  @JsonValue('LICENSE_NO')
  licenseNo(r'LICENSE_NO'),
  @JsonValue('USER_NM')
  userNm(r'USER_NM'),
  @JsonValue('REMARKS')
  remarks(r'REMARKS'),
  @JsonValue('USE_YN')
  useYn(r'USE_YN'),
  @JsonValue('DEL_YN')
  delYn(r'DEL_YN'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('UPD_DATE')
  updDate(r'UPD_DATE');

  const SOFTWAREASSETTBLScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum STADMINMENUScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('MENU_CD')
  menuCd(r'MENU_CD'),
  @JsonValue('MENU_NM')
  menuNm(r'MENU_NM'),
  @JsonValue('MENU_PATH')
  menuPath(r'MENU_PATH'),
  @JsonValue('MENU_SRT')
  menuSrt(r'MENU_SRT'),
  @JsonValue('MENU_DEPS')
  menuDeps(r'MENU_DEPS'),
  @JsonValue('MENU_ICON')
  menuIcon(r'MENU_ICON'),
  @JsonValue('MENU_TP')
  menuTp(r'MENU_TP'),
  @JsonValue('REG_ID')
  regId(r'REG_ID'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('EDIT_ID')
  editId(r'EDIT_ID'),
  @JsonValue('EDIT_DATE')
  editDate(r'EDIT_DATE'),
  @JsonValue('DEL_ID')
  delId(r'DEL_ID'),
  @JsonValue('DEL_DATE')
  delDate(r'DEL_DATE');

  const STADMINMENUScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum STALARMScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('SEQ')
  seq(r'SEQ'),
  @JsonValue('MSG_CD')
  msgCd(r'MSG_CD'),
  @JsonValue('MSG_CNTS')
  msgCnts(r'MSG_CNTS'),
  @JsonValue('SEND_DATE')
  sendDate(r'SEND_DATE'),
  @JsonValue('SEND_DIV')
  sendDiv(r'SEND_DIV'),
  @JsonValue('SEND_DEPT_CD')
  sendDeptCd(r'SEND_DEPT_CD'),
  @JsonValue('SEND_ID')
  sendId(r'SEND_ID'),
  @JsonValue('RECV_ID')
  recvId(r'RECV_ID'),
  @JsonValue('POP_YN')
  popYn(r'POP_YN'),
  @JsonValue('EDIT_ID')
  editId(r'EDIT_ID'),
  @JsonValue('EDIT_DATE')
  editDate(r'EDIT_DATE');

  const STALARMScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum STAUDITLOGScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('SEQ')
  seq(r'SEQ'),
  @JsonValue('LOG_CODE')
  logCode(r'LOG_CODE'),
  @JsonValue('LOG_CNTS')
  logCnts(r'LOG_CNTS'),
  @JsonValue('ERR_CODE')
  errCode(r'ERR_CODE'),
  @JsonValue('REG_ID')
  regId(r'REG_ID'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('EDIT_ID')
  editId(r'EDIT_ID'),
  @JsonValue('EDIT_DATE')
  editDate(r'EDIT_DATE'),
  @JsonValue('DEL_ID')
  delId(r'DEL_ID'),
  @JsonValue('DEL_DATE')
  delDate(r'DEL_DATE');

  const STAUDITLOGScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum STBANNERScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('BANNER_CD')
  bannerCd(r'BANNER_CD'),
  @JsonValue('LK_URL')
  lkUrl(r'LK_URL'),
  @JsonValue('LK_TARGET')
  lkTarget(r'LK_TARGET'),
  @JsonValue('FLPTH')
  flpth(r'FLPTH'),
  @JsonValue('FILE_NM')
  fileNm(r'FILE_NM'),
  @JsonValue('USE_YN')
  useYn(r'USE_YN'),
  @JsonValue('REG_ID')
  regId(r'REG_ID'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('EDIT_ID')
  editId(r'EDIT_ID'),
  @JsonValue('EDIT_DATE')
  editDate(r'EDIT_DATE'),
  @JsonValue('DEL_ID')
  delId(r'DEL_ID'),
  @JsonValue('DEL_DATE')
  delDate(r'DEL_DATE');

  const STBANNERScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum STBOARDCOLUMNScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('BOARD_CD')
  boardCd(r'BOARD_CD'),
  @JsonValue('SORT')
  sort(r'SORT'),
  @JsonValue('COL_CD')
  colCd(r'COL_CD'),
  @JsonValue('COL_NM')
  colNm(r'COL_NM'),
  @JsonValue('REG_ID')
  regId(r'REG_ID'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE');

  const STBOARDCOLUMNScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum STBOARDCOLUMNDFTScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('BOARD_TY')
  boardTy(r'BOARD_TY'),
  @JsonValue('SORT')
  sort(r'SORT'),
  @JsonValue('COL_CD')
  colCd(r'COL_CD'),
  @JsonValue('COL_NM')
  colNm(r'COL_NM'),
  @JsonValue('EDIT_ID')
  editId(r'EDIT_ID'),
  @JsonValue('EDIT_DATE')
  editDate(r'EDIT_DATE'),
  @JsonValue('DEL_YN')
  delYn(r'DEL_YN');

  const STBOARDCOLUMNDFTScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum STBOARDCOMMENTScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('SEQ')
  seq(r'SEQ'),
  @JsonValue('MSEQ')
  mseq(r'MSEQ'),
  @JsonValue('BOARD_CD')
  boardCd(r'BOARD_CD'),
  @JsonValue('CNTS')
  cnts(r'CNTS'),
  @JsonValue('UPPER_SEQ')
  upperSeq(r'UPPER_SEQ'),
  @JsonValue('REPLY_YN')
  replyYn(r'REPLY_YN'),
  @JsonValue('REG_ADMIN_YN')
  regAdminYn(r'REG_ADMIN_YN'),
  @JsonValue('REG_ID')
  regId(r'REG_ID'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('EDIT_ID')
  editId(r'EDIT_ID'),
  @JsonValue('EDIT_DATE')
  editDate(r'EDIT_DATE'),
  @JsonValue('DEL_ID')
  delId(r'DEL_ID'),
  @JsonValue('DEL_DATE')
  delDate(r'DEL_DATE');

  const STBOARDCOMMENTScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum STBOARDFILEScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('SEQ')
  seq(r'SEQ'),
  @JsonValue('MSEQ')
  mseq(r'MSEQ'),
  @JsonValue('BOARD_CD')
  boardCd(r'BOARD_CD'),
  @JsonValue('FILE_TP')
  fileTp(r'FILE_TP'),
  @JsonValue('FLPTH')
  flpth(r'FLPTH'),
  @JsonValue('ORGINAL_FILE_NM')
  orginalFileNm(r'ORGINAL_FILE_NM'),
  @JsonValue('STRE_FILE_NM')
  streFileNm(r'STRE_FILE_NM'),
  @JsonValue('FILE_SIZE')
  fileSize(r'FILE_SIZE'),
  @JsonValue('REPRE_YN')
  repreYn(r'REPRE_YN'),
  @JsonValue('DWLD_CO')
  dwldCo(r'DWLD_CO');

  const STBOARDFILEScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum STBOARDMSTScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('SEQ')
  seq(r'SEQ'),
  @JsonValue('BOARD_CD')
  boardCd(r'BOARD_CD'),
  @JsonValue('CLS_CD')
  clsCd(r'CLS_CD'),
  @JsonValue('TTL')
  ttl(r'TTL'),
  @JsonValue('CNTS')
  cnts(r'CNTS'),
  @JsonValue('FILE_YN')
  fileYn(r'FILE_YN'),
  @JsonValue('IMAGE_YN')
  imageYn(r'IMAGE_YN'),
  @JsonValue('NOTICE_YN')
  noticeYn(r'NOTICE_YN'),
  @JsonValue('LK_URL')
  lkUrl(r'LK_URL'),
  @JsonValue('LK_TARGET')
  lkTarget(r'LK_TARGET'),
  @JsonValue('READ_CNT')
  readCnt(r'READ_CNT'),
  @JsonValue('REG_ADMIN_YN')
  regAdminYn(r'REG_ADMIN_YN'),
  @JsonValue('REPLY_YN')
  replyYn(r'REPLY_YN'),
  @JsonValue('UPPER_SEQ')
  upperSeq(r'UPPER_SEQ'),
  @JsonValue('REG_ID')
  regId(r'REG_ID'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('EDIT_ID')
  editId(r'EDIT_ID'),
  @JsonValue('EDIT_DATE')
  editDate(r'EDIT_DATE'),
  @JsonValue('DEL_ID')
  delId(r'DEL_ID'),
  @JsonValue('DEL_DATE')
  delDate(r'DEL_DATE');

  const STBOARDMSTScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum STBOARDSTNGScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('BOARD_CD')
  boardCd(r'BOARD_CD'),
  @JsonValue('BOARD_NM')
  boardNm(r'BOARD_NM'),
  @JsonValue('BOARD_TY')
  boardTy(r'BOARD_TY'),
  @JsonValue('EDITOR_YN')
  editorYn(r'EDITOR_YN'),
  @JsonValue('RLS_YN')
  rlsYn(r'RLS_YN'),
  @JsonValue('CCL_SEQ')
  cclSeq(r'CCL_SEQ'),
  @JsonValue('LIST_CNT')
  listCnt(r'LIST_CNT'),
  @JsonValue('WRITE_YN')
  writeYn(r'WRITE_YN'),
  @JsonValue('COMMENT_YN')
  commentYn(r'COMMENT_YN'),
  @JsonValue('REPLY_YN')
  replyYn(r'REPLY_YN'),
  @JsonValue('ATTACH_YN')
  attachYn(r'ATTACH_YN'),
  @JsonValue('ATTACH_SIZE')
  attachSize(r'ATTACH_SIZE'),
  @JsonValue('ATTACH_CNT')
  attachCnt(r'ATTACH_CNT'),
  @JsonValue('ATTACH_EXT')
  attachExt(r'ATTACH_EXT'),
  @JsonValue('REG_ID')
  regId(r'REG_ID'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('EDIT_ID')
  editId(r'EDIT_ID'),
  @JsonValue('EDIT_DATE')
  editDate(r'EDIT_DATE'),
  @JsonValue('DEL_ID')
  delId(r'DEL_ID'),
  @JsonValue('DEL_DATE')
  delDate(r'DEL_DATE');

  const STBOARDSTNGScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum STCCLScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('SEQ')
  seq(r'SEQ'),
  @JsonValue('CCL_TYPE')
  cclType(r'CCL_TYPE'),
  @JsonValue('CCL_NM')
  cclNm(r'CCL_NM'),
  @JsonValue('FLPTH')
  flpth(r'FLPTH'),
  @JsonValue('ORGINAL_FILE_NM')
  orginalFileNm(r'ORGINAL_FILE_NM'),
  @JsonValue('STRE_FILE_NM')
  streFileNm(r'STRE_FILE_NM'),
  @JsonValue('FILE_EXTSN')
  fileExtsn(r'FILE_EXTSN'),
  @JsonValue('FILE_SIZE')
  fileSize(r'FILE_SIZE'),
  @JsonValue('REG_ID')
  regId(r'REG_ID'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('EDIT_ID')
  editId(r'EDIT_ID'),
  @JsonValue('EDIT_DATE')
  editDate(r'EDIT_DATE'),
  @JsonValue('DEL_ID')
  delId(r'DEL_ID'),
  @JsonValue('DEL_DATE')
  delDate(r'DEL_DATE');

  const STCCLScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum STCODEMSTScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('CD_GRP')
  cdGrp(r'CD_GRP'),
  @JsonValue('CD_KEY')
  cdKey(r'CD_KEY'),
  @JsonValue('CD_VAL')
  cdVal(r'CD_VAL'),
  @JsonValue('CD_DESC')
  cdDesc(r'CD_DESC'),
  @JsonValue('CD_SRT')
  cdSrt(r'CD_SRT'),
  @JsonValue('DEPTH')
  depth(r'DEPTH'),
  @JsonValue('REG_ID')
  regId(r'REG_ID'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('EDIT_ID')
  editId(r'EDIT_ID'),
  @JsonValue('EDIT_DATE')
  editDate(r'EDIT_DATE'),
  @JsonValue('DEL_ID')
  delId(r'DEL_ID'),
  @JsonValue('DEL_DATE')
  delDate(r'DEL_DATE');

  const STCODEMSTScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum STCONNECTLOGScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('SEQ')
  seq(r'SEQ'),
  @JsonValue('USER_ID')
  userId(r'USER_ID'),
  @JsonValue('CONN_TYPE')
  connType(r'CONN_TYPE'),
  @JsonValue('OS_TYPE')
  osType(r'OS_TYPE'),
  @JsonValue('BROWSER_TYPE')
  browserType(r'BROWSER_TYPE'),
  @JsonValue('CONNE_IP')
  conneIp(r'CONNE_IP'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE');

  const STCONNECTLOGScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum STCONTENTSFILEScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('SEQ')
  seq(r'SEQ'),
  @JsonValue('MSEQ')
  mseq(r'MSEQ'),
  @JsonValue('FILE_TP')
  fileTp(r'FILE_TP'),
  @JsonValue('FLPTH')
  flpth(r'FLPTH'),
  @JsonValue('ORGINAL_FILE_NM')
  orginalFileNm(r'ORGINAL_FILE_NM'),
  @JsonValue('STRE_FILE_NM')
  streFileNm(r'STRE_FILE_NM'),
  @JsonValue('FILE_SIZE')
  fileSize(r'FILE_SIZE');

  const STCONTENTSFILEScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum STCONTENTSMSTScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('SEQ')
  seq(r'SEQ'),
  @JsonValue('CNTS_NM')
  cntsNm(r'CNTS_NM'),
  @JsonValue('PUB_DATE')
  pubDate(r'PUB_DATE'),
  @JsonValue('PUB_STATE')
  pubState(r'PUB_STATE'),
  @JsonValue('CN')
  cn(r'CN'),
  @JsonValue('SRCH_YN')
  srchYn(r'SRCH_YN'),
  @JsonValue('FILE_YN')
  fileYn(r'FILE_YN'),
  @JsonValue('IMAGE_YN')
  imageYn(r'IMAGE_YN'),
  @JsonValue('REG_ID')
  regId(r'REG_ID'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('EDIT_ID')
  editId(r'EDIT_ID'),
  @JsonValue('EDIT_DATE')
  editDate(r'EDIT_DATE'),
  @JsonValue('DEL_ID')
  delId(r'DEL_ID'),
  @JsonValue('DEL_DATE')
  delDate(r'DEL_DATE');

  const STCONTENTSMSTScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum STDEPTScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('DEPT_CD')
  deptCd(r'DEPT_CD'),
  @JsonValue('DEPT_NM')
  deptNm(r'DEPT_NM'),
  @JsonValue('UPPER_DEPT_CD')
  upperDeptCd(r'UPPER_DEPT_CD'),
  @JsonValue('UPPER_DEPT_NM')
  upperDeptNm(r'UPPER_DEPT_NM'),
  @JsonValue('SORT')
  sort(r'SORT'),
  @JsonValue('MAIN_YN')
  mainYn(r'MAIN_YN'),
  @JsonValue('DEPT_DESC')
  deptDesc(r'DEPT_DESC'),
  @JsonValue('REG_ID')
  regId(r'REG_ID'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('EDIT_ID')
  editId(r'EDIT_ID'),
  @JsonValue('EDIT_DATE')
  editDate(r'EDIT_DATE'),
  @JsonValue('DEL_ID')
  delId(r'DEL_ID'),
  @JsonValue('DEL_DATE')
  delDate(r'DEL_DATE');

  const STDEPTScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum STDEPTEMPScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('EMP_NO')
  empNo(r'EMP_NO'),
  @JsonValue('EMP_NM')
  empNm(r'EMP_NM'),
  @JsonValue('DEPT_CD')
  deptCd(r'DEPT_CD'),
  @JsonValue('DEPT_NM')
  deptNm(r'DEPT_NM'),
  @JsonValue('FCTN_CD')
  fctnCd(r'FCTN_CD'),
  @JsonValue('FCTN_NM')
  fctnNm(r'FCTN_NM'),
  @JsonValue('OFCP_CD')
  ofcpCd(r'OFCP_CD'),
  @JsonValue('OFCP_NM')
  ofcpNm(r'OFCP_NM'),
  @JsonValue('EMAIL_ADDR')
  emailAddr(r'EMAIL_ADDR'),
  @JsonValue('OFFM_TELNO')
  offmTelno(r'OFFM_TELNO'),
  @JsonValue('HTEL_TELNO')
  htelTelno(r'HTEL_TELNO'),
  @JsonValue('DEPT_YN')
  deptYn(r'DEPT_YN'),
  @JsonValue('REG_ID')
  regId(r'REG_ID'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('EDIT_ID')
  editId(r'EDIT_ID'),
  @JsonValue('EDIT_DATE')
  editDate(r'EDIT_DATE'),
  @JsonValue('DEL_ID')
  delId(r'DEL_ID'),
  @JsonValue('DEL_DATE')
  delDate(r'DEL_DATE');

  const STDEPTEMPScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum STMENUScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('MENU_CD')
  menuCd(r'MENU_CD'),
  @JsonValue('MENU_NM')
  menuNm(r'MENU_NM'),
  @JsonValue('MENU_PATH')
  menuPath(r'MENU_PATH'),
  @JsonValue('MENU_MAPPING')
  menuMapping(r'MENU_MAPPING'),
  @JsonValue('MENU_SRT')
  menuSrt(r'MENU_SRT'),
  @JsonValue('MENU_DEPS')
  menuDeps(r'MENU_DEPS'),
  @JsonValue('MENU_ICON')
  menuIcon(r'MENU_ICON'),
  @JsonValue('MENU_TP')
  menuTp(r'MENU_TP'),
  @JsonValue('MAIN_EXPSR_YN')
  mainExpsrYn(r'MAIN_EXPSR_YN'),
  @JsonValue('SUB_EXPSR_YN')
  subExpsrYn(r'SUB_EXPSR_YN'),
  @JsonValue('UPEND_CLAS')
  upendClas(r'UPEND_CLAS'),
  @JsonValue('UPEND_CN')
  upendCn(r'UPEND_CN'),
  @JsonValue('CCL_TYPE')
  cclType(r'CCL_TYPE'),
  @JsonValue('REG_ID')
  regId(r'REG_ID'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('EDIT_ID')
  editId(r'EDIT_ID'),
  @JsonValue('EDIT_DATE')
  editDate(r'EDIT_DATE'),
  @JsonValue('DEL_ID')
  delId(r'DEL_ID'),
  @JsonValue('DEL_DATE')
  delDate(r'DEL_DATE');

  const STMENUScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum STMESSAGETMPLATScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('MSG_DIV_CD')
  msgDivCd(r'MSG_DIV_CD'),
  @JsonValue('MSG_CD')
  msgCd(r'MSG_CD'),
  @JsonValue('MSG_NM')
  msgNm(r'MSG_NM'),
  @JsonValue('MSG_TMPLAT')
  msgTmplat(r'MSG_TMPLAT'),
  @JsonValue('USE_YN')
  useYn(r'USE_YN'),
  @JsonValue('EDIT_ID')
  editId(r'EDIT_ID'),
  @JsonValue('EDIT_DATE')
  editDate(r'EDIT_DATE');

  const STMESSAGETMPLATScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum STMIMETYPEScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('SEQ')
  seq(r'SEQ'),
  @JsonValue('EXTN_NM')
  extnNm(r'EXTN_NM'),
  @JsonValue('FILE_MT')
  fileMt(r'FILE_MT');

  const STMIMETYPEScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum STMNGRGRPScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('GRP_CD')
  grpCd(r'GRP_CD'),
  @JsonValue('GRP_NM')
  grpNm(r'GRP_NM'),
  @JsonValue('GRP_DESC')
  grpDesc(r'GRP_DESC'),
  @JsonValue('SORT')
  sort(r'SORT'),
  @JsonValue('REG_ID')
  regId(r'REG_ID'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('EDIT_ID')
  editId(r'EDIT_ID'),
  @JsonValue('EDIT_DATE')
  editDate(r'EDIT_DATE'),
  @JsonValue('DEL_ID')
  delId(r'DEL_ID'),
  @JsonValue('DEL_DATE')
  delDate(r'DEL_DATE');

  const STMNGRGRPScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum STMNGRMSTScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('MNGR_ID')
  mngrId(r'MNGR_ID'),
  @JsonValue('MNGR_NM')
  mngrNm(r'MNGR_NM'),
  @JsonValue('MNGR_PW')
  mngrPw(r'MNGR_PW'),
  @JsonValue('GRP_CD')
  grpCd(r'GRP_CD'),
  @JsonValue('GRADE')
  grade(r'GRADE'),
  @JsonValue('PERM_CD')
  permCd(r'PERM_CD'),
  @JsonValue('ACS_YN')
  acsYn(r'ACS_YN'),
  @JsonValue('CLPH')
  clph(r'CLPH'),
  @JsonValue('EMP_NO')
  empNo(r'EMP_NO'),
  @JsonValue('JOIN_DATE')
  joinDate(r'JOIN_DATE'),
  @JsonValue('RETIRE_DATE')
  retireDate(r'RETIRE_DATE'),
  @JsonValue('PWD_CHG_DATE')
  pwdChgDate(r'PWD_CHG_DATE'),
  @JsonValue('PWD_WRONG_CNT')
  pwdWrongCnt(r'PWD_WRONG_CNT'),
  @JsonValue('PWD_WRONG_DATE')
  pwdWrongDate(r'PWD_WRONG_DATE'),
  @JsonValue('LST_LOGIN_DATE')
  lstLoginDate(r'LST_LOGIN_DATE'),
  @JsonValue('FLPTH')
  flpth(r'FLPTH'),
  @JsonValue('FILE_NM')
  fileNm(r'FILE_NM'),
  @JsonValue('REG_ID')
  regId(r'REG_ID'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('EDIT_ID')
  editId(r'EDIT_ID'),
  @JsonValue('EDIT_DATE')
  editDate(r'EDIT_DATE'),
  @JsonValue('DEL_ID')
  delId(r'DEL_ID'),
  @JsonValue('DEL_DATE')
  delDate(r'DEL_DATE');

  const STMNGRMSTScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum STMYSTNGScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('USER_ID')
  userId(r'USER_ID'),
  @JsonValue('STNG_CD')
  stngCd(r'STNG_CD'),
  @JsonValue('USER_DIV')
  userDiv(r'USER_DIV'),
  @JsonValue('STNG_DATA')
  stngData(r'STNG_DATA');

  const STMYSTNGScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum STPERMDTLScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('PERM_CD')
  permCd(r'PERM_CD'),
  @JsonValue('MENU_CD')
  menuCd(r'MENU_CD'),
  @JsonValue('READ_YN')
  readYn(r'READ_YN'),
  @JsonValue('REG_YN')
  regYn(r'REG_YN'),
  @JsonValue('MDFCN_YN')
  mdfcnYn(r'MDFCN_YN'),
  @JsonValue('DEL_YN')
  delYn(r'DEL_YN'),
  @JsonValue('MANAGE_YN')
  manageYn(r'MANAGE_YN'),
  @JsonValue('REG_ID')
  regId(r'REG_ID'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE');

  const STPERMDTLScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum STPERMMSTScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('PERM_CD')
  permCd(r'PERM_CD'),
  @JsonValue('PERM_NM')
  permNm(r'PERM_NM'),
  @JsonValue('SORT')
  sort(r'SORT'),
  @JsonValue('REG_ID')
  regId(r'REG_ID'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('EDIT_ID')
  editId(r'EDIT_ID'),
  @JsonValue('EDIT_DATE')
  editDate(r'EDIT_DATE'),
  @JsonValue('DEL_ID')
  delId(r'DEL_ID'),
  @JsonValue('DEL_DATE')
  delDate(r'DEL_DATE');

  const STPERMMSTScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum STPOPUPScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('POP_CD')
  popCd(r'POP_CD'),
  @JsonValue('POP_NM')
  popNm(r'POP_NM'),
  @JsonValue('POP_TY')
  popTy(r'POP_TY'),
  @JsonValue('IMG_TEXT')
  imgText(r'IMG_TEXT'),
  @JsonValue('LK_URL')
  lkUrl(r'LK_URL'),
  @JsonValue('LK_TARGET')
  lkTarget(r'LK_TARGET'),
  @JsonValue('BGNG_DATE')
  bgngDate(r'BGNG_DATE'),
  @JsonValue('END_DATE')
  endDate(r'END_DATE'),
  @JsonValue('SPWG_PRED')
  spwgPred(r'SPWG_PRED'),
  @JsonValue('FLPTH')
  flpth(r'FLPTH'),
  @JsonValue('FILE_NM')
  fileNm(r'FILE_NM'),
  @JsonValue('USE_YN')
  useYn(r'USE_YN'),
  @JsonValue('BEFORE_CD')
  beforeCd(r'BEFORE_CD'),
  @JsonValue('REG_ID')
  regId(r'REG_ID'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('EDIT_ID')
  editId(r'EDIT_ID'),
  @JsonValue('EDIT_DATE')
  editDate(r'EDIT_DATE'),
  @JsonValue('DEL_ID')
  delId(r'DEL_ID'),
  @JsonValue('DEL_DATE')
  delDate(r'DEL_DATE');

  const STPOPUPScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum STSTNGScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('STNG_CD')
  stngCd(r'STNG_CD'),
  @JsonValue('STNG_DATA')
  stngData(r'STNG_DATA'),
  @JsonValue('TITLE')
  title(r'TITLE'),
  @JsonValue('DESC_CN')
  descCn(r'DESC_CN'),
  @JsonValue('SORT')
  sort(r'SORT'),
  @JsonValue('EDIT_ID')
  editId(r'EDIT_ID'),
  @JsonValue('EDIT_DATE')
  editDate(r'EDIT_DATE');

  const STSTNGScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum STUSERMSTScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('USER_ID')
  userId(r'USER_ID'),
  @JsonValue('USER_NM')
  userNm(r'USER_NM'),
  @JsonValue('USER_PW')
  userPw(r'USER_PW'),
  @JsonValue('USER_DIV')
  userDiv(r'USER_DIV'),
  @JsonValue('STATUS')
  status(r'STATUS'),
  @JsonValue('PREV_LOGIN_YN')
  prevLoginYn(r'PREV_LOGIN_YN'),
  @JsonValue('WITHDRAWN_YN')
  withdrawnYn(r'WITHDRAWN_YN'),
  @JsonValue('CLPH')
  clph(r'CLPH'),
  @JsonValue('EMAIL')
  email(r'EMAIL'),
  @JsonValue('LST_LOGIN_DATE')
  lstLoginDate(r'LST_LOGIN_DATE'),
  @JsonValue('REG_ID')
  regId(r'REG_ID'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('EDIT_ID')
  editId(r'EDIT_ID'),
  @JsonValue('EDIT_DATE')
  editDate(r'EDIT_DATE'),
  @JsonValue('DEL_ID')
  delId(r'DEL_ID'),
  @JsonValue('DEL_DATE')
  delDate(r'DEL_DATE');

  const STUSERMSTScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum WORKREPORTDETAILTBLScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('REPORT_ID')
  reportId(r'REPORT_ID'),
  @JsonValue('SEQ')
  seq(r'SEQ'),
  @JsonValue('PROJECT_NM')
  projectNm(r'PROJECT_NM'),
  @JsonValue('PROJECT_SUB_NM')
  projectSubNm(r'PROJECT_SUB_NM'),
  @JsonValue('DETAIL_CONTENT')
  detailContent(r'DETAIL_CONTENT'),
  @JsonValue('WORKER')
  worker(r'WORKER'),
  @JsonValue('GRADE')
  grade(r'GRADE'),
  @JsonValue('PROCESS_RATE')
  processRate(r'PROCESS_RATE'),
  @JsonValue('WORK_DATE')
  workDate(r'WORK_DATE'),
  @JsonValue('PROCESS_TYPE')
  processType(r'PROCESS_TYPE'),
  @JsonValue('SUBJECT_YN')
  subjectYn(r'SUBJECT_YN'),
  @JsonValue('REG_USER')
  regUser(r'REG_USER'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('COMPLETE_DATE')
  completeDate(r'COMPLETE_DATE');

  const WORKREPORTDETAILTBLScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum WORKREPORTHTMLTBLScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('REPORT_ID')
  reportId(r'REPORT_ID'),
  @JsonValue('USER_ID')
  userId(r'USER_ID'),
  @JsonValue('TITLE')
  title(r'TITLE'),
  @JsonValue('HTML_CONTENT')
  htmlContent(r'HTML_CONTENT'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('DEL_YN')
  delYn(r'DEL_YN');

  const WORKREPORTHTMLTBLScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum WORKREPORTHTMLTBLBACKScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('REPORT_ID')
  reportId(r'REPORT_ID'),
  @JsonValue('USER_ID')
  userId(r'USER_ID'),
  @JsonValue('TITLE')
  title(r'TITLE'),
  @JsonValue('HTML_CONTENT')
  htmlContent(r'HTML_CONTENT'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('DEL_YN')
  delYn(r'DEL_YN');

  const WORKREPORTHTMLTBLBACKScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum WORKREPORTMASTERTBLScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('REPORT_ID')
  reportId(r'REPORT_ID'),
  @JsonValue('TITLE')
  title(r'TITLE'),
  @JsonValue('DEPT')
  dept(r'DEPT'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('UPD_DATE')
  updDate(r'UPD_DATE'),
  @JsonValue('DEL_YN')
  delYn(r'DEL_YN');

  const WORKREPORTMASTERTBLScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum WORKREQUESTMSTScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('SEQ')
  seq(r'SEQ'),
  @JsonValue('RQSTR_DPNM')
  rqstrDpnm(r'RQSTR_DPNM'),
  @JsonValue('RQSTR_NM')
  rqstrNm(r'RQSTR_NM'),
  @JsonValue('RQSTR_ID')
  rqstrId(r'RQSTR_ID'),
  @JsonValue('RQSTR_DATE')
  rqstrDate(r'RQSTR_DATE'),
  @JsonValue('HOPE_DATE')
  hopeDate(r'HOPE_DATE'),
  @JsonValue('CHR_DPR_NM')
  chrDprNm(r'CHR_DPR_NM'),
  @JsonValue('CHR_NM')
  chrNm(r'CHR_NM'),
  @JsonValue('CHR_ID')
  chrId(r'CHR_ID'),
  @JsonValue('CHR_CHK')
  chrChk(r'CHR_CHK'),
  @JsonValue('TITLE')
  title(r'TITLE'),
  @JsonValue('CN')
  cn(r'CN'),
  @JsonValue('ETC')
  etc(r'ETC'),
  @JsonValue('DOC')
  doc(r'DOC'),
  @JsonValue('REG_ID')
  regId(r'REG_ID'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('EDIT_ID')
  editId(r'EDIT_ID'),
  @JsonValue('EDIT_DATE')
  editDate(r'EDIT_DATE'),
  @JsonValue('DEL_ID')
  delId(r'DEL_ID'),
  @JsonValue('DEL_DATE')
  delDate(r'DEL_DATE');

  const WORKREQUESTMSTScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum WORKREQUESTREFScalarFieldEnum implements _i1.PrismaEnum {
  @JsonValue('SEQ')
  seq(r'SEQ'),
  @JsonValue('MSEQ')
  mseq(r'MSEQ'),
  @JsonValue('REF_ID')
  refId(r'REF_ID'),
  @JsonValue('REF_NM')
  refNm(r'REF_NM'),
  @JsonValue('REF_DEP')
  refDep(r'REF_DEP'),
  @JsonValue('REF_GRADE')
  refGrade(r'REF_GRADE'),
  @JsonValue('REG_ID')
  regId(r'REG_ID'),
  @JsonValue('REG_DATE')
  regDate(r'REG_DATE'),
  @JsonValue('EDIT_ID')
  editId(r'EDIT_ID'),
  @JsonValue('EDIT_DATE')
  editDate(r'EDIT_DATE'),
  @JsonValue('DEL_ID')
  delId(r'DEL_ID'),
  @JsonValue('DEL_DATE')
  delDate(r'DEL_DATE');

  const WORKREQUESTREFScalarFieldEnum([this.originalName]);

  @override
  final String? originalName;
}

enum SortOrder implements _i1.PrismaEnum {
  asc,
  desc;

  @override
  String? get originalName => null;
}

enum NullsOrder implements _i1.PrismaEnum {
  first,
  last;

  @override
  String? get originalName => null;
}

@_i1.jsonSerializable
class ALLCODETBLWhereInput implements _i1.JsonSerializable {
  const ALLCODETBLWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.codeType,
    this.codeName,
    this.unitType,
    this.unitName,
    this.sort,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory ALLCODETBLWhereInput.fromJson(Map<String, dynamic> json) =>
      _$ALLCODETBLWhereInputFromJson(json);

  final Iterable<ALLCODETBLWhereInput>? AND;

  final Iterable<ALLCODETBLWhereInput>? OR;

  final Iterable<ALLCODETBLWhereInput>? NOT;

  @JsonKey(name: r'CODE_TYPE')
  final StringFilter? codeType;

  @JsonKey(name: r'CODE_NAME')
  final StringNullableFilter? codeName;

  @JsonKey(name: r'UNIT_TYPE')
  final StringFilter? unitType;

  @JsonKey(name: r'UNIT_NAME')
  final StringNullableFilter? unitName;

  @JsonKey(name: r'SORT')
  final IntNullableFilter? sort;

  @JsonKey(name: r'USE_YN')
  final StringNullableFilter? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringNullableFilter? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFilter? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeFilter? updDate;

  @override
  Map<String, dynamic> toJson() => _$ALLCODETBLWhereInputToJson(this);
}

@_i1.jsonSerializable
class ALLCODETBLOrderByWithRelationInput implements _i1.JsonSerializable {
  const ALLCODETBLOrderByWithRelationInput({
    this.codeType,
    this.codeName,
    this.unitType,
    this.unitName,
    this.sort,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory ALLCODETBLOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$ALLCODETBLOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'CODE_TYPE')
  final SortOrder? codeType;

  @JsonKey(name: r'CODE_NAME')
  final SortOrder? codeName;

  @JsonKey(name: r'UNIT_TYPE')
  final SortOrder? unitType;

  @JsonKey(name: r'UNIT_NAME')
  final SortOrder? unitName;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$ALLCODETBLOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class ALLCODETBLWhereUniqueInput implements _i1.JsonSerializable {
  const ALLCODETBLWhereUniqueInput({this.codeTypeUnitType});

  factory ALLCODETBLWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$ALLCODETBLWhereUniqueInputFromJson(json);

  @JsonKey(name: r'CODE_TYPE_UNIT_TYPE')
  final ALLCODETBLCODETYPEUNITTYPECompoundUniqueInput? codeTypeUnitType;

  @override
  Map<String, dynamic> toJson() => _$ALLCODETBLWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class ALLCODETBLOrderByWithAggregationInput implements _i1.JsonSerializable {
  const ALLCODETBLOrderByWithAggregationInput({
    this.codeType,
    this.codeName,
    this.unitType,
    this.unitName,
    this.sort,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory ALLCODETBLOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$ALLCODETBLOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'CODE_TYPE')
  final SortOrder? codeType;

  @JsonKey(name: r'CODE_NAME')
  final SortOrder? codeName;

  @JsonKey(name: r'UNIT_TYPE')
  final SortOrder? unitType;

  @JsonKey(name: r'UNIT_NAME')
  final SortOrder? unitName;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'_count')
  final ALLCODETBLCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final ALLCODETBLAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final ALLCODETBLMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final ALLCODETBLMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final ALLCODETBLSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$ALLCODETBLOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class ALLCODETBLScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const ALLCODETBLScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.codeType,
    this.codeName,
    this.unitType,
    this.unitName,
    this.sort,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory ALLCODETBLScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$ALLCODETBLScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<ALLCODETBLScalarWhereWithAggregatesInput>? AND;

  final Iterable<ALLCODETBLScalarWhereWithAggregatesInput>? OR;

  final Iterable<ALLCODETBLScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'CODE_TYPE')
  final StringWithAggregatesFilter? codeType;

  @JsonKey(name: r'CODE_NAME')
  final StringNullableWithAggregatesFilter? codeName;

  @JsonKey(name: r'UNIT_TYPE')
  final StringWithAggregatesFilter? unitType;

  @JsonKey(name: r'UNIT_NAME')
  final StringNullableWithAggregatesFilter? unitName;

  @JsonKey(name: r'SORT')
  final IntNullableWithAggregatesFilter? sort;

  @JsonKey(name: r'USE_YN')
  final StringNullableWithAggregatesFilter? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringNullableWithAggregatesFilter? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeWithAggregatesFilter? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeWithAggregatesFilter? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$ALLCODETBLScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALATTACHFILETBLWhereInput implements _i1.JsonSerializable {
  const APPROVALATTACHFILETBLWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.approvalId,
    this.seq,
    this.oriFileNm,
    this.saveFileNm,
    this.fileSize,
    this.regDate,
  });

  factory APPROVALATTACHFILETBLWhereInput.fromJson(Map<String, dynamic> json) =>
      _$APPROVALATTACHFILETBLWhereInputFromJson(json);

  final Iterable<APPROVALATTACHFILETBLWhereInput>? AND;

  final Iterable<APPROVALATTACHFILETBLWhereInput>? OR;

  final Iterable<APPROVALATTACHFILETBLWhereInput>? NOT;

  @JsonKey(name: r'APPROVAL_ID')
  final StringFilter? approvalId;

  @JsonKey(name: r'SEQ')
  final DecimalFilter? seq;

  @JsonKey(name: r'ORI_FILE_NM')
  final StringNullableFilter? oriFileNm;

  @JsonKey(name: r'SAVE_FILE_NM')
  final StringNullableFilter? saveFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final IntNullableFilter? fileSize;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFilter? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALATTACHFILETBLWhereInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALATTACHFILETBLOrderByWithRelationInput
    implements _i1.JsonSerializable {
  const APPROVALATTACHFILETBLOrderByWithRelationInput({
    this.approvalId,
    this.seq,
    this.oriFileNm,
    this.saveFileNm,
    this.fileSize,
    this.regDate,
  });

  factory APPROVALATTACHFILETBLOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALATTACHFILETBLOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final SortOrder? approvalId;

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ORI_FILE_NM')
  final SortOrder? oriFileNm;

  @JsonKey(name: r'SAVE_FILE_NM')
  final SortOrder? saveFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final SortOrder? fileSize;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALATTACHFILETBLOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALATTACHFILETBLWhereUniqueInput implements _i1.JsonSerializable {
  const APPROVALATTACHFILETBLWhereUniqueInput({this.approvalIdSeq});

  factory APPROVALATTACHFILETBLWhereUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALATTACHFILETBLWhereUniqueInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID_SEQ')
  final APPROVALATTACHFILETBLAPPROVALIDSEQCompoundUniqueInput? approvalIdSeq;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALATTACHFILETBLWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALATTACHFILETBLOrderByWithAggregationInput
    implements _i1.JsonSerializable {
  const APPROVALATTACHFILETBLOrderByWithAggregationInput({
    this.approvalId,
    this.seq,
    this.oriFileNm,
    this.saveFileNm,
    this.fileSize,
    this.regDate,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory APPROVALATTACHFILETBLOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALATTACHFILETBLOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final SortOrder? approvalId;

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ORI_FILE_NM')
  final SortOrder? oriFileNm;

  @JsonKey(name: r'SAVE_FILE_NM')
  final SortOrder? saveFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final SortOrder? fileSize;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'_count')
  final APPROVALATTACHFILETBLCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final APPROVALATTACHFILETBLAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final APPROVALATTACHFILETBLMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final APPROVALATTACHFILETBLMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final APPROVALATTACHFILETBLSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALATTACHFILETBLOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALATTACHFILETBLScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const APPROVALATTACHFILETBLScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.approvalId,
    this.seq,
    this.oriFileNm,
    this.saveFileNm,
    this.fileSize,
    this.regDate,
  });

  factory APPROVALATTACHFILETBLScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALATTACHFILETBLScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<APPROVALATTACHFILETBLScalarWhereWithAggregatesInput>? AND;

  final Iterable<APPROVALATTACHFILETBLScalarWhereWithAggregatesInput>? OR;

  final Iterable<APPROVALATTACHFILETBLScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'APPROVAL_ID')
  final StringWithAggregatesFilter? approvalId;

  @JsonKey(name: r'SEQ')
  final DecimalWithAggregatesFilter? seq;

  @JsonKey(name: r'ORI_FILE_NM')
  final StringNullableWithAggregatesFilter? oriFileNm;

  @JsonKey(name: r'SAVE_FILE_NM')
  final StringNullableWithAggregatesFilter? saveFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final IntNullableWithAggregatesFilter? fileSize;

  @JsonKey(name: r'REG_DATE')
  final DateTimeWithAggregatesFilter? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALATTACHFILETBLScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALDOCINFOTBLWhereInput implements _i1.JsonSerializable {
  const APPROVALDOCINFOTBLWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.docType,
    this.docNm,
    this.title,
    this.approvalLineType,
    this.approvalLineContent,
    this.approvalLineContentBak,
    this.content,
    this.writerId,
    this.userNm,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
  });

  factory APPROVALDOCINFOTBLWhereInput.fromJson(Map<String, dynamic> json) =>
      _$APPROVALDOCINFOTBLWhereInputFromJson(json);

  final Iterable<APPROVALDOCINFOTBLWhereInput>? AND;

  final Iterable<APPROVALDOCINFOTBLWhereInput>? OR;

  final Iterable<APPROVALDOCINFOTBLWhereInput>? NOT;

  @JsonKey(name: r'SEQ')
  final BigIntFilter? seq;

  @JsonKey(name: r'DOC_TYPE')
  final StringNullableFilter? docType;

  @JsonKey(name: r'DOC_NM')
  final StringNullableFilter? docNm;

  @JsonKey(name: r'TITLE')
  final StringFilter? title;

  @JsonKey(name: r'APPROVAL_LINE_TYPE')
  final StringNullableFilter? approvalLineType;

  @JsonKey(name: r'APPROVAL_LINE_CONTENT')
  final StringNullableFilter? approvalLineContent;

  @JsonKey(name: r'APPROVAL_LINE_CONTENT_BAK')
  final StringNullableFilter? approvalLineContentBak;

  @JsonKey(name: r'CONTENT')
  final StringNullableFilter? content;

  @JsonKey(name: r'WRITER_ID')
  final StringNullableFilter? writerId;

  @JsonKey(name: r'USER_NM')
  final StringNullableFilter? userNm;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFilter? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeNullableFilter? updDate;

  @JsonKey(name: r'USE_YN')
  final StringNullableFilter? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringNullableFilter? delYn;

  @override
  Map<String, dynamic> toJson() => _$APPROVALDOCINFOTBLWhereInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALDOCINFOTBLOrderByWithRelationInput
    implements _i1.JsonSerializable {
  const APPROVALDOCINFOTBLOrderByWithRelationInput({
    this.seq,
    this.docType,
    this.docNm,
    this.title,
    this.approvalLineType,
    this.approvalLineContent,
    this.approvalLineContentBak,
    this.content,
    this.writerId,
    this.userNm,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
  });

  factory APPROVALDOCINFOTBLOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALDOCINFOTBLOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'DOC_TYPE')
  final SortOrder? docType;

  @JsonKey(name: r'DOC_NM')
  final SortOrder? docNm;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'APPROVAL_LINE_TYPE')
  final SortOrder? approvalLineType;

  @JsonKey(name: r'APPROVAL_LINE_CONTENT')
  final SortOrder? approvalLineContent;

  @JsonKey(name: r'APPROVAL_LINE_CONTENT_BAK')
  final SortOrder? approvalLineContentBak;

  @JsonKey(name: r'CONTENT')
  final SortOrder? content;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'USER_NM')
  final SortOrder? userNm;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALDOCINFOTBLOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALDOCINFOTBLWhereUniqueInput implements _i1.JsonSerializable {
  const APPROVALDOCINFOTBLWhereUniqueInput({this.seq});

  factory APPROVALDOCINFOTBLWhereUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALDOCINFOTBLWhereUniqueInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALDOCINFOTBLWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALDOCINFOTBLOrderByWithAggregationInput
    implements _i1.JsonSerializable {
  const APPROVALDOCINFOTBLOrderByWithAggregationInput({
    this.seq,
    this.docType,
    this.docNm,
    this.title,
    this.approvalLineType,
    this.approvalLineContent,
    this.approvalLineContentBak,
    this.content,
    this.writerId,
    this.userNm,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory APPROVALDOCINFOTBLOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALDOCINFOTBLOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'DOC_TYPE')
  final SortOrder? docType;

  @JsonKey(name: r'DOC_NM')
  final SortOrder? docNm;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'APPROVAL_LINE_TYPE')
  final SortOrder? approvalLineType;

  @JsonKey(name: r'APPROVAL_LINE_CONTENT')
  final SortOrder? approvalLineContent;

  @JsonKey(name: r'APPROVAL_LINE_CONTENT_BAK')
  final SortOrder? approvalLineContentBak;

  @JsonKey(name: r'CONTENT')
  final SortOrder? content;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'USER_NM')
  final SortOrder? userNm;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'_count')
  final APPROVALDOCINFOTBLCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final APPROVALDOCINFOTBLAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final APPROVALDOCINFOTBLMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final APPROVALDOCINFOTBLMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final APPROVALDOCINFOTBLSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALDOCINFOTBLOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALDOCINFOTBLScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const APPROVALDOCINFOTBLScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.docType,
    this.docNm,
    this.title,
    this.approvalLineType,
    this.approvalLineContent,
    this.approvalLineContentBak,
    this.content,
    this.writerId,
    this.userNm,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
  });

  factory APPROVALDOCINFOTBLScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALDOCINFOTBLScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<APPROVALDOCINFOTBLScalarWhereWithAggregatesInput>? AND;

  final Iterable<APPROVALDOCINFOTBLScalarWhereWithAggregatesInput>? OR;

  final Iterable<APPROVALDOCINFOTBLScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'SEQ')
  final BigIntWithAggregatesFilter? seq;

  @JsonKey(name: r'DOC_TYPE')
  final StringNullableWithAggregatesFilter? docType;

  @JsonKey(name: r'DOC_NM')
  final StringNullableWithAggregatesFilter? docNm;

  @JsonKey(name: r'TITLE')
  final StringWithAggregatesFilter? title;

  @JsonKey(name: r'APPROVAL_LINE_TYPE')
  final StringNullableWithAggregatesFilter? approvalLineType;

  @JsonKey(name: r'APPROVAL_LINE_CONTENT')
  final StringNullableWithAggregatesFilter? approvalLineContent;

  @JsonKey(name: r'APPROVAL_LINE_CONTENT_BAK')
  final StringNullableWithAggregatesFilter? approvalLineContentBak;

  @JsonKey(name: r'CONTENT')
  final StringNullableWithAggregatesFilter? content;

  @JsonKey(name: r'WRITER_ID')
  final StringNullableWithAggregatesFilter? writerId;

  @JsonKey(name: r'USER_NM')
  final StringNullableWithAggregatesFilter? userNm;

  @JsonKey(name: r'REG_DATE')
  final DateTimeWithAggregatesFilter? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeNullableWithAggregatesFilter? updDate;

  @JsonKey(name: r'USE_YN')
  final StringNullableWithAggregatesFilter? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringNullableWithAggregatesFilter? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALDOCINFOTBLScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALHISTORYTBLWhereInput implements _i1.JsonSerializable {
  const APPROVALHISTORYTBLWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.docType,
    this.keepPriod,
    this.keepDate,
    this.grade,
    this.status,
    this.content,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALHISTORYTBLWhereInput.fromJson(Map<String, dynamic> json) =>
      _$APPROVALHISTORYTBLWhereInputFromJson(json);

  final Iterable<APPROVALHISTORYTBLWhereInput>? AND;

  final Iterable<APPROVALHISTORYTBLWhereInput>? OR;

  final Iterable<APPROVALHISTORYTBLWhereInput>? NOT;

  @JsonKey(name: r'SEQ')
  final BigIntFilter? seq;

  @JsonKey(name: r'APPROVAL_ID')
  final StringFilter? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final StringFilter? writerId;

  @JsonKey(name: r'WRITER_NM')
  final StringFilter? writerNm;

  @JsonKey(name: r'DOC_TYPE')
  final StringFilter? docType;

  @JsonKey(name: r'KEEP_PRIOD')
  final IntFilter? keepPriod;

  @JsonKey(name: r'KEEP_DATE')
  final DateTimeFilter? keepDate;

  @JsonKey(name: r'GRADE')
  final StringFilter? grade;

  @JsonKey(name: r'STATUS')
  final StringNullableFilter? status;

  @JsonKey(name: r'CONTENT')
  final StringNullableFilter? content;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFilter? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeNullableFilter? updDate;

  @JsonKey(name: r'DEL_YN')
  final StringNullableFilter? delYn;

  @override
  Map<String, dynamic> toJson() => _$APPROVALHISTORYTBLWhereInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALHISTORYTBLOrderByWithRelationInput
    implements _i1.JsonSerializable {
  const APPROVALHISTORYTBLOrderByWithRelationInput({
    this.seq,
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.docType,
    this.keepPriod,
    this.keepDate,
    this.grade,
    this.status,
    this.content,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALHISTORYTBLOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALHISTORYTBLOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'APPROVAL_ID')
  final SortOrder? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'WRITER_NM')
  final SortOrder? writerNm;

  @JsonKey(name: r'DOC_TYPE')
  final SortOrder? docType;

  @JsonKey(name: r'KEEP_PRIOD')
  final SortOrder? keepPriod;

  @JsonKey(name: r'KEEP_DATE')
  final SortOrder? keepDate;

  @JsonKey(name: r'GRADE')
  final SortOrder? grade;

  @JsonKey(name: r'STATUS')
  final SortOrder? status;

  @JsonKey(name: r'CONTENT')
  final SortOrder? content;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALHISTORYTBLOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALHISTORYTBLWhereUniqueInput implements _i1.JsonSerializable {
  const APPROVALHISTORYTBLWhereUniqueInput({this.seq});

  factory APPROVALHISTORYTBLWhereUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALHISTORYTBLWhereUniqueInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALHISTORYTBLWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALHISTORYTBLOrderByWithAggregationInput
    implements _i1.JsonSerializable {
  const APPROVALHISTORYTBLOrderByWithAggregationInput({
    this.seq,
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.docType,
    this.keepPriod,
    this.keepDate,
    this.grade,
    this.status,
    this.content,
    this.regDate,
    this.updDate,
    this.delYn,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory APPROVALHISTORYTBLOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALHISTORYTBLOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'APPROVAL_ID')
  final SortOrder? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'WRITER_NM')
  final SortOrder? writerNm;

  @JsonKey(name: r'DOC_TYPE')
  final SortOrder? docType;

  @JsonKey(name: r'KEEP_PRIOD')
  final SortOrder? keepPriod;

  @JsonKey(name: r'KEEP_DATE')
  final SortOrder? keepDate;

  @JsonKey(name: r'GRADE')
  final SortOrder? grade;

  @JsonKey(name: r'STATUS')
  final SortOrder? status;

  @JsonKey(name: r'CONTENT')
  final SortOrder? content;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'_count')
  final APPROVALHISTORYTBLCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final APPROVALHISTORYTBLAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final APPROVALHISTORYTBLMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final APPROVALHISTORYTBLMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final APPROVALHISTORYTBLSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALHISTORYTBLOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALHISTORYTBLScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const APPROVALHISTORYTBLScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.docType,
    this.keepPriod,
    this.keepDate,
    this.grade,
    this.status,
    this.content,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALHISTORYTBLScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALHISTORYTBLScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<APPROVALHISTORYTBLScalarWhereWithAggregatesInput>? AND;

  final Iterable<APPROVALHISTORYTBLScalarWhereWithAggregatesInput>? OR;

  final Iterable<APPROVALHISTORYTBLScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'SEQ')
  final BigIntWithAggregatesFilter? seq;

  @JsonKey(name: r'APPROVAL_ID')
  final StringWithAggregatesFilter? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final StringWithAggregatesFilter? writerId;

  @JsonKey(name: r'WRITER_NM')
  final StringWithAggregatesFilter? writerNm;

  @JsonKey(name: r'DOC_TYPE')
  final StringWithAggregatesFilter? docType;

  @JsonKey(name: r'KEEP_PRIOD')
  final IntWithAggregatesFilter? keepPriod;

  @JsonKey(name: r'KEEP_DATE')
  final DateTimeWithAggregatesFilter? keepDate;

  @JsonKey(name: r'GRADE')
  final StringWithAggregatesFilter? grade;

  @JsonKey(name: r'STATUS')
  final StringNullableWithAggregatesFilter? status;

  @JsonKey(name: r'CONTENT')
  final StringNullableWithAggregatesFilter? content;

  @JsonKey(name: r'REG_DATE')
  final DateTimeWithAggregatesFilter? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeNullableWithAggregatesFilter? updDate;

  @JsonKey(name: r'DEL_YN')
  final StringNullableWithAggregatesFilter? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALHISTORYTBLScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALMASTERTBLWhereInput implements _i1.JsonSerializable {
  const APPROVALMASTERTBLWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.docType,
    this.keepPriod,
    this.keepDate,
    this.grade,
    this.status,
    this.title,
    this.header,
    this.content,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
    this.regDate,
    this.completeDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALMASTERTBLWhereInput.fromJson(Map<String, dynamic> json) =>
      _$APPROVALMASTERTBLWhereInputFromJson(json);

  final Iterable<APPROVALMASTERTBLWhereInput>? AND;

  final Iterable<APPROVALMASTERTBLWhereInput>? OR;

  final Iterable<APPROVALMASTERTBLWhereInput>? NOT;

  @JsonKey(name: r'APPROVAL_ID')
  final StringFilter? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final StringFilter? writerId;

  @JsonKey(name: r'WRITER_NM')
  final StringFilter? writerNm;

  @JsonKey(name: r'DOC_TYPE')
  final StringFilter? docType;

  @JsonKey(name: r'KEEP_PRIOD')
  final IntFilter? keepPriod;

  @JsonKey(name: r'KEEP_DATE')
  final DateTimeFilter? keepDate;

  @JsonKey(name: r'GRADE')
  final StringFilter? grade;

  @JsonKey(name: r'STATUS')
  final StringNullableFilter? status;

  @JsonKey(name: r'TITLE')
  final StringNullableFilter? title;

  @JsonKey(name: r'HEADER')
  final StringNullableFilter? header;

  @JsonKey(name: r'CONTENT')
  final StringNullableFilter? content;

  @JsonKey(name: r'M1')
  final DecimalNullableFilter? m1;

  @JsonKey(name: r'M2')
  final DecimalNullableFilter? m2;

  @JsonKey(name: r'M3')
  final DecimalNullableFilter? m3;

  @JsonKey(name: r'M4')
  final DecimalNullableFilter? m4;

  @JsonKey(name: r'M5')
  final DecimalNullableFilter? m5;

  @JsonKey(name: r'M6')
  final DecimalNullableFilter? m6;

  @JsonKey(name: r'M7')
  final DecimalNullableFilter? m7;

  @JsonKey(name: r'M8')
  final DecimalNullableFilter? m8;

  @JsonKey(name: r'M9')
  final DecimalNullableFilter? m9;

  @JsonKey(name: r'M10')
  final DecimalNullableFilter? m10;

  @JsonKey(name: r'M11')
  final DecimalNullableFilter? m11;

  @JsonKey(name: r'M12')
  final DecimalNullableFilter? m12;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFilter? regDate;

  @JsonKey(name: r'COMPLETE_DATE')
  final DateTimeFilter? completeDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeNullableFilter? updDate;

  @JsonKey(name: r'DEL_YN')
  final StringNullableFilter? delYn;

  @override
  Map<String, dynamic> toJson() => _$APPROVALMASTERTBLWhereInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALMASTERTBLOrderByWithRelationInput
    implements _i1.JsonSerializable {
  const APPROVALMASTERTBLOrderByWithRelationInput({
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.docType,
    this.keepPriod,
    this.keepDate,
    this.grade,
    this.status,
    this.title,
    this.header,
    this.content,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
    this.regDate,
    this.completeDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALMASTERTBLOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALMASTERTBLOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final SortOrder? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'WRITER_NM')
  final SortOrder? writerNm;

  @JsonKey(name: r'DOC_TYPE')
  final SortOrder? docType;

  @JsonKey(name: r'KEEP_PRIOD')
  final SortOrder? keepPriod;

  @JsonKey(name: r'KEEP_DATE')
  final SortOrder? keepDate;

  @JsonKey(name: r'GRADE')
  final SortOrder? grade;

  @JsonKey(name: r'STATUS')
  final SortOrder? status;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'HEADER')
  final SortOrder? header;

  @JsonKey(name: r'CONTENT')
  final SortOrder? content;

  @JsonKey(name: r'M1')
  final SortOrder? m1;

  @JsonKey(name: r'M2')
  final SortOrder? m2;

  @JsonKey(name: r'M3')
  final SortOrder? m3;

  @JsonKey(name: r'M4')
  final SortOrder? m4;

  @JsonKey(name: r'M5')
  final SortOrder? m5;

  @JsonKey(name: r'M6')
  final SortOrder? m6;

  @JsonKey(name: r'M7')
  final SortOrder? m7;

  @JsonKey(name: r'M8')
  final SortOrder? m8;

  @JsonKey(name: r'M9')
  final SortOrder? m9;

  @JsonKey(name: r'M10')
  final SortOrder? m10;

  @JsonKey(name: r'M11')
  final SortOrder? m11;

  @JsonKey(name: r'M12')
  final SortOrder? m12;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'COMPLETE_DATE')
  final SortOrder? completeDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALMASTERTBLOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALMASTERTBLWhereUniqueInput implements _i1.JsonSerializable {
  const APPROVALMASTERTBLWhereUniqueInput({this.approvalId});

  factory APPROVALMASTERTBLWhereUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALMASTERTBLWhereUniqueInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final String? approvalId;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALMASTERTBLWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALMASTERTBLOrderByWithAggregationInput
    implements _i1.JsonSerializable {
  const APPROVALMASTERTBLOrderByWithAggregationInput({
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.docType,
    this.keepPriod,
    this.keepDate,
    this.grade,
    this.status,
    this.title,
    this.header,
    this.content,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
    this.regDate,
    this.completeDate,
    this.updDate,
    this.delYn,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory APPROVALMASTERTBLOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALMASTERTBLOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final SortOrder? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'WRITER_NM')
  final SortOrder? writerNm;

  @JsonKey(name: r'DOC_TYPE')
  final SortOrder? docType;

  @JsonKey(name: r'KEEP_PRIOD')
  final SortOrder? keepPriod;

  @JsonKey(name: r'KEEP_DATE')
  final SortOrder? keepDate;

  @JsonKey(name: r'GRADE')
  final SortOrder? grade;

  @JsonKey(name: r'STATUS')
  final SortOrder? status;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'HEADER')
  final SortOrder? header;

  @JsonKey(name: r'CONTENT')
  final SortOrder? content;

  @JsonKey(name: r'M1')
  final SortOrder? m1;

  @JsonKey(name: r'M2')
  final SortOrder? m2;

  @JsonKey(name: r'M3')
  final SortOrder? m3;

  @JsonKey(name: r'M4')
  final SortOrder? m4;

  @JsonKey(name: r'M5')
  final SortOrder? m5;

  @JsonKey(name: r'M6')
  final SortOrder? m6;

  @JsonKey(name: r'M7')
  final SortOrder? m7;

  @JsonKey(name: r'M8')
  final SortOrder? m8;

  @JsonKey(name: r'M9')
  final SortOrder? m9;

  @JsonKey(name: r'M10')
  final SortOrder? m10;

  @JsonKey(name: r'M11')
  final SortOrder? m11;

  @JsonKey(name: r'M12')
  final SortOrder? m12;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'COMPLETE_DATE')
  final SortOrder? completeDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'_count')
  final APPROVALMASTERTBLCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final APPROVALMASTERTBLAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final APPROVALMASTERTBLMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final APPROVALMASTERTBLMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final APPROVALMASTERTBLSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALMASTERTBLOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALMASTERTBLScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const APPROVALMASTERTBLScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.docType,
    this.keepPriod,
    this.keepDate,
    this.grade,
    this.status,
    this.title,
    this.header,
    this.content,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
    this.regDate,
    this.completeDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALMASTERTBLScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALMASTERTBLScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<APPROVALMASTERTBLScalarWhereWithAggregatesInput>? AND;

  final Iterable<APPROVALMASTERTBLScalarWhereWithAggregatesInput>? OR;

  final Iterable<APPROVALMASTERTBLScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'APPROVAL_ID')
  final StringWithAggregatesFilter? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final StringWithAggregatesFilter? writerId;

  @JsonKey(name: r'WRITER_NM')
  final StringWithAggregatesFilter? writerNm;

  @JsonKey(name: r'DOC_TYPE')
  final StringWithAggregatesFilter? docType;

  @JsonKey(name: r'KEEP_PRIOD')
  final IntWithAggregatesFilter? keepPriod;

  @JsonKey(name: r'KEEP_DATE')
  final DateTimeWithAggregatesFilter? keepDate;

  @JsonKey(name: r'GRADE')
  final StringWithAggregatesFilter? grade;

  @JsonKey(name: r'STATUS')
  final StringNullableWithAggregatesFilter? status;

  @JsonKey(name: r'TITLE')
  final StringNullableWithAggregatesFilter? title;

  @JsonKey(name: r'HEADER')
  final StringNullableWithAggregatesFilter? header;

  @JsonKey(name: r'CONTENT')
  final StringNullableWithAggregatesFilter? content;

  @JsonKey(name: r'M1')
  final DecimalNullableWithAggregatesFilter? m1;

  @JsonKey(name: r'M2')
  final DecimalNullableWithAggregatesFilter? m2;

  @JsonKey(name: r'M3')
  final DecimalNullableWithAggregatesFilter? m3;

  @JsonKey(name: r'M4')
  final DecimalNullableWithAggregatesFilter? m4;

  @JsonKey(name: r'M5')
  final DecimalNullableWithAggregatesFilter? m5;

  @JsonKey(name: r'M6')
  final DecimalNullableWithAggregatesFilter? m6;

  @JsonKey(name: r'M7')
  final DecimalNullableWithAggregatesFilter? m7;

  @JsonKey(name: r'M8')
  final DecimalNullableWithAggregatesFilter? m8;

  @JsonKey(name: r'M9')
  final DecimalNullableWithAggregatesFilter? m9;

  @JsonKey(name: r'M10')
  final DecimalNullableWithAggregatesFilter? m10;

  @JsonKey(name: r'M11')
  final DecimalNullableWithAggregatesFilter? m11;

  @JsonKey(name: r'M12')
  final DecimalNullableWithAggregatesFilter? m12;

  @JsonKey(name: r'REG_DATE')
  final DateTimeWithAggregatesFilter? regDate;

  @JsonKey(name: r'COMPLETE_DATE')
  final DateTimeWithAggregatesFilter? completeDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeNullableWithAggregatesFilter? updDate;

  @JsonKey(name: r'DEL_YN')
  final StringNullableWithAggregatesFilter? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALMASTERTBLScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALMEMOTBLWhereInput implements _i1.JsonSerializable {
  const APPROVALMEMOTBLWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.content,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALMEMOTBLWhereInput.fromJson(Map<String, dynamic> json) =>
      _$APPROVALMEMOTBLWhereInputFromJson(json);

  final Iterable<APPROVALMEMOTBLWhereInput>? AND;

  final Iterable<APPROVALMEMOTBLWhereInput>? OR;

  final Iterable<APPROVALMEMOTBLWhereInput>? NOT;

  @JsonKey(name: r'SEQ')
  final BigIntFilter? seq;

  @JsonKey(name: r'APPROVAL_ID')
  final StringFilter? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final StringFilter? writerId;

  @JsonKey(name: r'WRITER_NM')
  final StringFilter? writerNm;

  @JsonKey(name: r'CONTENT')
  final StringNullableFilter? content;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFilter? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeNullableFilter? updDate;

  @JsonKey(name: r'DEL_YN')
  final StringNullableFilter? delYn;

  @override
  Map<String, dynamic> toJson() => _$APPROVALMEMOTBLWhereInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALMEMOTBLOrderByWithRelationInput implements _i1.JsonSerializable {
  const APPROVALMEMOTBLOrderByWithRelationInput({
    this.seq,
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.content,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALMEMOTBLOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALMEMOTBLOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'APPROVAL_ID')
  final SortOrder? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'WRITER_NM')
  final SortOrder? writerNm;

  @JsonKey(name: r'CONTENT')
  final SortOrder? content;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALMEMOTBLOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALMEMOTBLWhereUniqueInput implements _i1.JsonSerializable {
  const APPROVALMEMOTBLWhereUniqueInput({this.seq});

  factory APPROVALMEMOTBLWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$APPROVALMEMOTBLWhereUniqueInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALMEMOTBLWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALMEMOTBLOrderByWithAggregationInput
    implements _i1.JsonSerializable {
  const APPROVALMEMOTBLOrderByWithAggregationInput({
    this.seq,
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.content,
    this.regDate,
    this.updDate,
    this.delYn,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory APPROVALMEMOTBLOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALMEMOTBLOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'APPROVAL_ID')
  final SortOrder? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'WRITER_NM')
  final SortOrder? writerNm;

  @JsonKey(name: r'CONTENT')
  final SortOrder? content;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'_count')
  final APPROVALMEMOTBLCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final APPROVALMEMOTBLAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final APPROVALMEMOTBLMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final APPROVALMEMOTBLMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final APPROVALMEMOTBLSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALMEMOTBLOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALMEMOTBLScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const APPROVALMEMOTBLScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.content,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALMEMOTBLScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALMEMOTBLScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<APPROVALMEMOTBLScalarWhereWithAggregatesInput>? AND;

  final Iterable<APPROVALMEMOTBLScalarWhereWithAggregatesInput>? OR;

  final Iterable<APPROVALMEMOTBLScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'SEQ')
  final BigIntWithAggregatesFilter? seq;

  @JsonKey(name: r'APPROVAL_ID')
  final StringWithAggregatesFilter? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final StringWithAggregatesFilter? writerId;

  @JsonKey(name: r'WRITER_NM')
  final StringWithAggregatesFilter? writerNm;

  @JsonKey(name: r'CONTENT')
  final StringNullableWithAggregatesFilter? content;

  @JsonKey(name: r'REG_DATE')
  final DateTimeWithAggregatesFilter? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeNullableWithAggregatesFilter? updDate;

  @JsonKey(name: r'DEL_YN')
  final StringNullableWithAggregatesFilter? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALMEMOTBLScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALTYPETBLWhereInput implements _i1.JsonSerializable {
  const APPROVALTYPETBLWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.type,
    this.content,
    this.contentBak,
    this.useYn,
    this.delYn,
  });

  factory APPROVALTYPETBLWhereInput.fromJson(Map<String, dynamic> json) =>
      _$APPROVALTYPETBLWhereInputFromJson(json);

  final Iterable<APPROVALTYPETBLWhereInput>? AND;

  final Iterable<APPROVALTYPETBLWhereInput>? OR;

  final Iterable<APPROVALTYPETBLWhereInput>? NOT;

  @JsonKey(name: r'TYPE')
  final StringFilter? type;

  @JsonKey(name: r'CONTENT')
  final StringNullableFilter? content;

  @JsonKey(name: r'CONTENT_BAK')
  final StringNullableFilter? contentBak;

  @JsonKey(name: r'USE_YN')
  final StringNullableFilter? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringNullableFilter? delYn;

  @override
  Map<String, dynamic> toJson() => _$APPROVALTYPETBLWhereInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALTYPETBLOrderByWithRelationInput implements _i1.JsonSerializable {
  const APPROVALTYPETBLOrderByWithRelationInput({
    this.type,
    this.content,
    this.contentBak,
    this.useYn,
    this.delYn,
  });

  factory APPROVALTYPETBLOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALTYPETBLOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'TYPE')
  final SortOrder? type;

  @JsonKey(name: r'CONTENT')
  final SortOrder? content;

  @JsonKey(name: r'CONTENT_BAK')
  final SortOrder? contentBak;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALTYPETBLOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALTYPETBLWhereUniqueInput implements _i1.JsonSerializable {
  const APPROVALTYPETBLWhereUniqueInput({this.type});

  factory APPROVALTYPETBLWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$APPROVALTYPETBLWhereUniqueInputFromJson(json);

  @JsonKey(name: r'TYPE')
  final String? type;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALTYPETBLWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALTYPETBLOrderByWithAggregationInput
    implements _i1.JsonSerializable {
  const APPROVALTYPETBLOrderByWithAggregationInput({
    this.type,
    this.content,
    this.contentBak,
    this.useYn,
    this.delYn,
    this.$count,
    this.$max,
    this.$min,
  });

  factory APPROVALTYPETBLOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALTYPETBLOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'TYPE')
  final SortOrder? type;

  @JsonKey(name: r'CONTENT')
  final SortOrder? content;

  @JsonKey(name: r'CONTENT_BAK')
  final SortOrder? contentBak;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'_count')
  final APPROVALTYPETBLCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_max')
  final APPROVALTYPETBLMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final APPROVALTYPETBLMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALTYPETBLOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALTYPETBLScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const APPROVALTYPETBLScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.type,
    this.content,
    this.contentBak,
    this.useYn,
    this.delYn,
  });

  factory APPROVALTYPETBLScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALTYPETBLScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<APPROVALTYPETBLScalarWhereWithAggregatesInput>? AND;

  final Iterable<APPROVALTYPETBLScalarWhereWithAggregatesInput>? OR;

  final Iterable<APPROVALTYPETBLScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'TYPE')
  final StringWithAggregatesFilter? type;

  @JsonKey(name: r'CONTENT')
  final StringNullableWithAggregatesFilter? content;

  @JsonKey(name: r'CONTENT_BAK')
  final StringNullableWithAggregatesFilter? contentBak;

  @JsonKey(name: r'USE_YN')
  final StringNullableWithAggregatesFilter? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringNullableWithAggregatesFilter? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALTYPETBLScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALUSERTBLWhereInput implements _i1.JsonSerializable {
  const APPROVALUSERTBLWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.approvalId,
    this.approvalUsrId,
    this.approvalUsrGradeCd,
    this.approvalUsrType,
    this.approvalUsrSort,
    this.approvalProcUserYn,
    this.approvalProcYn,
    this.approvalProcDate,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALUSERTBLWhereInput.fromJson(Map<String, dynamic> json) =>
      _$APPROVALUSERTBLWhereInputFromJson(json);

  final Iterable<APPROVALUSERTBLWhereInput>? AND;

  final Iterable<APPROVALUSERTBLWhereInput>? OR;

  final Iterable<APPROVALUSERTBLWhereInput>? NOT;

  @JsonKey(name: r'APPROVAL_ID')
  final StringFilter? approvalId;

  @JsonKey(name: r'APPROVAL_USR_ID')
  final StringFilter? approvalUsrId;

  @JsonKey(name: r'APPROVAL_USR_GRADE_CD')
  final StringNullableFilter? approvalUsrGradeCd;

  @JsonKey(name: r'APPROVAL_USR_TYPE')
  final StringFilter? approvalUsrType;

  @JsonKey(name: r'APPROVAL_USR_SORT')
  final IntFilter? approvalUsrSort;

  @JsonKey(name: r'APPROVAL_PROC_USER_YN')
  final StringNullableFilter? approvalProcUserYn;

  @JsonKey(name: r'APPROVAL_PROC_YN')
  final StringFilter? approvalProcYn;

  @JsonKey(name: r'APPROVAL_PROC_DATE')
  final DateTimeFilter? approvalProcDate;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFilter? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeNullableFilter? updDate;

  @JsonKey(name: r'DEL_YN')
  final StringNullableFilter? delYn;

  @override
  Map<String, dynamic> toJson() => _$APPROVALUSERTBLWhereInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALUSERTBLOrderByWithRelationInput implements _i1.JsonSerializable {
  const APPROVALUSERTBLOrderByWithRelationInput({
    this.approvalId,
    this.approvalUsrId,
    this.approvalUsrGradeCd,
    this.approvalUsrType,
    this.approvalUsrSort,
    this.approvalProcUserYn,
    this.approvalProcYn,
    this.approvalProcDate,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALUSERTBLOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALUSERTBLOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final SortOrder? approvalId;

  @JsonKey(name: r'APPROVAL_USR_ID')
  final SortOrder? approvalUsrId;

  @JsonKey(name: r'APPROVAL_USR_GRADE_CD')
  final SortOrder? approvalUsrGradeCd;

  @JsonKey(name: r'APPROVAL_USR_TYPE')
  final SortOrder? approvalUsrType;

  @JsonKey(name: r'APPROVAL_USR_SORT')
  final SortOrder? approvalUsrSort;

  @JsonKey(name: r'APPROVAL_PROC_USER_YN')
  final SortOrder? approvalProcUserYn;

  @JsonKey(name: r'APPROVAL_PROC_YN')
  final SortOrder? approvalProcYn;

  @JsonKey(name: r'APPROVAL_PROC_DATE')
  final SortOrder? approvalProcDate;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALUSERTBLOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALUSERTBLWhereUniqueInput implements _i1.JsonSerializable {
  const APPROVALUSERTBLWhereUniqueInput(
      {this.approvalIdApprovalUsrIdApprovalUsrType});

  factory APPROVALUSERTBLWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$APPROVALUSERTBLWhereUniqueInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID_APPROVAL_USR_ID_APPROVAL_USR_TYPE')
  final APPROVALUSERTBLAPPROVALIDAPPROVALUSRIDAPPROVALUSRTYPECompoundUniqueInput?
      approvalIdApprovalUsrIdApprovalUsrType;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALUSERTBLWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALUSERTBLOrderByWithAggregationInput
    implements _i1.JsonSerializable {
  const APPROVALUSERTBLOrderByWithAggregationInput({
    this.approvalId,
    this.approvalUsrId,
    this.approvalUsrGradeCd,
    this.approvalUsrType,
    this.approvalUsrSort,
    this.approvalProcUserYn,
    this.approvalProcYn,
    this.approvalProcDate,
    this.regDate,
    this.updDate,
    this.delYn,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory APPROVALUSERTBLOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALUSERTBLOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final SortOrder? approvalId;

  @JsonKey(name: r'APPROVAL_USR_ID')
  final SortOrder? approvalUsrId;

  @JsonKey(name: r'APPROVAL_USR_GRADE_CD')
  final SortOrder? approvalUsrGradeCd;

  @JsonKey(name: r'APPROVAL_USR_TYPE')
  final SortOrder? approvalUsrType;

  @JsonKey(name: r'APPROVAL_USR_SORT')
  final SortOrder? approvalUsrSort;

  @JsonKey(name: r'APPROVAL_PROC_USER_YN')
  final SortOrder? approvalProcUserYn;

  @JsonKey(name: r'APPROVAL_PROC_YN')
  final SortOrder? approvalProcYn;

  @JsonKey(name: r'APPROVAL_PROC_DATE')
  final SortOrder? approvalProcDate;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'_count')
  final APPROVALUSERTBLCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final APPROVALUSERTBLAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final APPROVALUSERTBLMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final APPROVALUSERTBLMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final APPROVALUSERTBLSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALUSERTBLOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALUSERTBLScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const APPROVALUSERTBLScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.approvalId,
    this.approvalUsrId,
    this.approvalUsrGradeCd,
    this.approvalUsrType,
    this.approvalUsrSort,
    this.approvalProcUserYn,
    this.approvalProcYn,
    this.approvalProcDate,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALUSERTBLScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALUSERTBLScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<APPROVALUSERTBLScalarWhereWithAggregatesInput>? AND;

  final Iterable<APPROVALUSERTBLScalarWhereWithAggregatesInput>? OR;

  final Iterable<APPROVALUSERTBLScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'APPROVAL_ID')
  final StringWithAggregatesFilter? approvalId;

  @JsonKey(name: r'APPROVAL_USR_ID')
  final StringWithAggregatesFilter? approvalUsrId;

  @JsonKey(name: r'APPROVAL_USR_GRADE_CD')
  final StringNullableWithAggregatesFilter? approvalUsrGradeCd;

  @JsonKey(name: r'APPROVAL_USR_TYPE')
  final StringWithAggregatesFilter? approvalUsrType;

  @JsonKey(name: r'APPROVAL_USR_SORT')
  final IntWithAggregatesFilter? approvalUsrSort;

  @JsonKey(name: r'APPROVAL_PROC_USER_YN')
  final StringNullableWithAggregatesFilter? approvalProcUserYn;

  @JsonKey(name: r'APPROVAL_PROC_YN')
  final StringWithAggregatesFilter? approvalProcYn;

  @JsonKey(name: r'APPROVAL_PROC_DATE')
  final DateTimeWithAggregatesFilter? approvalProcDate;

  @JsonKey(name: r'REG_DATE')
  final DateTimeWithAggregatesFilter? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeNullableWithAggregatesFilter? updDate;

  @JsonKey(name: r'DEL_YN')
  final StringNullableWithAggregatesFilter? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALUSERTBLScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class BOOKASSETTBLWhereInput implements _i1.JsonSerializable {
  const BOOKASSETTBLWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.assetNo,
    this.bookNm,
    this.cnt,
    this.publisher,
    this.amount,
    this.buyDate,
    this.mngDept,
    this.rentYn,
    this.rentUser,
    this.remarks,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory BOOKASSETTBLWhereInput.fromJson(Map<String, dynamic> json) =>
      _$BOOKASSETTBLWhereInputFromJson(json);

  final Iterable<BOOKASSETTBLWhereInput>? AND;

  final Iterable<BOOKASSETTBLWhereInput>? OR;

  final Iterable<BOOKASSETTBLWhereInput>? NOT;

  @JsonKey(name: r'SEQ')
  final BigIntFilter? seq;

  @JsonKey(name: r'ASSET_NO')
  final StringFilter? assetNo;

  @JsonKey(name: r'BOOK_NM')
  final StringNullableFilter? bookNm;

  @JsonKey(name: r'CNT')
  final IntNullableFilter? cnt;

  @JsonKey(name: r'PUBLISHER')
  final StringNullableFilter? publisher;

  @JsonKey(name: r'AMOUNT')
  final IntNullableFilter? amount;

  @JsonKey(name: r'BUY_DATE')
  final StringNullableFilter? buyDate;

  @JsonKey(name: r'MNG_DEPT')
  final StringNullableFilter? mngDept;

  @JsonKey(name: r'RENT_YN')
  final StringNullableFilter? rentYn;

  @JsonKey(name: r'RENT_USER')
  final StringNullableFilter? rentUser;

  @JsonKey(name: r'REMARKS')
  final StringNullableFilter? remarks;

  @JsonKey(name: r'USE_YN')
  final StringFilter? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringFilter? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFilter? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeNullableFilter? updDate;

  @override
  Map<String, dynamic> toJson() => _$BOOKASSETTBLWhereInputToJson(this);
}

@_i1.jsonSerializable
class BOOKASSETTBLOrderByWithRelationInput implements _i1.JsonSerializable {
  const BOOKASSETTBLOrderByWithRelationInput({
    this.seq,
    this.assetNo,
    this.bookNm,
    this.cnt,
    this.publisher,
    this.amount,
    this.buyDate,
    this.mngDept,
    this.rentYn,
    this.rentUser,
    this.remarks,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory BOOKASSETTBLOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$BOOKASSETTBLOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ASSET_NO')
  final SortOrder? assetNo;

  @JsonKey(name: r'BOOK_NM')
  final SortOrder? bookNm;

  @JsonKey(name: r'CNT')
  final SortOrder? cnt;

  @JsonKey(name: r'PUBLISHER')
  final SortOrder? publisher;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @JsonKey(name: r'BUY_DATE')
  final SortOrder? buyDate;

  @JsonKey(name: r'MNG_DEPT')
  final SortOrder? mngDept;

  @JsonKey(name: r'RENT_YN')
  final SortOrder? rentYn;

  @JsonKey(name: r'RENT_USER')
  final SortOrder? rentUser;

  @JsonKey(name: r'REMARKS')
  final SortOrder? remarks;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$BOOKASSETTBLOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class BOOKASSETTBLWhereUniqueInput implements _i1.JsonSerializable {
  const BOOKASSETTBLWhereUniqueInput({this.seq});

  factory BOOKASSETTBLWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$BOOKASSETTBLWhereUniqueInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @override
  Map<String, dynamic> toJson() => _$BOOKASSETTBLWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class BOOKASSETTBLOrderByWithAggregationInput implements _i1.JsonSerializable {
  const BOOKASSETTBLOrderByWithAggregationInput({
    this.seq,
    this.assetNo,
    this.bookNm,
    this.cnt,
    this.publisher,
    this.amount,
    this.buyDate,
    this.mngDept,
    this.rentYn,
    this.rentUser,
    this.remarks,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory BOOKASSETTBLOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$BOOKASSETTBLOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ASSET_NO')
  final SortOrder? assetNo;

  @JsonKey(name: r'BOOK_NM')
  final SortOrder? bookNm;

  @JsonKey(name: r'CNT')
  final SortOrder? cnt;

  @JsonKey(name: r'PUBLISHER')
  final SortOrder? publisher;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @JsonKey(name: r'BUY_DATE')
  final SortOrder? buyDate;

  @JsonKey(name: r'MNG_DEPT')
  final SortOrder? mngDept;

  @JsonKey(name: r'RENT_YN')
  final SortOrder? rentYn;

  @JsonKey(name: r'RENT_USER')
  final SortOrder? rentUser;

  @JsonKey(name: r'REMARKS')
  final SortOrder? remarks;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'_count')
  final BOOKASSETTBLCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final BOOKASSETTBLAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final BOOKASSETTBLMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final BOOKASSETTBLMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final BOOKASSETTBLSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$BOOKASSETTBLOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class BOOKASSETTBLScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const BOOKASSETTBLScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.assetNo,
    this.bookNm,
    this.cnt,
    this.publisher,
    this.amount,
    this.buyDate,
    this.mngDept,
    this.rentYn,
    this.rentUser,
    this.remarks,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory BOOKASSETTBLScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$BOOKASSETTBLScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<BOOKASSETTBLScalarWhereWithAggregatesInput>? AND;

  final Iterable<BOOKASSETTBLScalarWhereWithAggregatesInput>? OR;

  final Iterable<BOOKASSETTBLScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'SEQ')
  final BigIntWithAggregatesFilter? seq;

  @JsonKey(name: r'ASSET_NO')
  final StringWithAggregatesFilter? assetNo;

  @JsonKey(name: r'BOOK_NM')
  final StringNullableWithAggregatesFilter? bookNm;

  @JsonKey(name: r'CNT')
  final IntNullableWithAggregatesFilter? cnt;

  @JsonKey(name: r'PUBLISHER')
  final StringNullableWithAggregatesFilter? publisher;

  @JsonKey(name: r'AMOUNT')
  final IntNullableWithAggregatesFilter? amount;

  @JsonKey(name: r'BUY_DATE')
  final StringNullableWithAggregatesFilter? buyDate;

  @JsonKey(name: r'MNG_DEPT')
  final StringNullableWithAggregatesFilter? mngDept;

  @JsonKey(name: r'RENT_YN')
  final StringNullableWithAggregatesFilter? rentYn;

  @JsonKey(name: r'RENT_USER')
  final StringNullableWithAggregatesFilter? rentUser;

  @JsonKey(name: r'REMARKS')
  final StringNullableWithAggregatesFilter? remarks;

  @JsonKey(name: r'USE_YN')
  final StringWithAggregatesFilter? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringWithAggregatesFilter? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeWithAggregatesFilter? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeNullableWithAggregatesFilter? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$BOOKASSETTBLScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETINSURTBLWhereInput implements _i1.JsonSerializable {
  const CARASSETINSURTBLWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.mseq,
    this.guarantee,
  });

  factory CARASSETINSURTBLWhereInput.fromJson(Map<String, dynamic> json) =>
      _$CARASSETINSURTBLWhereInputFromJson(json);

  final Iterable<CARASSETINSURTBLWhereInput>? AND;

  final Iterable<CARASSETINSURTBLWhereInput>? OR;

  final Iterable<CARASSETINSURTBLWhereInput>? NOT;

  @JsonKey(name: r'SEQ')
  final BigIntFilter? seq;

  @JsonKey(name: r'MSEQ')
  final BigIntFilter? mseq;

  @JsonKey(name: r'GUARANTEE')
  final StringFilter? guarantee;

  @override
  Map<String, dynamic> toJson() => _$CARASSETINSURTBLWhereInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETINSURTBLOrderByWithRelationInput implements _i1.JsonSerializable {
  const CARASSETINSURTBLOrderByWithRelationInput({
    this.seq,
    this.mseq,
    this.guarantee,
  });

  factory CARASSETINSURTBLOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARASSETINSURTBLOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'GUARANTEE')
  final SortOrder? guarantee;

  @override
  Map<String, dynamic> toJson() =>
      _$CARASSETINSURTBLOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETINSURTBLWhereUniqueInput implements _i1.JsonSerializable {
  const CARASSETINSURTBLWhereUniqueInput({this.seq});

  factory CARASSETINSURTBLWhereUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARASSETINSURTBLWhereUniqueInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @override
  Map<String, dynamic> toJson() =>
      _$CARASSETINSURTBLWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETINSURTBLOrderByWithAggregationInput
    implements _i1.JsonSerializable {
  const CARASSETINSURTBLOrderByWithAggregationInput({
    this.seq,
    this.mseq,
    this.guarantee,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory CARASSETINSURTBLOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARASSETINSURTBLOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'GUARANTEE')
  final SortOrder? guarantee;

  @JsonKey(name: r'_count')
  final CARASSETINSURTBLCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final CARASSETINSURTBLAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final CARASSETINSURTBLMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final CARASSETINSURTBLMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final CARASSETINSURTBLSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$CARASSETINSURTBLOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETINSURTBLScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const CARASSETINSURTBLScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.mseq,
    this.guarantee,
  });

  factory CARASSETINSURTBLScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARASSETINSURTBLScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<CARASSETINSURTBLScalarWhereWithAggregatesInput>? AND;

  final Iterable<CARASSETINSURTBLScalarWhereWithAggregatesInput>? OR;

  final Iterable<CARASSETINSURTBLScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'SEQ')
  final BigIntWithAggregatesFilter? seq;

  @JsonKey(name: r'MSEQ')
  final BigIntWithAggregatesFilter? mseq;

  @JsonKey(name: r'GUARANTEE')
  final StringWithAggregatesFilter? guarantee;

  @override
  Map<String, dynamic> toJson() =>
      _$CARASSETINSURTBLScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETTBLWhereInput implements _i1.JsonSerializable {
  const CARASSETTBLWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.assetNo,
    this.modelNo,
    this.carNo,
    this.owner,
    this.ownerType,
    this.amount,
    this.buyDate,
    this.seller,
    this.remarks,
    this.mngrNm,
    this.fuel,
    this.manuDt,
    this.effic,
    this.insur,
    this.insurMngr,
    this.emgTel,
    this.storeNm,
    this.storeTel,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory CARASSETTBLWhereInput.fromJson(Map<String, dynamic> json) =>
      _$CARASSETTBLWhereInputFromJson(json);

  final Iterable<CARASSETTBLWhereInput>? AND;

  final Iterable<CARASSETTBLWhereInput>? OR;

  final Iterable<CARASSETTBLWhereInput>? NOT;

  @JsonKey(name: r'SEQ')
  final BigIntFilter? seq;

  @JsonKey(name: r'ASSET_NO')
  final StringFilter? assetNo;

  @JsonKey(name: r'MODEL_NO')
  final StringNullableFilter? modelNo;

  @JsonKey(name: r'CAR_NO')
  final StringNullableFilter? carNo;

  @JsonKey(name: r'OWNER')
  final StringNullableFilter? owner;

  @JsonKey(name: r'OWNER_TYPE')
  final StringNullableFilter? ownerType;

  @JsonKey(name: r'AMOUNT')
  final IntNullableFilter? amount;

  @JsonKey(name: r'BUY_DATE')
  final StringNullableFilter? buyDate;

  @JsonKey(name: r'SELLER')
  final StringNullableFilter? seller;

  @JsonKey(name: r'REMARKS')
  final StringNullableFilter? remarks;

  @JsonKey(name: r'MNGR_NM')
  final StringNullableFilter? mngrNm;

  @JsonKey(name: r'FUEL')
  final StringNullableFilter? fuel;

  @JsonKey(name: r'MANU_DT')
  final StringNullableFilter? manuDt;

  @JsonKey(name: r'EFFIC')
  final StringNullableFilter? effic;

  @JsonKey(name: r'INSUR')
  final StringNullableFilter? insur;

  @JsonKey(name: r'INSUR_MNGR')
  final StringNullableFilter? insurMngr;

  @JsonKey(name: r'EMG_TEL')
  final StringNullableFilter? emgTel;

  @JsonKey(name: r'STORE_NM')
  final StringNullableFilter? storeNm;

  @JsonKey(name: r'STORE_TEL')
  final StringNullableFilter? storeTel;

  @JsonKey(name: r'USE_YN')
  final StringFilter? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringFilter? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFilter? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeNullableFilter? updDate;

  @override
  Map<String, dynamic> toJson() => _$CARASSETTBLWhereInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETTBLOrderByWithRelationInput implements _i1.JsonSerializable {
  const CARASSETTBLOrderByWithRelationInput({
    this.seq,
    this.assetNo,
    this.modelNo,
    this.carNo,
    this.owner,
    this.ownerType,
    this.amount,
    this.buyDate,
    this.seller,
    this.remarks,
    this.mngrNm,
    this.fuel,
    this.manuDt,
    this.effic,
    this.insur,
    this.insurMngr,
    this.emgTel,
    this.storeNm,
    this.storeTel,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory CARASSETTBLOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARASSETTBLOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ASSET_NO')
  final SortOrder? assetNo;

  @JsonKey(name: r'MODEL_NO')
  final SortOrder? modelNo;

  @JsonKey(name: r'CAR_NO')
  final SortOrder? carNo;

  @JsonKey(name: r'OWNER')
  final SortOrder? owner;

  @JsonKey(name: r'OWNER_TYPE')
  final SortOrder? ownerType;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @JsonKey(name: r'BUY_DATE')
  final SortOrder? buyDate;

  @JsonKey(name: r'SELLER')
  final SortOrder? seller;

  @JsonKey(name: r'REMARKS')
  final SortOrder? remarks;

  @JsonKey(name: r'MNGR_NM')
  final SortOrder? mngrNm;

  @JsonKey(name: r'FUEL')
  final SortOrder? fuel;

  @JsonKey(name: r'MANU_DT')
  final SortOrder? manuDt;

  @JsonKey(name: r'EFFIC')
  final SortOrder? effic;

  @JsonKey(name: r'INSUR')
  final SortOrder? insur;

  @JsonKey(name: r'INSUR_MNGR')
  final SortOrder? insurMngr;

  @JsonKey(name: r'EMG_TEL')
  final SortOrder? emgTel;

  @JsonKey(name: r'STORE_NM')
  final SortOrder? storeNm;

  @JsonKey(name: r'STORE_TEL')
  final SortOrder? storeTel;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARASSETTBLOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETTBLWhereUniqueInput implements _i1.JsonSerializable {
  const CARASSETTBLWhereUniqueInput({this.seq});

  factory CARASSETTBLWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$CARASSETTBLWhereUniqueInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @override
  Map<String, dynamic> toJson() => _$CARASSETTBLWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETTBLOrderByWithAggregationInput implements _i1.JsonSerializable {
  const CARASSETTBLOrderByWithAggregationInput({
    this.seq,
    this.assetNo,
    this.modelNo,
    this.carNo,
    this.owner,
    this.ownerType,
    this.amount,
    this.buyDate,
    this.seller,
    this.remarks,
    this.mngrNm,
    this.fuel,
    this.manuDt,
    this.effic,
    this.insur,
    this.insurMngr,
    this.emgTel,
    this.storeNm,
    this.storeTel,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory CARASSETTBLOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARASSETTBLOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ASSET_NO')
  final SortOrder? assetNo;

  @JsonKey(name: r'MODEL_NO')
  final SortOrder? modelNo;

  @JsonKey(name: r'CAR_NO')
  final SortOrder? carNo;

  @JsonKey(name: r'OWNER')
  final SortOrder? owner;

  @JsonKey(name: r'OWNER_TYPE')
  final SortOrder? ownerType;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @JsonKey(name: r'BUY_DATE')
  final SortOrder? buyDate;

  @JsonKey(name: r'SELLER')
  final SortOrder? seller;

  @JsonKey(name: r'REMARKS')
  final SortOrder? remarks;

  @JsonKey(name: r'MNGR_NM')
  final SortOrder? mngrNm;

  @JsonKey(name: r'FUEL')
  final SortOrder? fuel;

  @JsonKey(name: r'MANU_DT')
  final SortOrder? manuDt;

  @JsonKey(name: r'EFFIC')
  final SortOrder? effic;

  @JsonKey(name: r'INSUR')
  final SortOrder? insur;

  @JsonKey(name: r'INSUR_MNGR')
  final SortOrder? insurMngr;

  @JsonKey(name: r'EMG_TEL')
  final SortOrder? emgTel;

  @JsonKey(name: r'STORE_NM')
  final SortOrder? storeNm;

  @JsonKey(name: r'STORE_TEL')
  final SortOrder? storeTel;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'_count')
  final CARASSETTBLCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final CARASSETTBLAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final CARASSETTBLMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final CARASSETTBLMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final CARASSETTBLSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$CARASSETTBLOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETTBLScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const CARASSETTBLScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.assetNo,
    this.modelNo,
    this.carNo,
    this.owner,
    this.ownerType,
    this.amount,
    this.buyDate,
    this.seller,
    this.remarks,
    this.mngrNm,
    this.fuel,
    this.manuDt,
    this.effic,
    this.insur,
    this.insurMngr,
    this.emgTel,
    this.storeNm,
    this.storeTel,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory CARASSETTBLScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARASSETTBLScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<CARASSETTBLScalarWhereWithAggregatesInput>? AND;

  final Iterable<CARASSETTBLScalarWhereWithAggregatesInput>? OR;

  final Iterable<CARASSETTBLScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'SEQ')
  final BigIntWithAggregatesFilter? seq;

  @JsonKey(name: r'ASSET_NO')
  final StringWithAggregatesFilter? assetNo;

  @JsonKey(name: r'MODEL_NO')
  final StringNullableWithAggregatesFilter? modelNo;

  @JsonKey(name: r'CAR_NO')
  final StringNullableWithAggregatesFilter? carNo;

  @JsonKey(name: r'OWNER')
  final StringNullableWithAggregatesFilter? owner;

  @JsonKey(name: r'OWNER_TYPE')
  final StringNullableWithAggregatesFilter? ownerType;

  @JsonKey(name: r'AMOUNT')
  final IntNullableWithAggregatesFilter? amount;

  @JsonKey(name: r'BUY_DATE')
  final StringNullableWithAggregatesFilter? buyDate;

  @JsonKey(name: r'SELLER')
  final StringNullableWithAggregatesFilter? seller;

  @JsonKey(name: r'REMARKS')
  final StringNullableWithAggregatesFilter? remarks;

  @JsonKey(name: r'MNGR_NM')
  final StringNullableWithAggregatesFilter? mngrNm;

  @JsonKey(name: r'FUEL')
  final StringNullableWithAggregatesFilter? fuel;

  @JsonKey(name: r'MANU_DT')
  final StringNullableWithAggregatesFilter? manuDt;

  @JsonKey(name: r'EFFIC')
  final StringNullableWithAggregatesFilter? effic;

  @JsonKey(name: r'INSUR')
  final StringNullableWithAggregatesFilter? insur;

  @JsonKey(name: r'INSUR_MNGR')
  final StringNullableWithAggregatesFilter? insurMngr;

  @JsonKey(name: r'EMG_TEL')
  final StringNullableWithAggregatesFilter? emgTel;

  @JsonKey(name: r'STORE_NM')
  final StringNullableWithAggregatesFilter? storeNm;

  @JsonKey(name: r'STORE_TEL')
  final StringNullableWithAggregatesFilter? storeTel;

  @JsonKey(name: r'USE_YN')
  final StringWithAggregatesFilter? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringWithAggregatesFilter? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeWithAggregatesFilter? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeNullableWithAggregatesFilter? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARASSETTBLScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class CARCHARGETBLWhereInput implements _i1.JsonSerializable {
  const CARCHARGETBLWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.item,
    this.charge,
    this.writerId,
    this.memo,
    this.regDate,
  });

  factory CARCHARGETBLWhereInput.fromJson(Map<String, dynamic> json) =>
      _$CARCHARGETBLWhereInputFromJson(json);

  final Iterable<CARCHARGETBLWhereInput>? AND;

  final Iterable<CARCHARGETBLWhereInput>? OR;

  final Iterable<CARCHARGETBLWhereInput>? NOT;

  @JsonKey(name: r'SEQ')
  final BigIntFilter? seq;

  @JsonKey(name: r'ITEM')
  final StringFilter? item;

  @JsonKey(name: r'CHARGE')
  final BigIntFilter? charge;

  @JsonKey(name: r'WRITER_ID')
  final StringFilter? writerId;

  @JsonKey(name: r'MEMO')
  final StringFilter? memo;

  @JsonKey(name: r'REG_DATE')
  final StringFilter? regDate;

  @override
  Map<String, dynamic> toJson() => _$CARCHARGETBLWhereInputToJson(this);
}

@_i1.jsonSerializable
class CARCHARGETBLOrderByWithRelationInput implements _i1.JsonSerializable {
  const CARCHARGETBLOrderByWithRelationInput({
    this.seq,
    this.item,
    this.charge,
    this.writerId,
    this.memo,
    this.regDate,
  });

  factory CARCHARGETBLOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARCHARGETBLOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ITEM')
  final SortOrder? item;

  @JsonKey(name: r'CHARGE')
  final SortOrder? charge;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'MEMO')
  final SortOrder? memo;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARCHARGETBLOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class CARCHARGETBLWhereUniqueInput implements _i1.JsonSerializable {
  const CARCHARGETBLWhereUniqueInput({this.seq});

  factory CARCHARGETBLWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$CARCHARGETBLWhereUniqueInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @override
  Map<String, dynamic> toJson() => _$CARCHARGETBLWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class CARCHARGETBLOrderByWithAggregationInput implements _i1.JsonSerializable {
  const CARCHARGETBLOrderByWithAggregationInput({
    this.seq,
    this.item,
    this.charge,
    this.writerId,
    this.memo,
    this.regDate,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory CARCHARGETBLOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARCHARGETBLOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ITEM')
  final SortOrder? item;

  @JsonKey(name: r'CHARGE')
  final SortOrder? charge;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'MEMO')
  final SortOrder? memo;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'_count')
  final CARCHARGETBLCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final CARCHARGETBLAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final CARCHARGETBLMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final CARCHARGETBLMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final CARCHARGETBLSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$CARCHARGETBLOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class CARCHARGETBLScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const CARCHARGETBLScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.item,
    this.charge,
    this.writerId,
    this.memo,
    this.regDate,
  });

  factory CARCHARGETBLScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARCHARGETBLScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<CARCHARGETBLScalarWhereWithAggregatesInput>? AND;

  final Iterable<CARCHARGETBLScalarWhereWithAggregatesInput>? OR;

  final Iterable<CARCHARGETBLScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'SEQ')
  final BigIntWithAggregatesFilter? seq;

  @JsonKey(name: r'ITEM')
  final StringWithAggregatesFilter? item;

  @JsonKey(name: r'CHARGE')
  final BigIntWithAggregatesFilter? charge;

  @JsonKey(name: r'WRITER_ID')
  final StringWithAggregatesFilter? writerId;

  @JsonKey(name: r'MEMO')
  final StringWithAggregatesFilter? memo;

  @JsonKey(name: r'REG_DATE')
  final StringWithAggregatesFilter? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARCHARGETBLScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class CARINFOTBLWhereInput implements _i1.JsonSerializable {
  const CARINFOTBLWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.sort,
    this.carManageNo,
    this.model,
    this.userId,
    this.regDate,
    this.disusedYn,
  });

  factory CARINFOTBLWhereInput.fromJson(Map<String, dynamic> json) =>
      _$CARINFOTBLWhereInputFromJson(json);

  final Iterable<CARINFOTBLWhereInput>? AND;

  final Iterable<CARINFOTBLWhereInput>? OR;

  final Iterable<CARINFOTBLWhereInput>? NOT;

  @JsonKey(name: r'SORT')
  final BigIntFilter? sort;

  @JsonKey(name: r'CAR_MANAGE_NO')
  final StringFilter? carManageNo;

  @JsonKey(name: r'MODEL')
  final StringFilter? model;

  @JsonKey(name: r'USER_ID')
  final StringFilter? userId;

  @JsonKey(name: r'REG_DATE')
  final StringFilter? regDate;

  @JsonKey(name: r'DISUSED_YN')
  final StringFilter? disusedYn;

  @override
  Map<String, dynamic> toJson() => _$CARINFOTBLWhereInputToJson(this);
}

@_i1.jsonSerializable
class CARINFOTBLOrderByWithRelationInput implements _i1.JsonSerializable {
  const CARINFOTBLOrderByWithRelationInput({
    this.sort,
    this.carManageNo,
    this.model,
    this.userId,
    this.regDate,
    this.disusedYn,
  });

  factory CARINFOTBLOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARINFOTBLOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'CAR_MANAGE_NO')
  final SortOrder? carManageNo;

  @JsonKey(name: r'MODEL')
  final SortOrder? model;

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'DISUSED_YN')
  final SortOrder? disusedYn;

  @override
  Map<String, dynamic> toJson() =>
      _$CARINFOTBLOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class CARINFOTBLWhereUniqueInput implements _i1.JsonSerializable {
  const CARINFOTBLWhereUniqueInput({this.sort});

  factory CARINFOTBLWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$CARINFOTBLWhereUniqueInputFromJson(json);

  @JsonKey(name: r'SORT')
  final BigInt? sort;

  @override
  Map<String, dynamic> toJson() => _$CARINFOTBLWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class CARINFOTBLOrderByWithAggregationInput implements _i1.JsonSerializable {
  const CARINFOTBLOrderByWithAggregationInput({
    this.sort,
    this.carManageNo,
    this.model,
    this.userId,
    this.regDate,
    this.disusedYn,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory CARINFOTBLOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARINFOTBLOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'CAR_MANAGE_NO')
  final SortOrder? carManageNo;

  @JsonKey(name: r'MODEL')
  final SortOrder? model;

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'DISUSED_YN')
  final SortOrder? disusedYn;

  @JsonKey(name: r'_count')
  final CARINFOTBLCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final CARINFOTBLAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final CARINFOTBLMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final CARINFOTBLMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final CARINFOTBLSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$CARINFOTBLOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class CARINFOTBLScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const CARINFOTBLScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.sort,
    this.carManageNo,
    this.model,
    this.userId,
    this.regDate,
    this.disusedYn,
  });

  factory CARINFOTBLScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARINFOTBLScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<CARINFOTBLScalarWhereWithAggregatesInput>? AND;

  final Iterable<CARINFOTBLScalarWhereWithAggregatesInput>? OR;

  final Iterable<CARINFOTBLScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'SORT')
  final BigIntWithAggregatesFilter? sort;

  @JsonKey(name: r'CAR_MANAGE_NO')
  final StringWithAggregatesFilter? carManageNo;

  @JsonKey(name: r'MODEL')
  final StringWithAggregatesFilter? model;

  @JsonKey(name: r'USER_ID')
  final StringWithAggregatesFilter? userId;

  @JsonKey(name: r'REG_DATE')
  final StringWithAggregatesFilter? regDate;

  @JsonKey(name: r'DISUSED_YN')
  final StringWithAggregatesFilter? disusedYn;

  @override
  Map<String, dynamic> toJson() =>
      _$CARINFOTBLScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class CARMILEAGETBLWhereInput implements _i1.JsonSerializable {
  const CARMILEAGETBLWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.carManageNo,
    this.forUse,
    this.stPoint,
    this.destination,
    this.mileage,
    this.totalMileage,
    this.recordDate,
    this.writerId,
    this.editorId,
    this.regDate,
    this.apprYn,
  });

  factory CARMILEAGETBLWhereInput.fromJson(Map<String, dynamic> json) =>
      _$CARMILEAGETBLWhereInputFromJson(json);

  final Iterable<CARMILEAGETBLWhereInput>? AND;

  final Iterable<CARMILEAGETBLWhereInput>? OR;

  final Iterable<CARMILEAGETBLWhereInput>? NOT;

  @JsonKey(name: r'SEQ')
  final BigIntFilter? seq;

  @JsonKey(name: r'CAR_MANAGE_NO')
  final StringFilter? carManageNo;

  @JsonKey(name: r'FOR_USE')
  final StringFilter? forUse;

  @JsonKey(name: r'ST_POINT')
  final StringFilter? stPoint;

  @JsonKey(name: r'DESTINATION')
  final StringFilter? destination;

  @JsonKey(name: r'MILEAGE')
  final BigIntFilter? mileage;

  @JsonKey(name: r'TOTAL_MILEAGE')
  final BigIntFilter? totalMileage;

  @JsonKey(name: r'RECORD_DATE')
  final StringFilter? recordDate;

  @JsonKey(name: r'WRITER_ID')
  final StringFilter? writerId;

  @JsonKey(name: r'EDITOR_ID')
  final StringFilter? editorId;

  @JsonKey(name: r'REG_DATE')
  final StringFilter? regDate;

  @JsonKey(name: r'APPR_YN')
  final StringFilter? apprYn;

  @override
  Map<String, dynamic> toJson() => _$CARMILEAGETBLWhereInputToJson(this);
}

@_i1.jsonSerializable
class CARMILEAGETBLOrderByWithRelationInput implements _i1.JsonSerializable {
  const CARMILEAGETBLOrderByWithRelationInput({
    this.seq,
    this.carManageNo,
    this.forUse,
    this.stPoint,
    this.destination,
    this.mileage,
    this.totalMileage,
    this.recordDate,
    this.writerId,
    this.editorId,
    this.regDate,
    this.apprYn,
  });

  factory CARMILEAGETBLOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARMILEAGETBLOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'CAR_MANAGE_NO')
  final SortOrder? carManageNo;

  @JsonKey(name: r'FOR_USE')
  final SortOrder? forUse;

  @JsonKey(name: r'ST_POINT')
  final SortOrder? stPoint;

  @JsonKey(name: r'DESTINATION')
  final SortOrder? destination;

  @JsonKey(name: r'MILEAGE')
  final SortOrder? mileage;

  @JsonKey(name: r'TOTAL_MILEAGE')
  final SortOrder? totalMileage;

  @JsonKey(name: r'RECORD_DATE')
  final SortOrder? recordDate;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'EDITOR_ID')
  final SortOrder? editorId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'APPR_YN')
  final SortOrder? apprYn;

  @override
  Map<String, dynamic> toJson() =>
      _$CARMILEAGETBLOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class CARMILEAGETBLWhereUniqueInput implements _i1.JsonSerializable {
  const CARMILEAGETBLWhereUniqueInput({this.seq});

  factory CARMILEAGETBLWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$CARMILEAGETBLWhereUniqueInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @override
  Map<String, dynamic> toJson() => _$CARMILEAGETBLWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class CARMILEAGETBLOrderByWithAggregationInput implements _i1.JsonSerializable {
  const CARMILEAGETBLOrderByWithAggregationInput({
    this.seq,
    this.carManageNo,
    this.forUse,
    this.stPoint,
    this.destination,
    this.mileage,
    this.totalMileage,
    this.recordDate,
    this.writerId,
    this.editorId,
    this.regDate,
    this.apprYn,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory CARMILEAGETBLOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARMILEAGETBLOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'CAR_MANAGE_NO')
  final SortOrder? carManageNo;

  @JsonKey(name: r'FOR_USE')
  final SortOrder? forUse;

  @JsonKey(name: r'ST_POINT')
  final SortOrder? stPoint;

  @JsonKey(name: r'DESTINATION')
  final SortOrder? destination;

  @JsonKey(name: r'MILEAGE')
  final SortOrder? mileage;

  @JsonKey(name: r'TOTAL_MILEAGE')
  final SortOrder? totalMileage;

  @JsonKey(name: r'RECORD_DATE')
  final SortOrder? recordDate;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'EDITOR_ID')
  final SortOrder? editorId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'APPR_YN')
  final SortOrder? apprYn;

  @JsonKey(name: r'_count')
  final CARMILEAGETBLCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final CARMILEAGETBLAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final CARMILEAGETBLMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final CARMILEAGETBLMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final CARMILEAGETBLSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$CARMILEAGETBLOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class CARMILEAGETBLScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const CARMILEAGETBLScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.carManageNo,
    this.forUse,
    this.stPoint,
    this.destination,
    this.mileage,
    this.totalMileage,
    this.recordDate,
    this.writerId,
    this.editorId,
    this.regDate,
    this.apprYn,
  });

  factory CARMILEAGETBLScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARMILEAGETBLScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<CARMILEAGETBLScalarWhereWithAggregatesInput>? AND;

  final Iterable<CARMILEAGETBLScalarWhereWithAggregatesInput>? OR;

  final Iterable<CARMILEAGETBLScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'SEQ')
  final BigIntWithAggregatesFilter? seq;

  @JsonKey(name: r'CAR_MANAGE_NO')
  final StringWithAggregatesFilter? carManageNo;

  @JsonKey(name: r'FOR_USE')
  final StringWithAggregatesFilter? forUse;

  @JsonKey(name: r'ST_POINT')
  final StringWithAggregatesFilter? stPoint;

  @JsonKey(name: r'DESTINATION')
  final StringWithAggregatesFilter? destination;

  @JsonKey(name: r'MILEAGE')
  final BigIntWithAggregatesFilter? mileage;

  @JsonKey(name: r'TOTAL_MILEAGE')
  final BigIntWithAggregatesFilter? totalMileage;

  @JsonKey(name: r'RECORD_DATE')
  final StringWithAggregatesFilter? recordDate;

  @JsonKey(name: r'WRITER_ID')
  final StringWithAggregatesFilter? writerId;

  @JsonKey(name: r'EDITOR_ID')
  final StringWithAggregatesFilter? editorId;

  @JsonKey(name: r'REG_DATE')
  final StringWithAggregatesFilter? regDate;

  @JsonKey(name: r'APPR_YN')
  final StringWithAggregatesFilter? apprYn;

  @override
  Map<String, dynamic> toJson() =>
      _$CARMILEAGETBLScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class CARPARTREPLACETBLWhereInput implements _i1.JsonSerializable {
  const CARPARTREPLACETBLWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.partNm,
    this.replacePeriod,
    this.reTotalMileage,
    this.nowTotalMileage,
    this.remainMileage,
    this.replaceCount,
    this.partReDate,
    this.writerId,
    this.regDate,
  });

  factory CARPARTREPLACETBLWhereInput.fromJson(Map<String, dynamic> json) =>
      _$CARPARTREPLACETBLWhereInputFromJson(json);

  final Iterable<CARPARTREPLACETBLWhereInput>? AND;

  final Iterable<CARPARTREPLACETBLWhereInput>? OR;

  final Iterable<CARPARTREPLACETBLWhereInput>? NOT;

  @JsonKey(name: r'SEQ')
  final BigIntFilter? seq;

  @JsonKey(name: r'PART_NM')
  final StringFilter? partNm;

  @JsonKey(name: r'REPLACE_PERIOD')
  final BigIntFilter? replacePeriod;

  @JsonKey(name: r'RE_TOTAL_MILEAGE')
  final BigIntFilter? reTotalMileage;

  @JsonKey(name: r'NOW_TOTAL_MILEAGE')
  final BigIntFilter? nowTotalMileage;

  @JsonKey(name: r'REMAIN_MILEAGE')
  final BigIntFilter? remainMileage;

  @JsonKey(name: r'REPLACE_COUNT')
  final BigIntFilter? replaceCount;

  @JsonKey(name: r'PART_RE_DATE')
  final StringFilter? partReDate;

  @JsonKey(name: r'WRITER_ID')
  final StringFilter? writerId;

  @JsonKey(name: r'REG_DATE')
  final StringFilter? regDate;

  @override
  Map<String, dynamic> toJson() => _$CARPARTREPLACETBLWhereInputToJson(this);
}

@_i1.jsonSerializable
class CARPARTREPLACETBLOrderByWithRelationInput
    implements _i1.JsonSerializable {
  const CARPARTREPLACETBLOrderByWithRelationInput({
    this.seq,
    this.partNm,
    this.replacePeriod,
    this.reTotalMileage,
    this.nowTotalMileage,
    this.remainMileage,
    this.replaceCount,
    this.partReDate,
    this.writerId,
    this.regDate,
  });

  factory CARPARTREPLACETBLOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARPARTREPLACETBLOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'PART_NM')
  final SortOrder? partNm;

  @JsonKey(name: r'REPLACE_PERIOD')
  final SortOrder? replacePeriod;

  @JsonKey(name: r'RE_TOTAL_MILEAGE')
  final SortOrder? reTotalMileage;

  @JsonKey(name: r'NOW_TOTAL_MILEAGE')
  final SortOrder? nowTotalMileage;

  @JsonKey(name: r'REMAIN_MILEAGE')
  final SortOrder? remainMileage;

  @JsonKey(name: r'REPLACE_COUNT')
  final SortOrder? replaceCount;

  @JsonKey(name: r'PART_RE_DATE')
  final SortOrder? partReDate;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARPARTREPLACETBLOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class CARPARTREPLACETBLWhereUniqueInput implements _i1.JsonSerializable {
  const CARPARTREPLACETBLWhereUniqueInput({this.seq});

  factory CARPARTREPLACETBLWhereUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARPARTREPLACETBLWhereUniqueInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @override
  Map<String, dynamic> toJson() =>
      _$CARPARTREPLACETBLWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class CARPARTREPLACETBLOrderByWithAggregationInput
    implements _i1.JsonSerializable {
  const CARPARTREPLACETBLOrderByWithAggregationInput({
    this.seq,
    this.partNm,
    this.replacePeriod,
    this.reTotalMileage,
    this.nowTotalMileage,
    this.remainMileage,
    this.replaceCount,
    this.partReDate,
    this.writerId,
    this.regDate,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory CARPARTREPLACETBLOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARPARTREPLACETBLOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'PART_NM')
  final SortOrder? partNm;

  @JsonKey(name: r'REPLACE_PERIOD')
  final SortOrder? replacePeriod;

  @JsonKey(name: r'RE_TOTAL_MILEAGE')
  final SortOrder? reTotalMileage;

  @JsonKey(name: r'NOW_TOTAL_MILEAGE')
  final SortOrder? nowTotalMileage;

  @JsonKey(name: r'REMAIN_MILEAGE')
  final SortOrder? remainMileage;

  @JsonKey(name: r'REPLACE_COUNT')
  final SortOrder? replaceCount;

  @JsonKey(name: r'PART_RE_DATE')
  final SortOrder? partReDate;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'_count')
  final CARPARTREPLACETBLCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final CARPARTREPLACETBLAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final CARPARTREPLACETBLMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final CARPARTREPLACETBLMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final CARPARTREPLACETBLSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$CARPARTREPLACETBLOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class CARPARTREPLACETBLScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const CARPARTREPLACETBLScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.partNm,
    this.replacePeriod,
    this.reTotalMileage,
    this.nowTotalMileage,
    this.remainMileage,
    this.replaceCount,
    this.partReDate,
    this.writerId,
    this.regDate,
  });

  factory CARPARTREPLACETBLScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARPARTREPLACETBLScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<CARPARTREPLACETBLScalarWhereWithAggregatesInput>? AND;

  final Iterable<CARPARTREPLACETBLScalarWhereWithAggregatesInput>? OR;

  final Iterable<CARPARTREPLACETBLScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'SEQ')
  final BigIntWithAggregatesFilter? seq;

  @JsonKey(name: r'PART_NM')
  final StringWithAggregatesFilter? partNm;

  @JsonKey(name: r'REPLACE_PERIOD')
  final BigIntWithAggregatesFilter? replacePeriod;

  @JsonKey(name: r'RE_TOTAL_MILEAGE')
  final BigIntWithAggregatesFilter? reTotalMileage;

  @JsonKey(name: r'NOW_TOTAL_MILEAGE')
  final BigIntWithAggregatesFilter? nowTotalMileage;

  @JsonKey(name: r'REMAIN_MILEAGE')
  final BigIntWithAggregatesFilter? remainMileage;

  @JsonKey(name: r'REPLACE_COUNT')
  final BigIntWithAggregatesFilter? replaceCount;

  @JsonKey(name: r'PART_RE_DATE')
  final StringWithAggregatesFilter? partReDate;

  @JsonKey(name: r'WRITER_ID')
  final StringWithAggregatesFilter? writerId;

  @JsonKey(name: r'REG_DATE')
  final StringWithAggregatesFilter? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARPARTREPLACETBLScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class CARREPAIRLOGWhereInput implements _i1.JsonSerializable {
  const CARREPAIRLOGWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.mseq,
    this.assetNo,
    this.repairDe,
    this.repairAmount,
    this.repairStore,
    this.repairLog,
    this.repairOwner,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory CARREPAIRLOGWhereInput.fromJson(Map<String, dynamic> json) =>
      _$CARREPAIRLOGWhereInputFromJson(json);

  final Iterable<CARREPAIRLOGWhereInput>? AND;

  final Iterable<CARREPAIRLOGWhereInput>? OR;

  final Iterable<CARREPAIRLOGWhereInput>? NOT;

  @JsonKey(name: r'SEQ')
  final BigIntFilter? seq;

  @JsonKey(name: r'MSEQ')
  final BigIntNullableFilter? mseq;

  @JsonKey(name: r'ASSET_NO')
  final StringNullableFilter? assetNo;

  @JsonKey(name: r'REPAIR_DE')
  final StringNullableFilter? repairDe;

  @JsonKey(name: r'REPAIR_AMOUNT')
  final StringNullableFilter? repairAmount;

  @JsonKey(name: r'REPAIR_STORE')
  final StringNullableFilter? repairStore;

  @JsonKey(name: r'REPAIR_LOG')
  final StringNullableFilter? repairLog;

  @JsonKey(name: r'REPAIR_OWNER')
  final StringNullableFilter? repairOwner;

  @JsonKey(name: r'FILE_TP')
  final StringNullableFilter? fileTp;

  @JsonKey(name: r'FLPTH')
  final StringNullableFilter? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final StringNullableFilter? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final StringNullableFilter? streFileNm;

  @JsonKey(name: r'REG_ID')
  final StringNullableFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringNullableFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableFilter? delDate;

  @override
  Map<String, dynamic> toJson() => _$CARREPAIRLOGWhereInputToJson(this);
}

@_i1.jsonSerializable
class CARREPAIRLOGOrderByWithRelationInput implements _i1.JsonSerializable {
  const CARREPAIRLOGOrderByWithRelationInput({
    this.seq,
    this.mseq,
    this.assetNo,
    this.repairDe,
    this.repairAmount,
    this.repairStore,
    this.repairLog,
    this.repairOwner,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory CARREPAIRLOGOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARREPAIRLOGOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'ASSET_NO')
  final SortOrder? assetNo;

  @JsonKey(name: r'REPAIR_DE')
  final SortOrder? repairDe;

  @JsonKey(name: r'REPAIR_AMOUNT')
  final SortOrder? repairAmount;

  @JsonKey(name: r'REPAIR_STORE')
  final SortOrder? repairStore;

  @JsonKey(name: r'REPAIR_LOG')
  final SortOrder? repairLog;

  @JsonKey(name: r'REPAIR_OWNER')
  final SortOrder? repairOwner;

  @JsonKey(name: r'FILE_TP')
  final SortOrder? fileTp;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final SortOrder? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final SortOrder? streFileNm;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARREPAIRLOGOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class CARREPAIRLOGWhereUniqueInput implements _i1.JsonSerializable {
  const CARREPAIRLOGWhereUniqueInput({this.seq});

  factory CARREPAIRLOGWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$CARREPAIRLOGWhereUniqueInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @override
  Map<String, dynamic> toJson() => _$CARREPAIRLOGWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class CARREPAIRLOGOrderByWithAggregationInput implements _i1.JsonSerializable {
  const CARREPAIRLOGOrderByWithAggregationInput({
    this.seq,
    this.mseq,
    this.assetNo,
    this.repairDe,
    this.repairAmount,
    this.repairStore,
    this.repairLog,
    this.repairOwner,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory CARREPAIRLOGOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARREPAIRLOGOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'ASSET_NO')
  final SortOrder? assetNo;

  @JsonKey(name: r'REPAIR_DE')
  final SortOrder? repairDe;

  @JsonKey(name: r'REPAIR_AMOUNT')
  final SortOrder? repairAmount;

  @JsonKey(name: r'REPAIR_STORE')
  final SortOrder? repairStore;

  @JsonKey(name: r'REPAIR_LOG')
  final SortOrder? repairLog;

  @JsonKey(name: r'REPAIR_OWNER')
  final SortOrder? repairOwner;

  @JsonKey(name: r'FILE_TP')
  final SortOrder? fileTp;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final SortOrder? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final SortOrder? streFileNm;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @JsonKey(name: r'_count')
  final CARREPAIRLOGCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final CARREPAIRLOGAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final CARREPAIRLOGMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final CARREPAIRLOGMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final CARREPAIRLOGSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$CARREPAIRLOGOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class CARREPAIRLOGScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const CARREPAIRLOGScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.mseq,
    this.assetNo,
    this.repairDe,
    this.repairAmount,
    this.repairStore,
    this.repairLog,
    this.repairOwner,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory CARREPAIRLOGScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARREPAIRLOGScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<CARREPAIRLOGScalarWhereWithAggregatesInput>? AND;

  final Iterable<CARREPAIRLOGScalarWhereWithAggregatesInput>? OR;

  final Iterable<CARREPAIRLOGScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'SEQ')
  final BigIntWithAggregatesFilter? seq;

  @JsonKey(name: r'MSEQ')
  final BigIntNullableWithAggregatesFilter? mseq;

  @JsonKey(name: r'ASSET_NO')
  final StringNullableWithAggregatesFilter? assetNo;

  @JsonKey(name: r'REPAIR_DE')
  final StringNullableWithAggregatesFilter? repairDe;

  @JsonKey(name: r'REPAIR_AMOUNT')
  final StringNullableWithAggregatesFilter? repairAmount;

  @JsonKey(name: r'REPAIR_STORE')
  final StringNullableWithAggregatesFilter? repairStore;

  @JsonKey(name: r'REPAIR_LOG')
  final StringNullableWithAggregatesFilter? repairLog;

  @JsonKey(name: r'REPAIR_OWNER')
  final StringNullableWithAggregatesFilter? repairOwner;

  @JsonKey(name: r'FILE_TP')
  final StringNullableWithAggregatesFilter? fileTp;

  @JsonKey(name: r'FLPTH')
  final StringNullableWithAggregatesFilter? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final StringNullableWithAggregatesFilter? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final StringNullableWithAggregatesFilter? streFileNm;

  @JsonKey(name: r'REG_ID')
  final StringNullableWithAggregatesFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringNullableWithAggregatesFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableWithAggregatesFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableWithAggregatesFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableWithAggregatesFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableWithAggregatesFilter? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARREPAIRLOGScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class CARUSEMANAGETBLWhereInput implements _i1.JsonSerializable {
  const CARUSEMANAGETBLWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.carNo,
    this.carType,
    this.destination,
    this.purpose,
    this.users,
    this.useStartDate,
    this.useEndDate,
    this.useBeforeDistance,
    this.useAfterDistance,
    this.remarks,
    this.acceptYn,
    this.regUser,
    this.regDate,
    this.useStartHour,
    this.useEndHour,
    this.cardApply,
  });

  factory CARUSEMANAGETBLWhereInput.fromJson(Map<String, dynamic> json) =>
      _$CARUSEMANAGETBLWhereInputFromJson(json);

  final Iterable<CARUSEMANAGETBLWhereInput>? AND;

  final Iterable<CARUSEMANAGETBLWhereInput>? OR;

  final Iterable<CARUSEMANAGETBLWhereInput>? NOT;

  @JsonKey(name: r'SEQ')
  final BigIntFilter? seq;

  @JsonKey(name: r'CAR_NO')
  final StringFilter? carNo;

  @JsonKey(name: r'CAR_TYPE')
  final StringFilter? carType;

  @JsonKey(name: r'DESTINATION')
  final StringFilter? destination;

  @JsonKey(name: r'PURPOSE')
  final StringNullableFilter? purpose;

  @JsonKey(name: r'USERS')
  final StringFilter? users;

  @JsonKey(name: r'USE_START_DATE')
  final DateTimeFilter? useStartDate;

  @JsonKey(name: r'USE_END_DATE')
  final DateTimeFilter? useEndDate;

  @JsonKey(name: r'USE_BEFORE_DISTANCE')
  final DecimalNullableFilter? useBeforeDistance;

  @JsonKey(name: r'USE_AFTER_DISTANCE')
  final DecimalNullableFilter? useAfterDistance;

  @JsonKey(name: r'REMARKS')
  final StringNullableFilter? remarks;

  @JsonKey(name: r'ACCEPT_YN')
  final StringNullableFilter? acceptYn;

  @JsonKey(name: r'REG_USER')
  final StringNullableFilter? regUser;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFilter? regDate;

  @JsonKey(name: r'USE_START_HOUR')
  final StringNullableFilter? useStartHour;

  @JsonKey(name: r'USE_END_HOUR')
  final StringNullableFilter? useEndHour;

  @JsonKey(name: r'CARD_APPLY')
  final StringFilter? cardApply;

  @override
  Map<String, dynamic> toJson() => _$CARUSEMANAGETBLWhereInputToJson(this);
}

@_i1.jsonSerializable
class CARUSEMANAGETBLOrderByWithRelationInput implements _i1.JsonSerializable {
  const CARUSEMANAGETBLOrderByWithRelationInput({
    this.seq,
    this.carNo,
    this.carType,
    this.destination,
    this.purpose,
    this.users,
    this.useStartDate,
    this.useEndDate,
    this.useBeforeDistance,
    this.useAfterDistance,
    this.remarks,
    this.acceptYn,
    this.regUser,
    this.regDate,
    this.useStartHour,
    this.useEndHour,
    this.cardApply,
  });

  factory CARUSEMANAGETBLOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARUSEMANAGETBLOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'CAR_NO')
  final SortOrder? carNo;

  @JsonKey(name: r'CAR_TYPE')
  final SortOrder? carType;

  @JsonKey(name: r'DESTINATION')
  final SortOrder? destination;

  @JsonKey(name: r'PURPOSE')
  final SortOrder? purpose;

  @JsonKey(name: r'USERS')
  final SortOrder? users;

  @JsonKey(name: r'USE_START_DATE')
  final SortOrder? useStartDate;

  @JsonKey(name: r'USE_END_DATE')
  final SortOrder? useEndDate;

  @JsonKey(name: r'USE_BEFORE_DISTANCE')
  final SortOrder? useBeforeDistance;

  @JsonKey(name: r'USE_AFTER_DISTANCE')
  final SortOrder? useAfterDistance;

  @JsonKey(name: r'REMARKS')
  final SortOrder? remarks;

  @JsonKey(name: r'ACCEPT_YN')
  final SortOrder? acceptYn;

  @JsonKey(name: r'REG_USER')
  final SortOrder? regUser;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'USE_START_HOUR')
  final SortOrder? useStartHour;

  @JsonKey(name: r'USE_END_HOUR')
  final SortOrder? useEndHour;

  @JsonKey(name: r'CARD_APPLY')
  final SortOrder? cardApply;

  @override
  Map<String, dynamic> toJson() =>
      _$CARUSEMANAGETBLOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class CARUSEMANAGETBLWhereUniqueInput implements _i1.JsonSerializable {
  const CARUSEMANAGETBLWhereUniqueInput({this.seq});

  factory CARUSEMANAGETBLWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$CARUSEMANAGETBLWhereUniqueInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @override
  Map<String, dynamic> toJson() =>
      _$CARUSEMANAGETBLWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class CARUSEMANAGETBLOrderByWithAggregationInput
    implements _i1.JsonSerializable {
  const CARUSEMANAGETBLOrderByWithAggregationInput({
    this.seq,
    this.carNo,
    this.carType,
    this.destination,
    this.purpose,
    this.users,
    this.useStartDate,
    this.useEndDate,
    this.useBeforeDistance,
    this.useAfterDistance,
    this.remarks,
    this.acceptYn,
    this.regUser,
    this.regDate,
    this.useStartHour,
    this.useEndHour,
    this.cardApply,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory CARUSEMANAGETBLOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARUSEMANAGETBLOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'CAR_NO')
  final SortOrder? carNo;

  @JsonKey(name: r'CAR_TYPE')
  final SortOrder? carType;

  @JsonKey(name: r'DESTINATION')
  final SortOrder? destination;

  @JsonKey(name: r'PURPOSE')
  final SortOrder? purpose;

  @JsonKey(name: r'USERS')
  final SortOrder? users;

  @JsonKey(name: r'USE_START_DATE')
  final SortOrder? useStartDate;

  @JsonKey(name: r'USE_END_DATE')
  final SortOrder? useEndDate;

  @JsonKey(name: r'USE_BEFORE_DISTANCE')
  final SortOrder? useBeforeDistance;

  @JsonKey(name: r'USE_AFTER_DISTANCE')
  final SortOrder? useAfterDistance;

  @JsonKey(name: r'REMARKS')
  final SortOrder? remarks;

  @JsonKey(name: r'ACCEPT_YN')
  final SortOrder? acceptYn;

  @JsonKey(name: r'REG_USER')
  final SortOrder? regUser;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'USE_START_HOUR')
  final SortOrder? useStartHour;

  @JsonKey(name: r'USE_END_HOUR')
  final SortOrder? useEndHour;

  @JsonKey(name: r'CARD_APPLY')
  final SortOrder? cardApply;

  @JsonKey(name: r'_count')
  final CARUSEMANAGETBLCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final CARUSEMANAGETBLAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final CARUSEMANAGETBLMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final CARUSEMANAGETBLMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final CARUSEMANAGETBLSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$CARUSEMANAGETBLOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class CARUSEMANAGETBLScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const CARUSEMANAGETBLScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.carNo,
    this.carType,
    this.destination,
    this.purpose,
    this.users,
    this.useStartDate,
    this.useEndDate,
    this.useBeforeDistance,
    this.useAfterDistance,
    this.remarks,
    this.acceptYn,
    this.regUser,
    this.regDate,
    this.useStartHour,
    this.useEndHour,
    this.cardApply,
  });

  factory CARUSEMANAGETBLScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARUSEMANAGETBLScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<CARUSEMANAGETBLScalarWhereWithAggregatesInput>? AND;

  final Iterable<CARUSEMANAGETBLScalarWhereWithAggregatesInput>? OR;

  final Iterable<CARUSEMANAGETBLScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'SEQ')
  final BigIntWithAggregatesFilter? seq;

  @JsonKey(name: r'CAR_NO')
  final StringWithAggregatesFilter? carNo;

  @JsonKey(name: r'CAR_TYPE')
  final StringWithAggregatesFilter? carType;

  @JsonKey(name: r'DESTINATION')
  final StringWithAggregatesFilter? destination;

  @JsonKey(name: r'PURPOSE')
  final StringNullableWithAggregatesFilter? purpose;

  @JsonKey(name: r'USERS')
  final StringWithAggregatesFilter? users;

  @JsonKey(name: r'USE_START_DATE')
  final DateTimeWithAggregatesFilter? useStartDate;

  @JsonKey(name: r'USE_END_DATE')
  final DateTimeWithAggregatesFilter? useEndDate;

  @JsonKey(name: r'USE_BEFORE_DISTANCE')
  final DecimalNullableWithAggregatesFilter? useBeforeDistance;

  @JsonKey(name: r'USE_AFTER_DISTANCE')
  final DecimalNullableWithAggregatesFilter? useAfterDistance;

  @JsonKey(name: r'REMARKS')
  final StringNullableWithAggregatesFilter? remarks;

  @JsonKey(name: r'ACCEPT_YN')
  final StringNullableWithAggregatesFilter? acceptYn;

  @JsonKey(name: r'REG_USER')
  final StringNullableWithAggregatesFilter? regUser;

  @JsonKey(name: r'REG_DATE')
  final DateTimeWithAggregatesFilter? regDate;

  @JsonKey(name: r'USE_START_HOUR')
  final StringNullableWithAggregatesFilter? useStartHour;

  @JsonKey(name: r'USE_END_HOUR')
  final StringNullableWithAggregatesFilter? useEndHour;

  @JsonKey(name: r'CARD_APPLY')
  final StringWithAggregatesFilter? cardApply;

  @override
  Map<String, dynamic> toJson() =>
      _$CARUSEMANAGETBLScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class HOLIDAYTBLWhereInput implements _i1.JsonSerializable {
  const HOLIDAYTBLWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.userId,
    this.stdYear,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory HOLIDAYTBLWhereInput.fromJson(Map<String, dynamic> json) =>
      _$HOLIDAYTBLWhereInputFromJson(json);

  final Iterable<HOLIDAYTBLWhereInput>? AND;

  final Iterable<HOLIDAYTBLWhereInput>? OR;

  final Iterable<HOLIDAYTBLWhereInput>? NOT;

  @JsonKey(name: r'USER_ID')
  final StringFilter? userId;

  @JsonKey(name: r'STD_YEAR')
  final StringFilter? stdYear;

  @JsonKey(name: r'M1')
  final DecimalNullableFilter? m1;

  @JsonKey(name: r'M2')
  final DecimalNullableFilter? m2;

  @JsonKey(name: r'M3')
  final DecimalNullableFilter? m3;

  @JsonKey(name: r'M4')
  final DecimalNullableFilter? m4;

  @JsonKey(name: r'M5')
  final DecimalNullableFilter? m5;

  @JsonKey(name: r'M6')
  final DecimalNullableFilter? m6;

  @JsonKey(name: r'M7')
  final DecimalNullableFilter? m7;

  @JsonKey(name: r'M8')
  final DecimalNullableFilter? m8;

  @JsonKey(name: r'M9')
  final DecimalNullableFilter? m9;

  @JsonKey(name: r'M10')
  final DecimalNullableFilter? m10;

  @JsonKey(name: r'M11')
  final DecimalNullableFilter? m11;

  @JsonKey(name: r'M12')
  final DecimalNullableFilter? m12;

  @JsonKey(name: r'USE_YN')
  final StringFilter? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringFilter? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFilter? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeNullableFilter? updDate;

  @override
  Map<String, dynamic> toJson() => _$HOLIDAYTBLWhereInputToJson(this);
}

@_i1.jsonSerializable
class HOLIDAYTBLOrderByWithRelationInput implements _i1.JsonSerializable {
  const HOLIDAYTBLOrderByWithRelationInput({
    this.userId,
    this.stdYear,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory HOLIDAYTBLOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$HOLIDAYTBLOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'STD_YEAR')
  final SortOrder? stdYear;

  @JsonKey(name: r'M1')
  final SortOrder? m1;

  @JsonKey(name: r'M2')
  final SortOrder? m2;

  @JsonKey(name: r'M3')
  final SortOrder? m3;

  @JsonKey(name: r'M4')
  final SortOrder? m4;

  @JsonKey(name: r'M5')
  final SortOrder? m5;

  @JsonKey(name: r'M6')
  final SortOrder? m6;

  @JsonKey(name: r'M7')
  final SortOrder? m7;

  @JsonKey(name: r'M8')
  final SortOrder? m8;

  @JsonKey(name: r'M9')
  final SortOrder? m9;

  @JsonKey(name: r'M10')
  final SortOrder? m10;

  @JsonKey(name: r'M11')
  final SortOrder? m11;

  @JsonKey(name: r'M12')
  final SortOrder? m12;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$HOLIDAYTBLOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class HOLIDAYTBLWhereUniqueInput implements _i1.JsonSerializable {
  const HOLIDAYTBLWhereUniqueInput({this.userIdStdYear});

  factory HOLIDAYTBLWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$HOLIDAYTBLWhereUniqueInputFromJson(json);

  @JsonKey(name: r'USER_ID_STD_YEAR')
  final HOLIDAYTBLUSERIDSTDYEARCompoundUniqueInput? userIdStdYear;

  @override
  Map<String, dynamic> toJson() => _$HOLIDAYTBLWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class HOLIDAYTBLOrderByWithAggregationInput implements _i1.JsonSerializable {
  const HOLIDAYTBLOrderByWithAggregationInput({
    this.userId,
    this.stdYear,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory HOLIDAYTBLOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$HOLIDAYTBLOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'STD_YEAR')
  final SortOrder? stdYear;

  @JsonKey(name: r'M1')
  final SortOrder? m1;

  @JsonKey(name: r'M2')
  final SortOrder? m2;

  @JsonKey(name: r'M3')
  final SortOrder? m3;

  @JsonKey(name: r'M4')
  final SortOrder? m4;

  @JsonKey(name: r'M5')
  final SortOrder? m5;

  @JsonKey(name: r'M6')
  final SortOrder? m6;

  @JsonKey(name: r'M7')
  final SortOrder? m7;

  @JsonKey(name: r'M8')
  final SortOrder? m8;

  @JsonKey(name: r'M9')
  final SortOrder? m9;

  @JsonKey(name: r'M10')
  final SortOrder? m10;

  @JsonKey(name: r'M11')
  final SortOrder? m11;

  @JsonKey(name: r'M12')
  final SortOrder? m12;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'_count')
  final HOLIDAYTBLCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final HOLIDAYTBLAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final HOLIDAYTBLMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final HOLIDAYTBLMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final HOLIDAYTBLSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$HOLIDAYTBLOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class HOLIDAYTBLScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const HOLIDAYTBLScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.userId,
    this.stdYear,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory HOLIDAYTBLScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$HOLIDAYTBLScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<HOLIDAYTBLScalarWhereWithAggregatesInput>? AND;

  final Iterable<HOLIDAYTBLScalarWhereWithAggregatesInput>? OR;

  final Iterable<HOLIDAYTBLScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'USER_ID')
  final StringWithAggregatesFilter? userId;

  @JsonKey(name: r'STD_YEAR')
  final StringWithAggregatesFilter? stdYear;

  @JsonKey(name: r'M1')
  final DecimalNullableWithAggregatesFilter? m1;

  @JsonKey(name: r'M2')
  final DecimalNullableWithAggregatesFilter? m2;

  @JsonKey(name: r'M3')
  final DecimalNullableWithAggregatesFilter? m3;

  @JsonKey(name: r'M4')
  final DecimalNullableWithAggregatesFilter? m4;

  @JsonKey(name: r'M5')
  final DecimalNullableWithAggregatesFilter? m5;

  @JsonKey(name: r'M6')
  final DecimalNullableWithAggregatesFilter? m6;

  @JsonKey(name: r'M7')
  final DecimalNullableWithAggregatesFilter? m7;

  @JsonKey(name: r'M8')
  final DecimalNullableWithAggregatesFilter? m8;

  @JsonKey(name: r'M9')
  final DecimalNullableWithAggregatesFilter? m9;

  @JsonKey(name: r'M10')
  final DecimalNullableWithAggregatesFilter? m10;

  @JsonKey(name: r'M11')
  final DecimalNullableWithAggregatesFilter? m11;

  @JsonKey(name: r'M12')
  final DecimalNullableWithAggregatesFilter? m12;

  @JsonKey(name: r'USE_YN')
  final StringWithAggregatesFilter? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringWithAggregatesFilter? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeWithAggregatesFilter? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeNullableWithAggregatesFilter? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$HOLIDAYTBLScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class MEMBERTBLWhereInput implements _i1.JsonSerializable {
  const MEMBERTBLWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.userId,
    this.passwd,
    this.userNm,
    this.dept,
    this.grade,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
    this.lastLoginDate,
    this.memo,
    this.menuTbl,
  });

  factory MEMBERTBLWhereInput.fromJson(Map<String, dynamic> json) =>
      _$MEMBERTBLWhereInputFromJson(json);

  final Iterable<MEMBERTBLWhereInput>? AND;

  final Iterable<MEMBERTBLWhereInput>? OR;

  final Iterable<MEMBERTBLWhereInput>? NOT;

  @JsonKey(name: r'USER_ID')
  final StringFilter? userId;

  @JsonKey(name: r'PASSWD')
  final StringFilter? passwd;

  @JsonKey(name: r'USER_NM')
  final StringFilter? userNm;

  @JsonKey(name: r'DEPT')
  final StringNullableFilter? dept;

  @JsonKey(name: r'GRADE')
  final StringNullableFilter? grade;

  @JsonKey(name: r'JOIN_DATE')
  final DateTimeFilter? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final DateTimeFilter? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final DateTimeFilter? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final IntNullableFilter? pwdWrongCnt;

  @JsonKey(name: r'USE_YN')
  final StringNullableFilter? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringNullableFilter? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFilter? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeNullableFilter? updDate;

  @JsonKey(name: r'LAST_LOGIN_DATE')
  final DateTimeFilter? lastLoginDate;

  @JsonKey(name: r'MEMO')
  final StringNullableFilter? memo;

  @JsonKey(name: r'MENU_TBL')
  final MENUTBLListRelationFilter? menuTbl;

  @override
  Map<String, dynamic> toJson() => _$MEMBERTBLWhereInputToJson(this);
}

@_i1.jsonSerializable
class MEMBERTBLOrderByWithRelationInput implements _i1.JsonSerializable {
  const MEMBERTBLOrderByWithRelationInput({
    this.userId,
    this.passwd,
    this.userNm,
    this.dept,
    this.grade,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
    this.lastLoginDate,
    this.memo,
    this.menuTbl,
  });

  factory MEMBERTBLOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$MEMBERTBLOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'PASSWD')
  final SortOrder? passwd;

  @JsonKey(name: r'USER_NM')
  final SortOrder? userNm;

  @JsonKey(name: r'DEPT')
  final SortOrder? dept;

  @JsonKey(name: r'GRADE')
  final SortOrder? grade;

  @JsonKey(name: r'JOIN_DATE')
  final SortOrder? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final SortOrder? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final SortOrder? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final SortOrder? pwdWrongCnt;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'LAST_LOGIN_DATE')
  final SortOrder? lastLoginDate;

  @JsonKey(name: r'MEMO')
  final SortOrder? memo;

  @JsonKey(name: r'MENU_TBL')
  final MENUTBLOrderByRelationAggregateInput? menuTbl;

  @override
  Map<String, dynamic> toJson() =>
      _$MEMBERTBLOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class MEMBERTBLWhereUniqueInput implements _i1.JsonSerializable {
  const MEMBERTBLWhereUniqueInput({this.userId});

  factory MEMBERTBLWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$MEMBERTBLWhereUniqueInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final String? userId;

  @override
  Map<String, dynamic> toJson() => _$MEMBERTBLWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class MEMBERTBLOrderByWithAggregationInput implements _i1.JsonSerializable {
  const MEMBERTBLOrderByWithAggregationInput({
    this.userId,
    this.passwd,
    this.userNm,
    this.dept,
    this.grade,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
    this.lastLoginDate,
    this.memo,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory MEMBERTBLOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$MEMBERTBLOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'PASSWD')
  final SortOrder? passwd;

  @JsonKey(name: r'USER_NM')
  final SortOrder? userNm;

  @JsonKey(name: r'DEPT')
  final SortOrder? dept;

  @JsonKey(name: r'GRADE')
  final SortOrder? grade;

  @JsonKey(name: r'JOIN_DATE')
  final SortOrder? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final SortOrder? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final SortOrder? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final SortOrder? pwdWrongCnt;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'LAST_LOGIN_DATE')
  final SortOrder? lastLoginDate;

  @JsonKey(name: r'MEMO')
  final SortOrder? memo;

  @JsonKey(name: r'_count')
  final MEMBERTBLCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final MEMBERTBLAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final MEMBERTBLMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final MEMBERTBLMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final MEMBERTBLSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$MEMBERTBLOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class MEMBERTBLScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const MEMBERTBLScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.userId,
    this.passwd,
    this.userNm,
    this.dept,
    this.grade,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
    this.lastLoginDate,
    this.memo,
  });

  factory MEMBERTBLScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$MEMBERTBLScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<MEMBERTBLScalarWhereWithAggregatesInput>? AND;

  final Iterable<MEMBERTBLScalarWhereWithAggregatesInput>? OR;

  final Iterable<MEMBERTBLScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'USER_ID')
  final StringWithAggregatesFilter? userId;

  @JsonKey(name: r'PASSWD')
  final StringWithAggregatesFilter? passwd;

  @JsonKey(name: r'USER_NM')
  final StringWithAggregatesFilter? userNm;

  @JsonKey(name: r'DEPT')
  final StringNullableWithAggregatesFilter? dept;

  @JsonKey(name: r'GRADE')
  final StringNullableWithAggregatesFilter? grade;

  @JsonKey(name: r'JOIN_DATE')
  final DateTimeWithAggregatesFilter? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final DateTimeWithAggregatesFilter? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final DateTimeWithAggregatesFilter? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final IntNullableWithAggregatesFilter? pwdWrongCnt;

  @JsonKey(name: r'USE_YN')
  final StringNullableWithAggregatesFilter? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringNullableWithAggregatesFilter? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeWithAggregatesFilter? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeNullableWithAggregatesFilter? updDate;

  @JsonKey(name: r'LAST_LOGIN_DATE')
  final DateTimeWithAggregatesFilter? lastLoginDate;

  @JsonKey(name: r'MEMO')
  final StringNullableWithAggregatesFilter? memo;

  @override
  Map<String, dynamic> toJson() =>
      _$MEMBERTBLScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class MENUAUTHTBLWhereInput implements _i1.JsonSerializable {
  const MENUAUTHTBLWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.userId,
    this.menuId,
    this.readYn,
    this.writeYn,
    this.regId,
    this.updId,
    this.regDate,
    this.updDate,
  });

  factory MENUAUTHTBLWhereInput.fromJson(Map<String, dynamic> json) =>
      _$MENUAUTHTBLWhereInputFromJson(json);

  final Iterable<MENUAUTHTBLWhereInput>? AND;

  final Iterable<MENUAUTHTBLWhereInput>? OR;

  final Iterable<MENUAUTHTBLWhereInput>? NOT;

  @JsonKey(name: r'USER_ID')
  final StringFilter? userId;

  @JsonKey(name: r'MENU_ID')
  final StringFilter? menuId;

  @JsonKey(name: r'READ_YN')
  final StringNullableFilter? readYn;

  @JsonKey(name: r'WRITE_YN')
  final StringNullableFilter? writeYn;

  @JsonKey(name: r'REG_ID')
  final StringNullableFilter? regId;

  @JsonKey(name: r'UPD_ID')
  final StringNullableFilter? updId;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFilter? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeNullableFilter? updDate;

  @override
  Map<String, dynamic> toJson() => _$MENUAUTHTBLWhereInputToJson(this);
}

@_i1.jsonSerializable
class MENUAUTHTBLOrderByWithRelationInput implements _i1.JsonSerializable {
  const MENUAUTHTBLOrderByWithRelationInput({
    this.userId,
    this.menuId,
    this.readYn,
    this.writeYn,
    this.regId,
    this.updId,
    this.regDate,
    this.updDate,
  });

  factory MENUAUTHTBLOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$MENUAUTHTBLOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'MENU_ID')
  final SortOrder? menuId;

  @JsonKey(name: r'READ_YN')
  final SortOrder? readYn;

  @JsonKey(name: r'WRITE_YN')
  final SortOrder? writeYn;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'UPD_ID')
  final SortOrder? updId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUAUTHTBLOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class MENUAUTHTBLWhereUniqueInput implements _i1.JsonSerializable {
  const MENUAUTHTBLWhereUniqueInput({this.userIdMenuId});

  factory MENUAUTHTBLWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$MENUAUTHTBLWhereUniqueInputFromJson(json);

  @JsonKey(name: r'USER_ID_MENU_ID')
  final MENUAUTHTBLUSERIDMENUIDCompoundUniqueInput? userIdMenuId;

  @override
  Map<String, dynamic> toJson() => _$MENUAUTHTBLWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class MENUAUTHTBLOrderByWithAggregationInput implements _i1.JsonSerializable {
  const MENUAUTHTBLOrderByWithAggregationInput({
    this.userId,
    this.menuId,
    this.readYn,
    this.writeYn,
    this.regId,
    this.updId,
    this.regDate,
    this.updDate,
    this.$count,
    this.$max,
    this.$min,
  });

  factory MENUAUTHTBLOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$MENUAUTHTBLOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'MENU_ID')
  final SortOrder? menuId;

  @JsonKey(name: r'READ_YN')
  final SortOrder? readYn;

  @JsonKey(name: r'WRITE_YN')
  final SortOrder? writeYn;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'UPD_ID')
  final SortOrder? updId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'_count')
  final MENUAUTHTBLCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_max')
  final MENUAUTHTBLMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final MENUAUTHTBLMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUAUTHTBLOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class MENUAUTHTBLScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const MENUAUTHTBLScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.userId,
    this.menuId,
    this.readYn,
    this.writeYn,
    this.regId,
    this.updId,
    this.regDate,
    this.updDate,
  });

  factory MENUAUTHTBLScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$MENUAUTHTBLScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<MENUAUTHTBLScalarWhereWithAggregatesInput>? AND;

  final Iterable<MENUAUTHTBLScalarWhereWithAggregatesInput>? OR;

  final Iterable<MENUAUTHTBLScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'USER_ID')
  final StringWithAggregatesFilter? userId;

  @JsonKey(name: r'MENU_ID')
  final StringWithAggregatesFilter? menuId;

  @JsonKey(name: r'READ_YN')
  final StringNullableWithAggregatesFilter? readYn;

  @JsonKey(name: r'WRITE_YN')
  final StringNullableWithAggregatesFilter? writeYn;

  @JsonKey(name: r'REG_ID')
  final StringNullableWithAggregatesFilter? regId;

  @JsonKey(name: r'UPD_ID')
  final StringNullableWithAggregatesFilter? updId;

  @JsonKey(name: r'REG_DATE')
  final DateTimeWithAggregatesFilter? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeNullableWithAggregatesFilter? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUAUTHTBLScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class MENUTBLWhereInput implements _i1.JsonSerializable {
  const MENUTBLWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.menuId,
    this.menuNm,
    this.depth,
    this.sort,
    this.ownerId,
    this.url,
    this.writerId,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
    this.dispYn,
    this.menuIcon,
    this.memberTbl,
  });

  factory MENUTBLWhereInput.fromJson(Map<String, dynamic> json) =>
      _$MENUTBLWhereInputFromJson(json);

  final Iterable<MENUTBLWhereInput>? AND;

  final Iterable<MENUTBLWhereInput>? OR;

  final Iterable<MENUTBLWhereInput>? NOT;

  @JsonKey(name: r'MENU_ID')
  final StringFilter? menuId;

  @JsonKey(name: r'MENU_NM')
  final StringFilter? menuNm;

  @JsonKey(name: r'DEPTH')
  final IntFilter? depth;

  @JsonKey(name: r'SORT')
  final IntFilter? sort;

  @JsonKey(name: r'OWNER_ID')
  final StringNullableFilter? ownerId;

  @JsonKey(name: r'URL')
  final StringNullableFilter? url;

  @JsonKey(name: r'WRITER_ID')
  final StringNullableFilter? writerId;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFilter? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeNullableFilter? updDate;

  @JsonKey(name: r'USE_YN')
  final StringNullableFilter? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringNullableFilter? delYn;

  @JsonKey(name: r'DISP_YN')
  final StringNullableFilter? dispYn;

  @JsonKey(name: r'MENU_ICON')
  final StringNullableFilter? menuIcon;

  @JsonKey(name: r'MEMBER_TBL')
  final MEMBERTBLRelationFilter? memberTbl;

  @override
  Map<String, dynamic> toJson() => _$MENUTBLWhereInputToJson(this);
}

@_i1.jsonSerializable
class MENUTBLOrderByWithRelationInput implements _i1.JsonSerializable {
  const MENUTBLOrderByWithRelationInput({
    this.menuId,
    this.menuNm,
    this.depth,
    this.sort,
    this.ownerId,
    this.url,
    this.writerId,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
    this.dispYn,
    this.menuIcon,
    this.memberTbl,
  });

  factory MENUTBLOrderByWithRelationInput.fromJson(Map<String, dynamic> json) =>
      _$MENUTBLOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'MENU_ID')
  final SortOrder? menuId;

  @JsonKey(name: r'MENU_NM')
  final SortOrder? menuNm;

  @JsonKey(name: r'DEPTH')
  final SortOrder? depth;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'OWNER_ID')
  final SortOrder? ownerId;

  @JsonKey(name: r'URL')
  final SortOrder? url;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'DISP_YN')
  final SortOrder? dispYn;

  @JsonKey(name: r'MENU_ICON')
  final SortOrder? menuIcon;

  @JsonKey(name: r'MEMBER_TBL')
  final MEMBERTBLOrderByWithRelationInput? memberTbl;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUTBLOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class MENUTBLWhereUniqueInput implements _i1.JsonSerializable {
  const MENUTBLWhereUniqueInput({this.menuId});

  factory MENUTBLWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$MENUTBLWhereUniqueInputFromJson(json);

  @JsonKey(name: r'MENU_ID')
  final String? menuId;

  @override
  Map<String, dynamic> toJson() => _$MENUTBLWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class MENUTBLOrderByWithAggregationInput implements _i1.JsonSerializable {
  const MENUTBLOrderByWithAggregationInput({
    this.menuId,
    this.menuNm,
    this.depth,
    this.sort,
    this.ownerId,
    this.url,
    this.writerId,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
    this.dispYn,
    this.menuIcon,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory MENUTBLOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$MENUTBLOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'MENU_ID')
  final SortOrder? menuId;

  @JsonKey(name: r'MENU_NM')
  final SortOrder? menuNm;

  @JsonKey(name: r'DEPTH')
  final SortOrder? depth;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'OWNER_ID')
  final SortOrder? ownerId;

  @JsonKey(name: r'URL')
  final SortOrder? url;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'DISP_YN')
  final SortOrder? dispYn;

  @JsonKey(name: r'MENU_ICON')
  final SortOrder? menuIcon;

  @JsonKey(name: r'_count')
  final MENUTBLCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final MENUTBLAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final MENUTBLMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final MENUTBLMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final MENUTBLSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUTBLOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class MENUTBLScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const MENUTBLScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.menuId,
    this.menuNm,
    this.depth,
    this.sort,
    this.ownerId,
    this.url,
    this.writerId,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
    this.dispYn,
    this.menuIcon,
  });

  factory MENUTBLScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$MENUTBLScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<MENUTBLScalarWhereWithAggregatesInput>? AND;

  final Iterable<MENUTBLScalarWhereWithAggregatesInput>? OR;

  final Iterable<MENUTBLScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'MENU_ID')
  final StringWithAggregatesFilter? menuId;

  @JsonKey(name: r'MENU_NM')
  final StringWithAggregatesFilter? menuNm;

  @JsonKey(name: r'DEPTH')
  final IntWithAggregatesFilter? depth;

  @JsonKey(name: r'SORT')
  final IntWithAggregatesFilter? sort;

  @JsonKey(name: r'OWNER_ID')
  final StringNullableWithAggregatesFilter? ownerId;

  @JsonKey(name: r'URL')
  final StringNullableWithAggregatesFilter? url;

  @JsonKey(name: r'WRITER_ID')
  final StringNullableWithAggregatesFilter? writerId;

  @JsonKey(name: r'REG_DATE')
  final DateTimeWithAggregatesFilter? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeNullableWithAggregatesFilter? updDate;

  @JsonKey(name: r'USE_YN')
  final StringNullableWithAggregatesFilter? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringNullableWithAggregatesFilter? delYn;

  @JsonKey(name: r'DISP_YN')
  final StringNullableWithAggregatesFilter? dispYn;

  @JsonKey(name: r'MENU_ICON')
  final StringNullableWithAggregatesFilter? menuIcon;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUTBLScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class OFFICEASSETTBLWhereInput implements _i1.JsonSerializable {
  const OFFICEASSETTBLWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.assetNo,
    this.assetType,
    this.seller,
    this.buyDate,
    this.modelNo,
    this.serialNo,
    this.amount,
    this.keepYear,
    this.mngDept,
    this.assetAccount,
    this.remarks,
    this.carryOut,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory OFFICEASSETTBLWhereInput.fromJson(Map<String, dynamic> json) =>
      _$OFFICEASSETTBLWhereInputFromJson(json);

  final Iterable<OFFICEASSETTBLWhereInput>? AND;

  final Iterable<OFFICEASSETTBLWhereInput>? OR;

  final Iterable<OFFICEASSETTBLWhereInput>? NOT;

  @JsonKey(name: r'SEQ')
  final BigIntFilter? seq;

  @JsonKey(name: r'ASSET_NO')
  final StringFilter? assetNo;

  @JsonKey(name: r'ASSET_TYPE')
  final StringFilter? assetType;

  @JsonKey(name: r'SELLER')
  final StringNullableFilter? seller;

  @JsonKey(name: r'BUY_DATE')
  final StringNullableFilter? buyDate;

  @JsonKey(name: r'MODEL_NO')
  final StringNullableFilter? modelNo;

  @JsonKey(name: r'SERIAL_NO')
  final StringNullableFilter? serialNo;

  @JsonKey(name: r'AMOUNT')
  final IntNullableFilter? amount;

  @JsonKey(name: r'KEEP_YEAR')
  final DecimalNullableFilter? keepYear;

  @JsonKey(name: r'MNG_DEPT')
  final StringNullableFilter? mngDept;

  @JsonKey(name: r'ASSET_ACCOUNT')
  final StringNullableFilter? assetAccount;

  @JsonKey(name: r'REMARKS')
  final StringNullableFilter? remarks;

  @JsonKey(name: r'CARRY_OUT')
  final StringNullableFilter? carryOut;

  @JsonKey(name: r'USE_YN')
  final StringFilter? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringFilter? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFilter? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeNullableFilter? updDate;

  @override
  Map<String, dynamic> toJson() => _$OFFICEASSETTBLWhereInputToJson(this);
}

@_i1.jsonSerializable
class OFFICEASSETTBLOrderByWithRelationInput implements _i1.JsonSerializable {
  const OFFICEASSETTBLOrderByWithRelationInput({
    this.seq,
    this.assetNo,
    this.assetType,
    this.seller,
    this.buyDate,
    this.modelNo,
    this.serialNo,
    this.amount,
    this.keepYear,
    this.mngDept,
    this.assetAccount,
    this.remarks,
    this.carryOut,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory OFFICEASSETTBLOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$OFFICEASSETTBLOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ASSET_NO')
  final SortOrder? assetNo;

  @JsonKey(name: r'ASSET_TYPE')
  final SortOrder? assetType;

  @JsonKey(name: r'SELLER')
  final SortOrder? seller;

  @JsonKey(name: r'BUY_DATE')
  final SortOrder? buyDate;

  @JsonKey(name: r'MODEL_NO')
  final SortOrder? modelNo;

  @JsonKey(name: r'SERIAL_NO')
  final SortOrder? serialNo;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @JsonKey(name: r'KEEP_YEAR')
  final SortOrder? keepYear;

  @JsonKey(name: r'MNG_DEPT')
  final SortOrder? mngDept;

  @JsonKey(name: r'ASSET_ACCOUNT')
  final SortOrder? assetAccount;

  @JsonKey(name: r'REMARKS')
  final SortOrder? remarks;

  @JsonKey(name: r'CARRY_OUT')
  final SortOrder? carryOut;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$OFFICEASSETTBLOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class OFFICEASSETTBLWhereUniqueInput implements _i1.JsonSerializable {
  const OFFICEASSETTBLWhereUniqueInput({this.seq});

  factory OFFICEASSETTBLWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$OFFICEASSETTBLWhereUniqueInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @override
  Map<String, dynamic> toJson() => _$OFFICEASSETTBLWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class OFFICEASSETTBLOrderByWithAggregationInput
    implements _i1.JsonSerializable {
  const OFFICEASSETTBLOrderByWithAggregationInput({
    this.seq,
    this.assetNo,
    this.assetType,
    this.seller,
    this.buyDate,
    this.modelNo,
    this.serialNo,
    this.amount,
    this.keepYear,
    this.mngDept,
    this.assetAccount,
    this.remarks,
    this.carryOut,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory OFFICEASSETTBLOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$OFFICEASSETTBLOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ASSET_NO')
  final SortOrder? assetNo;

  @JsonKey(name: r'ASSET_TYPE')
  final SortOrder? assetType;

  @JsonKey(name: r'SELLER')
  final SortOrder? seller;

  @JsonKey(name: r'BUY_DATE')
  final SortOrder? buyDate;

  @JsonKey(name: r'MODEL_NO')
  final SortOrder? modelNo;

  @JsonKey(name: r'SERIAL_NO')
  final SortOrder? serialNo;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @JsonKey(name: r'KEEP_YEAR')
  final SortOrder? keepYear;

  @JsonKey(name: r'MNG_DEPT')
  final SortOrder? mngDept;

  @JsonKey(name: r'ASSET_ACCOUNT')
  final SortOrder? assetAccount;

  @JsonKey(name: r'REMARKS')
  final SortOrder? remarks;

  @JsonKey(name: r'CARRY_OUT')
  final SortOrder? carryOut;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'_count')
  final OFFICEASSETTBLCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final OFFICEASSETTBLAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final OFFICEASSETTBLMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final OFFICEASSETTBLMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final OFFICEASSETTBLSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$OFFICEASSETTBLOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class OFFICEASSETTBLScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const OFFICEASSETTBLScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.assetNo,
    this.assetType,
    this.seller,
    this.buyDate,
    this.modelNo,
    this.serialNo,
    this.amount,
    this.keepYear,
    this.mngDept,
    this.assetAccount,
    this.remarks,
    this.carryOut,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory OFFICEASSETTBLScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$OFFICEASSETTBLScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<OFFICEASSETTBLScalarWhereWithAggregatesInput>? AND;

  final Iterable<OFFICEASSETTBLScalarWhereWithAggregatesInput>? OR;

  final Iterable<OFFICEASSETTBLScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'SEQ')
  final BigIntWithAggregatesFilter? seq;

  @JsonKey(name: r'ASSET_NO')
  final StringWithAggregatesFilter? assetNo;

  @JsonKey(name: r'ASSET_TYPE')
  final StringWithAggregatesFilter? assetType;

  @JsonKey(name: r'SELLER')
  final StringNullableWithAggregatesFilter? seller;

  @JsonKey(name: r'BUY_DATE')
  final StringNullableWithAggregatesFilter? buyDate;

  @JsonKey(name: r'MODEL_NO')
  final StringNullableWithAggregatesFilter? modelNo;

  @JsonKey(name: r'SERIAL_NO')
  final StringNullableWithAggregatesFilter? serialNo;

  @JsonKey(name: r'AMOUNT')
  final IntNullableWithAggregatesFilter? amount;

  @JsonKey(name: r'KEEP_YEAR')
  final DecimalNullableWithAggregatesFilter? keepYear;

  @JsonKey(name: r'MNG_DEPT')
  final StringNullableWithAggregatesFilter? mngDept;

  @JsonKey(name: r'ASSET_ACCOUNT')
  final StringNullableWithAggregatesFilter? assetAccount;

  @JsonKey(name: r'REMARKS')
  final StringNullableWithAggregatesFilter? remarks;

  @JsonKey(name: r'CARRY_OUT')
  final StringNullableWithAggregatesFilter? carryOut;

  @JsonKey(name: r'USE_YN')
  final StringWithAggregatesFilter? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringWithAggregatesFilter? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeWithAggregatesFilter? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeNullableWithAggregatesFilter? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$OFFICEASSETTBLScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class SERVERASSETTBLWhereInput implements _i1.JsonSerializable {
  const SERVERASSETTBLWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.assetNo,
    this.assetType,
    this.maker,
    this.cnt,
    this.amount,
    this.buyDate,
    this.seller,
    this.modelNo,
    this.serialNo,
    this.hostname,
    this.builtLoc,
    this.useDesc,
    this.osInfo,
    this.cpuInfo,
    this.ramInfo,
    this.hddInfo,
    this.ssdInfo,
    this.odd,
    this.remarks,
    this.carryOut,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory SERVERASSETTBLWhereInput.fromJson(Map<String, dynamic> json) =>
      _$SERVERASSETTBLWhereInputFromJson(json);

  final Iterable<SERVERASSETTBLWhereInput>? AND;

  final Iterable<SERVERASSETTBLWhereInput>? OR;

  final Iterable<SERVERASSETTBLWhereInput>? NOT;

  @JsonKey(name: r'SEQ')
  final BigIntFilter? seq;

  @JsonKey(name: r'ASSET_NO')
  final StringFilter? assetNo;

  @JsonKey(name: r'ASSET_TYPE')
  final StringFilter? assetType;

  @JsonKey(name: r'MAKER')
  final StringNullableFilter? maker;

  @JsonKey(name: r'CNT')
  final DecimalNullableFilter? cnt;

  @JsonKey(name: r'AMOUNT')
  final IntNullableFilter? amount;

  @JsonKey(name: r'BUY_DATE')
  final StringNullableFilter? buyDate;

  @JsonKey(name: r'SELLER')
  final StringNullableFilter? seller;

  @JsonKey(name: r'MODEL_NO')
  final StringNullableFilter? modelNo;

  @JsonKey(name: r'SERIAL_NO')
  final StringNullableFilter? serialNo;

  @JsonKey(name: r'HOSTNAME')
  final StringNullableFilter? hostname;

  @JsonKey(name: r'BUILT_LOC')
  final StringNullableFilter? builtLoc;

  @JsonKey(name: r'USE_DESC')
  final StringNullableFilter? useDesc;

  @JsonKey(name: r'OS_INFO')
  final StringNullableFilter? osInfo;

  @JsonKey(name: r'CPU_INFO')
  final StringNullableFilter? cpuInfo;

  @JsonKey(name: r'RAM_INFO')
  final StringNullableFilter? ramInfo;

  @JsonKey(name: r'HDD_INFO')
  final StringNullableFilter? hddInfo;

  @JsonKey(name: r'SSD_INFO')
  final StringNullableFilter? ssdInfo;

  @JsonKey(name: r'ODD')
  final StringNullableFilter? odd;

  @JsonKey(name: r'REMARKS')
  final StringNullableFilter? remarks;

  @JsonKey(name: r'CARRY_OUT')
  final StringNullableFilter? carryOut;

  @JsonKey(name: r'USE_YN')
  final StringFilter? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringFilter? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFilter? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeNullableFilter? updDate;

  @override
  Map<String, dynamic> toJson() => _$SERVERASSETTBLWhereInputToJson(this);
}

@_i1.jsonSerializable
class SERVERASSETTBLOrderByWithRelationInput implements _i1.JsonSerializable {
  const SERVERASSETTBLOrderByWithRelationInput({
    this.seq,
    this.assetNo,
    this.assetType,
    this.maker,
    this.cnt,
    this.amount,
    this.buyDate,
    this.seller,
    this.modelNo,
    this.serialNo,
    this.hostname,
    this.builtLoc,
    this.useDesc,
    this.osInfo,
    this.cpuInfo,
    this.ramInfo,
    this.hddInfo,
    this.ssdInfo,
    this.odd,
    this.remarks,
    this.carryOut,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory SERVERASSETTBLOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$SERVERASSETTBLOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ASSET_NO')
  final SortOrder? assetNo;

  @JsonKey(name: r'ASSET_TYPE')
  final SortOrder? assetType;

  @JsonKey(name: r'MAKER')
  final SortOrder? maker;

  @JsonKey(name: r'CNT')
  final SortOrder? cnt;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @JsonKey(name: r'BUY_DATE')
  final SortOrder? buyDate;

  @JsonKey(name: r'SELLER')
  final SortOrder? seller;

  @JsonKey(name: r'MODEL_NO')
  final SortOrder? modelNo;

  @JsonKey(name: r'SERIAL_NO')
  final SortOrder? serialNo;

  @JsonKey(name: r'HOSTNAME')
  final SortOrder? hostname;

  @JsonKey(name: r'BUILT_LOC')
  final SortOrder? builtLoc;

  @JsonKey(name: r'USE_DESC')
  final SortOrder? useDesc;

  @JsonKey(name: r'OS_INFO')
  final SortOrder? osInfo;

  @JsonKey(name: r'CPU_INFO')
  final SortOrder? cpuInfo;

  @JsonKey(name: r'RAM_INFO')
  final SortOrder? ramInfo;

  @JsonKey(name: r'HDD_INFO')
  final SortOrder? hddInfo;

  @JsonKey(name: r'SSD_INFO')
  final SortOrder? ssdInfo;

  @JsonKey(name: r'ODD')
  final SortOrder? odd;

  @JsonKey(name: r'REMARKS')
  final SortOrder? remarks;

  @JsonKey(name: r'CARRY_OUT')
  final SortOrder? carryOut;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$SERVERASSETTBLOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class SERVERASSETTBLWhereUniqueInput implements _i1.JsonSerializable {
  const SERVERASSETTBLWhereUniqueInput({this.seq});

  factory SERVERASSETTBLWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$SERVERASSETTBLWhereUniqueInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @override
  Map<String, dynamic> toJson() => _$SERVERASSETTBLWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class SERVERASSETTBLOrderByWithAggregationInput
    implements _i1.JsonSerializable {
  const SERVERASSETTBLOrderByWithAggregationInput({
    this.seq,
    this.assetNo,
    this.assetType,
    this.maker,
    this.cnt,
    this.amount,
    this.buyDate,
    this.seller,
    this.modelNo,
    this.serialNo,
    this.hostname,
    this.builtLoc,
    this.useDesc,
    this.osInfo,
    this.cpuInfo,
    this.ramInfo,
    this.hddInfo,
    this.ssdInfo,
    this.odd,
    this.remarks,
    this.carryOut,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory SERVERASSETTBLOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$SERVERASSETTBLOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ASSET_NO')
  final SortOrder? assetNo;

  @JsonKey(name: r'ASSET_TYPE')
  final SortOrder? assetType;

  @JsonKey(name: r'MAKER')
  final SortOrder? maker;

  @JsonKey(name: r'CNT')
  final SortOrder? cnt;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @JsonKey(name: r'BUY_DATE')
  final SortOrder? buyDate;

  @JsonKey(name: r'SELLER')
  final SortOrder? seller;

  @JsonKey(name: r'MODEL_NO')
  final SortOrder? modelNo;

  @JsonKey(name: r'SERIAL_NO')
  final SortOrder? serialNo;

  @JsonKey(name: r'HOSTNAME')
  final SortOrder? hostname;

  @JsonKey(name: r'BUILT_LOC')
  final SortOrder? builtLoc;

  @JsonKey(name: r'USE_DESC')
  final SortOrder? useDesc;

  @JsonKey(name: r'OS_INFO')
  final SortOrder? osInfo;

  @JsonKey(name: r'CPU_INFO')
  final SortOrder? cpuInfo;

  @JsonKey(name: r'RAM_INFO')
  final SortOrder? ramInfo;

  @JsonKey(name: r'HDD_INFO')
  final SortOrder? hddInfo;

  @JsonKey(name: r'SSD_INFO')
  final SortOrder? ssdInfo;

  @JsonKey(name: r'ODD')
  final SortOrder? odd;

  @JsonKey(name: r'REMARKS')
  final SortOrder? remarks;

  @JsonKey(name: r'CARRY_OUT')
  final SortOrder? carryOut;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'_count')
  final SERVERASSETTBLCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final SERVERASSETTBLAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final SERVERASSETTBLMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final SERVERASSETTBLMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final SERVERASSETTBLSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$SERVERASSETTBLOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class SERVERASSETTBLScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const SERVERASSETTBLScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.assetNo,
    this.assetType,
    this.maker,
    this.cnt,
    this.amount,
    this.buyDate,
    this.seller,
    this.modelNo,
    this.serialNo,
    this.hostname,
    this.builtLoc,
    this.useDesc,
    this.osInfo,
    this.cpuInfo,
    this.ramInfo,
    this.hddInfo,
    this.ssdInfo,
    this.odd,
    this.remarks,
    this.carryOut,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory SERVERASSETTBLScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$SERVERASSETTBLScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<SERVERASSETTBLScalarWhereWithAggregatesInput>? AND;

  final Iterable<SERVERASSETTBLScalarWhereWithAggregatesInput>? OR;

  final Iterable<SERVERASSETTBLScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'SEQ')
  final BigIntWithAggregatesFilter? seq;

  @JsonKey(name: r'ASSET_NO')
  final StringWithAggregatesFilter? assetNo;

  @JsonKey(name: r'ASSET_TYPE')
  final StringWithAggregatesFilter? assetType;

  @JsonKey(name: r'MAKER')
  final StringNullableWithAggregatesFilter? maker;

  @JsonKey(name: r'CNT')
  final DecimalNullableWithAggregatesFilter? cnt;

  @JsonKey(name: r'AMOUNT')
  final IntNullableWithAggregatesFilter? amount;

  @JsonKey(name: r'BUY_DATE')
  final StringNullableWithAggregatesFilter? buyDate;

  @JsonKey(name: r'SELLER')
  final StringNullableWithAggregatesFilter? seller;

  @JsonKey(name: r'MODEL_NO')
  final StringNullableWithAggregatesFilter? modelNo;

  @JsonKey(name: r'SERIAL_NO')
  final StringNullableWithAggregatesFilter? serialNo;

  @JsonKey(name: r'HOSTNAME')
  final StringNullableWithAggregatesFilter? hostname;

  @JsonKey(name: r'BUILT_LOC')
  final StringNullableWithAggregatesFilter? builtLoc;

  @JsonKey(name: r'USE_DESC')
  final StringNullableWithAggregatesFilter? useDesc;

  @JsonKey(name: r'OS_INFO')
  final StringNullableWithAggregatesFilter? osInfo;

  @JsonKey(name: r'CPU_INFO')
  final StringNullableWithAggregatesFilter? cpuInfo;

  @JsonKey(name: r'RAM_INFO')
  final StringNullableWithAggregatesFilter? ramInfo;

  @JsonKey(name: r'HDD_INFO')
  final StringNullableWithAggregatesFilter? hddInfo;

  @JsonKey(name: r'SSD_INFO')
  final StringNullableWithAggregatesFilter? ssdInfo;

  @JsonKey(name: r'ODD')
  final StringNullableWithAggregatesFilter? odd;

  @JsonKey(name: r'REMARKS')
  final StringNullableWithAggregatesFilter? remarks;

  @JsonKey(name: r'CARRY_OUT')
  final StringNullableWithAggregatesFilter? carryOut;

  @JsonKey(name: r'USE_YN')
  final StringWithAggregatesFilter? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringWithAggregatesFilter? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeWithAggregatesFilter? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeNullableWithAggregatesFilter? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$SERVERASSETTBLScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class SOFTWAREASSETTBLWhereInput implements _i1.JsonSerializable {
  const SOFTWAREASSETTBLWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.assetNo,
    this.softwareNm,
    this.versionNm,
    this.cnt,
    this.amount,
    this.buyDate,
    this.serialNo,
    this.licenseNo,
    this.userNm,
    this.remarks,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory SOFTWAREASSETTBLWhereInput.fromJson(Map<String, dynamic> json) =>
      _$SOFTWAREASSETTBLWhereInputFromJson(json);

  final Iterable<SOFTWAREASSETTBLWhereInput>? AND;

  final Iterable<SOFTWAREASSETTBLWhereInput>? OR;

  final Iterable<SOFTWAREASSETTBLWhereInput>? NOT;

  @JsonKey(name: r'SEQ')
  final BigIntFilter? seq;

  @JsonKey(name: r'ASSET_NO')
  final StringFilter? assetNo;

  @JsonKey(name: r'SOFTWARE_NM')
  final StringFilter? softwareNm;

  @JsonKey(name: r'VERSION_NM')
  final StringNullableFilter? versionNm;

  @JsonKey(name: r'CNT')
  final DecimalNullableFilter? cnt;

  @JsonKey(name: r'AMOUNT')
  final IntNullableFilter? amount;

  @JsonKey(name: r'BUY_DATE')
  final StringNullableFilter? buyDate;

  @JsonKey(name: r'SERIAL_NO')
  final StringNullableFilter? serialNo;

  @JsonKey(name: r'LICENSE_NO')
  final StringNullableFilter? licenseNo;

  @JsonKey(name: r'USER_NM')
  final StringNullableFilter? userNm;

  @JsonKey(name: r'REMARKS')
  final StringNullableFilter? remarks;

  @JsonKey(name: r'USE_YN')
  final StringFilter? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringFilter? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFilter? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeNullableFilter? updDate;

  @override
  Map<String, dynamic> toJson() => _$SOFTWAREASSETTBLWhereInputToJson(this);
}

@_i1.jsonSerializable
class SOFTWAREASSETTBLOrderByWithRelationInput implements _i1.JsonSerializable {
  const SOFTWAREASSETTBLOrderByWithRelationInput({
    this.seq,
    this.assetNo,
    this.softwareNm,
    this.versionNm,
    this.cnt,
    this.amount,
    this.buyDate,
    this.serialNo,
    this.licenseNo,
    this.userNm,
    this.remarks,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory SOFTWAREASSETTBLOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$SOFTWAREASSETTBLOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ASSET_NO')
  final SortOrder? assetNo;

  @JsonKey(name: r'SOFTWARE_NM')
  final SortOrder? softwareNm;

  @JsonKey(name: r'VERSION_NM')
  final SortOrder? versionNm;

  @JsonKey(name: r'CNT')
  final SortOrder? cnt;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @JsonKey(name: r'BUY_DATE')
  final SortOrder? buyDate;

  @JsonKey(name: r'SERIAL_NO')
  final SortOrder? serialNo;

  @JsonKey(name: r'LICENSE_NO')
  final SortOrder? licenseNo;

  @JsonKey(name: r'USER_NM')
  final SortOrder? userNm;

  @JsonKey(name: r'REMARKS')
  final SortOrder? remarks;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$SOFTWAREASSETTBLOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class SOFTWAREASSETTBLWhereUniqueInput implements _i1.JsonSerializable {
  const SOFTWAREASSETTBLWhereUniqueInput({this.seq});

  factory SOFTWAREASSETTBLWhereUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$SOFTWAREASSETTBLWhereUniqueInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @override
  Map<String, dynamic> toJson() =>
      _$SOFTWAREASSETTBLWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class SOFTWAREASSETTBLOrderByWithAggregationInput
    implements _i1.JsonSerializable {
  const SOFTWAREASSETTBLOrderByWithAggregationInput({
    this.seq,
    this.assetNo,
    this.softwareNm,
    this.versionNm,
    this.cnt,
    this.amount,
    this.buyDate,
    this.serialNo,
    this.licenseNo,
    this.userNm,
    this.remarks,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory SOFTWAREASSETTBLOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$SOFTWAREASSETTBLOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ASSET_NO')
  final SortOrder? assetNo;

  @JsonKey(name: r'SOFTWARE_NM')
  final SortOrder? softwareNm;

  @JsonKey(name: r'VERSION_NM')
  final SortOrder? versionNm;

  @JsonKey(name: r'CNT')
  final SortOrder? cnt;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @JsonKey(name: r'BUY_DATE')
  final SortOrder? buyDate;

  @JsonKey(name: r'SERIAL_NO')
  final SortOrder? serialNo;

  @JsonKey(name: r'LICENSE_NO')
  final SortOrder? licenseNo;

  @JsonKey(name: r'USER_NM')
  final SortOrder? userNm;

  @JsonKey(name: r'REMARKS')
  final SortOrder? remarks;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'_count')
  final SOFTWAREASSETTBLCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final SOFTWAREASSETTBLAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final SOFTWAREASSETTBLMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final SOFTWAREASSETTBLMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final SOFTWAREASSETTBLSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$SOFTWAREASSETTBLOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class SOFTWAREASSETTBLScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const SOFTWAREASSETTBLScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.assetNo,
    this.softwareNm,
    this.versionNm,
    this.cnt,
    this.amount,
    this.buyDate,
    this.serialNo,
    this.licenseNo,
    this.userNm,
    this.remarks,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory SOFTWAREASSETTBLScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$SOFTWAREASSETTBLScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<SOFTWAREASSETTBLScalarWhereWithAggregatesInput>? AND;

  final Iterable<SOFTWAREASSETTBLScalarWhereWithAggregatesInput>? OR;

  final Iterable<SOFTWAREASSETTBLScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'SEQ')
  final BigIntWithAggregatesFilter? seq;

  @JsonKey(name: r'ASSET_NO')
  final StringWithAggregatesFilter? assetNo;

  @JsonKey(name: r'SOFTWARE_NM')
  final StringWithAggregatesFilter? softwareNm;

  @JsonKey(name: r'VERSION_NM')
  final StringNullableWithAggregatesFilter? versionNm;

  @JsonKey(name: r'CNT')
  final DecimalNullableWithAggregatesFilter? cnt;

  @JsonKey(name: r'AMOUNT')
  final IntNullableWithAggregatesFilter? amount;

  @JsonKey(name: r'BUY_DATE')
  final StringNullableWithAggregatesFilter? buyDate;

  @JsonKey(name: r'SERIAL_NO')
  final StringNullableWithAggregatesFilter? serialNo;

  @JsonKey(name: r'LICENSE_NO')
  final StringNullableWithAggregatesFilter? licenseNo;

  @JsonKey(name: r'USER_NM')
  final StringNullableWithAggregatesFilter? userNm;

  @JsonKey(name: r'REMARKS')
  final StringNullableWithAggregatesFilter? remarks;

  @JsonKey(name: r'USE_YN')
  final StringWithAggregatesFilter? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringWithAggregatesFilter? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeWithAggregatesFilter? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeNullableWithAggregatesFilter? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$SOFTWAREASSETTBLScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class STADMINMENUWhereInput implements _i1.JsonSerializable {
  const STADMINMENUWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.menuCd,
    this.menuNm,
    this.menuPath,
    this.menuSrt,
    this.menuDeps,
    this.menuIcon,
    this.menuTp,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STADMINMENUWhereInput.fromJson(Map<String, dynamic> json) =>
      _$STADMINMENUWhereInputFromJson(json);

  final Iterable<STADMINMENUWhereInput>? AND;

  final Iterable<STADMINMENUWhereInput>? OR;

  final Iterable<STADMINMENUWhereInput>? NOT;

  @JsonKey(name: r'MENU_CD')
  final StringFilter? menuCd;

  @JsonKey(name: r'MENU_NM')
  final StringFilter? menuNm;

  @JsonKey(name: r'MENU_PATH')
  final StringNullableFilter? menuPath;

  @JsonKey(name: r'MENU_SRT')
  final IntFilter? menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final IntFilter? menuDeps;

  @JsonKey(name: r'MENU_ICON')
  final StringNullableFilter? menuIcon;

  @JsonKey(name: r'MENU_TP')
  final StringFilter? menuTp;

  @JsonKey(name: r'REG_ID')
  final StringFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringNullableFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableFilter? delDate;

  @override
  Map<String, dynamic> toJson() => _$STADMINMENUWhereInputToJson(this);
}

@_i1.jsonSerializable
class STADMINMENUOrderByWithRelationInput implements _i1.JsonSerializable {
  const STADMINMENUOrderByWithRelationInput({
    this.menuCd,
    this.menuNm,
    this.menuPath,
    this.menuSrt,
    this.menuDeps,
    this.menuIcon,
    this.menuTp,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STADMINMENUOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STADMINMENUOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'MENU_CD')
  final SortOrder? menuCd;

  @JsonKey(name: r'MENU_NM')
  final SortOrder? menuNm;

  @JsonKey(name: r'MENU_PATH')
  final SortOrder? menuPath;

  @JsonKey(name: r'MENU_SRT')
  final SortOrder? menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final SortOrder? menuDeps;

  @JsonKey(name: r'MENU_ICON')
  final SortOrder? menuIcon;

  @JsonKey(name: r'MENU_TP')
  final SortOrder? menuTp;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STADMINMENUOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class STADMINMENUWhereUniqueInput implements _i1.JsonSerializable {
  const STADMINMENUWhereUniqueInput({this.menuCd});

  factory STADMINMENUWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$STADMINMENUWhereUniqueInputFromJson(json);

  @JsonKey(name: r'MENU_CD')
  final String? menuCd;

  @override
  Map<String, dynamic> toJson() => _$STADMINMENUWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STADMINMENUOrderByWithAggregationInput implements _i1.JsonSerializable {
  const STADMINMENUOrderByWithAggregationInput({
    this.menuCd,
    this.menuNm,
    this.menuPath,
    this.menuSrt,
    this.menuDeps,
    this.menuIcon,
    this.menuTp,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory STADMINMENUOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STADMINMENUOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'MENU_CD')
  final SortOrder? menuCd;

  @JsonKey(name: r'MENU_NM')
  final SortOrder? menuNm;

  @JsonKey(name: r'MENU_PATH')
  final SortOrder? menuPath;

  @JsonKey(name: r'MENU_SRT')
  final SortOrder? menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final SortOrder? menuDeps;

  @JsonKey(name: r'MENU_ICON')
  final SortOrder? menuIcon;

  @JsonKey(name: r'MENU_TP')
  final SortOrder? menuTp;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @JsonKey(name: r'_count')
  final STADMINMENUCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final STADMINMENUAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final STADMINMENUMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final STADMINMENUMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final STADMINMENUSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$STADMINMENUOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class STADMINMENUScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const STADMINMENUScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.menuCd,
    this.menuNm,
    this.menuPath,
    this.menuSrt,
    this.menuDeps,
    this.menuIcon,
    this.menuTp,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STADMINMENUScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$STADMINMENUScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<STADMINMENUScalarWhereWithAggregatesInput>? AND;

  final Iterable<STADMINMENUScalarWhereWithAggregatesInput>? OR;

  final Iterable<STADMINMENUScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'MENU_CD')
  final StringWithAggregatesFilter? menuCd;

  @JsonKey(name: r'MENU_NM')
  final StringWithAggregatesFilter? menuNm;

  @JsonKey(name: r'MENU_PATH')
  final StringNullableWithAggregatesFilter? menuPath;

  @JsonKey(name: r'MENU_SRT')
  final IntWithAggregatesFilter? menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final IntWithAggregatesFilter? menuDeps;

  @JsonKey(name: r'MENU_ICON')
  final StringNullableWithAggregatesFilter? menuIcon;

  @JsonKey(name: r'MENU_TP')
  final StringWithAggregatesFilter? menuTp;

  @JsonKey(name: r'REG_ID')
  final StringWithAggregatesFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringNullableWithAggregatesFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableWithAggregatesFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableWithAggregatesFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableWithAggregatesFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableWithAggregatesFilter? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STADMINMENUScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class STALARMWhereInput implements _i1.JsonSerializable {
  const STALARMWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.msgCd,
    this.msgCnts,
    this.sendDate,
    this.sendDiv,
    this.sendDeptCd,
    this.sendId,
    this.recvId,
    this.popYn,
    this.editId,
    this.editDate,
  });

  factory STALARMWhereInput.fromJson(Map<String, dynamic> json) =>
      _$STALARMWhereInputFromJson(json);

  final Iterable<STALARMWhereInput>? AND;

  final Iterable<STALARMWhereInput>? OR;

  final Iterable<STALARMWhereInput>? NOT;

  @JsonKey(name: r'SEQ')
  final IntFilter? seq;

  @JsonKey(name: r'MSG_CD')
  final StringNullableFilter? msgCd;

  @JsonKey(name: r'MSG_CNTS')
  final StringNullableFilter? msgCnts;

  @JsonKey(name: r'SEND_DATE')
  final StringNullableFilter? sendDate;

  @JsonKey(name: r'SEND_DIV')
  final StringNullableFilter? sendDiv;

  @JsonKey(name: r'SEND_DEPT_CD')
  final StringNullableFilter? sendDeptCd;

  @JsonKey(name: r'SEND_ID')
  final StringNullableFilter? sendId;

  @JsonKey(name: r'RECV_ID')
  final StringNullableFilter? recvId;

  @JsonKey(name: r'POP_YN')
  final StringNullableFilter? popYn;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableFilter? editDate;

  @override
  Map<String, dynamic> toJson() => _$STALARMWhereInputToJson(this);
}

@_i1.jsonSerializable
class STALARMOrderByWithRelationInput implements _i1.JsonSerializable {
  const STALARMOrderByWithRelationInput({
    this.seq,
    this.msgCd,
    this.msgCnts,
    this.sendDate,
    this.sendDiv,
    this.sendDeptCd,
    this.sendId,
    this.recvId,
    this.popYn,
    this.editId,
    this.editDate,
  });

  factory STALARMOrderByWithRelationInput.fromJson(Map<String, dynamic> json) =>
      _$STALARMOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSG_CD')
  final SortOrder? msgCd;

  @JsonKey(name: r'MSG_CNTS')
  final SortOrder? msgCnts;

  @JsonKey(name: r'SEND_DATE')
  final SortOrder? sendDate;

  @JsonKey(name: r'SEND_DIV')
  final SortOrder? sendDiv;

  @JsonKey(name: r'SEND_DEPT_CD')
  final SortOrder? sendDeptCd;

  @JsonKey(name: r'SEND_ID')
  final SortOrder? sendId;

  @JsonKey(name: r'RECV_ID')
  final SortOrder? recvId;

  @JsonKey(name: r'POP_YN')
  final SortOrder? popYn;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STALARMOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class STALARMWhereUniqueInput implements _i1.JsonSerializable {
  const STALARMWhereUniqueInput({this.seq});

  factory STALARMWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$STALARMWhereUniqueInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int? seq;

  @override
  Map<String, dynamic> toJson() => _$STALARMWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STALARMOrderByWithAggregationInput implements _i1.JsonSerializable {
  const STALARMOrderByWithAggregationInput({
    this.seq,
    this.msgCd,
    this.msgCnts,
    this.sendDate,
    this.sendDiv,
    this.sendDeptCd,
    this.sendId,
    this.recvId,
    this.popYn,
    this.editId,
    this.editDate,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory STALARMOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STALARMOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSG_CD')
  final SortOrder? msgCd;

  @JsonKey(name: r'MSG_CNTS')
  final SortOrder? msgCnts;

  @JsonKey(name: r'SEND_DATE')
  final SortOrder? sendDate;

  @JsonKey(name: r'SEND_DIV')
  final SortOrder? sendDiv;

  @JsonKey(name: r'SEND_DEPT_CD')
  final SortOrder? sendDeptCd;

  @JsonKey(name: r'SEND_ID')
  final SortOrder? sendId;

  @JsonKey(name: r'RECV_ID')
  final SortOrder? recvId;

  @JsonKey(name: r'POP_YN')
  final SortOrder? popYn;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'_count')
  final STALARMCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final STALARMAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final STALARMMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final STALARMMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final STALARMSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$STALARMOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class STALARMScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const STALARMScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.msgCd,
    this.msgCnts,
    this.sendDate,
    this.sendDiv,
    this.sendDeptCd,
    this.sendId,
    this.recvId,
    this.popYn,
    this.editId,
    this.editDate,
  });

  factory STALARMScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$STALARMScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<STALARMScalarWhereWithAggregatesInput>? AND;

  final Iterable<STALARMScalarWhereWithAggregatesInput>? OR;

  final Iterable<STALARMScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'SEQ')
  final IntWithAggregatesFilter? seq;

  @JsonKey(name: r'MSG_CD')
  final StringNullableWithAggregatesFilter? msgCd;

  @JsonKey(name: r'MSG_CNTS')
  final StringNullableWithAggregatesFilter? msgCnts;

  @JsonKey(name: r'SEND_DATE')
  final StringNullableWithAggregatesFilter? sendDate;

  @JsonKey(name: r'SEND_DIV')
  final StringNullableWithAggregatesFilter? sendDiv;

  @JsonKey(name: r'SEND_DEPT_CD')
  final StringNullableWithAggregatesFilter? sendDeptCd;

  @JsonKey(name: r'SEND_ID')
  final StringNullableWithAggregatesFilter? sendId;

  @JsonKey(name: r'RECV_ID')
  final StringNullableWithAggregatesFilter? recvId;

  @JsonKey(name: r'POP_YN')
  final StringNullableWithAggregatesFilter? popYn;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableWithAggregatesFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableWithAggregatesFilter? editDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STALARMScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class STAUDITLOGWhereInput implements _i1.JsonSerializable {
  const STAUDITLOGWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.logCode,
    this.logCnts,
    this.errCode,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STAUDITLOGWhereInput.fromJson(Map<String, dynamic> json) =>
      _$STAUDITLOGWhereInputFromJson(json);

  final Iterable<STAUDITLOGWhereInput>? AND;

  final Iterable<STAUDITLOGWhereInput>? OR;

  final Iterable<STAUDITLOGWhereInput>? NOT;

  @JsonKey(name: r'SEQ')
  final IntFilter? seq;

  @JsonKey(name: r'LOG_CODE')
  final StringFilter? logCode;

  @JsonKey(name: r'LOG_CNTS')
  final StringFilter? logCnts;

  @JsonKey(name: r'ERR_CODE')
  final StringNullableFilter? errCode;

  @JsonKey(name: r'REG_ID')
  final StringFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableFilter? delDate;

  @override
  Map<String, dynamic> toJson() => _$STAUDITLOGWhereInputToJson(this);
}

@_i1.jsonSerializable
class STAUDITLOGOrderByWithRelationInput implements _i1.JsonSerializable {
  const STAUDITLOGOrderByWithRelationInput({
    this.seq,
    this.logCode,
    this.logCnts,
    this.errCode,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STAUDITLOGOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STAUDITLOGOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'LOG_CODE')
  final SortOrder? logCode;

  @JsonKey(name: r'LOG_CNTS')
  final SortOrder? logCnts;

  @JsonKey(name: r'ERR_CODE')
  final SortOrder? errCode;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STAUDITLOGOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class STAUDITLOGWhereUniqueInput implements _i1.JsonSerializable {
  const STAUDITLOGWhereUniqueInput({this.seq});

  factory STAUDITLOGWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$STAUDITLOGWhereUniqueInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int? seq;

  @override
  Map<String, dynamic> toJson() => _$STAUDITLOGWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STAUDITLOGOrderByWithAggregationInput implements _i1.JsonSerializable {
  const STAUDITLOGOrderByWithAggregationInput({
    this.seq,
    this.logCode,
    this.logCnts,
    this.errCode,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory STAUDITLOGOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STAUDITLOGOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'LOG_CODE')
  final SortOrder? logCode;

  @JsonKey(name: r'LOG_CNTS')
  final SortOrder? logCnts;

  @JsonKey(name: r'ERR_CODE')
  final SortOrder? errCode;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @JsonKey(name: r'_count')
  final STAUDITLOGCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final STAUDITLOGAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final STAUDITLOGMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final STAUDITLOGMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final STAUDITLOGSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$STAUDITLOGOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class STAUDITLOGScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const STAUDITLOGScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.logCode,
    this.logCnts,
    this.errCode,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STAUDITLOGScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$STAUDITLOGScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<STAUDITLOGScalarWhereWithAggregatesInput>? AND;

  final Iterable<STAUDITLOGScalarWhereWithAggregatesInput>? OR;

  final Iterable<STAUDITLOGScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'SEQ')
  final IntWithAggregatesFilter? seq;

  @JsonKey(name: r'LOG_CODE')
  final StringWithAggregatesFilter? logCode;

  @JsonKey(name: r'LOG_CNTS')
  final StringWithAggregatesFilter? logCnts;

  @JsonKey(name: r'ERR_CODE')
  final StringNullableWithAggregatesFilter? errCode;

  @JsonKey(name: r'REG_ID')
  final StringWithAggregatesFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringWithAggregatesFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableWithAggregatesFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableWithAggregatesFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableWithAggregatesFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableWithAggregatesFilter? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STAUDITLOGScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class STBANNERWhereInput implements _i1.JsonSerializable {
  const STBANNERWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.bannerCd,
    this.lkUrl,
    this.lkTarget,
    this.flpth,
    this.fileNm,
    this.useYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBANNERWhereInput.fromJson(Map<String, dynamic> json) =>
      _$STBANNERWhereInputFromJson(json);

  final Iterable<STBANNERWhereInput>? AND;

  final Iterable<STBANNERWhereInput>? OR;

  final Iterable<STBANNERWhereInput>? NOT;

  @JsonKey(name: r'BANNER_CD')
  final StringFilter? bannerCd;

  @JsonKey(name: r'LK_URL')
  final StringNullableFilter? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final StringNullableFilter? lkTarget;

  @JsonKey(name: r'FLPTH')
  final StringNullableFilter? flpth;

  @JsonKey(name: r'FILE_NM')
  final StringNullableFilter? fileNm;

  @JsonKey(name: r'USE_YN')
  final StringNullableFilter? useYn;

  @JsonKey(name: r'REG_ID')
  final StringFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringNullableFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableFilter? delDate;

  @override
  Map<String, dynamic> toJson() => _$STBANNERWhereInputToJson(this);
}

@_i1.jsonSerializable
class STBANNEROrderByWithRelationInput implements _i1.JsonSerializable {
  const STBANNEROrderByWithRelationInput({
    this.bannerCd,
    this.lkUrl,
    this.lkTarget,
    this.flpth,
    this.fileNm,
    this.useYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBANNEROrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBANNEROrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'BANNER_CD')
  final SortOrder? bannerCd;

  @JsonKey(name: r'LK_URL')
  final SortOrder? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final SortOrder? lkTarget;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'FILE_NM')
  final SortOrder? fileNm;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBANNEROrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class STBANNERWhereUniqueInput implements _i1.JsonSerializable {
  const STBANNERWhereUniqueInput({this.bannerCd});

  factory STBANNERWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$STBANNERWhereUniqueInputFromJson(json);

  @JsonKey(name: r'BANNER_CD')
  final String? bannerCd;

  @override
  Map<String, dynamic> toJson() => _$STBANNERWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STBANNEROrderByWithAggregationInput implements _i1.JsonSerializable {
  const STBANNEROrderByWithAggregationInput({
    this.bannerCd,
    this.lkUrl,
    this.lkTarget,
    this.flpth,
    this.fileNm,
    this.useYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
    this.$count,
    this.$max,
    this.$min,
  });

  factory STBANNEROrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBANNEROrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'BANNER_CD')
  final SortOrder? bannerCd;

  @JsonKey(name: r'LK_URL')
  final SortOrder? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final SortOrder? lkTarget;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'FILE_NM')
  final SortOrder? fileNm;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @JsonKey(name: r'_count')
  final STBANNERCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_max')
  final STBANNERMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final STBANNERMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() =>
      _$STBANNEROrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class STBANNERScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const STBANNERScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.bannerCd,
    this.lkUrl,
    this.lkTarget,
    this.flpth,
    this.fileNm,
    this.useYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBANNERScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBANNERScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<STBANNERScalarWhereWithAggregatesInput>? AND;

  final Iterable<STBANNERScalarWhereWithAggregatesInput>? OR;

  final Iterable<STBANNERScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'BANNER_CD')
  final StringWithAggregatesFilter? bannerCd;

  @JsonKey(name: r'LK_URL')
  final StringNullableWithAggregatesFilter? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final StringNullableWithAggregatesFilter? lkTarget;

  @JsonKey(name: r'FLPTH')
  final StringNullableWithAggregatesFilter? flpth;

  @JsonKey(name: r'FILE_NM')
  final StringNullableWithAggregatesFilter? fileNm;

  @JsonKey(name: r'USE_YN')
  final StringNullableWithAggregatesFilter? useYn;

  @JsonKey(name: r'REG_ID')
  final StringWithAggregatesFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringNullableWithAggregatesFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableWithAggregatesFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableWithAggregatesFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableWithAggregatesFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableWithAggregatesFilter? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBANNERScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNWhereInput implements _i1.JsonSerializable {
  const STBOARDCOLUMNWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.boardCd,
    this.sort,
    this.colCd,
    this.colNm,
    this.regId,
    this.regDate,
  });

  factory STBOARDCOLUMNWhereInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDCOLUMNWhereInputFromJson(json);

  final Iterable<STBOARDCOLUMNWhereInput>? AND;

  final Iterable<STBOARDCOLUMNWhereInput>? OR;

  final Iterable<STBOARDCOLUMNWhereInput>? NOT;

  @JsonKey(name: r'BOARD_CD')
  final StringFilter? boardCd;

  @JsonKey(name: r'SORT')
  final IntFilter? sort;

  @JsonKey(name: r'COL_CD')
  final StringFilter? colCd;

  @JsonKey(name: r'COL_NM')
  final StringFilter? colNm;

  @JsonKey(name: r'REG_ID')
  final StringFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFilter? regDate;

  @override
  Map<String, dynamic> toJson() => _$STBOARDCOLUMNWhereInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNOrderByWithRelationInput implements _i1.JsonSerializable {
  const STBOARDCOLUMNOrderByWithRelationInput({
    this.boardCd,
    this.sort,
    this.colCd,
    this.colNm,
    this.regId,
    this.regDate,
  });

  factory STBOARDCOLUMNOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOLUMNOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'BOARD_CD')
  final SortOrder? boardCd;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'COL_CD')
  final SortOrder? colCd;

  @JsonKey(name: r'COL_NM')
  final SortOrder? colNm;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOLUMNOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNWhereUniqueInput implements _i1.JsonSerializable {
  const STBOARDCOLUMNWhereUniqueInput({this.boardCdColCd});

  factory STBOARDCOLUMNWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDCOLUMNWhereUniqueInputFromJson(json);

  @JsonKey(name: r'BOARD_CD_COL_CD')
  final STBOARDCOLUMNBOARDCDCOLCDCompoundUniqueInput? boardCdColCd;

  @override
  Map<String, dynamic> toJson() => _$STBOARDCOLUMNWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNOrderByWithAggregationInput implements _i1.JsonSerializable {
  const STBOARDCOLUMNOrderByWithAggregationInput({
    this.boardCd,
    this.sort,
    this.colCd,
    this.colNm,
    this.regId,
    this.regDate,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory STBOARDCOLUMNOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOLUMNOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'BOARD_CD')
  final SortOrder? boardCd;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'COL_CD')
  final SortOrder? colCd;

  @JsonKey(name: r'COL_NM')
  final SortOrder? colNm;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'_count')
  final STBOARDCOLUMNCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final STBOARDCOLUMNAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final STBOARDCOLUMNMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final STBOARDCOLUMNMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final STBOARDCOLUMNSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOLUMNOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const STBOARDCOLUMNScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.boardCd,
    this.sort,
    this.colCd,
    this.colNm,
    this.regId,
    this.regDate,
  });

  factory STBOARDCOLUMNScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOLUMNScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<STBOARDCOLUMNScalarWhereWithAggregatesInput>? AND;

  final Iterable<STBOARDCOLUMNScalarWhereWithAggregatesInput>? OR;

  final Iterable<STBOARDCOLUMNScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'BOARD_CD')
  final StringWithAggregatesFilter? boardCd;

  @JsonKey(name: r'SORT')
  final IntWithAggregatesFilter? sort;

  @JsonKey(name: r'COL_CD')
  final StringWithAggregatesFilter? colCd;

  @JsonKey(name: r'COL_NM')
  final StringWithAggregatesFilter? colNm;

  @JsonKey(name: r'REG_ID')
  final StringWithAggregatesFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringWithAggregatesFilter? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOLUMNScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNDFTWhereInput implements _i1.JsonSerializable {
  const STBOARDCOLUMNDFTWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.boardTy,
    this.sort,
    this.colCd,
    this.colNm,
    this.editId,
    this.editDate,
    this.delYn,
  });

  factory STBOARDCOLUMNDFTWhereInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDCOLUMNDFTWhereInputFromJson(json);

  final Iterable<STBOARDCOLUMNDFTWhereInput>? AND;

  final Iterable<STBOARDCOLUMNDFTWhereInput>? OR;

  final Iterable<STBOARDCOLUMNDFTWhereInput>? NOT;

  @JsonKey(name: r'BOARD_TY')
  final StringFilter? boardTy;

  @JsonKey(name: r'SORT')
  final IntFilter? sort;

  @JsonKey(name: r'COL_CD')
  final StringFilter? colCd;

  @JsonKey(name: r'COL_NM')
  final StringFilter? colNm;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableFilter? editDate;

  @JsonKey(name: r'DEL_YN')
  final StringFilter? delYn;

  @override
  Map<String, dynamic> toJson() => _$STBOARDCOLUMNDFTWhereInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNDFTOrderByWithRelationInput implements _i1.JsonSerializable {
  const STBOARDCOLUMNDFTOrderByWithRelationInput({
    this.boardTy,
    this.sort,
    this.colCd,
    this.colNm,
    this.editId,
    this.editDate,
    this.delYn,
  });

  factory STBOARDCOLUMNDFTOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOLUMNDFTOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'BOARD_TY')
  final SortOrder? boardTy;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'COL_CD')
  final SortOrder? colCd;

  @JsonKey(name: r'COL_NM')
  final SortOrder? colNm;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOLUMNDFTOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNDFTWhereUniqueInput implements _i1.JsonSerializable {
  const STBOARDCOLUMNDFTWhereUniqueInput({this.boardTyColCdDelYn});

  factory STBOARDCOLUMNDFTWhereUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOLUMNDFTWhereUniqueInputFromJson(json);

  @JsonKey(name: r'BOARD_TY_COL_CD_DEL_YN')
  final STBOARDCOLUMNDFTBOARDTYCOLCDDELYNCompoundUniqueInput? boardTyColCdDelYn;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOLUMNDFTWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNDFTOrderByWithAggregationInput
    implements _i1.JsonSerializable {
  const STBOARDCOLUMNDFTOrderByWithAggregationInput({
    this.boardTy,
    this.sort,
    this.colCd,
    this.colNm,
    this.editId,
    this.editDate,
    this.delYn,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory STBOARDCOLUMNDFTOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOLUMNDFTOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'BOARD_TY')
  final SortOrder? boardTy;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'COL_CD')
  final SortOrder? colCd;

  @JsonKey(name: r'COL_NM')
  final SortOrder? colNm;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'_count')
  final STBOARDCOLUMNDFTCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final STBOARDCOLUMNDFTAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final STBOARDCOLUMNDFTMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final STBOARDCOLUMNDFTMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final STBOARDCOLUMNDFTSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOLUMNDFTOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNDFTScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const STBOARDCOLUMNDFTScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.boardTy,
    this.sort,
    this.colCd,
    this.colNm,
    this.editId,
    this.editDate,
    this.delYn,
  });

  factory STBOARDCOLUMNDFTScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOLUMNDFTScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<STBOARDCOLUMNDFTScalarWhereWithAggregatesInput>? AND;

  final Iterable<STBOARDCOLUMNDFTScalarWhereWithAggregatesInput>? OR;

  final Iterable<STBOARDCOLUMNDFTScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'BOARD_TY')
  final StringWithAggregatesFilter? boardTy;

  @JsonKey(name: r'SORT')
  final IntWithAggregatesFilter? sort;

  @JsonKey(name: r'COL_CD')
  final StringWithAggregatesFilter? colCd;

  @JsonKey(name: r'COL_NM')
  final StringWithAggregatesFilter? colNm;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableWithAggregatesFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableWithAggregatesFilter? editDate;

  @JsonKey(name: r'DEL_YN')
  final StringWithAggregatesFilter? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOLUMNDFTScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOMMENTWhereInput implements _i1.JsonSerializable {
  const STBOARDCOMMENTWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.mseq,
    this.boardCd,
    this.cnts,
    this.upperSeq,
    this.replyYn,
    this.regAdminYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDCOMMENTWhereInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDCOMMENTWhereInputFromJson(json);

  final Iterable<STBOARDCOMMENTWhereInput>? AND;

  final Iterable<STBOARDCOMMENTWhereInput>? OR;

  final Iterable<STBOARDCOMMENTWhereInput>? NOT;

  @JsonKey(name: r'SEQ')
  final IntFilter? seq;

  @JsonKey(name: r'MSEQ')
  final IntFilter? mseq;

  @JsonKey(name: r'BOARD_CD')
  final StringFilter? boardCd;

  @JsonKey(name: r'CNTS')
  final StringNullableFilter? cnts;

  @JsonKey(name: r'UPPER_SEQ')
  final IntNullableFilter? upperSeq;

  @JsonKey(name: r'REPLY_YN')
  final StringNullableFilter? replyYn;

  @JsonKey(name: r'REG_ADMIN_YN')
  final StringNullableFilter? regAdminYn;

  @JsonKey(name: r'REG_ID')
  final StringFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableFilter? delDate;

  @override
  Map<String, dynamic> toJson() => _$STBOARDCOMMENTWhereInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOMMENTOrderByWithRelationInput implements _i1.JsonSerializable {
  const STBOARDCOMMENTOrderByWithRelationInput({
    this.seq,
    this.mseq,
    this.boardCd,
    this.cnts,
    this.upperSeq,
    this.replyYn,
    this.regAdminYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDCOMMENTOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOMMENTOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'BOARD_CD')
  final SortOrder? boardCd;

  @JsonKey(name: r'CNTS')
  final SortOrder? cnts;

  @JsonKey(name: r'UPPER_SEQ')
  final SortOrder? upperSeq;

  @JsonKey(name: r'REPLY_YN')
  final SortOrder? replyYn;

  @JsonKey(name: r'REG_ADMIN_YN')
  final SortOrder? regAdminYn;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOMMENTOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOMMENTWhereUniqueInput implements _i1.JsonSerializable {
  const STBOARDCOMMENTWhereUniqueInput({this.seqMseqBoardCd});

  factory STBOARDCOMMENTWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDCOMMENTWhereUniqueInputFromJson(json);

  @JsonKey(name: r'SEQ_MSEQ_BOARD_CD')
  final STBOARDCOMMENTSEQMSEQBOARDCDCompoundUniqueInput? seqMseqBoardCd;

  @override
  Map<String, dynamic> toJson() => _$STBOARDCOMMENTWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOMMENTOrderByWithAggregationInput
    implements _i1.JsonSerializable {
  const STBOARDCOMMENTOrderByWithAggregationInput({
    this.seq,
    this.mseq,
    this.boardCd,
    this.cnts,
    this.upperSeq,
    this.replyYn,
    this.regAdminYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory STBOARDCOMMENTOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOMMENTOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'BOARD_CD')
  final SortOrder? boardCd;

  @JsonKey(name: r'CNTS')
  final SortOrder? cnts;

  @JsonKey(name: r'UPPER_SEQ')
  final SortOrder? upperSeq;

  @JsonKey(name: r'REPLY_YN')
  final SortOrder? replyYn;

  @JsonKey(name: r'REG_ADMIN_YN')
  final SortOrder? regAdminYn;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @JsonKey(name: r'_count')
  final STBOARDCOMMENTCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final STBOARDCOMMENTAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final STBOARDCOMMENTMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final STBOARDCOMMENTMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final STBOARDCOMMENTSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOMMENTOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOMMENTScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const STBOARDCOMMENTScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.mseq,
    this.boardCd,
    this.cnts,
    this.upperSeq,
    this.replyYn,
    this.regAdminYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDCOMMENTScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOMMENTScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<STBOARDCOMMENTScalarWhereWithAggregatesInput>? AND;

  final Iterable<STBOARDCOMMENTScalarWhereWithAggregatesInput>? OR;

  final Iterable<STBOARDCOMMENTScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'SEQ')
  final IntWithAggregatesFilter? seq;

  @JsonKey(name: r'MSEQ')
  final IntWithAggregatesFilter? mseq;

  @JsonKey(name: r'BOARD_CD')
  final StringWithAggregatesFilter? boardCd;

  @JsonKey(name: r'CNTS')
  final StringNullableWithAggregatesFilter? cnts;

  @JsonKey(name: r'UPPER_SEQ')
  final IntNullableWithAggregatesFilter? upperSeq;

  @JsonKey(name: r'REPLY_YN')
  final StringNullableWithAggregatesFilter? replyYn;

  @JsonKey(name: r'REG_ADMIN_YN')
  final StringNullableWithAggregatesFilter? regAdminYn;

  @JsonKey(name: r'REG_ID')
  final StringWithAggregatesFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringWithAggregatesFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableWithAggregatesFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableWithAggregatesFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableWithAggregatesFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableWithAggregatesFilter? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOMMENTScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDFILEWhereInput implements _i1.JsonSerializable {
  const STBOARDFILEWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.mseq,
    this.boardCd,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileSize,
    this.repreYn,
    this.dwldCo,
  });

  factory STBOARDFILEWhereInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDFILEWhereInputFromJson(json);

  final Iterable<STBOARDFILEWhereInput>? AND;

  final Iterable<STBOARDFILEWhereInput>? OR;

  final Iterable<STBOARDFILEWhereInput>? NOT;

  @JsonKey(name: r'SEQ')
  final IntFilter? seq;

  @JsonKey(name: r'MSEQ')
  final IntFilter? mseq;

  @JsonKey(name: r'BOARD_CD')
  final StringFilter? boardCd;

  @JsonKey(name: r'FILE_TP')
  final StringNullableFilter? fileTp;

  @JsonKey(name: r'FLPTH')
  final StringNullableFilter? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final StringNullableFilter? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final StringNullableFilter? streFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final IntNullableFilter? fileSize;

  @JsonKey(name: r'REPRE_YN')
  final StringNullableFilter? repreYn;

  @JsonKey(name: r'DWLD_CO')
  final IntNullableFilter? dwldCo;

  @override
  Map<String, dynamic> toJson() => _$STBOARDFILEWhereInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDFILEOrderByWithRelationInput implements _i1.JsonSerializable {
  const STBOARDFILEOrderByWithRelationInput({
    this.seq,
    this.mseq,
    this.boardCd,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileSize,
    this.repreYn,
    this.dwldCo,
  });

  factory STBOARDFILEOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDFILEOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'BOARD_CD')
  final SortOrder? boardCd;

  @JsonKey(name: r'FILE_TP')
  final SortOrder? fileTp;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final SortOrder? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final SortOrder? streFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final SortOrder? fileSize;

  @JsonKey(name: r'REPRE_YN')
  final SortOrder? repreYn;

  @JsonKey(name: r'DWLD_CO')
  final SortOrder? dwldCo;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDFILEOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDFILEWhereUniqueInput implements _i1.JsonSerializable {
  const STBOARDFILEWhereUniqueInput({this.seqMseqBoardCd});

  factory STBOARDFILEWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDFILEWhereUniqueInputFromJson(json);

  @JsonKey(name: r'SEQ_MSEQ_BOARD_CD')
  final STBOARDFILESEQMSEQBOARDCDCompoundUniqueInput? seqMseqBoardCd;

  @override
  Map<String, dynamic> toJson() => _$STBOARDFILEWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDFILEOrderByWithAggregationInput implements _i1.JsonSerializable {
  const STBOARDFILEOrderByWithAggregationInput({
    this.seq,
    this.mseq,
    this.boardCd,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileSize,
    this.repreYn,
    this.dwldCo,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory STBOARDFILEOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDFILEOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'BOARD_CD')
  final SortOrder? boardCd;

  @JsonKey(name: r'FILE_TP')
  final SortOrder? fileTp;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final SortOrder? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final SortOrder? streFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final SortOrder? fileSize;

  @JsonKey(name: r'REPRE_YN')
  final SortOrder? repreYn;

  @JsonKey(name: r'DWLD_CO')
  final SortOrder? dwldCo;

  @JsonKey(name: r'_count')
  final STBOARDFILECountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final STBOARDFILEAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final STBOARDFILEMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final STBOARDFILEMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final STBOARDFILESumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDFILEOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDFILEScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const STBOARDFILEScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.mseq,
    this.boardCd,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileSize,
    this.repreYn,
    this.dwldCo,
  });

  factory STBOARDFILEScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDFILEScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<STBOARDFILEScalarWhereWithAggregatesInput>? AND;

  final Iterable<STBOARDFILEScalarWhereWithAggregatesInput>? OR;

  final Iterable<STBOARDFILEScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'SEQ')
  final IntWithAggregatesFilter? seq;

  @JsonKey(name: r'MSEQ')
  final IntWithAggregatesFilter? mseq;

  @JsonKey(name: r'BOARD_CD')
  final StringWithAggregatesFilter? boardCd;

  @JsonKey(name: r'FILE_TP')
  final StringNullableWithAggregatesFilter? fileTp;

  @JsonKey(name: r'FLPTH')
  final StringNullableWithAggregatesFilter? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final StringNullableWithAggregatesFilter? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final StringNullableWithAggregatesFilter? streFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final IntNullableWithAggregatesFilter? fileSize;

  @JsonKey(name: r'REPRE_YN')
  final StringNullableWithAggregatesFilter? repreYn;

  @JsonKey(name: r'DWLD_CO')
  final IntNullableWithAggregatesFilter? dwldCo;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDFILEScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDMSTWhereInput implements _i1.JsonSerializable {
  const STBOARDMSTWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.boardCd,
    this.clsCd,
    this.ttl,
    this.cnts,
    this.fileYn,
    this.imageYn,
    this.noticeYn,
    this.lkUrl,
    this.lkTarget,
    this.readCnt,
    this.regAdminYn,
    this.replyYn,
    this.upperSeq,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDMSTWhereInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDMSTWhereInputFromJson(json);

  final Iterable<STBOARDMSTWhereInput>? AND;

  final Iterable<STBOARDMSTWhereInput>? OR;

  final Iterable<STBOARDMSTWhereInput>? NOT;

  @JsonKey(name: r'SEQ')
  final IntFilter? seq;

  @JsonKey(name: r'BOARD_CD')
  final StringFilter? boardCd;

  @JsonKey(name: r'CLS_CD')
  final StringNullableFilter? clsCd;

  @JsonKey(name: r'TTL')
  final StringFilter? ttl;

  @JsonKey(name: r'CNTS')
  final StringFilter? cnts;

  @JsonKey(name: r'FILE_YN')
  final StringNullableFilter? fileYn;

  @JsonKey(name: r'IMAGE_YN')
  final StringNullableFilter? imageYn;

  @JsonKey(name: r'NOTICE_YN')
  final StringNullableFilter? noticeYn;

  @JsonKey(name: r'LK_URL')
  final StringNullableFilter? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final StringNullableFilter? lkTarget;

  @JsonKey(name: r'READ_CNT')
  final IntNullableFilter? readCnt;

  @JsonKey(name: r'REG_ADMIN_YN')
  final StringNullableFilter? regAdminYn;

  @JsonKey(name: r'REPLY_YN')
  final StringNullableFilter? replyYn;

  @JsonKey(name: r'UPPER_SEQ')
  final IntNullableFilter? upperSeq;

  @JsonKey(name: r'REG_ID')
  final StringFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableFilter? delDate;

  @override
  Map<String, dynamic> toJson() => _$STBOARDMSTWhereInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDMSTOrderByWithRelationInput implements _i1.JsonSerializable {
  const STBOARDMSTOrderByWithRelationInput({
    this.seq,
    this.boardCd,
    this.clsCd,
    this.ttl,
    this.cnts,
    this.fileYn,
    this.imageYn,
    this.noticeYn,
    this.lkUrl,
    this.lkTarget,
    this.readCnt,
    this.regAdminYn,
    this.replyYn,
    this.upperSeq,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDMSTOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDMSTOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'BOARD_CD')
  final SortOrder? boardCd;

  @JsonKey(name: r'CLS_CD')
  final SortOrder? clsCd;

  @JsonKey(name: r'TTL')
  final SortOrder? ttl;

  @JsonKey(name: r'CNTS')
  final SortOrder? cnts;

  @JsonKey(name: r'FILE_YN')
  final SortOrder? fileYn;

  @JsonKey(name: r'IMAGE_YN')
  final SortOrder? imageYn;

  @JsonKey(name: r'NOTICE_YN')
  final SortOrder? noticeYn;

  @JsonKey(name: r'LK_URL')
  final SortOrder? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final SortOrder? lkTarget;

  @JsonKey(name: r'READ_CNT')
  final SortOrder? readCnt;

  @JsonKey(name: r'REG_ADMIN_YN')
  final SortOrder? regAdminYn;

  @JsonKey(name: r'REPLY_YN')
  final SortOrder? replyYn;

  @JsonKey(name: r'UPPER_SEQ')
  final SortOrder? upperSeq;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDMSTOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDMSTWhereUniqueInput implements _i1.JsonSerializable {
  const STBOARDMSTWhereUniqueInput({this.seqBoardCd});

  factory STBOARDMSTWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDMSTWhereUniqueInputFromJson(json);

  @JsonKey(name: r'SEQ_BOARD_CD')
  final STBOARDMSTSEQBOARDCDCompoundUniqueInput? seqBoardCd;

  @override
  Map<String, dynamic> toJson() => _$STBOARDMSTWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDMSTOrderByWithAggregationInput implements _i1.JsonSerializable {
  const STBOARDMSTOrderByWithAggregationInput({
    this.seq,
    this.boardCd,
    this.clsCd,
    this.ttl,
    this.cnts,
    this.fileYn,
    this.imageYn,
    this.noticeYn,
    this.lkUrl,
    this.lkTarget,
    this.readCnt,
    this.regAdminYn,
    this.replyYn,
    this.upperSeq,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory STBOARDMSTOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDMSTOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'BOARD_CD')
  final SortOrder? boardCd;

  @JsonKey(name: r'CLS_CD')
  final SortOrder? clsCd;

  @JsonKey(name: r'TTL')
  final SortOrder? ttl;

  @JsonKey(name: r'CNTS')
  final SortOrder? cnts;

  @JsonKey(name: r'FILE_YN')
  final SortOrder? fileYn;

  @JsonKey(name: r'IMAGE_YN')
  final SortOrder? imageYn;

  @JsonKey(name: r'NOTICE_YN')
  final SortOrder? noticeYn;

  @JsonKey(name: r'LK_URL')
  final SortOrder? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final SortOrder? lkTarget;

  @JsonKey(name: r'READ_CNT')
  final SortOrder? readCnt;

  @JsonKey(name: r'REG_ADMIN_YN')
  final SortOrder? regAdminYn;

  @JsonKey(name: r'REPLY_YN')
  final SortOrder? replyYn;

  @JsonKey(name: r'UPPER_SEQ')
  final SortOrder? upperSeq;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @JsonKey(name: r'_count')
  final STBOARDMSTCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final STBOARDMSTAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final STBOARDMSTMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final STBOARDMSTMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final STBOARDMSTSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDMSTOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDMSTScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const STBOARDMSTScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.boardCd,
    this.clsCd,
    this.ttl,
    this.cnts,
    this.fileYn,
    this.imageYn,
    this.noticeYn,
    this.lkUrl,
    this.lkTarget,
    this.readCnt,
    this.regAdminYn,
    this.replyYn,
    this.upperSeq,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDMSTScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDMSTScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<STBOARDMSTScalarWhereWithAggregatesInput>? AND;

  final Iterable<STBOARDMSTScalarWhereWithAggregatesInput>? OR;

  final Iterable<STBOARDMSTScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'SEQ')
  final IntWithAggregatesFilter? seq;

  @JsonKey(name: r'BOARD_CD')
  final StringWithAggregatesFilter? boardCd;

  @JsonKey(name: r'CLS_CD')
  final StringNullableWithAggregatesFilter? clsCd;

  @JsonKey(name: r'TTL')
  final StringWithAggregatesFilter? ttl;

  @JsonKey(name: r'CNTS')
  final StringWithAggregatesFilter? cnts;

  @JsonKey(name: r'FILE_YN')
  final StringNullableWithAggregatesFilter? fileYn;

  @JsonKey(name: r'IMAGE_YN')
  final StringNullableWithAggregatesFilter? imageYn;

  @JsonKey(name: r'NOTICE_YN')
  final StringNullableWithAggregatesFilter? noticeYn;

  @JsonKey(name: r'LK_URL')
  final StringNullableWithAggregatesFilter? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final StringNullableWithAggregatesFilter? lkTarget;

  @JsonKey(name: r'READ_CNT')
  final IntNullableWithAggregatesFilter? readCnt;

  @JsonKey(name: r'REG_ADMIN_YN')
  final StringNullableWithAggregatesFilter? regAdminYn;

  @JsonKey(name: r'REPLY_YN')
  final StringNullableWithAggregatesFilter? replyYn;

  @JsonKey(name: r'UPPER_SEQ')
  final IntNullableWithAggregatesFilter? upperSeq;

  @JsonKey(name: r'REG_ID')
  final StringWithAggregatesFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringWithAggregatesFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableWithAggregatesFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableWithAggregatesFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableWithAggregatesFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableWithAggregatesFilter? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDMSTScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDSTNGWhereInput implements _i1.JsonSerializable {
  const STBOARDSTNGWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.boardCd,
    this.boardNm,
    this.boardTy,
    this.editorYn,
    this.rlsYn,
    this.cclSeq,
    this.listCnt,
    this.writeYn,
    this.commentYn,
    this.replyYn,
    this.attachYn,
    this.attachSize,
    this.attachCnt,
    this.attachExt,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDSTNGWhereInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDSTNGWhereInputFromJson(json);

  final Iterable<STBOARDSTNGWhereInput>? AND;

  final Iterable<STBOARDSTNGWhereInput>? OR;

  final Iterable<STBOARDSTNGWhereInput>? NOT;

  @JsonKey(name: r'BOARD_CD')
  final StringFilter? boardCd;

  @JsonKey(name: r'BOARD_NM')
  final StringFilter? boardNm;

  @JsonKey(name: r'BOARD_TY')
  final StringFilter? boardTy;

  @JsonKey(name: r'EDITOR_YN')
  final StringFilter? editorYn;

  @JsonKey(name: r'RLS_YN')
  final StringFilter? rlsYn;

  @JsonKey(name: r'CCL_SEQ')
  final IntNullableFilter? cclSeq;

  @JsonKey(name: r'LIST_CNT')
  final IntNullableFilter? listCnt;

  @JsonKey(name: r'WRITE_YN')
  final StringNullableFilter? writeYn;

  @JsonKey(name: r'COMMENT_YN')
  final StringNullableFilter? commentYn;

  @JsonKey(name: r'REPLY_YN')
  final StringNullableFilter? replyYn;

  @JsonKey(name: r'ATTACH_YN')
  final StringNullableFilter? attachYn;

  @JsonKey(name: r'ATTACH_SIZE')
  final StringNullableFilter? attachSize;

  @JsonKey(name: r'ATTACH_CNT')
  final StringNullableFilter? attachCnt;

  @JsonKey(name: r'ATTACH_EXT')
  final StringNullableFilter? attachExt;

  @JsonKey(name: r'REG_ID')
  final StringFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableFilter? delDate;

  @override
  Map<String, dynamic> toJson() => _$STBOARDSTNGWhereInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDSTNGOrderByWithRelationInput implements _i1.JsonSerializable {
  const STBOARDSTNGOrderByWithRelationInput({
    this.boardCd,
    this.boardNm,
    this.boardTy,
    this.editorYn,
    this.rlsYn,
    this.cclSeq,
    this.listCnt,
    this.writeYn,
    this.commentYn,
    this.replyYn,
    this.attachYn,
    this.attachSize,
    this.attachCnt,
    this.attachExt,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDSTNGOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDSTNGOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'BOARD_CD')
  final SortOrder? boardCd;

  @JsonKey(name: r'BOARD_NM')
  final SortOrder? boardNm;

  @JsonKey(name: r'BOARD_TY')
  final SortOrder? boardTy;

  @JsonKey(name: r'EDITOR_YN')
  final SortOrder? editorYn;

  @JsonKey(name: r'RLS_YN')
  final SortOrder? rlsYn;

  @JsonKey(name: r'CCL_SEQ')
  final SortOrder? cclSeq;

  @JsonKey(name: r'LIST_CNT')
  final SortOrder? listCnt;

  @JsonKey(name: r'WRITE_YN')
  final SortOrder? writeYn;

  @JsonKey(name: r'COMMENT_YN')
  final SortOrder? commentYn;

  @JsonKey(name: r'REPLY_YN')
  final SortOrder? replyYn;

  @JsonKey(name: r'ATTACH_YN')
  final SortOrder? attachYn;

  @JsonKey(name: r'ATTACH_SIZE')
  final SortOrder? attachSize;

  @JsonKey(name: r'ATTACH_CNT')
  final SortOrder? attachCnt;

  @JsonKey(name: r'ATTACH_EXT')
  final SortOrder? attachExt;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDSTNGOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDSTNGWhereUniqueInput implements _i1.JsonSerializable {
  const STBOARDSTNGWhereUniqueInput({this.boardCd});

  factory STBOARDSTNGWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDSTNGWhereUniqueInputFromJson(json);

  @JsonKey(name: r'BOARD_CD')
  final String? boardCd;

  @override
  Map<String, dynamic> toJson() => _$STBOARDSTNGWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDSTNGOrderByWithAggregationInput implements _i1.JsonSerializable {
  const STBOARDSTNGOrderByWithAggregationInput({
    this.boardCd,
    this.boardNm,
    this.boardTy,
    this.editorYn,
    this.rlsYn,
    this.cclSeq,
    this.listCnt,
    this.writeYn,
    this.commentYn,
    this.replyYn,
    this.attachYn,
    this.attachSize,
    this.attachCnt,
    this.attachExt,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory STBOARDSTNGOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDSTNGOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'BOARD_CD')
  final SortOrder? boardCd;

  @JsonKey(name: r'BOARD_NM')
  final SortOrder? boardNm;

  @JsonKey(name: r'BOARD_TY')
  final SortOrder? boardTy;

  @JsonKey(name: r'EDITOR_YN')
  final SortOrder? editorYn;

  @JsonKey(name: r'RLS_YN')
  final SortOrder? rlsYn;

  @JsonKey(name: r'CCL_SEQ')
  final SortOrder? cclSeq;

  @JsonKey(name: r'LIST_CNT')
  final SortOrder? listCnt;

  @JsonKey(name: r'WRITE_YN')
  final SortOrder? writeYn;

  @JsonKey(name: r'COMMENT_YN')
  final SortOrder? commentYn;

  @JsonKey(name: r'REPLY_YN')
  final SortOrder? replyYn;

  @JsonKey(name: r'ATTACH_YN')
  final SortOrder? attachYn;

  @JsonKey(name: r'ATTACH_SIZE')
  final SortOrder? attachSize;

  @JsonKey(name: r'ATTACH_CNT')
  final SortOrder? attachCnt;

  @JsonKey(name: r'ATTACH_EXT')
  final SortOrder? attachExt;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @JsonKey(name: r'_count')
  final STBOARDSTNGCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final STBOARDSTNGAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final STBOARDSTNGMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final STBOARDSTNGMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final STBOARDSTNGSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDSTNGOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDSTNGScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const STBOARDSTNGScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.boardCd,
    this.boardNm,
    this.boardTy,
    this.editorYn,
    this.rlsYn,
    this.cclSeq,
    this.listCnt,
    this.writeYn,
    this.commentYn,
    this.replyYn,
    this.attachYn,
    this.attachSize,
    this.attachCnt,
    this.attachExt,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDSTNGScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDSTNGScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<STBOARDSTNGScalarWhereWithAggregatesInput>? AND;

  final Iterable<STBOARDSTNGScalarWhereWithAggregatesInput>? OR;

  final Iterable<STBOARDSTNGScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'BOARD_CD')
  final StringWithAggregatesFilter? boardCd;

  @JsonKey(name: r'BOARD_NM')
  final StringWithAggregatesFilter? boardNm;

  @JsonKey(name: r'BOARD_TY')
  final StringWithAggregatesFilter? boardTy;

  @JsonKey(name: r'EDITOR_YN')
  final StringWithAggregatesFilter? editorYn;

  @JsonKey(name: r'RLS_YN')
  final StringWithAggregatesFilter? rlsYn;

  @JsonKey(name: r'CCL_SEQ')
  final IntNullableWithAggregatesFilter? cclSeq;

  @JsonKey(name: r'LIST_CNT')
  final IntNullableWithAggregatesFilter? listCnt;

  @JsonKey(name: r'WRITE_YN')
  final StringNullableWithAggregatesFilter? writeYn;

  @JsonKey(name: r'COMMENT_YN')
  final StringNullableWithAggregatesFilter? commentYn;

  @JsonKey(name: r'REPLY_YN')
  final StringNullableWithAggregatesFilter? replyYn;

  @JsonKey(name: r'ATTACH_YN')
  final StringNullableWithAggregatesFilter? attachYn;

  @JsonKey(name: r'ATTACH_SIZE')
  final StringNullableWithAggregatesFilter? attachSize;

  @JsonKey(name: r'ATTACH_CNT')
  final StringNullableWithAggregatesFilter? attachCnt;

  @JsonKey(name: r'ATTACH_EXT')
  final StringNullableWithAggregatesFilter? attachExt;

  @JsonKey(name: r'REG_ID')
  final StringWithAggregatesFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringWithAggregatesFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableWithAggregatesFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableWithAggregatesFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableWithAggregatesFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableWithAggregatesFilter? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDSTNGScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class STCCLWhereInput implements _i1.JsonSerializable {
  const STCCLWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.cclType,
    this.cclNm,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileExtsn,
    this.fileSize,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCCLWhereInput.fromJson(Map<String, dynamic> json) =>
      _$STCCLWhereInputFromJson(json);

  final Iterable<STCCLWhereInput>? AND;

  final Iterable<STCCLWhereInput>? OR;

  final Iterable<STCCLWhereInput>? NOT;

  @JsonKey(name: r'SEQ')
  final IntFilter? seq;

  @JsonKey(name: r'CCL_TYPE')
  final StringFilter? cclType;

  @JsonKey(name: r'CCL_NM')
  final StringFilter? cclNm;

  @JsonKey(name: r'FLPTH')
  final StringNullableFilter? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final StringNullableFilter? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final StringNullableFilter? streFileNm;

  @JsonKey(name: r'FILE_EXTSN')
  final StringNullableFilter? fileExtsn;

  @JsonKey(name: r'FILE_SIZE')
  final IntNullableFilter? fileSize;

  @JsonKey(name: r'REG_ID')
  final StringFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableFilter? delDate;

  @override
  Map<String, dynamic> toJson() => _$STCCLWhereInputToJson(this);
}

@_i1.jsonSerializable
class STCCLOrderByWithRelationInput implements _i1.JsonSerializable {
  const STCCLOrderByWithRelationInput({
    this.seq,
    this.cclType,
    this.cclNm,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileExtsn,
    this.fileSize,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCCLOrderByWithRelationInput.fromJson(Map<String, dynamic> json) =>
      _$STCCLOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'CCL_TYPE')
  final SortOrder? cclType;

  @JsonKey(name: r'CCL_NM')
  final SortOrder? cclNm;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final SortOrder? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final SortOrder? streFileNm;

  @JsonKey(name: r'FILE_EXTSN')
  final SortOrder? fileExtsn;

  @JsonKey(name: r'FILE_SIZE')
  final SortOrder? fileSize;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() => _$STCCLOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class STCCLWhereUniqueInput implements _i1.JsonSerializable {
  const STCCLWhereUniqueInput({this.seq});

  factory STCCLWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$STCCLWhereUniqueInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int? seq;

  @override
  Map<String, dynamic> toJson() => _$STCCLWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STCCLOrderByWithAggregationInput implements _i1.JsonSerializable {
  const STCCLOrderByWithAggregationInput({
    this.seq,
    this.cclType,
    this.cclNm,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileExtsn,
    this.fileSize,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory STCCLOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCCLOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'CCL_TYPE')
  final SortOrder? cclType;

  @JsonKey(name: r'CCL_NM')
  final SortOrder? cclNm;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final SortOrder? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final SortOrder? streFileNm;

  @JsonKey(name: r'FILE_EXTSN')
  final SortOrder? fileExtsn;

  @JsonKey(name: r'FILE_SIZE')
  final SortOrder? fileSize;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @JsonKey(name: r'_count')
  final STCCLCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final STCCLAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final STCCLMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final STCCLMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final STCCLSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$STCCLOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class STCCLScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const STCCLScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.cclType,
    this.cclNm,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileExtsn,
    this.fileSize,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCCLScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCCLScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<STCCLScalarWhereWithAggregatesInput>? AND;

  final Iterable<STCCLScalarWhereWithAggregatesInput>? OR;

  final Iterable<STCCLScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'SEQ')
  final IntWithAggregatesFilter? seq;

  @JsonKey(name: r'CCL_TYPE')
  final StringWithAggregatesFilter? cclType;

  @JsonKey(name: r'CCL_NM')
  final StringWithAggregatesFilter? cclNm;

  @JsonKey(name: r'FLPTH')
  final StringNullableWithAggregatesFilter? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final StringNullableWithAggregatesFilter? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final StringNullableWithAggregatesFilter? streFileNm;

  @JsonKey(name: r'FILE_EXTSN')
  final StringNullableWithAggregatesFilter? fileExtsn;

  @JsonKey(name: r'FILE_SIZE')
  final IntNullableWithAggregatesFilter? fileSize;

  @JsonKey(name: r'REG_ID')
  final StringWithAggregatesFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringWithAggregatesFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableWithAggregatesFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableWithAggregatesFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableWithAggregatesFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableWithAggregatesFilter? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STCCLScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class STCODEMSTWhereInput implements _i1.JsonSerializable {
  const STCODEMSTWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.cdGrp,
    this.cdKey,
    this.cdVal,
    this.cdDesc,
    this.cdSrt,
    this.depth,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCODEMSTWhereInput.fromJson(Map<String, dynamic> json) =>
      _$STCODEMSTWhereInputFromJson(json);

  final Iterable<STCODEMSTWhereInput>? AND;

  final Iterable<STCODEMSTWhereInput>? OR;

  final Iterable<STCODEMSTWhereInput>? NOT;

  @JsonKey(name: r'CD_GRP')
  final StringFilter? cdGrp;

  @JsonKey(name: r'CD_KEY')
  final StringFilter? cdKey;

  @JsonKey(name: r'CD_VAL')
  final StringFilter? cdVal;

  @JsonKey(name: r'CD_DESC')
  final StringNullableFilter? cdDesc;

  @JsonKey(name: r'CD_SRT')
  final IntFilter? cdSrt;

  @JsonKey(name: r'DEPTH')
  final IntNullableFilter? depth;

  @JsonKey(name: r'REG_ID')
  final StringFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringNullableFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableFilter? delDate;

  @override
  Map<String, dynamic> toJson() => _$STCODEMSTWhereInputToJson(this);
}

@_i1.jsonSerializable
class STCODEMSTOrderByWithRelationInput implements _i1.JsonSerializable {
  const STCODEMSTOrderByWithRelationInput({
    this.cdGrp,
    this.cdKey,
    this.cdVal,
    this.cdDesc,
    this.cdSrt,
    this.depth,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCODEMSTOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCODEMSTOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'CD_GRP')
  final SortOrder? cdGrp;

  @JsonKey(name: r'CD_KEY')
  final SortOrder? cdKey;

  @JsonKey(name: r'CD_VAL')
  final SortOrder? cdVal;

  @JsonKey(name: r'CD_DESC')
  final SortOrder? cdDesc;

  @JsonKey(name: r'CD_SRT')
  final SortOrder? cdSrt;

  @JsonKey(name: r'DEPTH')
  final SortOrder? depth;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STCODEMSTOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class STCODEMSTWhereUniqueInput implements _i1.JsonSerializable {
  const STCODEMSTWhereUniqueInput({this.cdGrpCdKey});

  factory STCODEMSTWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$STCODEMSTWhereUniqueInputFromJson(json);

  @JsonKey(name: r'CD_GRP_CD_KEY')
  final STCODEMSTCDGRPCDKEYCompoundUniqueInput? cdGrpCdKey;

  @override
  Map<String, dynamic> toJson() => _$STCODEMSTWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STCODEMSTOrderByWithAggregationInput implements _i1.JsonSerializable {
  const STCODEMSTOrderByWithAggregationInput({
    this.cdGrp,
    this.cdKey,
    this.cdVal,
    this.cdDesc,
    this.cdSrt,
    this.depth,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory STCODEMSTOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCODEMSTOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'CD_GRP')
  final SortOrder? cdGrp;

  @JsonKey(name: r'CD_KEY')
  final SortOrder? cdKey;

  @JsonKey(name: r'CD_VAL')
  final SortOrder? cdVal;

  @JsonKey(name: r'CD_DESC')
  final SortOrder? cdDesc;

  @JsonKey(name: r'CD_SRT')
  final SortOrder? cdSrt;

  @JsonKey(name: r'DEPTH')
  final SortOrder? depth;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @JsonKey(name: r'_count')
  final STCODEMSTCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final STCODEMSTAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final STCODEMSTMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final STCODEMSTMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final STCODEMSTSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$STCODEMSTOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class STCODEMSTScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const STCODEMSTScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.cdGrp,
    this.cdKey,
    this.cdVal,
    this.cdDesc,
    this.cdSrt,
    this.depth,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCODEMSTScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCODEMSTScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<STCODEMSTScalarWhereWithAggregatesInput>? AND;

  final Iterable<STCODEMSTScalarWhereWithAggregatesInput>? OR;

  final Iterable<STCODEMSTScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'CD_GRP')
  final StringWithAggregatesFilter? cdGrp;

  @JsonKey(name: r'CD_KEY')
  final StringWithAggregatesFilter? cdKey;

  @JsonKey(name: r'CD_VAL')
  final StringWithAggregatesFilter? cdVal;

  @JsonKey(name: r'CD_DESC')
  final StringNullableWithAggregatesFilter? cdDesc;

  @JsonKey(name: r'CD_SRT')
  final IntWithAggregatesFilter? cdSrt;

  @JsonKey(name: r'DEPTH')
  final IntNullableWithAggregatesFilter? depth;

  @JsonKey(name: r'REG_ID')
  final StringWithAggregatesFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringNullableWithAggregatesFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableWithAggregatesFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableWithAggregatesFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableWithAggregatesFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableWithAggregatesFilter? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STCODEMSTScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class STCONNECTLOGWhereInput implements _i1.JsonSerializable {
  const STCONNECTLOGWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.userId,
    this.connType,
    this.osType,
    this.browserType,
    this.conneIp,
    this.regDate,
  });

  factory STCONNECTLOGWhereInput.fromJson(Map<String, dynamic> json) =>
      _$STCONNECTLOGWhereInputFromJson(json);

  final Iterable<STCONNECTLOGWhereInput>? AND;

  final Iterable<STCONNECTLOGWhereInput>? OR;

  final Iterable<STCONNECTLOGWhereInput>? NOT;

  @JsonKey(name: r'SEQ')
  final IntFilter? seq;

  @JsonKey(name: r'USER_ID')
  final StringFilter? userId;

  @JsonKey(name: r'CONN_TYPE')
  final StringNullableFilter? connType;

  @JsonKey(name: r'OS_TYPE')
  final StringNullableFilter? osType;

  @JsonKey(name: r'BROWSER_TYPE')
  final StringNullableFilter? browserType;

  @JsonKey(name: r'CONNE_IP')
  final StringNullableFilter? conneIp;

  @JsonKey(name: r'REG_DATE')
  final StringNullableFilter? regDate;

  @override
  Map<String, dynamic> toJson() => _$STCONNECTLOGWhereInputToJson(this);
}

@_i1.jsonSerializable
class STCONNECTLOGOrderByWithRelationInput implements _i1.JsonSerializable {
  const STCONNECTLOGOrderByWithRelationInput({
    this.seq,
    this.userId,
    this.connType,
    this.osType,
    this.browserType,
    this.conneIp,
    this.regDate,
  });

  factory STCONNECTLOGOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONNECTLOGOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'CONN_TYPE')
  final SortOrder? connType;

  @JsonKey(name: r'OS_TYPE')
  final SortOrder? osType;

  @JsonKey(name: r'BROWSER_TYPE')
  final SortOrder? browserType;

  @JsonKey(name: r'CONNE_IP')
  final SortOrder? conneIp;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONNECTLOGOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class STCONNECTLOGWhereUniqueInput implements _i1.JsonSerializable {
  const STCONNECTLOGWhereUniqueInput({this.seq});

  factory STCONNECTLOGWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$STCONNECTLOGWhereUniqueInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int? seq;

  @override
  Map<String, dynamic> toJson() => _$STCONNECTLOGWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STCONNECTLOGOrderByWithAggregationInput implements _i1.JsonSerializable {
  const STCONNECTLOGOrderByWithAggregationInput({
    this.seq,
    this.userId,
    this.connType,
    this.osType,
    this.browserType,
    this.conneIp,
    this.regDate,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory STCONNECTLOGOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONNECTLOGOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'CONN_TYPE')
  final SortOrder? connType;

  @JsonKey(name: r'OS_TYPE')
  final SortOrder? osType;

  @JsonKey(name: r'BROWSER_TYPE')
  final SortOrder? browserType;

  @JsonKey(name: r'CONNE_IP')
  final SortOrder? conneIp;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'_count')
  final STCONNECTLOGCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final STCONNECTLOGAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final STCONNECTLOGMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final STCONNECTLOGMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final STCONNECTLOGSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONNECTLOGOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class STCONNECTLOGScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const STCONNECTLOGScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.userId,
    this.connType,
    this.osType,
    this.browserType,
    this.conneIp,
    this.regDate,
  });

  factory STCONNECTLOGScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONNECTLOGScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<STCONNECTLOGScalarWhereWithAggregatesInput>? AND;

  final Iterable<STCONNECTLOGScalarWhereWithAggregatesInput>? OR;

  final Iterable<STCONNECTLOGScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'SEQ')
  final IntWithAggregatesFilter? seq;

  @JsonKey(name: r'USER_ID')
  final StringWithAggregatesFilter? userId;

  @JsonKey(name: r'CONN_TYPE')
  final StringNullableWithAggregatesFilter? connType;

  @JsonKey(name: r'OS_TYPE')
  final StringNullableWithAggregatesFilter? osType;

  @JsonKey(name: r'BROWSER_TYPE')
  final StringNullableWithAggregatesFilter? browserType;

  @JsonKey(name: r'CONNE_IP')
  final StringNullableWithAggregatesFilter? conneIp;

  @JsonKey(name: r'REG_DATE')
  final StringNullableWithAggregatesFilter? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONNECTLOGScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSFILEWhereInput implements _i1.JsonSerializable {
  const STCONTENTSFILEWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.mseq,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileSize,
  });

  factory STCONTENTSFILEWhereInput.fromJson(Map<String, dynamic> json) =>
      _$STCONTENTSFILEWhereInputFromJson(json);

  final Iterable<STCONTENTSFILEWhereInput>? AND;

  final Iterable<STCONTENTSFILEWhereInput>? OR;

  final Iterable<STCONTENTSFILEWhereInput>? NOT;

  @JsonKey(name: r'SEQ')
  final IntFilter? seq;

  @JsonKey(name: r'MSEQ')
  final StringFilter? mseq;

  @JsonKey(name: r'FILE_TP')
  final StringNullableFilter? fileTp;

  @JsonKey(name: r'FLPTH')
  final StringFilter? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final StringFilter? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final StringFilter? streFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final IntFilter? fileSize;

  @override
  Map<String, dynamic> toJson() => _$STCONTENTSFILEWhereInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSFILEOrderByWithRelationInput implements _i1.JsonSerializable {
  const STCONTENTSFILEOrderByWithRelationInput({
    this.seq,
    this.mseq,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileSize,
  });

  factory STCONTENTSFILEOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONTENTSFILEOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'FILE_TP')
  final SortOrder? fileTp;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final SortOrder? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final SortOrder? streFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final SortOrder? fileSize;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONTENTSFILEOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSFILEWhereUniqueInput implements _i1.JsonSerializable {
  const STCONTENTSFILEWhereUniqueInput({this.seq});

  factory STCONTENTSFILEWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$STCONTENTSFILEWhereUniqueInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int? seq;

  @override
  Map<String, dynamic> toJson() => _$STCONTENTSFILEWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSFILEOrderByWithAggregationInput
    implements _i1.JsonSerializable {
  const STCONTENTSFILEOrderByWithAggregationInput({
    this.seq,
    this.mseq,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileSize,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory STCONTENTSFILEOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONTENTSFILEOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'FILE_TP')
  final SortOrder? fileTp;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final SortOrder? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final SortOrder? streFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final SortOrder? fileSize;

  @JsonKey(name: r'_count')
  final STCONTENTSFILECountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final STCONTENTSFILEAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final STCONTENTSFILEMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final STCONTENTSFILEMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final STCONTENTSFILESumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONTENTSFILEOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSFILEScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const STCONTENTSFILEScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.mseq,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileSize,
  });

  factory STCONTENTSFILEScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONTENTSFILEScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<STCONTENTSFILEScalarWhereWithAggregatesInput>? AND;

  final Iterable<STCONTENTSFILEScalarWhereWithAggregatesInput>? OR;

  final Iterable<STCONTENTSFILEScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'SEQ')
  final IntWithAggregatesFilter? seq;

  @JsonKey(name: r'MSEQ')
  final StringWithAggregatesFilter? mseq;

  @JsonKey(name: r'FILE_TP')
  final StringNullableWithAggregatesFilter? fileTp;

  @JsonKey(name: r'FLPTH')
  final StringWithAggregatesFilter? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final StringWithAggregatesFilter? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final StringWithAggregatesFilter? streFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final IntWithAggregatesFilter? fileSize;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONTENTSFILEScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSMSTWhereInput implements _i1.JsonSerializable {
  const STCONTENTSMSTWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.cntsNm,
    this.pubDate,
    this.pubState,
    this.cn,
    this.srchYn,
    this.fileYn,
    this.imageYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCONTENTSMSTWhereInput.fromJson(Map<String, dynamic> json) =>
      _$STCONTENTSMSTWhereInputFromJson(json);

  final Iterable<STCONTENTSMSTWhereInput>? AND;

  final Iterable<STCONTENTSMSTWhereInput>? OR;

  final Iterable<STCONTENTSMSTWhereInput>? NOT;

  @JsonKey(name: r'SEQ')
  final IntFilter? seq;

  @JsonKey(name: r'CNTS_NM')
  final StringFilter? cntsNm;

  @JsonKey(name: r'PUB_DATE')
  final StringNullableFilter? pubDate;

  @JsonKey(name: r'PUB_STATE')
  final StringNullableFilter? pubState;

  @JsonKey(name: r'CN')
  final StringNullableFilter? cn;

  @JsonKey(name: r'SRCH_YN')
  final StringNullableFilter? srchYn;

  @JsonKey(name: r'FILE_YN')
  final StringNullableFilter? fileYn;

  @JsonKey(name: r'IMAGE_YN')
  final StringNullableFilter? imageYn;

  @JsonKey(name: r'REG_ID')
  final StringFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringNullableFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableFilter? delDate;

  @override
  Map<String, dynamic> toJson() => _$STCONTENTSMSTWhereInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSMSTOrderByWithRelationInput implements _i1.JsonSerializable {
  const STCONTENTSMSTOrderByWithRelationInput({
    this.seq,
    this.cntsNm,
    this.pubDate,
    this.pubState,
    this.cn,
    this.srchYn,
    this.fileYn,
    this.imageYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCONTENTSMSTOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONTENTSMSTOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'CNTS_NM')
  final SortOrder? cntsNm;

  @JsonKey(name: r'PUB_DATE')
  final SortOrder? pubDate;

  @JsonKey(name: r'PUB_STATE')
  final SortOrder? pubState;

  @JsonKey(name: r'CN')
  final SortOrder? cn;

  @JsonKey(name: r'SRCH_YN')
  final SortOrder? srchYn;

  @JsonKey(name: r'FILE_YN')
  final SortOrder? fileYn;

  @JsonKey(name: r'IMAGE_YN')
  final SortOrder? imageYn;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONTENTSMSTOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSMSTWhereUniqueInput implements _i1.JsonSerializable {
  const STCONTENTSMSTWhereUniqueInput({this.seq});

  factory STCONTENTSMSTWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$STCONTENTSMSTWhereUniqueInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int? seq;

  @override
  Map<String, dynamic> toJson() => _$STCONTENTSMSTWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSMSTOrderByWithAggregationInput implements _i1.JsonSerializable {
  const STCONTENTSMSTOrderByWithAggregationInput({
    this.seq,
    this.cntsNm,
    this.pubDate,
    this.pubState,
    this.cn,
    this.srchYn,
    this.fileYn,
    this.imageYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory STCONTENTSMSTOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONTENTSMSTOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'CNTS_NM')
  final SortOrder? cntsNm;

  @JsonKey(name: r'PUB_DATE')
  final SortOrder? pubDate;

  @JsonKey(name: r'PUB_STATE')
  final SortOrder? pubState;

  @JsonKey(name: r'CN')
  final SortOrder? cn;

  @JsonKey(name: r'SRCH_YN')
  final SortOrder? srchYn;

  @JsonKey(name: r'FILE_YN')
  final SortOrder? fileYn;

  @JsonKey(name: r'IMAGE_YN')
  final SortOrder? imageYn;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @JsonKey(name: r'_count')
  final STCONTENTSMSTCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final STCONTENTSMSTAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final STCONTENTSMSTMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final STCONTENTSMSTMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final STCONTENTSMSTSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONTENTSMSTOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSMSTScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const STCONTENTSMSTScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.cntsNm,
    this.pubDate,
    this.pubState,
    this.cn,
    this.srchYn,
    this.fileYn,
    this.imageYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCONTENTSMSTScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONTENTSMSTScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<STCONTENTSMSTScalarWhereWithAggregatesInput>? AND;

  final Iterable<STCONTENTSMSTScalarWhereWithAggregatesInput>? OR;

  final Iterable<STCONTENTSMSTScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'SEQ')
  final IntWithAggregatesFilter? seq;

  @JsonKey(name: r'CNTS_NM')
  final StringWithAggregatesFilter? cntsNm;

  @JsonKey(name: r'PUB_DATE')
  final StringNullableWithAggregatesFilter? pubDate;

  @JsonKey(name: r'PUB_STATE')
  final StringNullableWithAggregatesFilter? pubState;

  @JsonKey(name: r'CN')
  final StringNullableWithAggregatesFilter? cn;

  @JsonKey(name: r'SRCH_YN')
  final StringNullableWithAggregatesFilter? srchYn;

  @JsonKey(name: r'FILE_YN')
  final StringNullableWithAggregatesFilter? fileYn;

  @JsonKey(name: r'IMAGE_YN')
  final StringNullableWithAggregatesFilter? imageYn;

  @JsonKey(name: r'REG_ID')
  final StringWithAggregatesFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringNullableWithAggregatesFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableWithAggregatesFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableWithAggregatesFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableWithAggregatesFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableWithAggregatesFilter? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONTENTSMSTScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class STDEPTWhereInput implements _i1.JsonSerializable {
  const STDEPTWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.deptCd,
    this.deptNm,
    this.upperDeptCd,
    this.upperDeptNm,
    this.sort,
    this.mainYn,
    this.deptDesc,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STDEPTWhereInput.fromJson(Map<String, dynamic> json) =>
      _$STDEPTWhereInputFromJson(json);

  final Iterable<STDEPTWhereInput>? AND;

  final Iterable<STDEPTWhereInput>? OR;

  final Iterable<STDEPTWhereInput>? NOT;

  @JsonKey(name: r'DEPT_CD')
  final StringFilter? deptCd;

  @JsonKey(name: r'DEPT_NM')
  final StringFilter? deptNm;

  @JsonKey(name: r'UPPER_DEPT_CD')
  final StringNullableFilter? upperDeptCd;

  @JsonKey(name: r'UPPER_DEPT_NM')
  final StringNullableFilter? upperDeptNm;

  @JsonKey(name: r'SORT')
  final IntNullableFilter? sort;

  @JsonKey(name: r'MAIN_YN')
  final StringNullableFilter? mainYn;

  @JsonKey(name: r'DEPT_DESC')
  final StringNullableFilter? deptDesc;

  @JsonKey(name: r'REG_ID')
  final StringFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableFilter? delDate;

  @override
  Map<String, dynamic> toJson() => _$STDEPTWhereInputToJson(this);
}

@_i1.jsonSerializable
class STDEPTOrderByWithRelationInput implements _i1.JsonSerializable {
  const STDEPTOrderByWithRelationInput({
    this.deptCd,
    this.deptNm,
    this.upperDeptCd,
    this.upperDeptNm,
    this.sort,
    this.mainYn,
    this.deptDesc,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STDEPTOrderByWithRelationInput.fromJson(Map<String, dynamic> json) =>
      _$STDEPTOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'DEPT_CD')
  final SortOrder? deptCd;

  @JsonKey(name: r'DEPT_NM')
  final SortOrder? deptNm;

  @JsonKey(name: r'UPPER_DEPT_CD')
  final SortOrder? upperDeptCd;

  @JsonKey(name: r'UPPER_DEPT_NM')
  final SortOrder? upperDeptNm;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'MAIN_YN')
  final SortOrder? mainYn;

  @JsonKey(name: r'DEPT_DESC')
  final SortOrder? deptDesc;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() => _$STDEPTOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class STDEPTWhereUniqueInput implements _i1.JsonSerializable {
  const STDEPTWhereUniqueInput({this.deptCd});

  factory STDEPTWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$STDEPTWhereUniqueInputFromJson(json);

  @JsonKey(name: r'DEPT_CD')
  final String? deptCd;

  @override
  Map<String, dynamic> toJson() => _$STDEPTWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STDEPTOrderByWithAggregationInput implements _i1.JsonSerializable {
  const STDEPTOrderByWithAggregationInput({
    this.deptCd,
    this.deptNm,
    this.upperDeptCd,
    this.upperDeptNm,
    this.sort,
    this.mainYn,
    this.deptDesc,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory STDEPTOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STDEPTOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'DEPT_CD')
  final SortOrder? deptCd;

  @JsonKey(name: r'DEPT_NM')
  final SortOrder? deptNm;

  @JsonKey(name: r'UPPER_DEPT_CD')
  final SortOrder? upperDeptCd;

  @JsonKey(name: r'UPPER_DEPT_NM')
  final SortOrder? upperDeptNm;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'MAIN_YN')
  final SortOrder? mainYn;

  @JsonKey(name: r'DEPT_DESC')
  final SortOrder? deptDesc;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @JsonKey(name: r'_count')
  final STDEPTCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final STDEPTAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final STDEPTMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final STDEPTMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final STDEPTSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$STDEPTOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class STDEPTScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const STDEPTScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.deptCd,
    this.deptNm,
    this.upperDeptCd,
    this.upperDeptNm,
    this.sort,
    this.mainYn,
    this.deptDesc,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STDEPTScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$STDEPTScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<STDEPTScalarWhereWithAggregatesInput>? AND;

  final Iterable<STDEPTScalarWhereWithAggregatesInput>? OR;

  final Iterable<STDEPTScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'DEPT_CD')
  final StringWithAggregatesFilter? deptCd;

  @JsonKey(name: r'DEPT_NM')
  final StringWithAggregatesFilter? deptNm;

  @JsonKey(name: r'UPPER_DEPT_CD')
  final StringNullableWithAggregatesFilter? upperDeptCd;

  @JsonKey(name: r'UPPER_DEPT_NM')
  final StringNullableWithAggregatesFilter? upperDeptNm;

  @JsonKey(name: r'SORT')
  final IntNullableWithAggregatesFilter? sort;

  @JsonKey(name: r'MAIN_YN')
  final StringNullableWithAggregatesFilter? mainYn;

  @JsonKey(name: r'DEPT_DESC')
  final StringNullableWithAggregatesFilter? deptDesc;

  @JsonKey(name: r'REG_ID')
  final StringWithAggregatesFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringWithAggregatesFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableWithAggregatesFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableWithAggregatesFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableWithAggregatesFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableWithAggregatesFilter? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STDEPTScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class STDEPTEMPWhereInput implements _i1.JsonSerializable {
  const STDEPTEMPWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.empNo,
    this.empNm,
    this.deptCd,
    this.deptNm,
    this.fctnCd,
    this.fctnNm,
    this.ofcpCd,
    this.ofcpNm,
    this.emailAddr,
    this.offmTelno,
    this.htelTelno,
    this.deptYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STDEPTEMPWhereInput.fromJson(Map<String, dynamic> json) =>
      _$STDEPTEMPWhereInputFromJson(json);

  final Iterable<STDEPTEMPWhereInput>? AND;

  final Iterable<STDEPTEMPWhereInput>? OR;

  final Iterable<STDEPTEMPWhereInput>? NOT;

  @JsonKey(name: r'EMP_NO')
  final StringFilter? empNo;

  @JsonKey(name: r'EMP_NM')
  final StringFilter? empNm;

  @JsonKey(name: r'DEPT_CD')
  final StringNullableFilter? deptCd;

  @JsonKey(name: r'DEPT_NM')
  final StringNullableFilter? deptNm;

  @JsonKey(name: r'FCTN_CD')
  final StringNullableFilter? fctnCd;

  @JsonKey(name: r'FCTN_NM')
  final StringNullableFilter? fctnNm;

  @JsonKey(name: r'OFCP_CD')
  final StringNullableFilter? ofcpCd;

  @JsonKey(name: r'OFCP_NM')
  final StringNullableFilter? ofcpNm;

  @JsonKey(name: r'EMAIL_ADDR')
  final StringNullableFilter? emailAddr;

  @JsonKey(name: r'OFFM_TELNO')
  final StringNullableFilter? offmTelno;

  @JsonKey(name: r'HTEL_TELNO')
  final StringNullableFilter? htelTelno;

  @JsonKey(name: r'DEPT_YN')
  final StringNullableFilter? deptYn;

  @JsonKey(name: r'REG_ID')
  final StringFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableFilter? delDate;

  @override
  Map<String, dynamic> toJson() => _$STDEPTEMPWhereInputToJson(this);
}

@_i1.jsonSerializable
class STDEPTEMPOrderByWithRelationInput implements _i1.JsonSerializable {
  const STDEPTEMPOrderByWithRelationInput({
    this.empNo,
    this.empNm,
    this.deptCd,
    this.deptNm,
    this.fctnCd,
    this.fctnNm,
    this.ofcpCd,
    this.ofcpNm,
    this.emailAddr,
    this.offmTelno,
    this.htelTelno,
    this.deptYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STDEPTEMPOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STDEPTEMPOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'EMP_NO')
  final SortOrder? empNo;

  @JsonKey(name: r'EMP_NM')
  final SortOrder? empNm;

  @JsonKey(name: r'DEPT_CD')
  final SortOrder? deptCd;

  @JsonKey(name: r'DEPT_NM')
  final SortOrder? deptNm;

  @JsonKey(name: r'FCTN_CD')
  final SortOrder? fctnCd;

  @JsonKey(name: r'FCTN_NM')
  final SortOrder? fctnNm;

  @JsonKey(name: r'OFCP_CD')
  final SortOrder? ofcpCd;

  @JsonKey(name: r'OFCP_NM')
  final SortOrder? ofcpNm;

  @JsonKey(name: r'EMAIL_ADDR')
  final SortOrder? emailAddr;

  @JsonKey(name: r'OFFM_TELNO')
  final SortOrder? offmTelno;

  @JsonKey(name: r'HTEL_TELNO')
  final SortOrder? htelTelno;

  @JsonKey(name: r'DEPT_YN')
  final SortOrder? deptYn;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STDEPTEMPOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class STDEPTEMPWhereUniqueInput implements _i1.JsonSerializable {
  const STDEPTEMPWhereUniqueInput({this.empNo});

  factory STDEPTEMPWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$STDEPTEMPWhereUniqueInputFromJson(json);

  @JsonKey(name: r'EMP_NO')
  final String? empNo;

  @override
  Map<String, dynamic> toJson() => _$STDEPTEMPWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STDEPTEMPOrderByWithAggregationInput implements _i1.JsonSerializable {
  const STDEPTEMPOrderByWithAggregationInput({
    this.empNo,
    this.empNm,
    this.deptCd,
    this.deptNm,
    this.fctnCd,
    this.fctnNm,
    this.ofcpCd,
    this.ofcpNm,
    this.emailAddr,
    this.offmTelno,
    this.htelTelno,
    this.deptYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
    this.$count,
    this.$max,
    this.$min,
  });

  factory STDEPTEMPOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STDEPTEMPOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'EMP_NO')
  final SortOrder? empNo;

  @JsonKey(name: r'EMP_NM')
  final SortOrder? empNm;

  @JsonKey(name: r'DEPT_CD')
  final SortOrder? deptCd;

  @JsonKey(name: r'DEPT_NM')
  final SortOrder? deptNm;

  @JsonKey(name: r'FCTN_CD')
  final SortOrder? fctnCd;

  @JsonKey(name: r'FCTN_NM')
  final SortOrder? fctnNm;

  @JsonKey(name: r'OFCP_CD')
  final SortOrder? ofcpCd;

  @JsonKey(name: r'OFCP_NM')
  final SortOrder? ofcpNm;

  @JsonKey(name: r'EMAIL_ADDR')
  final SortOrder? emailAddr;

  @JsonKey(name: r'OFFM_TELNO')
  final SortOrder? offmTelno;

  @JsonKey(name: r'HTEL_TELNO')
  final SortOrder? htelTelno;

  @JsonKey(name: r'DEPT_YN')
  final SortOrder? deptYn;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @JsonKey(name: r'_count')
  final STDEPTEMPCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_max')
  final STDEPTEMPMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final STDEPTEMPMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() =>
      _$STDEPTEMPOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class STDEPTEMPScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const STDEPTEMPScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.empNo,
    this.empNm,
    this.deptCd,
    this.deptNm,
    this.fctnCd,
    this.fctnNm,
    this.ofcpCd,
    this.ofcpNm,
    this.emailAddr,
    this.offmTelno,
    this.htelTelno,
    this.deptYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STDEPTEMPScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$STDEPTEMPScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<STDEPTEMPScalarWhereWithAggregatesInput>? AND;

  final Iterable<STDEPTEMPScalarWhereWithAggregatesInput>? OR;

  final Iterable<STDEPTEMPScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'EMP_NO')
  final StringWithAggregatesFilter? empNo;

  @JsonKey(name: r'EMP_NM')
  final StringWithAggregatesFilter? empNm;

  @JsonKey(name: r'DEPT_CD')
  final StringNullableWithAggregatesFilter? deptCd;

  @JsonKey(name: r'DEPT_NM')
  final StringNullableWithAggregatesFilter? deptNm;

  @JsonKey(name: r'FCTN_CD')
  final StringNullableWithAggregatesFilter? fctnCd;

  @JsonKey(name: r'FCTN_NM')
  final StringNullableWithAggregatesFilter? fctnNm;

  @JsonKey(name: r'OFCP_CD')
  final StringNullableWithAggregatesFilter? ofcpCd;

  @JsonKey(name: r'OFCP_NM')
  final StringNullableWithAggregatesFilter? ofcpNm;

  @JsonKey(name: r'EMAIL_ADDR')
  final StringNullableWithAggregatesFilter? emailAddr;

  @JsonKey(name: r'OFFM_TELNO')
  final StringNullableWithAggregatesFilter? offmTelno;

  @JsonKey(name: r'HTEL_TELNO')
  final StringNullableWithAggregatesFilter? htelTelno;

  @JsonKey(name: r'DEPT_YN')
  final StringNullableWithAggregatesFilter? deptYn;

  @JsonKey(name: r'REG_ID')
  final StringWithAggregatesFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringWithAggregatesFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableWithAggregatesFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableWithAggregatesFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableWithAggregatesFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableWithAggregatesFilter? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STDEPTEMPScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class STMENUWhereInput implements _i1.JsonSerializable {
  const STMENUWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.menuCd,
    this.menuNm,
    this.menuPath,
    this.menuMapping,
    this.menuSrt,
    this.menuDeps,
    this.menuIcon,
    this.menuTp,
    this.mainExpsrYn,
    this.subExpsrYn,
    this.upendClas,
    this.upendCn,
    this.cclType,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMENUWhereInput.fromJson(Map<String, dynamic> json) =>
      _$STMENUWhereInputFromJson(json);

  final Iterable<STMENUWhereInput>? AND;

  final Iterable<STMENUWhereInput>? OR;

  final Iterable<STMENUWhereInput>? NOT;

  @JsonKey(name: r'MENU_CD')
  final StringFilter? menuCd;

  @JsonKey(name: r'MENU_NM')
  final StringFilter? menuNm;

  @JsonKey(name: r'MENU_PATH')
  final StringNullableFilter? menuPath;

  @JsonKey(name: r'MENU_MAPPING')
  final StringNullableFilter? menuMapping;

  @JsonKey(name: r'MENU_SRT')
  final IntFilter? menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final IntFilter? menuDeps;

  @JsonKey(name: r'MENU_ICON')
  final StringNullableFilter? menuIcon;

  @JsonKey(name: r'MENU_TP')
  final StringFilter? menuTp;

  @JsonKey(name: r'MAIN_EXPSR_YN')
  final StringNullableFilter? mainExpsrYn;

  @JsonKey(name: r'SUB_EXPSR_YN')
  final StringNullableFilter? subExpsrYn;

  @JsonKey(name: r'UPEND_CLAS')
  final StringNullableFilter? upendClas;

  @JsonKey(name: r'UPEND_CN')
  final StringNullableFilter? upendCn;

  @JsonKey(name: r'CCL_TYPE')
  final StringNullableFilter? cclType;

  @JsonKey(name: r'REG_ID')
  final StringFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringNullableFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableFilter? delDate;

  @override
  Map<String, dynamic> toJson() => _$STMENUWhereInputToJson(this);
}

@_i1.jsonSerializable
class STMENUOrderByWithRelationInput implements _i1.JsonSerializable {
  const STMENUOrderByWithRelationInput({
    this.menuCd,
    this.menuNm,
    this.menuPath,
    this.menuMapping,
    this.menuSrt,
    this.menuDeps,
    this.menuIcon,
    this.menuTp,
    this.mainExpsrYn,
    this.subExpsrYn,
    this.upendClas,
    this.upendCn,
    this.cclType,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMENUOrderByWithRelationInput.fromJson(Map<String, dynamic> json) =>
      _$STMENUOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'MENU_CD')
  final SortOrder? menuCd;

  @JsonKey(name: r'MENU_NM')
  final SortOrder? menuNm;

  @JsonKey(name: r'MENU_PATH')
  final SortOrder? menuPath;

  @JsonKey(name: r'MENU_MAPPING')
  final SortOrder? menuMapping;

  @JsonKey(name: r'MENU_SRT')
  final SortOrder? menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final SortOrder? menuDeps;

  @JsonKey(name: r'MENU_ICON')
  final SortOrder? menuIcon;

  @JsonKey(name: r'MENU_TP')
  final SortOrder? menuTp;

  @JsonKey(name: r'MAIN_EXPSR_YN')
  final SortOrder? mainExpsrYn;

  @JsonKey(name: r'SUB_EXPSR_YN')
  final SortOrder? subExpsrYn;

  @JsonKey(name: r'UPEND_CLAS')
  final SortOrder? upendClas;

  @JsonKey(name: r'UPEND_CN')
  final SortOrder? upendCn;

  @JsonKey(name: r'CCL_TYPE')
  final SortOrder? cclType;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() => _$STMENUOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class STMENUWhereUniqueInput implements _i1.JsonSerializable {
  const STMENUWhereUniqueInput({this.menuCd});

  factory STMENUWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$STMENUWhereUniqueInputFromJson(json);

  @JsonKey(name: r'MENU_CD')
  final String? menuCd;

  @override
  Map<String, dynamic> toJson() => _$STMENUWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STMENUOrderByWithAggregationInput implements _i1.JsonSerializable {
  const STMENUOrderByWithAggregationInput({
    this.menuCd,
    this.menuNm,
    this.menuPath,
    this.menuMapping,
    this.menuSrt,
    this.menuDeps,
    this.menuIcon,
    this.menuTp,
    this.mainExpsrYn,
    this.subExpsrYn,
    this.upendClas,
    this.upendCn,
    this.cclType,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory STMENUOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMENUOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'MENU_CD')
  final SortOrder? menuCd;

  @JsonKey(name: r'MENU_NM')
  final SortOrder? menuNm;

  @JsonKey(name: r'MENU_PATH')
  final SortOrder? menuPath;

  @JsonKey(name: r'MENU_MAPPING')
  final SortOrder? menuMapping;

  @JsonKey(name: r'MENU_SRT')
  final SortOrder? menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final SortOrder? menuDeps;

  @JsonKey(name: r'MENU_ICON')
  final SortOrder? menuIcon;

  @JsonKey(name: r'MENU_TP')
  final SortOrder? menuTp;

  @JsonKey(name: r'MAIN_EXPSR_YN')
  final SortOrder? mainExpsrYn;

  @JsonKey(name: r'SUB_EXPSR_YN')
  final SortOrder? subExpsrYn;

  @JsonKey(name: r'UPEND_CLAS')
  final SortOrder? upendClas;

  @JsonKey(name: r'UPEND_CN')
  final SortOrder? upendCn;

  @JsonKey(name: r'CCL_TYPE')
  final SortOrder? cclType;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @JsonKey(name: r'_count')
  final STMENUCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final STMENUAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final STMENUMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final STMENUMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final STMENUSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$STMENUOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class STMENUScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const STMENUScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.menuCd,
    this.menuNm,
    this.menuPath,
    this.menuMapping,
    this.menuSrt,
    this.menuDeps,
    this.menuIcon,
    this.menuTp,
    this.mainExpsrYn,
    this.subExpsrYn,
    this.upendClas,
    this.upendCn,
    this.cclType,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMENUScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMENUScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<STMENUScalarWhereWithAggregatesInput>? AND;

  final Iterable<STMENUScalarWhereWithAggregatesInput>? OR;

  final Iterable<STMENUScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'MENU_CD')
  final StringWithAggregatesFilter? menuCd;

  @JsonKey(name: r'MENU_NM')
  final StringWithAggregatesFilter? menuNm;

  @JsonKey(name: r'MENU_PATH')
  final StringNullableWithAggregatesFilter? menuPath;

  @JsonKey(name: r'MENU_MAPPING')
  final StringNullableWithAggregatesFilter? menuMapping;

  @JsonKey(name: r'MENU_SRT')
  final IntWithAggregatesFilter? menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final IntWithAggregatesFilter? menuDeps;

  @JsonKey(name: r'MENU_ICON')
  final StringNullableWithAggregatesFilter? menuIcon;

  @JsonKey(name: r'MENU_TP')
  final StringWithAggregatesFilter? menuTp;

  @JsonKey(name: r'MAIN_EXPSR_YN')
  final StringNullableWithAggregatesFilter? mainExpsrYn;

  @JsonKey(name: r'SUB_EXPSR_YN')
  final StringNullableWithAggregatesFilter? subExpsrYn;

  @JsonKey(name: r'UPEND_CLAS')
  final StringNullableWithAggregatesFilter? upendClas;

  @JsonKey(name: r'UPEND_CN')
  final StringNullableWithAggregatesFilter? upendCn;

  @JsonKey(name: r'CCL_TYPE')
  final StringNullableWithAggregatesFilter? cclType;

  @JsonKey(name: r'REG_ID')
  final StringWithAggregatesFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringNullableWithAggregatesFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableWithAggregatesFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableWithAggregatesFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableWithAggregatesFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableWithAggregatesFilter? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STMENUScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class STMESSAGETMPLATWhereInput implements _i1.JsonSerializable {
  const STMESSAGETMPLATWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.msgDivCd,
    this.msgCd,
    this.msgNm,
    this.msgTmplat,
    this.useYn,
    this.editId,
    this.editDate,
  });

  factory STMESSAGETMPLATWhereInput.fromJson(Map<String, dynamic> json) =>
      _$STMESSAGETMPLATWhereInputFromJson(json);

  final Iterable<STMESSAGETMPLATWhereInput>? AND;

  final Iterable<STMESSAGETMPLATWhereInput>? OR;

  final Iterable<STMESSAGETMPLATWhereInput>? NOT;

  @JsonKey(name: r'MSG_DIV_CD')
  final StringFilter? msgDivCd;

  @JsonKey(name: r'MSG_CD')
  final StringFilter? msgCd;

  @JsonKey(name: r'MSG_NM')
  final StringNullableFilter? msgNm;

  @JsonKey(name: r'MSG_TMPLAT')
  final StringNullableFilter? msgTmplat;

  @JsonKey(name: r'USE_YN')
  final StringNullableFilter? useYn;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableFilter? editDate;

  @override
  Map<String, dynamic> toJson() => _$STMESSAGETMPLATWhereInputToJson(this);
}

@_i1.jsonSerializable
class STMESSAGETMPLATOrderByWithRelationInput implements _i1.JsonSerializable {
  const STMESSAGETMPLATOrderByWithRelationInput({
    this.msgDivCd,
    this.msgCd,
    this.msgNm,
    this.msgTmplat,
    this.useYn,
    this.editId,
    this.editDate,
  });

  factory STMESSAGETMPLATOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMESSAGETMPLATOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'MSG_DIV_CD')
  final SortOrder? msgDivCd;

  @JsonKey(name: r'MSG_CD')
  final SortOrder? msgCd;

  @JsonKey(name: r'MSG_NM')
  final SortOrder? msgNm;

  @JsonKey(name: r'MSG_TMPLAT')
  final SortOrder? msgTmplat;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STMESSAGETMPLATOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class STMESSAGETMPLATWhereUniqueInput implements _i1.JsonSerializable {
  const STMESSAGETMPLATWhereUniqueInput({this.msgDivCdMsgCd});

  factory STMESSAGETMPLATWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$STMESSAGETMPLATWhereUniqueInputFromJson(json);

  @JsonKey(name: r'MSG_DIV_CD_MSG_CD')
  final STMESSAGETMPLATMSGDIVCDMSGCDCompoundUniqueInput? msgDivCdMsgCd;

  @override
  Map<String, dynamic> toJson() =>
      _$STMESSAGETMPLATWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STMESSAGETMPLATOrderByWithAggregationInput
    implements _i1.JsonSerializable {
  const STMESSAGETMPLATOrderByWithAggregationInput({
    this.msgDivCd,
    this.msgCd,
    this.msgNm,
    this.msgTmplat,
    this.useYn,
    this.editId,
    this.editDate,
    this.$count,
    this.$max,
    this.$min,
  });

  factory STMESSAGETMPLATOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMESSAGETMPLATOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'MSG_DIV_CD')
  final SortOrder? msgDivCd;

  @JsonKey(name: r'MSG_CD')
  final SortOrder? msgCd;

  @JsonKey(name: r'MSG_NM')
  final SortOrder? msgNm;

  @JsonKey(name: r'MSG_TMPLAT')
  final SortOrder? msgTmplat;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'_count')
  final STMESSAGETMPLATCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_max')
  final STMESSAGETMPLATMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final STMESSAGETMPLATMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() =>
      _$STMESSAGETMPLATOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class STMESSAGETMPLATScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const STMESSAGETMPLATScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.msgDivCd,
    this.msgCd,
    this.msgNm,
    this.msgTmplat,
    this.useYn,
    this.editId,
    this.editDate,
  });

  factory STMESSAGETMPLATScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMESSAGETMPLATScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<STMESSAGETMPLATScalarWhereWithAggregatesInput>? AND;

  final Iterable<STMESSAGETMPLATScalarWhereWithAggregatesInput>? OR;

  final Iterable<STMESSAGETMPLATScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'MSG_DIV_CD')
  final StringWithAggregatesFilter? msgDivCd;

  @JsonKey(name: r'MSG_CD')
  final StringWithAggregatesFilter? msgCd;

  @JsonKey(name: r'MSG_NM')
  final StringNullableWithAggregatesFilter? msgNm;

  @JsonKey(name: r'MSG_TMPLAT')
  final StringNullableWithAggregatesFilter? msgTmplat;

  @JsonKey(name: r'USE_YN')
  final StringNullableWithAggregatesFilter? useYn;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableWithAggregatesFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableWithAggregatesFilter? editDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STMESSAGETMPLATScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class STMIMETYPEWhereInput implements _i1.JsonSerializable {
  const STMIMETYPEWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.extnNm,
    this.fileMt,
  });

  factory STMIMETYPEWhereInput.fromJson(Map<String, dynamic> json) =>
      _$STMIMETYPEWhereInputFromJson(json);

  final Iterable<STMIMETYPEWhereInput>? AND;

  final Iterable<STMIMETYPEWhereInput>? OR;

  final Iterable<STMIMETYPEWhereInput>? NOT;

  @JsonKey(name: r'SEQ')
  final IntFilter? seq;

  @JsonKey(name: r'EXTN_NM')
  final StringFilter? extnNm;

  @JsonKey(name: r'FILE_MT')
  final StringFilter? fileMt;

  @override
  Map<String, dynamic> toJson() => _$STMIMETYPEWhereInputToJson(this);
}

@_i1.jsonSerializable
class STMIMETYPEOrderByWithRelationInput implements _i1.JsonSerializable {
  const STMIMETYPEOrderByWithRelationInput({
    this.seq,
    this.extnNm,
    this.fileMt,
  });

  factory STMIMETYPEOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMIMETYPEOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'EXTN_NM')
  final SortOrder? extnNm;

  @JsonKey(name: r'FILE_MT')
  final SortOrder? fileMt;

  @override
  Map<String, dynamic> toJson() =>
      _$STMIMETYPEOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class STMIMETYPEWhereUniqueInput implements _i1.JsonSerializable {
  const STMIMETYPEWhereUniqueInput({this.seq});

  factory STMIMETYPEWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$STMIMETYPEWhereUniqueInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int? seq;

  @override
  Map<String, dynamic> toJson() => _$STMIMETYPEWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STMIMETYPEOrderByWithAggregationInput implements _i1.JsonSerializable {
  const STMIMETYPEOrderByWithAggregationInput({
    this.seq,
    this.extnNm,
    this.fileMt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory STMIMETYPEOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMIMETYPEOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'EXTN_NM')
  final SortOrder? extnNm;

  @JsonKey(name: r'FILE_MT')
  final SortOrder? fileMt;

  @JsonKey(name: r'_count')
  final STMIMETYPECountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final STMIMETYPEAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final STMIMETYPEMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final STMIMETYPEMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final STMIMETYPESumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$STMIMETYPEOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class STMIMETYPEScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const STMIMETYPEScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.extnNm,
    this.fileMt,
  });

  factory STMIMETYPEScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMIMETYPEScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<STMIMETYPEScalarWhereWithAggregatesInput>? AND;

  final Iterable<STMIMETYPEScalarWhereWithAggregatesInput>? OR;

  final Iterable<STMIMETYPEScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'SEQ')
  final IntWithAggregatesFilter? seq;

  @JsonKey(name: r'EXTN_NM')
  final StringWithAggregatesFilter? extnNm;

  @JsonKey(name: r'FILE_MT')
  final StringWithAggregatesFilter? fileMt;

  @override
  Map<String, dynamic> toJson() =>
      _$STMIMETYPEScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRGRPWhereInput implements _i1.JsonSerializable {
  const STMNGRGRPWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.grpCd,
    this.grpNm,
    this.grpDesc,
    this.sort,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMNGRGRPWhereInput.fromJson(Map<String, dynamic> json) =>
      _$STMNGRGRPWhereInputFromJson(json);

  final Iterable<STMNGRGRPWhereInput>? AND;

  final Iterable<STMNGRGRPWhereInput>? OR;

  final Iterable<STMNGRGRPWhereInput>? NOT;

  @JsonKey(name: r'GRP_CD')
  final StringFilter? grpCd;

  @JsonKey(name: r'GRP_NM')
  final StringNullableFilter? grpNm;

  @JsonKey(name: r'GRP_DESC')
  final StringNullableFilter? grpDesc;

  @JsonKey(name: r'SORT')
  final IntNullableFilter? sort;

  @JsonKey(name: r'REG_ID')
  final StringFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableFilter? delDate;

  @override
  Map<String, dynamic> toJson() => _$STMNGRGRPWhereInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRGRPOrderByWithRelationInput implements _i1.JsonSerializable {
  const STMNGRGRPOrderByWithRelationInput({
    this.grpCd,
    this.grpNm,
    this.grpDesc,
    this.sort,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMNGRGRPOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMNGRGRPOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'GRP_CD')
  final SortOrder? grpCd;

  @JsonKey(name: r'GRP_NM')
  final SortOrder? grpNm;

  @JsonKey(name: r'GRP_DESC')
  final SortOrder? grpDesc;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STMNGRGRPOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRGRPWhereUniqueInput implements _i1.JsonSerializable {
  const STMNGRGRPWhereUniqueInput({this.grpCd});

  factory STMNGRGRPWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$STMNGRGRPWhereUniqueInputFromJson(json);

  @JsonKey(name: r'GRP_CD')
  final String? grpCd;

  @override
  Map<String, dynamic> toJson() => _$STMNGRGRPWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRGRPOrderByWithAggregationInput implements _i1.JsonSerializable {
  const STMNGRGRPOrderByWithAggregationInput({
    this.grpCd,
    this.grpNm,
    this.grpDesc,
    this.sort,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory STMNGRGRPOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMNGRGRPOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'GRP_CD')
  final SortOrder? grpCd;

  @JsonKey(name: r'GRP_NM')
  final SortOrder? grpNm;

  @JsonKey(name: r'GRP_DESC')
  final SortOrder? grpDesc;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @JsonKey(name: r'_count')
  final STMNGRGRPCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final STMNGRGRPAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final STMNGRGRPMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final STMNGRGRPMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final STMNGRGRPSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$STMNGRGRPOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRGRPScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const STMNGRGRPScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.grpCd,
    this.grpNm,
    this.grpDesc,
    this.sort,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMNGRGRPScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMNGRGRPScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<STMNGRGRPScalarWhereWithAggregatesInput>? AND;

  final Iterable<STMNGRGRPScalarWhereWithAggregatesInput>? OR;

  final Iterable<STMNGRGRPScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'GRP_CD')
  final StringWithAggregatesFilter? grpCd;

  @JsonKey(name: r'GRP_NM')
  final StringNullableWithAggregatesFilter? grpNm;

  @JsonKey(name: r'GRP_DESC')
  final StringNullableWithAggregatesFilter? grpDesc;

  @JsonKey(name: r'SORT')
  final IntNullableWithAggregatesFilter? sort;

  @JsonKey(name: r'REG_ID')
  final StringWithAggregatesFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringWithAggregatesFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableWithAggregatesFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableWithAggregatesFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableWithAggregatesFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableWithAggregatesFilter? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STMNGRGRPScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRMSTWhereInput implements _i1.JsonSerializable {
  const STMNGRMSTWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.mngrId,
    this.mngrNm,
    this.mngrPw,
    this.grpCd,
    this.grade,
    this.permCd,
    this.acsYn,
    this.clph,
    this.empNo,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.pwdWrongDate,
    this.lstLoginDate,
    this.flpth,
    this.fileNm,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMNGRMSTWhereInput.fromJson(Map<String, dynamic> json) =>
      _$STMNGRMSTWhereInputFromJson(json);

  final Iterable<STMNGRMSTWhereInput>? AND;

  final Iterable<STMNGRMSTWhereInput>? OR;

  final Iterable<STMNGRMSTWhereInput>? NOT;

  @JsonKey(name: r'MNGR_ID')
  final StringFilter? mngrId;

  @JsonKey(name: r'MNGR_NM')
  final StringFilter? mngrNm;

  @JsonKey(name: r'MNGR_PW')
  final StringNullableFilter? mngrPw;

  @JsonKey(name: r'GRP_CD')
  final StringNullableFilter? grpCd;

  @JsonKey(name: r'GRADE')
  final StringNullableFilter? grade;

  @JsonKey(name: r'PERM_CD')
  final StringFilter? permCd;

  @JsonKey(name: r'ACS_YN')
  final StringNullableFilter? acsYn;

  @JsonKey(name: r'CLPH')
  final StringNullableFilter? clph;

  @JsonKey(name: r'EMP_NO')
  final StringNullableFilter? empNo;

  @JsonKey(name: r'JOIN_DATE')
  final StringFilter? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final DateTimeFilter? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final DateTimeFilter? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final IntNullableFilter? pwdWrongCnt;

  @JsonKey(name: r'PWD_WRONG_DATE')
  final StringNullableFilter? pwdWrongDate;

  @JsonKey(name: r'LST_LOGIN_DATE')
  final StringNullableFilter? lstLoginDate;

  @JsonKey(name: r'FLPTH')
  final StringNullableFilter? flpth;

  @JsonKey(name: r'FILE_NM')
  final StringNullableFilter? fileNm;

  @JsonKey(name: r'REG_ID')
  final StringFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableFilter? delDate;

  @override
  Map<String, dynamic> toJson() => _$STMNGRMSTWhereInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRMSTOrderByWithRelationInput implements _i1.JsonSerializable {
  const STMNGRMSTOrderByWithRelationInput({
    this.mngrId,
    this.mngrNm,
    this.mngrPw,
    this.grpCd,
    this.grade,
    this.permCd,
    this.acsYn,
    this.clph,
    this.empNo,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.pwdWrongDate,
    this.lstLoginDate,
    this.flpth,
    this.fileNm,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMNGRMSTOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMNGRMSTOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'MNGR_ID')
  final SortOrder? mngrId;

  @JsonKey(name: r'MNGR_NM')
  final SortOrder? mngrNm;

  @JsonKey(name: r'MNGR_PW')
  final SortOrder? mngrPw;

  @JsonKey(name: r'GRP_CD')
  final SortOrder? grpCd;

  @JsonKey(name: r'GRADE')
  final SortOrder? grade;

  @JsonKey(name: r'PERM_CD')
  final SortOrder? permCd;

  @JsonKey(name: r'ACS_YN')
  final SortOrder? acsYn;

  @JsonKey(name: r'CLPH')
  final SortOrder? clph;

  @JsonKey(name: r'EMP_NO')
  final SortOrder? empNo;

  @JsonKey(name: r'JOIN_DATE')
  final SortOrder? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final SortOrder? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final SortOrder? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final SortOrder? pwdWrongCnt;

  @JsonKey(name: r'PWD_WRONG_DATE')
  final SortOrder? pwdWrongDate;

  @JsonKey(name: r'LST_LOGIN_DATE')
  final SortOrder? lstLoginDate;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'FILE_NM')
  final SortOrder? fileNm;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STMNGRMSTOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRMSTWhereUniqueInput implements _i1.JsonSerializable {
  const STMNGRMSTWhereUniqueInput({this.mngrId});

  factory STMNGRMSTWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$STMNGRMSTWhereUniqueInputFromJson(json);

  @JsonKey(name: r'MNGR_ID')
  final String? mngrId;

  @override
  Map<String, dynamic> toJson() => _$STMNGRMSTWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRMSTOrderByWithAggregationInput implements _i1.JsonSerializable {
  const STMNGRMSTOrderByWithAggregationInput({
    this.mngrId,
    this.mngrNm,
    this.mngrPw,
    this.grpCd,
    this.grade,
    this.permCd,
    this.acsYn,
    this.clph,
    this.empNo,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.pwdWrongDate,
    this.lstLoginDate,
    this.flpth,
    this.fileNm,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory STMNGRMSTOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMNGRMSTOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'MNGR_ID')
  final SortOrder? mngrId;

  @JsonKey(name: r'MNGR_NM')
  final SortOrder? mngrNm;

  @JsonKey(name: r'MNGR_PW')
  final SortOrder? mngrPw;

  @JsonKey(name: r'GRP_CD')
  final SortOrder? grpCd;

  @JsonKey(name: r'GRADE')
  final SortOrder? grade;

  @JsonKey(name: r'PERM_CD')
  final SortOrder? permCd;

  @JsonKey(name: r'ACS_YN')
  final SortOrder? acsYn;

  @JsonKey(name: r'CLPH')
  final SortOrder? clph;

  @JsonKey(name: r'EMP_NO')
  final SortOrder? empNo;

  @JsonKey(name: r'JOIN_DATE')
  final SortOrder? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final SortOrder? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final SortOrder? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final SortOrder? pwdWrongCnt;

  @JsonKey(name: r'PWD_WRONG_DATE')
  final SortOrder? pwdWrongDate;

  @JsonKey(name: r'LST_LOGIN_DATE')
  final SortOrder? lstLoginDate;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'FILE_NM')
  final SortOrder? fileNm;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @JsonKey(name: r'_count')
  final STMNGRMSTCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final STMNGRMSTAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final STMNGRMSTMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final STMNGRMSTMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final STMNGRMSTSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$STMNGRMSTOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRMSTScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const STMNGRMSTScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.mngrId,
    this.mngrNm,
    this.mngrPw,
    this.grpCd,
    this.grade,
    this.permCd,
    this.acsYn,
    this.clph,
    this.empNo,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.pwdWrongDate,
    this.lstLoginDate,
    this.flpth,
    this.fileNm,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMNGRMSTScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMNGRMSTScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<STMNGRMSTScalarWhereWithAggregatesInput>? AND;

  final Iterable<STMNGRMSTScalarWhereWithAggregatesInput>? OR;

  final Iterable<STMNGRMSTScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'MNGR_ID')
  final StringWithAggregatesFilter? mngrId;

  @JsonKey(name: r'MNGR_NM')
  final StringWithAggregatesFilter? mngrNm;

  @JsonKey(name: r'MNGR_PW')
  final StringNullableWithAggregatesFilter? mngrPw;

  @JsonKey(name: r'GRP_CD')
  final StringNullableWithAggregatesFilter? grpCd;

  @JsonKey(name: r'GRADE')
  final StringNullableWithAggregatesFilter? grade;

  @JsonKey(name: r'PERM_CD')
  final StringWithAggregatesFilter? permCd;

  @JsonKey(name: r'ACS_YN')
  final StringNullableWithAggregatesFilter? acsYn;

  @JsonKey(name: r'CLPH')
  final StringNullableWithAggregatesFilter? clph;

  @JsonKey(name: r'EMP_NO')
  final StringNullableWithAggregatesFilter? empNo;

  @JsonKey(name: r'JOIN_DATE')
  final StringWithAggregatesFilter? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final DateTimeWithAggregatesFilter? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final DateTimeWithAggregatesFilter? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final IntNullableWithAggregatesFilter? pwdWrongCnt;

  @JsonKey(name: r'PWD_WRONG_DATE')
  final StringNullableWithAggregatesFilter? pwdWrongDate;

  @JsonKey(name: r'LST_LOGIN_DATE')
  final StringNullableWithAggregatesFilter? lstLoginDate;

  @JsonKey(name: r'FLPTH')
  final StringNullableWithAggregatesFilter? flpth;

  @JsonKey(name: r'FILE_NM')
  final StringNullableWithAggregatesFilter? fileNm;

  @JsonKey(name: r'REG_ID')
  final StringWithAggregatesFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringWithAggregatesFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableWithAggregatesFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableWithAggregatesFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableWithAggregatesFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableWithAggregatesFilter? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STMNGRMSTScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class STMYSTNGWhereInput implements _i1.JsonSerializable {
  const STMYSTNGWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.userId,
    this.stngCd,
    this.userDiv,
    this.stngData,
  });

  factory STMYSTNGWhereInput.fromJson(Map<String, dynamic> json) =>
      _$STMYSTNGWhereInputFromJson(json);

  final Iterable<STMYSTNGWhereInput>? AND;

  final Iterable<STMYSTNGWhereInput>? OR;

  final Iterable<STMYSTNGWhereInput>? NOT;

  @JsonKey(name: r'USER_ID')
  final StringFilter? userId;

  @JsonKey(name: r'STNG_CD')
  final StringFilter? stngCd;

  @JsonKey(name: r'USER_DIV')
  final StringFilter? userDiv;

  @JsonKey(name: r'STNG_DATA')
  final StringNullableFilter? stngData;

  @override
  Map<String, dynamic> toJson() => _$STMYSTNGWhereInputToJson(this);
}

@_i1.jsonSerializable
class STMYSTNGOrderByWithRelationInput implements _i1.JsonSerializable {
  const STMYSTNGOrderByWithRelationInput({
    this.userId,
    this.stngCd,
    this.userDiv,
    this.stngData,
  });

  factory STMYSTNGOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMYSTNGOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'STNG_CD')
  final SortOrder? stngCd;

  @JsonKey(name: r'USER_DIV')
  final SortOrder? userDiv;

  @JsonKey(name: r'STNG_DATA')
  final SortOrder? stngData;

  @override
  Map<String, dynamic> toJson() =>
      _$STMYSTNGOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class STMYSTNGWhereUniqueInput implements _i1.JsonSerializable {
  const STMYSTNGWhereUniqueInput({this.userIdStngCdUserDiv});

  factory STMYSTNGWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$STMYSTNGWhereUniqueInputFromJson(json);

  @JsonKey(name: r'USER_ID_STNG_CD_USER_DIV')
  final STMYSTNGUSERIDSTNGCDUSERDIVCompoundUniqueInput? userIdStngCdUserDiv;

  @override
  Map<String, dynamic> toJson() => _$STMYSTNGWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STMYSTNGOrderByWithAggregationInput implements _i1.JsonSerializable {
  const STMYSTNGOrderByWithAggregationInput({
    this.userId,
    this.stngCd,
    this.userDiv,
    this.stngData,
    this.$count,
    this.$max,
    this.$min,
  });

  factory STMYSTNGOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMYSTNGOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'STNG_CD')
  final SortOrder? stngCd;

  @JsonKey(name: r'USER_DIV')
  final SortOrder? userDiv;

  @JsonKey(name: r'STNG_DATA')
  final SortOrder? stngData;

  @JsonKey(name: r'_count')
  final STMYSTNGCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_max')
  final STMYSTNGMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final STMYSTNGMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() =>
      _$STMYSTNGOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class STMYSTNGScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const STMYSTNGScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.userId,
    this.stngCd,
    this.userDiv,
    this.stngData,
  });

  factory STMYSTNGScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMYSTNGScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<STMYSTNGScalarWhereWithAggregatesInput>? AND;

  final Iterable<STMYSTNGScalarWhereWithAggregatesInput>? OR;

  final Iterable<STMYSTNGScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'USER_ID')
  final StringWithAggregatesFilter? userId;

  @JsonKey(name: r'STNG_CD')
  final StringWithAggregatesFilter? stngCd;

  @JsonKey(name: r'USER_DIV')
  final StringWithAggregatesFilter? userDiv;

  @JsonKey(name: r'STNG_DATA')
  final StringNullableWithAggregatesFilter? stngData;

  @override
  Map<String, dynamic> toJson() =>
      _$STMYSTNGScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class STPERMDTLWhereInput implements _i1.JsonSerializable {
  const STPERMDTLWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.permCd,
    this.menuCd,
    this.readYn,
    this.regYn,
    this.mdfcnYn,
    this.delYn,
    this.manageYn,
    this.regId,
    this.regDate,
  });

  factory STPERMDTLWhereInput.fromJson(Map<String, dynamic> json) =>
      _$STPERMDTLWhereInputFromJson(json);

  final Iterable<STPERMDTLWhereInput>? AND;

  final Iterable<STPERMDTLWhereInput>? OR;

  final Iterable<STPERMDTLWhereInput>? NOT;

  @JsonKey(name: r'PERM_CD')
  final StringFilter? permCd;

  @JsonKey(name: r'MENU_CD')
  final StringFilter? menuCd;

  @JsonKey(name: r'READ_YN')
  final StringNullableFilter? readYn;

  @JsonKey(name: r'REG_YN')
  final StringNullableFilter? regYn;

  @JsonKey(name: r'MDFCN_YN')
  final StringNullableFilter? mdfcnYn;

  @JsonKey(name: r'DEL_YN')
  final StringNullableFilter? delYn;

  @JsonKey(name: r'MANAGE_YN')
  final StringNullableFilter? manageYn;

  @JsonKey(name: r'REG_ID')
  final StringFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFilter? regDate;

  @override
  Map<String, dynamic> toJson() => _$STPERMDTLWhereInputToJson(this);
}

@_i1.jsonSerializable
class STPERMDTLOrderByWithRelationInput implements _i1.JsonSerializable {
  const STPERMDTLOrderByWithRelationInput({
    this.permCd,
    this.menuCd,
    this.readYn,
    this.regYn,
    this.mdfcnYn,
    this.delYn,
    this.manageYn,
    this.regId,
    this.regDate,
  });

  factory STPERMDTLOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STPERMDTLOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'PERM_CD')
  final SortOrder? permCd;

  @JsonKey(name: r'MENU_CD')
  final SortOrder? menuCd;

  @JsonKey(name: r'READ_YN')
  final SortOrder? readYn;

  @JsonKey(name: r'REG_YN')
  final SortOrder? regYn;

  @JsonKey(name: r'MDFCN_YN')
  final SortOrder? mdfcnYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'MANAGE_YN')
  final SortOrder? manageYn;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STPERMDTLOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class STPERMDTLWhereUniqueInput implements _i1.JsonSerializable {
  const STPERMDTLWhereUniqueInput({this.permCdMenuCd});

  factory STPERMDTLWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$STPERMDTLWhereUniqueInputFromJson(json);

  @JsonKey(name: r'PERM_CD_MENU_CD')
  final STPERMDTLPERMCDMENUCDCompoundUniqueInput? permCdMenuCd;

  @override
  Map<String, dynamic> toJson() => _$STPERMDTLWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STPERMDTLOrderByWithAggregationInput implements _i1.JsonSerializable {
  const STPERMDTLOrderByWithAggregationInput({
    this.permCd,
    this.menuCd,
    this.readYn,
    this.regYn,
    this.mdfcnYn,
    this.delYn,
    this.manageYn,
    this.regId,
    this.regDate,
    this.$count,
    this.$max,
    this.$min,
  });

  factory STPERMDTLOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STPERMDTLOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'PERM_CD')
  final SortOrder? permCd;

  @JsonKey(name: r'MENU_CD')
  final SortOrder? menuCd;

  @JsonKey(name: r'READ_YN')
  final SortOrder? readYn;

  @JsonKey(name: r'REG_YN')
  final SortOrder? regYn;

  @JsonKey(name: r'MDFCN_YN')
  final SortOrder? mdfcnYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'MANAGE_YN')
  final SortOrder? manageYn;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'_count')
  final STPERMDTLCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_max')
  final STPERMDTLMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final STPERMDTLMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() =>
      _$STPERMDTLOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class STPERMDTLScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const STPERMDTLScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.permCd,
    this.menuCd,
    this.readYn,
    this.regYn,
    this.mdfcnYn,
    this.delYn,
    this.manageYn,
    this.regId,
    this.regDate,
  });

  factory STPERMDTLScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$STPERMDTLScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<STPERMDTLScalarWhereWithAggregatesInput>? AND;

  final Iterable<STPERMDTLScalarWhereWithAggregatesInput>? OR;

  final Iterable<STPERMDTLScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'PERM_CD')
  final StringWithAggregatesFilter? permCd;

  @JsonKey(name: r'MENU_CD')
  final StringWithAggregatesFilter? menuCd;

  @JsonKey(name: r'READ_YN')
  final StringNullableWithAggregatesFilter? readYn;

  @JsonKey(name: r'REG_YN')
  final StringNullableWithAggregatesFilter? regYn;

  @JsonKey(name: r'MDFCN_YN')
  final StringNullableWithAggregatesFilter? mdfcnYn;

  @JsonKey(name: r'DEL_YN')
  final StringNullableWithAggregatesFilter? delYn;

  @JsonKey(name: r'MANAGE_YN')
  final StringNullableWithAggregatesFilter? manageYn;

  @JsonKey(name: r'REG_ID')
  final StringWithAggregatesFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringWithAggregatesFilter? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STPERMDTLScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class STPERMMSTWhereInput implements _i1.JsonSerializable {
  const STPERMMSTWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.permCd,
    this.permNm,
    this.sort,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STPERMMSTWhereInput.fromJson(Map<String, dynamic> json) =>
      _$STPERMMSTWhereInputFromJson(json);

  final Iterable<STPERMMSTWhereInput>? AND;

  final Iterable<STPERMMSTWhereInput>? OR;

  final Iterable<STPERMMSTWhereInput>? NOT;

  @JsonKey(name: r'PERM_CD')
  final StringFilter? permCd;

  @JsonKey(name: r'PERM_NM')
  final StringFilter? permNm;

  @JsonKey(name: r'SORT')
  final StringNullableFilter? sort;

  @JsonKey(name: r'REG_ID')
  final StringFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableFilter? delDate;

  @override
  Map<String, dynamic> toJson() => _$STPERMMSTWhereInputToJson(this);
}

@_i1.jsonSerializable
class STPERMMSTOrderByWithRelationInput implements _i1.JsonSerializable {
  const STPERMMSTOrderByWithRelationInput({
    this.permCd,
    this.permNm,
    this.sort,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STPERMMSTOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STPERMMSTOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'PERM_CD')
  final SortOrder? permCd;

  @JsonKey(name: r'PERM_NM')
  final SortOrder? permNm;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STPERMMSTOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class STPERMMSTWhereUniqueInput implements _i1.JsonSerializable {
  const STPERMMSTWhereUniqueInput({this.permCd});

  factory STPERMMSTWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$STPERMMSTWhereUniqueInputFromJson(json);

  @JsonKey(name: r'PERM_CD')
  final String? permCd;

  @override
  Map<String, dynamic> toJson() => _$STPERMMSTWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STPERMMSTOrderByWithAggregationInput implements _i1.JsonSerializable {
  const STPERMMSTOrderByWithAggregationInput({
    this.permCd,
    this.permNm,
    this.sort,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
    this.$count,
    this.$max,
    this.$min,
  });

  factory STPERMMSTOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STPERMMSTOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'PERM_CD')
  final SortOrder? permCd;

  @JsonKey(name: r'PERM_NM')
  final SortOrder? permNm;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @JsonKey(name: r'_count')
  final STPERMMSTCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_max')
  final STPERMMSTMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final STPERMMSTMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() =>
      _$STPERMMSTOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class STPERMMSTScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const STPERMMSTScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.permCd,
    this.permNm,
    this.sort,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STPERMMSTScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$STPERMMSTScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<STPERMMSTScalarWhereWithAggregatesInput>? AND;

  final Iterable<STPERMMSTScalarWhereWithAggregatesInput>? OR;

  final Iterable<STPERMMSTScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'PERM_CD')
  final StringWithAggregatesFilter? permCd;

  @JsonKey(name: r'PERM_NM')
  final StringWithAggregatesFilter? permNm;

  @JsonKey(name: r'SORT')
  final StringNullableWithAggregatesFilter? sort;

  @JsonKey(name: r'REG_ID')
  final StringWithAggregatesFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringWithAggregatesFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableWithAggregatesFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableWithAggregatesFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableWithAggregatesFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableWithAggregatesFilter? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STPERMMSTScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class STPOPUPWhereInput implements _i1.JsonSerializable {
  const STPOPUPWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.popCd,
    this.popNm,
    this.popTy,
    this.imgText,
    this.lkUrl,
    this.lkTarget,
    this.bgngDate,
    this.endDate,
    this.spwgPred,
    this.flpth,
    this.fileNm,
    this.useYn,
    this.beforeCd,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STPOPUPWhereInput.fromJson(Map<String, dynamic> json) =>
      _$STPOPUPWhereInputFromJson(json);

  final Iterable<STPOPUPWhereInput>? AND;

  final Iterable<STPOPUPWhereInput>? OR;

  final Iterable<STPOPUPWhereInput>? NOT;

  @JsonKey(name: r'POP_CD')
  final StringFilter? popCd;

  @JsonKey(name: r'POP_NM')
  final StringFilter? popNm;

  @JsonKey(name: r'POP_TY')
  final StringFilter? popTy;

  @JsonKey(name: r'IMG_TEXT')
  final StringNullableFilter? imgText;

  @JsonKey(name: r'LK_URL')
  final StringNullableFilter? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final StringNullableFilter? lkTarget;

  @JsonKey(name: r'BGNG_DATE')
  final StringFilter? bgngDate;

  @JsonKey(name: r'END_DATE')
  final StringFilter? endDate;

  @JsonKey(name: r'SPWG_PRED')
  final StringNullableFilter? spwgPred;

  @JsonKey(name: r'FLPTH')
  final StringNullableFilter? flpth;

  @JsonKey(name: r'FILE_NM')
  final StringNullableFilter? fileNm;

  @JsonKey(name: r'USE_YN')
  final StringNullableFilter? useYn;

  @JsonKey(name: r'BEFORE_CD')
  final StringNullableFilter? beforeCd;

  @JsonKey(name: r'REG_ID')
  final StringFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringNullableFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableFilter? delDate;

  @override
  Map<String, dynamic> toJson() => _$STPOPUPWhereInputToJson(this);
}

@_i1.jsonSerializable
class STPOPUPOrderByWithRelationInput implements _i1.JsonSerializable {
  const STPOPUPOrderByWithRelationInput({
    this.popCd,
    this.popNm,
    this.popTy,
    this.imgText,
    this.lkUrl,
    this.lkTarget,
    this.bgngDate,
    this.endDate,
    this.spwgPred,
    this.flpth,
    this.fileNm,
    this.useYn,
    this.beforeCd,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STPOPUPOrderByWithRelationInput.fromJson(Map<String, dynamic> json) =>
      _$STPOPUPOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'POP_CD')
  final SortOrder? popCd;

  @JsonKey(name: r'POP_NM')
  final SortOrder? popNm;

  @JsonKey(name: r'POP_TY')
  final SortOrder? popTy;

  @JsonKey(name: r'IMG_TEXT')
  final SortOrder? imgText;

  @JsonKey(name: r'LK_URL')
  final SortOrder? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final SortOrder? lkTarget;

  @JsonKey(name: r'BGNG_DATE')
  final SortOrder? bgngDate;

  @JsonKey(name: r'END_DATE')
  final SortOrder? endDate;

  @JsonKey(name: r'SPWG_PRED')
  final SortOrder? spwgPred;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'FILE_NM')
  final SortOrder? fileNm;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'BEFORE_CD')
  final SortOrder? beforeCd;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STPOPUPOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class STPOPUPWhereUniqueInput implements _i1.JsonSerializable {
  const STPOPUPWhereUniqueInput({this.popCd});

  factory STPOPUPWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$STPOPUPWhereUniqueInputFromJson(json);

  @JsonKey(name: r'POP_CD')
  final String? popCd;

  @override
  Map<String, dynamic> toJson() => _$STPOPUPWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STPOPUPOrderByWithAggregationInput implements _i1.JsonSerializable {
  const STPOPUPOrderByWithAggregationInput({
    this.popCd,
    this.popNm,
    this.popTy,
    this.imgText,
    this.lkUrl,
    this.lkTarget,
    this.bgngDate,
    this.endDate,
    this.spwgPred,
    this.flpth,
    this.fileNm,
    this.useYn,
    this.beforeCd,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
    this.$count,
    this.$max,
    this.$min,
  });

  factory STPOPUPOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STPOPUPOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'POP_CD')
  final SortOrder? popCd;

  @JsonKey(name: r'POP_NM')
  final SortOrder? popNm;

  @JsonKey(name: r'POP_TY')
  final SortOrder? popTy;

  @JsonKey(name: r'IMG_TEXT')
  final SortOrder? imgText;

  @JsonKey(name: r'LK_URL')
  final SortOrder? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final SortOrder? lkTarget;

  @JsonKey(name: r'BGNG_DATE')
  final SortOrder? bgngDate;

  @JsonKey(name: r'END_DATE')
  final SortOrder? endDate;

  @JsonKey(name: r'SPWG_PRED')
  final SortOrder? spwgPred;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'FILE_NM')
  final SortOrder? fileNm;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'BEFORE_CD')
  final SortOrder? beforeCd;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @JsonKey(name: r'_count')
  final STPOPUPCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_max')
  final STPOPUPMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final STPOPUPMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() =>
      _$STPOPUPOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class STPOPUPScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const STPOPUPScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.popCd,
    this.popNm,
    this.popTy,
    this.imgText,
    this.lkUrl,
    this.lkTarget,
    this.bgngDate,
    this.endDate,
    this.spwgPred,
    this.flpth,
    this.fileNm,
    this.useYn,
    this.beforeCd,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STPOPUPScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$STPOPUPScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<STPOPUPScalarWhereWithAggregatesInput>? AND;

  final Iterable<STPOPUPScalarWhereWithAggregatesInput>? OR;

  final Iterable<STPOPUPScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'POP_CD')
  final StringWithAggregatesFilter? popCd;

  @JsonKey(name: r'POP_NM')
  final StringWithAggregatesFilter? popNm;

  @JsonKey(name: r'POP_TY')
  final StringWithAggregatesFilter? popTy;

  @JsonKey(name: r'IMG_TEXT')
  final StringNullableWithAggregatesFilter? imgText;

  @JsonKey(name: r'LK_URL')
  final StringNullableWithAggregatesFilter? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final StringNullableWithAggregatesFilter? lkTarget;

  @JsonKey(name: r'BGNG_DATE')
  final StringWithAggregatesFilter? bgngDate;

  @JsonKey(name: r'END_DATE')
  final StringWithAggregatesFilter? endDate;

  @JsonKey(name: r'SPWG_PRED')
  final StringNullableWithAggregatesFilter? spwgPred;

  @JsonKey(name: r'FLPTH')
  final StringNullableWithAggregatesFilter? flpth;

  @JsonKey(name: r'FILE_NM')
  final StringNullableWithAggregatesFilter? fileNm;

  @JsonKey(name: r'USE_YN')
  final StringNullableWithAggregatesFilter? useYn;

  @JsonKey(name: r'BEFORE_CD')
  final StringNullableWithAggregatesFilter? beforeCd;

  @JsonKey(name: r'REG_ID')
  final StringWithAggregatesFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringNullableWithAggregatesFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableWithAggregatesFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableWithAggregatesFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableWithAggregatesFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableWithAggregatesFilter? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STPOPUPScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class STSTNGWhereInput implements _i1.JsonSerializable {
  const STSTNGWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.stngCd,
    this.stngData,
    this.title,
    this.descCn,
    this.sort,
    this.editId,
    this.editDate,
  });

  factory STSTNGWhereInput.fromJson(Map<String, dynamic> json) =>
      _$STSTNGWhereInputFromJson(json);

  final Iterable<STSTNGWhereInput>? AND;

  final Iterable<STSTNGWhereInput>? OR;

  final Iterable<STSTNGWhereInput>? NOT;

  @JsonKey(name: r'STNG_CD')
  final StringFilter? stngCd;

  @JsonKey(name: r'STNG_DATA')
  final StringNullableFilter? stngData;

  @JsonKey(name: r'TITLE')
  final StringNullableFilter? title;

  @JsonKey(name: r'DESC_CN')
  final StringNullableFilter? descCn;

  @JsonKey(name: r'SORT')
  final IntNullableFilter? sort;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableFilter? editDate;

  @override
  Map<String, dynamic> toJson() => _$STSTNGWhereInputToJson(this);
}

@_i1.jsonSerializable
class STSTNGOrderByWithRelationInput implements _i1.JsonSerializable {
  const STSTNGOrderByWithRelationInput({
    this.stngCd,
    this.stngData,
    this.title,
    this.descCn,
    this.sort,
    this.editId,
    this.editDate,
  });

  factory STSTNGOrderByWithRelationInput.fromJson(Map<String, dynamic> json) =>
      _$STSTNGOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'STNG_CD')
  final SortOrder? stngCd;

  @JsonKey(name: r'STNG_DATA')
  final SortOrder? stngData;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'DESC_CN')
  final SortOrder? descCn;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @override
  Map<String, dynamic> toJson() => _$STSTNGOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class STSTNGWhereUniqueInput implements _i1.JsonSerializable {
  const STSTNGWhereUniqueInput({this.stngCd});

  factory STSTNGWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$STSTNGWhereUniqueInputFromJson(json);

  @JsonKey(name: r'STNG_CD')
  final String? stngCd;

  @override
  Map<String, dynamic> toJson() => _$STSTNGWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STSTNGOrderByWithAggregationInput implements _i1.JsonSerializable {
  const STSTNGOrderByWithAggregationInput({
    this.stngCd,
    this.stngData,
    this.title,
    this.descCn,
    this.sort,
    this.editId,
    this.editDate,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory STSTNGOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STSTNGOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'STNG_CD')
  final SortOrder? stngCd;

  @JsonKey(name: r'STNG_DATA')
  final SortOrder? stngData;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'DESC_CN')
  final SortOrder? descCn;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'_count')
  final STSTNGCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final STSTNGAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final STSTNGMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final STSTNGMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final STSTNGSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$STSTNGOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class STSTNGScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const STSTNGScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.stngCd,
    this.stngData,
    this.title,
    this.descCn,
    this.sort,
    this.editId,
    this.editDate,
  });

  factory STSTNGScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$STSTNGScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<STSTNGScalarWhereWithAggregatesInput>? AND;

  final Iterable<STSTNGScalarWhereWithAggregatesInput>? OR;

  final Iterable<STSTNGScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'STNG_CD')
  final StringWithAggregatesFilter? stngCd;

  @JsonKey(name: r'STNG_DATA')
  final StringNullableWithAggregatesFilter? stngData;

  @JsonKey(name: r'TITLE')
  final StringNullableWithAggregatesFilter? title;

  @JsonKey(name: r'DESC_CN')
  final StringNullableWithAggregatesFilter? descCn;

  @JsonKey(name: r'SORT')
  final IntNullableWithAggregatesFilter? sort;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableWithAggregatesFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableWithAggregatesFilter? editDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STSTNGScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class STUSERMSTWhereInput implements _i1.JsonSerializable {
  const STUSERMSTWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.userId,
    this.userNm,
    this.userPw,
    this.userDiv,
    this.status,
    this.prevLoginYn,
    this.withdrawnYn,
    this.clph,
    this.email,
    this.lstLoginDate,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STUSERMSTWhereInput.fromJson(Map<String, dynamic> json) =>
      _$STUSERMSTWhereInputFromJson(json);

  final Iterable<STUSERMSTWhereInput>? AND;

  final Iterable<STUSERMSTWhereInput>? OR;

  final Iterable<STUSERMSTWhereInput>? NOT;

  @JsonKey(name: r'USER_ID')
  final StringFilter? userId;

  @JsonKey(name: r'USER_NM')
  final StringNullableFilter? userNm;

  @JsonKey(name: r'USER_PW')
  final StringFilter? userPw;

  @JsonKey(name: r'USER_DIV')
  final StringNullableFilter? userDiv;

  @JsonKey(name: r'STATUS')
  final StringNullableFilter? status;

  @JsonKey(name: r'PREV_LOGIN_YN')
  final StringNullableFilter? prevLoginYn;

  @JsonKey(name: r'WITHDRAWN_YN')
  final StringNullableFilter? withdrawnYn;

  @JsonKey(name: r'CLPH')
  final StringNullableFilter? clph;

  @JsonKey(name: r'EMAIL')
  final StringNullableFilter? email;

  @JsonKey(name: r'LST_LOGIN_DATE')
  final StringNullableFilter? lstLoginDate;

  @JsonKey(name: r'REG_ID')
  final StringFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringNullableFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableFilter? delDate;

  @override
  Map<String, dynamic> toJson() => _$STUSERMSTWhereInputToJson(this);
}

@_i1.jsonSerializable
class STUSERMSTOrderByWithRelationInput implements _i1.JsonSerializable {
  const STUSERMSTOrderByWithRelationInput({
    this.userId,
    this.userNm,
    this.userPw,
    this.userDiv,
    this.status,
    this.prevLoginYn,
    this.withdrawnYn,
    this.clph,
    this.email,
    this.lstLoginDate,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STUSERMSTOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STUSERMSTOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'USER_NM')
  final SortOrder? userNm;

  @JsonKey(name: r'USER_PW')
  final SortOrder? userPw;

  @JsonKey(name: r'USER_DIV')
  final SortOrder? userDiv;

  @JsonKey(name: r'STATUS')
  final SortOrder? status;

  @JsonKey(name: r'PREV_LOGIN_YN')
  final SortOrder? prevLoginYn;

  @JsonKey(name: r'WITHDRAWN_YN')
  final SortOrder? withdrawnYn;

  @JsonKey(name: r'CLPH')
  final SortOrder? clph;

  @JsonKey(name: r'EMAIL')
  final SortOrder? email;

  @JsonKey(name: r'LST_LOGIN_DATE')
  final SortOrder? lstLoginDate;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STUSERMSTOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class STUSERMSTWhereUniqueInput implements _i1.JsonSerializable {
  const STUSERMSTWhereUniqueInput({this.userId});

  factory STUSERMSTWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$STUSERMSTWhereUniqueInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final String? userId;

  @override
  Map<String, dynamic> toJson() => _$STUSERMSTWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STUSERMSTOrderByWithAggregationInput implements _i1.JsonSerializable {
  const STUSERMSTOrderByWithAggregationInput({
    this.userId,
    this.userNm,
    this.userPw,
    this.userDiv,
    this.status,
    this.prevLoginYn,
    this.withdrawnYn,
    this.clph,
    this.email,
    this.lstLoginDate,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
    this.$count,
    this.$max,
    this.$min,
  });

  factory STUSERMSTOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STUSERMSTOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'USER_NM')
  final SortOrder? userNm;

  @JsonKey(name: r'USER_PW')
  final SortOrder? userPw;

  @JsonKey(name: r'USER_DIV')
  final SortOrder? userDiv;

  @JsonKey(name: r'STATUS')
  final SortOrder? status;

  @JsonKey(name: r'PREV_LOGIN_YN')
  final SortOrder? prevLoginYn;

  @JsonKey(name: r'WITHDRAWN_YN')
  final SortOrder? withdrawnYn;

  @JsonKey(name: r'CLPH')
  final SortOrder? clph;

  @JsonKey(name: r'EMAIL')
  final SortOrder? email;

  @JsonKey(name: r'LST_LOGIN_DATE')
  final SortOrder? lstLoginDate;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @JsonKey(name: r'_count')
  final STUSERMSTCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_max')
  final STUSERMSTMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final STUSERMSTMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() =>
      _$STUSERMSTOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class STUSERMSTScalarWhereWithAggregatesInput implements _i1.JsonSerializable {
  const STUSERMSTScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.userId,
    this.userNm,
    this.userPw,
    this.userDiv,
    this.status,
    this.prevLoginYn,
    this.withdrawnYn,
    this.clph,
    this.email,
    this.lstLoginDate,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STUSERMSTScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$STUSERMSTScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<STUSERMSTScalarWhereWithAggregatesInput>? AND;

  final Iterable<STUSERMSTScalarWhereWithAggregatesInput>? OR;

  final Iterable<STUSERMSTScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'USER_ID')
  final StringWithAggregatesFilter? userId;

  @JsonKey(name: r'USER_NM')
  final StringNullableWithAggregatesFilter? userNm;

  @JsonKey(name: r'USER_PW')
  final StringWithAggregatesFilter? userPw;

  @JsonKey(name: r'USER_DIV')
  final StringNullableWithAggregatesFilter? userDiv;

  @JsonKey(name: r'STATUS')
  final StringNullableWithAggregatesFilter? status;

  @JsonKey(name: r'PREV_LOGIN_YN')
  final StringNullableWithAggregatesFilter? prevLoginYn;

  @JsonKey(name: r'WITHDRAWN_YN')
  final StringNullableWithAggregatesFilter? withdrawnYn;

  @JsonKey(name: r'CLPH')
  final StringNullableWithAggregatesFilter? clph;

  @JsonKey(name: r'EMAIL')
  final StringNullableWithAggregatesFilter? email;

  @JsonKey(name: r'LST_LOGIN_DATE')
  final StringNullableWithAggregatesFilter? lstLoginDate;

  @JsonKey(name: r'REG_ID')
  final StringWithAggregatesFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringNullableWithAggregatesFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableWithAggregatesFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableWithAggregatesFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableWithAggregatesFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableWithAggregatesFilter? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STUSERMSTScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTDETAILTBLWhereInput implements _i1.JsonSerializable {
  const WORKREPORTDETAILTBLWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.reportId,
    this.seq,
    this.projectNm,
    this.projectSubNm,
    this.detailContent,
    this.worker,
    this.grade,
    this.processRate,
    this.workDate,
    this.processType,
    this.subjectYn,
    this.regUser,
    this.regDate,
    this.completeDate,
  });

  factory WORKREPORTDETAILTBLWhereInput.fromJson(Map<String, dynamic> json) =>
      _$WORKREPORTDETAILTBLWhereInputFromJson(json);

  final Iterable<WORKREPORTDETAILTBLWhereInput>? AND;

  final Iterable<WORKREPORTDETAILTBLWhereInput>? OR;

  final Iterable<WORKREPORTDETAILTBLWhereInput>? NOT;

  @JsonKey(name: r'REPORT_ID')
  final StringFilter? reportId;

  @JsonKey(name: r'SEQ')
  final BigIntFilter? seq;

  @JsonKey(name: r'PROJECT_NM')
  final StringFilter? projectNm;

  @JsonKey(name: r'PROJECT_SUB_NM')
  final StringFilter? projectSubNm;

  @JsonKey(name: r'DETAIL_CONTENT')
  final StringNullableFilter? detailContent;

  @JsonKey(name: r'WORKER')
  final StringNullableFilter? worker;

  @JsonKey(name: r'GRADE')
  final StringNullableFilter? grade;

  @JsonKey(name: r'PROCESS_RATE')
  final StringNullableFilter? processRate;

  @JsonKey(name: r'WORK_DATE')
  final StringNullableFilter? workDate;

  @JsonKey(name: r'PROCESS_TYPE')
  final StringNullableFilter? processType;

  @JsonKey(name: r'SUBJECT_YN')
  final StringFilter? subjectYn;

  @JsonKey(name: r'REG_USER')
  final StringFilter? regUser;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFilter? regDate;

  @JsonKey(name: r'COMPLETE_DATE')
  final StringNullableFilter? completeDate;

  @override
  Map<String, dynamic> toJson() => _$WORKREPORTDETAILTBLWhereInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTDETAILTBLOrderByWithRelationInput
    implements _i1.JsonSerializable {
  const WORKREPORTDETAILTBLOrderByWithRelationInput({
    this.reportId,
    this.seq,
    this.projectNm,
    this.projectSubNm,
    this.detailContent,
    this.worker,
    this.grade,
    this.processRate,
    this.workDate,
    this.processType,
    this.subjectYn,
    this.regUser,
    this.regDate,
    this.completeDate,
  });

  factory WORKREPORTDETAILTBLOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTDETAILTBLOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final SortOrder? reportId;

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'PROJECT_NM')
  final SortOrder? projectNm;

  @JsonKey(name: r'PROJECT_SUB_NM')
  final SortOrder? projectSubNm;

  @JsonKey(name: r'DETAIL_CONTENT')
  final SortOrder? detailContent;

  @JsonKey(name: r'WORKER')
  final SortOrder? worker;

  @JsonKey(name: r'GRADE')
  final SortOrder? grade;

  @JsonKey(name: r'PROCESS_RATE')
  final SortOrder? processRate;

  @JsonKey(name: r'WORK_DATE')
  final SortOrder? workDate;

  @JsonKey(name: r'PROCESS_TYPE')
  final SortOrder? processType;

  @JsonKey(name: r'SUBJECT_YN')
  final SortOrder? subjectYn;

  @JsonKey(name: r'REG_USER')
  final SortOrder? regUser;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'COMPLETE_DATE')
  final SortOrder? completeDate;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTDETAILTBLOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTDETAILTBLWhereUniqueInput implements _i1.JsonSerializable {
  const WORKREPORTDETAILTBLWhereUniqueInput({this.seqReportId});

  factory WORKREPORTDETAILTBLWhereUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTDETAILTBLWhereUniqueInputFromJson(json);

  @JsonKey(name: r'SEQ_REPORT_ID')
  final WORKREPORTDETAILTBLSEQREPORTIDCompoundUniqueInput? seqReportId;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTDETAILTBLWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTDETAILTBLOrderByWithAggregationInput
    implements _i1.JsonSerializable {
  const WORKREPORTDETAILTBLOrderByWithAggregationInput({
    this.reportId,
    this.seq,
    this.projectNm,
    this.projectSubNm,
    this.detailContent,
    this.worker,
    this.grade,
    this.processRate,
    this.workDate,
    this.processType,
    this.subjectYn,
    this.regUser,
    this.regDate,
    this.completeDate,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory WORKREPORTDETAILTBLOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTDETAILTBLOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final SortOrder? reportId;

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'PROJECT_NM')
  final SortOrder? projectNm;

  @JsonKey(name: r'PROJECT_SUB_NM')
  final SortOrder? projectSubNm;

  @JsonKey(name: r'DETAIL_CONTENT')
  final SortOrder? detailContent;

  @JsonKey(name: r'WORKER')
  final SortOrder? worker;

  @JsonKey(name: r'GRADE')
  final SortOrder? grade;

  @JsonKey(name: r'PROCESS_RATE')
  final SortOrder? processRate;

  @JsonKey(name: r'WORK_DATE')
  final SortOrder? workDate;

  @JsonKey(name: r'PROCESS_TYPE')
  final SortOrder? processType;

  @JsonKey(name: r'SUBJECT_YN')
  final SortOrder? subjectYn;

  @JsonKey(name: r'REG_USER')
  final SortOrder? regUser;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'COMPLETE_DATE')
  final SortOrder? completeDate;

  @JsonKey(name: r'_count')
  final WORKREPORTDETAILTBLCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final WORKREPORTDETAILTBLAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final WORKREPORTDETAILTBLMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final WORKREPORTDETAILTBLMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final WORKREPORTDETAILTBLSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTDETAILTBLOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTDETAILTBLScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const WORKREPORTDETAILTBLScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.reportId,
    this.seq,
    this.projectNm,
    this.projectSubNm,
    this.detailContent,
    this.worker,
    this.grade,
    this.processRate,
    this.workDate,
    this.processType,
    this.subjectYn,
    this.regUser,
    this.regDate,
    this.completeDate,
  });

  factory WORKREPORTDETAILTBLScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTDETAILTBLScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<WORKREPORTDETAILTBLScalarWhereWithAggregatesInput>? AND;

  final Iterable<WORKREPORTDETAILTBLScalarWhereWithAggregatesInput>? OR;

  final Iterable<WORKREPORTDETAILTBLScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'REPORT_ID')
  final StringWithAggregatesFilter? reportId;

  @JsonKey(name: r'SEQ')
  final BigIntWithAggregatesFilter? seq;

  @JsonKey(name: r'PROJECT_NM')
  final StringWithAggregatesFilter? projectNm;

  @JsonKey(name: r'PROJECT_SUB_NM')
  final StringWithAggregatesFilter? projectSubNm;

  @JsonKey(name: r'DETAIL_CONTENT')
  final StringNullableWithAggregatesFilter? detailContent;

  @JsonKey(name: r'WORKER')
  final StringNullableWithAggregatesFilter? worker;

  @JsonKey(name: r'GRADE')
  final StringNullableWithAggregatesFilter? grade;

  @JsonKey(name: r'PROCESS_RATE')
  final StringNullableWithAggregatesFilter? processRate;

  @JsonKey(name: r'WORK_DATE')
  final StringNullableWithAggregatesFilter? workDate;

  @JsonKey(name: r'PROCESS_TYPE')
  final StringNullableWithAggregatesFilter? processType;

  @JsonKey(name: r'SUBJECT_YN')
  final StringWithAggregatesFilter? subjectYn;

  @JsonKey(name: r'REG_USER')
  final StringWithAggregatesFilter? regUser;

  @JsonKey(name: r'REG_DATE')
  final DateTimeWithAggregatesFilter? regDate;

  @JsonKey(name: r'COMPLETE_DATE')
  final StringNullableWithAggregatesFilter? completeDate;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTDETAILTBLScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLWhereInput implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.reportId,
    this.userId,
    this.title,
    this.htmlContent,
    this.regDate,
    this.delYn,
  });

  factory WORKREPORTHTMLTBLWhereInput.fromJson(Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLWhereInputFromJson(json);

  final Iterable<WORKREPORTHTMLTBLWhereInput>? AND;

  final Iterable<WORKREPORTHTMLTBLWhereInput>? OR;

  final Iterable<WORKREPORTHTMLTBLWhereInput>? NOT;

  @JsonKey(name: r'REPORT_ID')
  final StringFilter? reportId;

  @JsonKey(name: r'USER_ID')
  final StringFilter? userId;

  @JsonKey(name: r'TITLE')
  final StringFilter? title;

  @JsonKey(name: r'HTML_CONTENT')
  final StringNullableFilter? htmlContent;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFilter? regDate;

  @JsonKey(name: r'DEL_YN')
  final StringNullableFilter? delYn;

  @override
  Map<String, dynamic> toJson() => _$WORKREPORTHTMLTBLWhereInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLOrderByWithRelationInput
    implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLOrderByWithRelationInput({
    this.reportId,
    this.userId,
    this.title,
    this.htmlContent,
    this.regDate,
    this.delYn,
  });

  factory WORKREPORTHTMLTBLOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final SortOrder? reportId;

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'HTML_CONTENT')
  final SortOrder? htmlContent;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTHTMLTBLOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLWhereUniqueInput implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLWhereUniqueInput({this.reportIdUserId});

  factory WORKREPORTHTMLTBLWhereUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLWhereUniqueInputFromJson(json);

  @JsonKey(name: r'REPORT_ID_USER_ID')
  final WORKREPORTHTMLTBLREPORTIDUSERIDCompoundUniqueInput? reportIdUserId;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTHTMLTBLWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLOrderByWithAggregationInput
    implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLOrderByWithAggregationInput({
    this.reportId,
    this.userId,
    this.title,
    this.htmlContent,
    this.regDate,
    this.delYn,
    this.$count,
    this.$max,
    this.$min,
  });

  factory WORKREPORTHTMLTBLOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final SortOrder? reportId;

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'HTML_CONTENT')
  final SortOrder? htmlContent;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'_count')
  final WORKREPORTHTMLTBLCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_max')
  final WORKREPORTHTMLTBLMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final WORKREPORTHTMLTBLMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTHTMLTBLOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.reportId,
    this.userId,
    this.title,
    this.htmlContent,
    this.regDate,
    this.delYn,
  });

  factory WORKREPORTHTMLTBLScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<WORKREPORTHTMLTBLScalarWhereWithAggregatesInput>? AND;

  final Iterable<WORKREPORTHTMLTBLScalarWhereWithAggregatesInput>? OR;

  final Iterable<WORKREPORTHTMLTBLScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'REPORT_ID')
  final StringWithAggregatesFilter? reportId;

  @JsonKey(name: r'USER_ID')
  final StringWithAggregatesFilter? userId;

  @JsonKey(name: r'TITLE')
  final StringWithAggregatesFilter? title;

  @JsonKey(name: r'HTML_CONTENT')
  final StringNullableWithAggregatesFilter? htmlContent;

  @JsonKey(name: r'REG_DATE')
  final DateTimeWithAggregatesFilter? regDate;

  @JsonKey(name: r'DEL_YN')
  final StringNullableWithAggregatesFilter? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTHTMLTBLScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLBACKWhereInput implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLBACKWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.reportId,
    this.userId,
    this.title,
    this.htmlContent,
    this.regDate,
    this.delYn,
  });

  factory WORKREPORTHTMLTBLBACKWhereInput.fromJson(Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLBACKWhereInputFromJson(json);

  final Iterable<WORKREPORTHTMLTBLBACKWhereInput>? AND;

  final Iterable<WORKREPORTHTMLTBLBACKWhereInput>? OR;

  final Iterable<WORKREPORTHTMLTBLBACKWhereInput>? NOT;

  @JsonKey(name: r'REPORT_ID')
  final StringFilter? reportId;

  @JsonKey(name: r'USER_ID')
  final StringFilter? userId;

  @JsonKey(name: r'TITLE')
  final StringFilter? title;

  @JsonKey(name: r'HTML_CONTENT')
  final StringNullableFilter? htmlContent;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFilter? regDate;

  @JsonKey(name: r'DEL_YN')
  final StringNullableFilter? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTHTMLTBLBACKWhereInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLBACKOrderByWithRelationInput
    implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLBACKOrderByWithRelationInput({
    this.reportId,
    this.userId,
    this.title,
    this.htmlContent,
    this.regDate,
    this.delYn,
  });

  factory WORKREPORTHTMLTBLBACKOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLBACKOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final SortOrder? reportId;

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'HTML_CONTENT')
  final SortOrder? htmlContent;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTHTMLTBLBACKOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLBACKWhereUniqueInput implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLBACKWhereUniqueInput({this.reportIdUserId});

  factory WORKREPORTHTMLTBLBACKWhereUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLBACKWhereUniqueInputFromJson(json);

  @JsonKey(name: r'REPORT_ID_USER_ID')
  final WORKREPORTHTMLTBLBACKREPORTIDUSERIDCompoundUniqueInput? reportIdUserId;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTHTMLTBLBACKWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLBACKOrderByWithAggregationInput
    implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLBACKOrderByWithAggregationInput({
    this.reportId,
    this.userId,
    this.title,
    this.htmlContent,
    this.regDate,
    this.delYn,
    this.$count,
    this.$max,
    this.$min,
  });

  factory WORKREPORTHTMLTBLBACKOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLBACKOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final SortOrder? reportId;

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'HTML_CONTENT')
  final SortOrder? htmlContent;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'_count')
  final WORKREPORTHTMLTBLBACKCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_max')
  final WORKREPORTHTMLTBLBACKMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final WORKREPORTHTMLTBLBACKMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTHTMLTBLBACKOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLBACKScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLBACKScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.reportId,
    this.userId,
    this.title,
    this.htmlContent,
    this.regDate,
    this.delYn,
  });

  factory WORKREPORTHTMLTBLBACKScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLBACKScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<WORKREPORTHTMLTBLBACKScalarWhereWithAggregatesInput>? AND;

  final Iterable<WORKREPORTHTMLTBLBACKScalarWhereWithAggregatesInput>? OR;

  final Iterable<WORKREPORTHTMLTBLBACKScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'REPORT_ID')
  final StringWithAggregatesFilter? reportId;

  @JsonKey(name: r'USER_ID')
  final StringWithAggregatesFilter? userId;

  @JsonKey(name: r'TITLE')
  final StringWithAggregatesFilter? title;

  @JsonKey(name: r'HTML_CONTENT')
  final StringNullableWithAggregatesFilter? htmlContent;

  @JsonKey(name: r'REG_DATE')
  final DateTimeWithAggregatesFilter? regDate;

  @JsonKey(name: r'DEL_YN')
  final StringNullableWithAggregatesFilter? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTHTMLTBLBACKScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTMASTERTBLWhereInput implements _i1.JsonSerializable {
  const WORKREPORTMASTERTBLWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.reportId,
    this.title,
    this.dept,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory WORKREPORTMASTERTBLWhereInput.fromJson(Map<String, dynamic> json) =>
      _$WORKREPORTMASTERTBLWhereInputFromJson(json);

  final Iterable<WORKREPORTMASTERTBLWhereInput>? AND;

  final Iterable<WORKREPORTMASTERTBLWhereInput>? OR;

  final Iterable<WORKREPORTMASTERTBLWhereInput>? NOT;

  @JsonKey(name: r'REPORT_ID')
  final StringFilter? reportId;

  @JsonKey(name: r'TITLE')
  final StringFilter? title;

  @JsonKey(name: r'DEPT')
  final StringFilter? dept;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFilter? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeNullableFilter? updDate;

  @JsonKey(name: r'DEL_YN')
  final StringNullableFilter? delYn;

  @override
  Map<String, dynamic> toJson() => _$WORKREPORTMASTERTBLWhereInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTMASTERTBLOrderByWithRelationInput
    implements _i1.JsonSerializable {
  const WORKREPORTMASTERTBLOrderByWithRelationInput({
    this.reportId,
    this.title,
    this.dept,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory WORKREPORTMASTERTBLOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTMASTERTBLOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final SortOrder? reportId;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'DEPT')
  final SortOrder? dept;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTMASTERTBLOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTMASTERTBLWhereUniqueInput implements _i1.JsonSerializable {
  const WORKREPORTMASTERTBLWhereUniqueInput({this.reportId});

  factory WORKREPORTMASTERTBLWhereUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTMASTERTBLWhereUniqueInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final String? reportId;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTMASTERTBLWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTMASTERTBLOrderByWithAggregationInput
    implements _i1.JsonSerializable {
  const WORKREPORTMASTERTBLOrderByWithAggregationInput({
    this.reportId,
    this.title,
    this.dept,
    this.regDate,
    this.updDate,
    this.delYn,
    this.$count,
    this.$max,
    this.$min,
  });

  factory WORKREPORTMASTERTBLOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTMASTERTBLOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final SortOrder? reportId;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'DEPT')
  final SortOrder? dept;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'_count')
  final WORKREPORTMASTERTBLCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_max')
  final WORKREPORTMASTERTBLMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final WORKREPORTMASTERTBLMinOrderByAggregateInput? $min;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTMASTERTBLOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTMASTERTBLScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const WORKREPORTMASTERTBLScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.reportId,
    this.title,
    this.dept,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory WORKREPORTMASTERTBLScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTMASTERTBLScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<WORKREPORTMASTERTBLScalarWhereWithAggregatesInput>? AND;

  final Iterable<WORKREPORTMASTERTBLScalarWhereWithAggregatesInput>? OR;

  final Iterable<WORKREPORTMASTERTBLScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'REPORT_ID')
  final StringWithAggregatesFilter? reportId;

  @JsonKey(name: r'TITLE')
  final StringWithAggregatesFilter? title;

  @JsonKey(name: r'DEPT')
  final StringWithAggregatesFilter? dept;

  @JsonKey(name: r'REG_DATE')
  final DateTimeWithAggregatesFilter? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeNullableWithAggregatesFilter? updDate;

  @JsonKey(name: r'DEL_YN')
  final StringNullableWithAggregatesFilter? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTMASTERTBLScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTMSTWhereInput implements _i1.JsonSerializable {
  const WORKREQUESTMSTWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.rqstrDpnm,
    this.rqstrNm,
    this.rqstrId,
    this.rqstrDate,
    this.hopeDate,
    this.chrDprNm,
    this.chrNm,
    this.chrId,
    this.chrChk,
    this.title,
    this.cn,
    this.etc,
    this.doc,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory WORKREQUESTMSTWhereInput.fromJson(Map<String, dynamic> json) =>
      _$WORKREQUESTMSTWhereInputFromJson(json);

  final Iterable<WORKREQUESTMSTWhereInput>? AND;

  final Iterable<WORKREQUESTMSTWhereInput>? OR;

  final Iterable<WORKREQUESTMSTWhereInput>? NOT;

  @JsonKey(name: r'SEQ')
  final IntFilter? seq;

  @JsonKey(name: r'RQSTR_DPNM')
  final StringFilter? rqstrDpnm;

  @JsonKey(name: r'RQSTR_NM')
  final StringFilter? rqstrNm;

  @JsonKey(name: r'RQSTR_ID')
  final StringFilter? rqstrId;

  @JsonKey(name: r'RQSTR_DATE')
  final StringFilter? rqstrDate;

  @JsonKey(name: r'HOPE_DATE')
  final StringFilter? hopeDate;

  @JsonKey(name: r'CHR_DPR_NM')
  final StringFilter? chrDprNm;

  @JsonKey(name: r'CHR_NM')
  final StringFilter? chrNm;

  @JsonKey(name: r'CHR_ID')
  final StringFilter? chrId;

  @JsonKey(name: r'CHR_CHK')
  final StringNullableFilter? chrChk;

  @JsonKey(name: r'TITLE')
  final StringFilter? title;

  @JsonKey(name: r'CN')
  final StringFilter? cn;

  @JsonKey(name: r'ETC')
  final StringNullableFilter? etc;

  @JsonKey(name: r'DOC')
  final StringNullableFilter? doc;

  @JsonKey(name: r'REG_ID')
  final StringFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableFilter? delDate;

  @override
  Map<String, dynamic> toJson() => _$WORKREQUESTMSTWhereInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTMSTOrderByWithRelationInput implements _i1.JsonSerializable {
  const WORKREQUESTMSTOrderByWithRelationInput({
    this.seq,
    this.rqstrDpnm,
    this.rqstrNm,
    this.rqstrId,
    this.rqstrDate,
    this.hopeDate,
    this.chrDprNm,
    this.chrNm,
    this.chrId,
    this.chrChk,
    this.title,
    this.cn,
    this.etc,
    this.doc,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory WORKREQUESTMSTOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREQUESTMSTOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'RQSTR_DPNM')
  final SortOrder? rqstrDpnm;

  @JsonKey(name: r'RQSTR_NM')
  final SortOrder? rqstrNm;

  @JsonKey(name: r'RQSTR_ID')
  final SortOrder? rqstrId;

  @JsonKey(name: r'RQSTR_DATE')
  final SortOrder? rqstrDate;

  @JsonKey(name: r'HOPE_DATE')
  final SortOrder? hopeDate;

  @JsonKey(name: r'CHR_DPR_NM')
  final SortOrder? chrDprNm;

  @JsonKey(name: r'CHR_NM')
  final SortOrder? chrNm;

  @JsonKey(name: r'CHR_ID')
  final SortOrder? chrId;

  @JsonKey(name: r'CHR_CHK')
  final SortOrder? chrChk;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'CN')
  final SortOrder? cn;

  @JsonKey(name: r'ETC')
  final SortOrder? etc;

  @JsonKey(name: r'DOC')
  final SortOrder? doc;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREQUESTMSTOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTMSTWhereUniqueInput implements _i1.JsonSerializable {
  const WORKREQUESTMSTWhereUniqueInput({this.seq});

  factory WORKREQUESTMSTWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$WORKREQUESTMSTWhereUniqueInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int? seq;

  @override
  Map<String, dynamic> toJson() => _$WORKREQUESTMSTWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTMSTOrderByWithAggregationInput
    implements _i1.JsonSerializable {
  const WORKREQUESTMSTOrderByWithAggregationInput({
    this.seq,
    this.rqstrDpnm,
    this.rqstrNm,
    this.rqstrId,
    this.rqstrDate,
    this.hopeDate,
    this.chrDprNm,
    this.chrNm,
    this.chrId,
    this.chrChk,
    this.title,
    this.cn,
    this.etc,
    this.doc,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory WORKREQUESTMSTOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREQUESTMSTOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'RQSTR_DPNM')
  final SortOrder? rqstrDpnm;

  @JsonKey(name: r'RQSTR_NM')
  final SortOrder? rqstrNm;

  @JsonKey(name: r'RQSTR_ID')
  final SortOrder? rqstrId;

  @JsonKey(name: r'RQSTR_DATE')
  final SortOrder? rqstrDate;

  @JsonKey(name: r'HOPE_DATE')
  final SortOrder? hopeDate;

  @JsonKey(name: r'CHR_DPR_NM')
  final SortOrder? chrDprNm;

  @JsonKey(name: r'CHR_NM')
  final SortOrder? chrNm;

  @JsonKey(name: r'CHR_ID')
  final SortOrder? chrId;

  @JsonKey(name: r'CHR_CHK')
  final SortOrder? chrChk;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'CN')
  final SortOrder? cn;

  @JsonKey(name: r'ETC')
  final SortOrder? etc;

  @JsonKey(name: r'DOC')
  final SortOrder? doc;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @JsonKey(name: r'_count')
  final WORKREQUESTMSTCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final WORKREQUESTMSTAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final WORKREQUESTMSTMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final WORKREQUESTMSTMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final WORKREQUESTMSTSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREQUESTMSTOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTMSTScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const WORKREQUESTMSTScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.rqstrDpnm,
    this.rqstrNm,
    this.rqstrId,
    this.rqstrDate,
    this.hopeDate,
    this.chrDprNm,
    this.chrNm,
    this.chrId,
    this.chrChk,
    this.title,
    this.cn,
    this.etc,
    this.doc,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory WORKREQUESTMSTScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREQUESTMSTScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<WORKREQUESTMSTScalarWhereWithAggregatesInput>? AND;

  final Iterable<WORKREQUESTMSTScalarWhereWithAggregatesInput>? OR;

  final Iterable<WORKREQUESTMSTScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'SEQ')
  final IntWithAggregatesFilter? seq;

  @JsonKey(name: r'RQSTR_DPNM')
  final StringWithAggregatesFilter? rqstrDpnm;

  @JsonKey(name: r'RQSTR_NM')
  final StringWithAggregatesFilter? rqstrNm;

  @JsonKey(name: r'RQSTR_ID')
  final StringWithAggregatesFilter? rqstrId;

  @JsonKey(name: r'RQSTR_DATE')
  final StringWithAggregatesFilter? rqstrDate;

  @JsonKey(name: r'HOPE_DATE')
  final StringWithAggregatesFilter? hopeDate;

  @JsonKey(name: r'CHR_DPR_NM')
  final StringWithAggregatesFilter? chrDprNm;

  @JsonKey(name: r'CHR_NM')
  final StringWithAggregatesFilter? chrNm;

  @JsonKey(name: r'CHR_ID')
  final StringWithAggregatesFilter? chrId;

  @JsonKey(name: r'CHR_CHK')
  final StringNullableWithAggregatesFilter? chrChk;

  @JsonKey(name: r'TITLE')
  final StringWithAggregatesFilter? title;

  @JsonKey(name: r'CN')
  final StringWithAggregatesFilter? cn;

  @JsonKey(name: r'ETC')
  final StringNullableWithAggregatesFilter? etc;

  @JsonKey(name: r'DOC')
  final StringNullableWithAggregatesFilter? doc;

  @JsonKey(name: r'REG_ID')
  final StringWithAggregatesFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringWithAggregatesFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableWithAggregatesFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableWithAggregatesFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableWithAggregatesFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableWithAggregatesFilter? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREQUESTMSTScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTREFWhereInput implements _i1.JsonSerializable {
  const WORKREQUESTREFWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.mseq,
    this.refId,
    this.refNm,
    this.refDep,
    this.refGrade,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory WORKREQUESTREFWhereInput.fromJson(Map<String, dynamic> json) =>
      _$WORKREQUESTREFWhereInputFromJson(json);

  final Iterable<WORKREQUESTREFWhereInput>? AND;

  final Iterable<WORKREQUESTREFWhereInput>? OR;

  final Iterable<WORKREQUESTREFWhereInput>? NOT;

  @JsonKey(name: r'SEQ')
  final IntFilter? seq;

  @JsonKey(name: r'MSEQ')
  final IntFilter? mseq;

  @JsonKey(name: r'REF_ID')
  final StringFilter? refId;

  @JsonKey(name: r'REF_NM')
  final StringNullableFilter? refNm;

  @JsonKey(name: r'REF_DEP')
  final StringNullableFilter? refDep;

  @JsonKey(name: r'REF_GRADE')
  final StringNullableFilter? refGrade;

  @JsonKey(name: r'REG_ID')
  final StringFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableFilter? delDate;

  @override
  Map<String, dynamic> toJson() => _$WORKREQUESTREFWhereInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTREFOrderByWithRelationInput implements _i1.JsonSerializable {
  const WORKREQUESTREFOrderByWithRelationInput({
    this.seq,
    this.mseq,
    this.refId,
    this.refNm,
    this.refDep,
    this.refGrade,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory WORKREQUESTREFOrderByWithRelationInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREQUESTREFOrderByWithRelationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'REF_ID')
  final SortOrder? refId;

  @JsonKey(name: r'REF_NM')
  final SortOrder? refNm;

  @JsonKey(name: r'REF_DEP')
  final SortOrder? refDep;

  @JsonKey(name: r'REF_GRADE')
  final SortOrder? refGrade;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREQUESTREFOrderByWithRelationInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTREFWhereUniqueInput implements _i1.JsonSerializable {
  const WORKREQUESTREFWhereUniqueInput({this.seq});

  factory WORKREQUESTREFWhereUniqueInput.fromJson(Map<String, dynamic> json) =>
      _$WORKREQUESTREFWhereUniqueInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int? seq;

  @override
  Map<String, dynamic> toJson() => _$WORKREQUESTREFWhereUniqueInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTREFOrderByWithAggregationInput
    implements _i1.JsonSerializable {
  const WORKREQUESTREFOrderByWithAggregationInput({
    this.seq,
    this.mseq,
    this.refId,
    this.refNm,
    this.refDep,
    this.refGrade,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  factory WORKREQUESTREFOrderByWithAggregationInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREQUESTREFOrderByWithAggregationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'REF_ID')
  final SortOrder? refId;

  @JsonKey(name: r'REF_NM')
  final SortOrder? refNm;

  @JsonKey(name: r'REF_DEP')
  final SortOrder? refDep;

  @JsonKey(name: r'REF_GRADE')
  final SortOrder? refGrade;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @JsonKey(name: r'_count')
  final WORKREQUESTREFCountOrderByAggregateInput? $count;

  @JsonKey(name: r'_avg')
  final WORKREQUESTREFAvgOrderByAggregateInput? $avg;

  @JsonKey(name: r'_max')
  final WORKREQUESTREFMaxOrderByAggregateInput? $max;

  @JsonKey(name: r'_min')
  final WORKREQUESTREFMinOrderByAggregateInput? $min;

  @JsonKey(name: r'_sum')
  final WORKREQUESTREFSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREQUESTREFOrderByWithAggregationInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTREFScalarWhereWithAggregatesInput
    implements _i1.JsonSerializable {
  const WORKREQUESTREFScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.seq,
    this.mseq,
    this.refId,
    this.refNm,
    this.refDep,
    this.refGrade,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory WORKREQUESTREFScalarWhereWithAggregatesInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREQUESTREFScalarWhereWithAggregatesInputFromJson(json);

  final Iterable<WORKREQUESTREFScalarWhereWithAggregatesInput>? AND;

  final Iterable<WORKREQUESTREFScalarWhereWithAggregatesInput>? OR;

  final Iterable<WORKREQUESTREFScalarWhereWithAggregatesInput>? NOT;

  @JsonKey(name: r'SEQ')
  final IntWithAggregatesFilter? seq;

  @JsonKey(name: r'MSEQ')
  final IntWithAggregatesFilter? mseq;

  @JsonKey(name: r'REF_ID')
  final StringWithAggregatesFilter? refId;

  @JsonKey(name: r'REF_NM')
  final StringNullableWithAggregatesFilter? refNm;

  @JsonKey(name: r'REF_DEP')
  final StringNullableWithAggregatesFilter? refDep;

  @JsonKey(name: r'REF_GRADE')
  final StringNullableWithAggregatesFilter? refGrade;

  @JsonKey(name: r'REG_ID')
  final StringWithAggregatesFilter? regId;

  @JsonKey(name: r'REG_DATE')
  final StringWithAggregatesFilter? regDate;

  @JsonKey(name: r'EDIT_ID')
  final StringNullableWithAggregatesFilter? editId;

  @JsonKey(name: r'EDIT_DATE')
  final StringNullableWithAggregatesFilter? editDate;

  @JsonKey(name: r'DEL_ID')
  final StringNullableWithAggregatesFilter? delId;

  @JsonKey(name: r'DEL_DATE')
  final StringNullableWithAggregatesFilter? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREQUESTREFScalarWhereWithAggregatesInputToJson(this);
}

@_i1.jsonSerializable
class ALLCODETBLCreateInput implements _i1.JsonSerializable {
  const ALLCODETBLCreateInput({
    required this.codeType,
    this.codeName,
    required this.unitType,
    this.unitName,
    this.sort,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory ALLCODETBLCreateInput.fromJson(Map<String, dynamic> json) =>
      _$ALLCODETBLCreateInputFromJson(json);

  @JsonKey(name: r'CODE_TYPE')
  final String codeType;

  @JsonKey(name: r'CODE_NAME')
  final String? codeName;

  @JsonKey(name: r'UNIT_TYPE')
  final String unitType;

  @JsonKey(name: r'UNIT_NAME')
  final String? unitName;

  @JsonKey(name: r'SORT')
  final int? sort;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() => _$ALLCODETBLCreateInputToJson(this);
}

@_i1.jsonSerializable
class ALLCODETBLUncheckedCreateInput implements _i1.JsonSerializable {
  const ALLCODETBLUncheckedCreateInput({
    required this.codeType,
    this.codeName,
    required this.unitType,
    this.unitName,
    this.sort,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory ALLCODETBLUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$ALLCODETBLUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'CODE_TYPE')
  final String codeType;

  @JsonKey(name: r'CODE_NAME')
  final String? codeName;

  @JsonKey(name: r'UNIT_TYPE')
  final String unitType;

  @JsonKey(name: r'UNIT_NAME')
  final String? unitName;

  @JsonKey(name: r'SORT')
  final int? sort;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() => _$ALLCODETBLUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class ALLCODETBLUpdateInput implements _i1.JsonSerializable {
  const ALLCODETBLUpdateInput({
    this.codeType,
    this.codeName,
    this.unitType,
    this.unitName,
    this.sort,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory ALLCODETBLUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$ALLCODETBLUpdateInputFromJson(json);

  @JsonKey(name: r'CODE_TYPE')
  final StringFieldUpdateOperationsInput? codeType;

  @JsonKey(name: r'CODE_NAME')
  final NullableStringFieldUpdateOperationsInput? codeName;

  @JsonKey(name: r'UNIT_TYPE')
  final StringFieldUpdateOperationsInput? unitType;

  @JsonKey(name: r'UNIT_NAME')
  final NullableStringFieldUpdateOperationsInput? unitName;

  @JsonKey(name: r'SORT')
  final NullableIntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeFieldUpdateOperationsInput? updDate;

  @override
  Map<String, dynamic> toJson() => _$ALLCODETBLUpdateInputToJson(this);
}

@_i1.jsonSerializable
class ALLCODETBLUncheckedUpdateInput implements _i1.JsonSerializable {
  const ALLCODETBLUncheckedUpdateInput({
    this.codeType,
    this.codeName,
    this.unitType,
    this.unitName,
    this.sort,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory ALLCODETBLUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$ALLCODETBLUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'CODE_TYPE')
  final StringFieldUpdateOperationsInput? codeType;

  @JsonKey(name: r'CODE_NAME')
  final NullableStringFieldUpdateOperationsInput? codeName;

  @JsonKey(name: r'UNIT_TYPE')
  final StringFieldUpdateOperationsInput? unitType;

  @JsonKey(name: r'UNIT_NAME')
  final NullableStringFieldUpdateOperationsInput? unitName;

  @JsonKey(name: r'SORT')
  final NullableIntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeFieldUpdateOperationsInput? updDate;

  @override
  Map<String, dynamic> toJson() => _$ALLCODETBLUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class ALLCODETBLCreateManyInput implements _i1.JsonSerializable {
  const ALLCODETBLCreateManyInput({
    required this.codeType,
    this.codeName,
    required this.unitType,
    this.unitName,
    this.sort,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory ALLCODETBLCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$ALLCODETBLCreateManyInputFromJson(json);

  @JsonKey(name: r'CODE_TYPE')
  final String codeType;

  @JsonKey(name: r'CODE_NAME')
  final String? codeName;

  @JsonKey(name: r'UNIT_TYPE')
  final String unitType;

  @JsonKey(name: r'UNIT_NAME')
  final String? unitName;

  @JsonKey(name: r'SORT')
  final int? sort;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() => _$ALLCODETBLCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class ALLCODETBLUpdateManyMutationInput implements _i1.JsonSerializable {
  const ALLCODETBLUpdateManyMutationInput({
    this.codeType,
    this.codeName,
    this.unitType,
    this.unitName,
    this.sort,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory ALLCODETBLUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$ALLCODETBLUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'CODE_TYPE')
  final StringFieldUpdateOperationsInput? codeType;

  @JsonKey(name: r'CODE_NAME')
  final NullableStringFieldUpdateOperationsInput? codeName;

  @JsonKey(name: r'UNIT_TYPE')
  final StringFieldUpdateOperationsInput? unitType;

  @JsonKey(name: r'UNIT_NAME')
  final NullableStringFieldUpdateOperationsInput? unitName;

  @JsonKey(name: r'SORT')
  final NullableIntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeFieldUpdateOperationsInput? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$ALLCODETBLUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class ALLCODETBLUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const ALLCODETBLUncheckedUpdateManyInput({
    this.codeType,
    this.codeName,
    this.unitType,
    this.unitName,
    this.sort,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory ALLCODETBLUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$ALLCODETBLUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'CODE_TYPE')
  final StringFieldUpdateOperationsInput? codeType;

  @JsonKey(name: r'CODE_NAME')
  final NullableStringFieldUpdateOperationsInput? codeName;

  @JsonKey(name: r'UNIT_TYPE')
  final StringFieldUpdateOperationsInput? unitType;

  @JsonKey(name: r'UNIT_NAME')
  final NullableStringFieldUpdateOperationsInput? unitName;

  @JsonKey(name: r'SORT')
  final NullableIntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeFieldUpdateOperationsInput? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$ALLCODETBLUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALATTACHFILETBLCreateInput implements _i1.JsonSerializable {
  const APPROVALATTACHFILETBLCreateInput({
    required this.approvalId,
    required this.seq,
    this.oriFileNm,
    this.saveFileNm,
    this.fileSize,
    this.regDate,
  });

  factory APPROVALATTACHFILETBLCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALATTACHFILETBLCreateInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final String approvalId;

  @JsonKey(name: r'SEQ')
  final double seq;

  @JsonKey(name: r'ORI_FILE_NM')
  final String? oriFileNm;

  @JsonKey(name: r'SAVE_FILE_NM')
  final String? saveFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final int? fileSize;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALATTACHFILETBLCreateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALATTACHFILETBLUncheckedCreateInput
    implements _i1.JsonSerializable {
  const APPROVALATTACHFILETBLUncheckedCreateInput({
    required this.approvalId,
    required this.seq,
    this.oriFileNm,
    this.saveFileNm,
    this.fileSize,
    this.regDate,
  });

  factory APPROVALATTACHFILETBLUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALATTACHFILETBLUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final String approvalId;

  @JsonKey(name: r'SEQ')
  final double seq;

  @JsonKey(name: r'ORI_FILE_NM')
  final String? oriFileNm;

  @JsonKey(name: r'SAVE_FILE_NM')
  final String? saveFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final int? fileSize;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALATTACHFILETBLUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALATTACHFILETBLUpdateInput implements _i1.JsonSerializable {
  const APPROVALATTACHFILETBLUpdateInput({
    this.approvalId,
    this.seq,
    this.oriFileNm,
    this.saveFileNm,
    this.fileSize,
    this.regDate,
  });

  factory APPROVALATTACHFILETBLUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALATTACHFILETBLUpdateInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final StringFieldUpdateOperationsInput? approvalId;

  @JsonKey(name: r'SEQ')
  final DecimalFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'ORI_FILE_NM')
  final NullableStringFieldUpdateOperationsInput? oriFileNm;

  @JsonKey(name: r'SAVE_FILE_NM')
  final NullableStringFieldUpdateOperationsInput? saveFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final NullableIntFieldUpdateOperationsInput? fileSize;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALATTACHFILETBLUpdateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALATTACHFILETBLUncheckedUpdateInput
    implements _i1.JsonSerializable {
  const APPROVALATTACHFILETBLUncheckedUpdateInput({
    this.approvalId,
    this.seq,
    this.oriFileNm,
    this.saveFileNm,
    this.fileSize,
    this.regDate,
  });

  factory APPROVALATTACHFILETBLUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALATTACHFILETBLUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final StringFieldUpdateOperationsInput? approvalId;

  @JsonKey(name: r'SEQ')
  final DecimalFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'ORI_FILE_NM')
  final NullableStringFieldUpdateOperationsInput? oriFileNm;

  @JsonKey(name: r'SAVE_FILE_NM')
  final NullableStringFieldUpdateOperationsInput? saveFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final NullableIntFieldUpdateOperationsInput? fileSize;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALATTACHFILETBLUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALATTACHFILETBLCreateManyInput implements _i1.JsonSerializable {
  const APPROVALATTACHFILETBLCreateManyInput({
    required this.approvalId,
    required this.seq,
    this.oriFileNm,
    this.saveFileNm,
    this.fileSize,
    this.regDate,
  });

  factory APPROVALATTACHFILETBLCreateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALATTACHFILETBLCreateManyInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final String approvalId;

  @JsonKey(name: r'SEQ')
  final double seq;

  @JsonKey(name: r'ORI_FILE_NM')
  final String? oriFileNm;

  @JsonKey(name: r'SAVE_FILE_NM')
  final String? saveFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final int? fileSize;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALATTACHFILETBLCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALATTACHFILETBLUpdateManyMutationInput
    implements _i1.JsonSerializable {
  const APPROVALATTACHFILETBLUpdateManyMutationInput({
    this.approvalId,
    this.seq,
    this.oriFileNm,
    this.saveFileNm,
    this.fileSize,
    this.regDate,
  });

  factory APPROVALATTACHFILETBLUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALATTACHFILETBLUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final StringFieldUpdateOperationsInput? approvalId;

  @JsonKey(name: r'SEQ')
  final DecimalFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'ORI_FILE_NM')
  final NullableStringFieldUpdateOperationsInput? oriFileNm;

  @JsonKey(name: r'SAVE_FILE_NM')
  final NullableStringFieldUpdateOperationsInput? saveFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final NullableIntFieldUpdateOperationsInput? fileSize;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALATTACHFILETBLUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALATTACHFILETBLUncheckedUpdateManyInput
    implements _i1.JsonSerializable {
  const APPROVALATTACHFILETBLUncheckedUpdateManyInput({
    this.approvalId,
    this.seq,
    this.oriFileNm,
    this.saveFileNm,
    this.fileSize,
    this.regDate,
  });

  factory APPROVALATTACHFILETBLUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALATTACHFILETBLUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final StringFieldUpdateOperationsInput? approvalId;

  @JsonKey(name: r'SEQ')
  final DecimalFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'ORI_FILE_NM')
  final NullableStringFieldUpdateOperationsInput? oriFileNm;

  @JsonKey(name: r'SAVE_FILE_NM')
  final NullableStringFieldUpdateOperationsInput? saveFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final NullableIntFieldUpdateOperationsInput? fileSize;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALATTACHFILETBLUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALDOCINFOTBLCreateInput implements _i1.JsonSerializable {
  const APPROVALDOCINFOTBLCreateInput({
    this.seq,
    this.docType,
    this.docNm,
    required this.title,
    this.approvalLineType,
    this.approvalLineContent,
    this.approvalLineContentBak,
    this.content,
    this.writerId,
    this.userNm,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
  });

  factory APPROVALDOCINFOTBLCreateInput.fromJson(Map<String, dynamic> json) =>
      _$APPROVALDOCINFOTBLCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'DOC_TYPE')
  final String? docType;

  @JsonKey(name: r'DOC_NM')
  final String? docNm;

  @JsonKey(name: r'TITLE')
  final String title;

  @JsonKey(name: r'APPROVAL_LINE_TYPE')
  final String? approvalLineType;

  @JsonKey(name: r'APPROVAL_LINE_CONTENT')
  final String? approvalLineContent;

  @JsonKey(name: r'APPROVAL_LINE_CONTENT_BAK')
  final String? approvalLineContentBak;

  @JsonKey(name: r'CONTENT')
  final String? content;

  @JsonKey(name: r'WRITER_ID')
  final String? writerId;

  @JsonKey(name: r'USER_NM')
  final String? userNm;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() => _$APPROVALDOCINFOTBLCreateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALDOCINFOTBLUncheckedCreateInput implements _i1.JsonSerializable {
  const APPROVALDOCINFOTBLUncheckedCreateInput({
    this.seq,
    this.docType,
    this.docNm,
    required this.title,
    this.approvalLineType,
    this.approvalLineContent,
    this.approvalLineContentBak,
    this.content,
    this.writerId,
    this.userNm,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
  });

  factory APPROVALDOCINFOTBLUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALDOCINFOTBLUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'DOC_TYPE')
  final String? docType;

  @JsonKey(name: r'DOC_NM')
  final String? docNm;

  @JsonKey(name: r'TITLE')
  final String title;

  @JsonKey(name: r'APPROVAL_LINE_TYPE')
  final String? approvalLineType;

  @JsonKey(name: r'APPROVAL_LINE_CONTENT')
  final String? approvalLineContent;

  @JsonKey(name: r'APPROVAL_LINE_CONTENT_BAK')
  final String? approvalLineContentBak;

  @JsonKey(name: r'CONTENT')
  final String? content;

  @JsonKey(name: r'WRITER_ID')
  final String? writerId;

  @JsonKey(name: r'USER_NM')
  final String? userNm;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALDOCINFOTBLUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALDOCINFOTBLUpdateInput implements _i1.JsonSerializable {
  const APPROVALDOCINFOTBLUpdateInput({
    this.seq,
    this.docType,
    this.docNm,
    this.title,
    this.approvalLineType,
    this.approvalLineContent,
    this.approvalLineContentBak,
    this.content,
    this.writerId,
    this.userNm,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
  });

  factory APPROVALDOCINFOTBLUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$APPROVALDOCINFOTBLUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'DOC_TYPE')
  final NullableStringFieldUpdateOperationsInput? docType;

  @JsonKey(name: r'DOC_NM')
  final NullableStringFieldUpdateOperationsInput? docNm;

  @JsonKey(name: r'TITLE')
  final StringFieldUpdateOperationsInput? title;

  @JsonKey(name: r'APPROVAL_LINE_TYPE')
  final NullableStringFieldUpdateOperationsInput? approvalLineType;

  @JsonKey(name: r'APPROVAL_LINE_CONTENT')
  final NullableStringFieldUpdateOperationsInput? approvalLineContent;

  @JsonKey(name: r'APPROVAL_LINE_CONTENT_BAK')
  final NullableStringFieldUpdateOperationsInput? approvalLineContentBak;

  @JsonKey(name: r'CONTENT')
  final NullableStringFieldUpdateOperationsInput? content;

  @JsonKey(name: r'WRITER_ID')
  final NullableStringFieldUpdateOperationsInput? writerId;

  @JsonKey(name: r'USER_NM')
  final NullableStringFieldUpdateOperationsInput? userNm;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() => _$APPROVALDOCINFOTBLUpdateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALDOCINFOTBLUncheckedUpdateInput implements _i1.JsonSerializable {
  const APPROVALDOCINFOTBLUncheckedUpdateInput({
    this.seq,
    this.docType,
    this.docNm,
    this.title,
    this.approvalLineType,
    this.approvalLineContent,
    this.approvalLineContentBak,
    this.content,
    this.writerId,
    this.userNm,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
  });

  factory APPROVALDOCINFOTBLUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALDOCINFOTBLUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'DOC_TYPE')
  final NullableStringFieldUpdateOperationsInput? docType;

  @JsonKey(name: r'DOC_NM')
  final NullableStringFieldUpdateOperationsInput? docNm;

  @JsonKey(name: r'TITLE')
  final StringFieldUpdateOperationsInput? title;

  @JsonKey(name: r'APPROVAL_LINE_TYPE')
  final NullableStringFieldUpdateOperationsInput? approvalLineType;

  @JsonKey(name: r'APPROVAL_LINE_CONTENT')
  final NullableStringFieldUpdateOperationsInput? approvalLineContent;

  @JsonKey(name: r'APPROVAL_LINE_CONTENT_BAK')
  final NullableStringFieldUpdateOperationsInput? approvalLineContentBak;

  @JsonKey(name: r'CONTENT')
  final NullableStringFieldUpdateOperationsInput? content;

  @JsonKey(name: r'WRITER_ID')
  final NullableStringFieldUpdateOperationsInput? writerId;

  @JsonKey(name: r'USER_NM')
  final NullableStringFieldUpdateOperationsInput? userNm;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALDOCINFOTBLUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALDOCINFOTBLCreateManyInput implements _i1.JsonSerializable {
  const APPROVALDOCINFOTBLCreateManyInput({
    this.seq,
    this.docType,
    this.docNm,
    required this.title,
    this.approvalLineType,
    this.approvalLineContent,
    this.approvalLineContentBak,
    this.content,
    this.writerId,
    this.userNm,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
  });

  factory APPROVALDOCINFOTBLCreateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALDOCINFOTBLCreateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'DOC_TYPE')
  final String? docType;

  @JsonKey(name: r'DOC_NM')
  final String? docNm;

  @JsonKey(name: r'TITLE')
  final String title;

  @JsonKey(name: r'APPROVAL_LINE_TYPE')
  final String? approvalLineType;

  @JsonKey(name: r'APPROVAL_LINE_CONTENT')
  final String? approvalLineContent;

  @JsonKey(name: r'APPROVAL_LINE_CONTENT_BAK')
  final String? approvalLineContentBak;

  @JsonKey(name: r'CONTENT')
  final String? content;

  @JsonKey(name: r'WRITER_ID')
  final String? writerId;

  @JsonKey(name: r'USER_NM')
  final String? userNm;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALDOCINFOTBLCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALDOCINFOTBLUpdateManyMutationInput
    implements _i1.JsonSerializable {
  const APPROVALDOCINFOTBLUpdateManyMutationInput({
    this.seq,
    this.docType,
    this.docNm,
    this.title,
    this.approvalLineType,
    this.approvalLineContent,
    this.approvalLineContentBak,
    this.content,
    this.writerId,
    this.userNm,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
  });

  factory APPROVALDOCINFOTBLUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALDOCINFOTBLUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'DOC_TYPE')
  final NullableStringFieldUpdateOperationsInput? docType;

  @JsonKey(name: r'DOC_NM')
  final NullableStringFieldUpdateOperationsInput? docNm;

  @JsonKey(name: r'TITLE')
  final StringFieldUpdateOperationsInput? title;

  @JsonKey(name: r'APPROVAL_LINE_TYPE')
  final NullableStringFieldUpdateOperationsInput? approvalLineType;

  @JsonKey(name: r'APPROVAL_LINE_CONTENT')
  final NullableStringFieldUpdateOperationsInput? approvalLineContent;

  @JsonKey(name: r'APPROVAL_LINE_CONTENT_BAK')
  final NullableStringFieldUpdateOperationsInput? approvalLineContentBak;

  @JsonKey(name: r'CONTENT')
  final NullableStringFieldUpdateOperationsInput? content;

  @JsonKey(name: r'WRITER_ID')
  final NullableStringFieldUpdateOperationsInput? writerId;

  @JsonKey(name: r'USER_NM')
  final NullableStringFieldUpdateOperationsInput? userNm;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALDOCINFOTBLUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALDOCINFOTBLUncheckedUpdateManyInput
    implements _i1.JsonSerializable {
  const APPROVALDOCINFOTBLUncheckedUpdateManyInput({
    this.seq,
    this.docType,
    this.docNm,
    this.title,
    this.approvalLineType,
    this.approvalLineContent,
    this.approvalLineContentBak,
    this.content,
    this.writerId,
    this.userNm,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
  });

  factory APPROVALDOCINFOTBLUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALDOCINFOTBLUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'DOC_TYPE')
  final NullableStringFieldUpdateOperationsInput? docType;

  @JsonKey(name: r'DOC_NM')
  final NullableStringFieldUpdateOperationsInput? docNm;

  @JsonKey(name: r'TITLE')
  final StringFieldUpdateOperationsInput? title;

  @JsonKey(name: r'APPROVAL_LINE_TYPE')
  final NullableStringFieldUpdateOperationsInput? approvalLineType;

  @JsonKey(name: r'APPROVAL_LINE_CONTENT')
  final NullableStringFieldUpdateOperationsInput? approvalLineContent;

  @JsonKey(name: r'APPROVAL_LINE_CONTENT_BAK')
  final NullableStringFieldUpdateOperationsInput? approvalLineContentBak;

  @JsonKey(name: r'CONTENT')
  final NullableStringFieldUpdateOperationsInput? content;

  @JsonKey(name: r'WRITER_ID')
  final NullableStringFieldUpdateOperationsInput? writerId;

  @JsonKey(name: r'USER_NM')
  final NullableStringFieldUpdateOperationsInput? userNm;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALDOCINFOTBLUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALHISTORYTBLCreateInput implements _i1.JsonSerializable {
  const APPROVALHISTORYTBLCreateInput({
    this.seq,
    required this.approvalId,
    required this.writerId,
    required this.writerNm,
    required this.docType,
    this.keepPriod,
    this.keepDate,
    this.grade,
    this.status,
    this.content,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALHISTORYTBLCreateInput.fromJson(Map<String, dynamic> json) =>
      _$APPROVALHISTORYTBLCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'APPROVAL_ID')
  final String approvalId;

  @JsonKey(name: r'WRITER_ID')
  final String writerId;

  @JsonKey(name: r'WRITER_NM')
  final String writerNm;

  @JsonKey(name: r'DOC_TYPE')
  final String docType;

  @JsonKey(name: r'KEEP_PRIOD')
  final int? keepPriod;

  @JsonKey(name: r'KEEP_DATE')
  final DateTime? keepDate;

  @JsonKey(name: r'GRADE')
  final String? grade;

  @JsonKey(name: r'STATUS')
  final String? status;

  @JsonKey(name: r'CONTENT')
  final String? content;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() => _$APPROVALHISTORYTBLCreateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALHISTORYTBLUncheckedCreateInput implements _i1.JsonSerializable {
  const APPROVALHISTORYTBLUncheckedCreateInput({
    this.seq,
    required this.approvalId,
    required this.writerId,
    required this.writerNm,
    required this.docType,
    this.keepPriod,
    this.keepDate,
    this.grade,
    this.status,
    this.content,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALHISTORYTBLUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALHISTORYTBLUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'APPROVAL_ID')
  final String approvalId;

  @JsonKey(name: r'WRITER_ID')
  final String writerId;

  @JsonKey(name: r'WRITER_NM')
  final String writerNm;

  @JsonKey(name: r'DOC_TYPE')
  final String docType;

  @JsonKey(name: r'KEEP_PRIOD')
  final int? keepPriod;

  @JsonKey(name: r'KEEP_DATE')
  final DateTime? keepDate;

  @JsonKey(name: r'GRADE')
  final String? grade;

  @JsonKey(name: r'STATUS')
  final String? status;

  @JsonKey(name: r'CONTENT')
  final String? content;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALHISTORYTBLUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALHISTORYTBLUpdateInput implements _i1.JsonSerializable {
  const APPROVALHISTORYTBLUpdateInput({
    this.seq,
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.docType,
    this.keepPriod,
    this.keepDate,
    this.grade,
    this.status,
    this.content,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALHISTORYTBLUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$APPROVALHISTORYTBLUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'APPROVAL_ID')
  final StringFieldUpdateOperationsInput? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final StringFieldUpdateOperationsInput? writerId;

  @JsonKey(name: r'WRITER_NM')
  final StringFieldUpdateOperationsInput? writerNm;

  @JsonKey(name: r'DOC_TYPE')
  final StringFieldUpdateOperationsInput? docType;

  @JsonKey(name: r'KEEP_PRIOD')
  final IntFieldUpdateOperationsInput? keepPriod;

  @JsonKey(name: r'KEEP_DATE')
  final DateTimeFieldUpdateOperationsInput? keepDate;

  @JsonKey(name: r'GRADE')
  final StringFieldUpdateOperationsInput? grade;

  @JsonKey(name: r'STATUS')
  final NullableStringFieldUpdateOperationsInput? status;

  @JsonKey(name: r'CONTENT')
  final NullableStringFieldUpdateOperationsInput? content;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() => _$APPROVALHISTORYTBLUpdateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALHISTORYTBLUncheckedUpdateInput implements _i1.JsonSerializable {
  const APPROVALHISTORYTBLUncheckedUpdateInput({
    this.seq,
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.docType,
    this.keepPriod,
    this.keepDate,
    this.grade,
    this.status,
    this.content,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALHISTORYTBLUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALHISTORYTBLUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'APPROVAL_ID')
  final StringFieldUpdateOperationsInput? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final StringFieldUpdateOperationsInput? writerId;

  @JsonKey(name: r'WRITER_NM')
  final StringFieldUpdateOperationsInput? writerNm;

  @JsonKey(name: r'DOC_TYPE')
  final StringFieldUpdateOperationsInput? docType;

  @JsonKey(name: r'KEEP_PRIOD')
  final IntFieldUpdateOperationsInput? keepPriod;

  @JsonKey(name: r'KEEP_DATE')
  final DateTimeFieldUpdateOperationsInput? keepDate;

  @JsonKey(name: r'GRADE')
  final StringFieldUpdateOperationsInput? grade;

  @JsonKey(name: r'STATUS')
  final NullableStringFieldUpdateOperationsInput? status;

  @JsonKey(name: r'CONTENT')
  final NullableStringFieldUpdateOperationsInput? content;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALHISTORYTBLUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALHISTORYTBLCreateManyInput implements _i1.JsonSerializable {
  const APPROVALHISTORYTBLCreateManyInput({
    this.seq,
    required this.approvalId,
    required this.writerId,
    required this.writerNm,
    required this.docType,
    this.keepPriod,
    this.keepDate,
    this.grade,
    this.status,
    this.content,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALHISTORYTBLCreateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALHISTORYTBLCreateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'APPROVAL_ID')
  final String approvalId;

  @JsonKey(name: r'WRITER_ID')
  final String writerId;

  @JsonKey(name: r'WRITER_NM')
  final String writerNm;

  @JsonKey(name: r'DOC_TYPE')
  final String docType;

  @JsonKey(name: r'KEEP_PRIOD')
  final int? keepPriod;

  @JsonKey(name: r'KEEP_DATE')
  final DateTime? keepDate;

  @JsonKey(name: r'GRADE')
  final String? grade;

  @JsonKey(name: r'STATUS')
  final String? status;

  @JsonKey(name: r'CONTENT')
  final String? content;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALHISTORYTBLCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALHISTORYTBLUpdateManyMutationInput
    implements _i1.JsonSerializable {
  const APPROVALHISTORYTBLUpdateManyMutationInput({
    this.seq,
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.docType,
    this.keepPriod,
    this.keepDate,
    this.grade,
    this.status,
    this.content,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALHISTORYTBLUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALHISTORYTBLUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'APPROVAL_ID')
  final StringFieldUpdateOperationsInput? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final StringFieldUpdateOperationsInput? writerId;

  @JsonKey(name: r'WRITER_NM')
  final StringFieldUpdateOperationsInput? writerNm;

  @JsonKey(name: r'DOC_TYPE')
  final StringFieldUpdateOperationsInput? docType;

  @JsonKey(name: r'KEEP_PRIOD')
  final IntFieldUpdateOperationsInput? keepPriod;

  @JsonKey(name: r'KEEP_DATE')
  final DateTimeFieldUpdateOperationsInput? keepDate;

  @JsonKey(name: r'GRADE')
  final StringFieldUpdateOperationsInput? grade;

  @JsonKey(name: r'STATUS')
  final NullableStringFieldUpdateOperationsInput? status;

  @JsonKey(name: r'CONTENT')
  final NullableStringFieldUpdateOperationsInput? content;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALHISTORYTBLUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALHISTORYTBLUncheckedUpdateManyInput
    implements _i1.JsonSerializable {
  const APPROVALHISTORYTBLUncheckedUpdateManyInput({
    this.seq,
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.docType,
    this.keepPriod,
    this.keepDate,
    this.grade,
    this.status,
    this.content,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALHISTORYTBLUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALHISTORYTBLUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'APPROVAL_ID')
  final StringFieldUpdateOperationsInput? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final StringFieldUpdateOperationsInput? writerId;

  @JsonKey(name: r'WRITER_NM')
  final StringFieldUpdateOperationsInput? writerNm;

  @JsonKey(name: r'DOC_TYPE')
  final StringFieldUpdateOperationsInput? docType;

  @JsonKey(name: r'KEEP_PRIOD')
  final IntFieldUpdateOperationsInput? keepPriod;

  @JsonKey(name: r'KEEP_DATE')
  final DateTimeFieldUpdateOperationsInput? keepDate;

  @JsonKey(name: r'GRADE')
  final StringFieldUpdateOperationsInput? grade;

  @JsonKey(name: r'STATUS')
  final NullableStringFieldUpdateOperationsInput? status;

  @JsonKey(name: r'CONTENT')
  final NullableStringFieldUpdateOperationsInput? content;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALHISTORYTBLUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALMASTERTBLCreateInput implements _i1.JsonSerializable {
  const APPROVALMASTERTBLCreateInput({
    required this.approvalId,
    required this.writerId,
    required this.writerNm,
    required this.docType,
    this.keepPriod,
    this.keepDate,
    this.grade,
    this.status,
    this.title,
    this.header,
    this.content,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
    this.regDate,
    this.completeDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALMASTERTBLCreateInput.fromJson(Map<String, dynamic> json) =>
      _$APPROVALMASTERTBLCreateInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final String approvalId;

  @JsonKey(name: r'WRITER_ID')
  final String writerId;

  @JsonKey(name: r'WRITER_NM')
  final String writerNm;

  @JsonKey(name: r'DOC_TYPE')
  final String docType;

  @JsonKey(name: r'KEEP_PRIOD')
  final int? keepPriod;

  @JsonKey(name: r'KEEP_DATE')
  final DateTime? keepDate;

  @JsonKey(name: r'GRADE')
  final String? grade;

  @JsonKey(name: r'STATUS')
  final String? status;

  @JsonKey(name: r'TITLE')
  final String? title;

  @JsonKey(name: r'HEADER')
  final String? header;

  @JsonKey(name: r'CONTENT')
  final String? content;

  @JsonKey(name: r'M1')
  final double? m1;

  @JsonKey(name: r'M2')
  final double? m2;

  @JsonKey(name: r'M3')
  final double? m3;

  @JsonKey(name: r'M4')
  final double? m4;

  @JsonKey(name: r'M5')
  final double? m5;

  @JsonKey(name: r'M6')
  final double? m6;

  @JsonKey(name: r'M7')
  final double? m7;

  @JsonKey(name: r'M8')
  final double? m8;

  @JsonKey(name: r'M9')
  final double? m9;

  @JsonKey(name: r'M10')
  final double? m10;

  @JsonKey(name: r'M11')
  final double? m11;

  @JsonKey(name: r'M12')
  final double? m12;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'COMPLETE_DATE')
  final DateTime? completeDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() => _$APPROVALMASTERTBLCreateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALMASTERTBLUncheckedCreateInput implements _i1.JsonSerializable {
  const APPROVALMASTERTBLUncheckedCreateInput({
    required this.approvalId,
    required this.writerId,
    required this.writerNm,
    required this.docType,
    this.keepPriod,
    this.keepDate,
    this.grade,
    this.status,
    this.title,
    this.header,
    this.content,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
    this.regDate,
    this.completeDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALMASTERTBLUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALMASTERTBLUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final String approvalId;

  @JsonKey(name: r'WRITER_ID')
  final String writerId;

  @JsonKey(name: r'WRITER_NM')
  final String writerNm;

  @JsonKey(name: r'DOC_TYPE')
  final String docType;

  @JsonKey(name: r'KEEP_PRIOD')
  final int? keepPriod;

  @JsonKey(name: r'KEEP_DATE')
  final DateTime? keepDate;

  @JsonKey(name: r'GRADE')
  final String? grade;

  @JsonKey(name: r'STATUS')
  final String? status;

  @JsonKey(name: r'TITLE')
  final String? title;

  @JsonKey(name: r'HEADER')
  final String? header;

  @JsonKey(name: r'CONTENT')
  final String? content;

  @JsonKey(name: r'M1')
  final double? m1;

  @JsonKey(name: r'M2')
  final double? m2;

  @JsonKey(name: r'M3')
  final double? m3;

  @JsonKey(name: r'M4')
  final double? m4;

  @JsonKey(name: r'M5')
  final double? m5;

  @JsonKey(name: r'M6')
  final double? m6;

  @JsonKey(name: r'M7')
  final double? m7;

  @JsonKey(name: r'M8')
  final double? m8;

  @JsonKey(name: r'M9')
  final double? m9;

  @JsonKey(name: r'M10')
  final double? m10;

  @JsonKey(name: r'M11')
  final double? m11;

  @JsonKey(name: r'M12')
  final double? m12;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'COMPLETE_DATE')
  final DateTime? completeDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALMASTERTBLUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALMASTERTBLUpdateInput implements _i1.JsonSerializable {
  const APPROVALMASTERTBLUpdateInput({
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.docType,
    this.keepPriod,
    this.keepDate,
    this.grade,
    this.status,
    this.title,
    this.header,
    this.content,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
    this.regDate,
    this.completeDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALMASTERTBLUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$APPROVALMASTERTBLUpdateInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final StringFieldUpdateOperationsInput? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final StringFieldUpdateOperationsInput? writerId;

  @JsonKey(name: r'WRITER_NM')
  final StringFieldUpdateOperationsInput? writerNm;

  @JsonKey(name: r'DOC_TYPE')
  final StringFieldUpdateOperationsInput? docType;

  @JsonKey(name: r'KEEP_PRIOD')
  final IntFieldUpdateOperationsInput? keepPriod;

  @JsonKey(name: r'KEEP_DATE')
  final DateTimeFieldUpdateOperationsInput? keepDate;

  @JsonKey(name: r'GRADE')
  final StringFieldUpdateOperationsInput? grade;

  @JsonKey(name: r'STATUS')
  final NullableStringFieldUpdateOperationsInput? status;

  @JsonKey(name: r'TITLE')
  final NullableStringFieldUpdateOperationsInput? title;

  @JsonKey(name: r'HEADER')
  final NullableStringFieldUpdateOperationsInput? header;

  @JsonKey(name: r'CONTENT')
  final NullableStringFieldUpdateOperationsInput? content;

  @JsonKey(name: r'M1')
  final NullableDecimalFieldUpdateOperationsInput? m1;

  @JsonKey(name: r'M2')
  final NullableDecimalFieldUpdateOperationsInput? m2;

  @JsonKey(name: r'M3')
  final NullableDecimalFieldUpdateOperationsInput? m3;

  @JsonKey(name: r'M4')
  final NullableDecimalFieldUpdateOperationsInput? m4;

  @JsonKey(name: r'M5')
  final NullableDecimalFieldUpdateOperationsInput? m5;

  @JsonKey(name: r'M6')
  final NullableDecimalFieldUpdateOperationsInput? m6;

  @JsonKey(name: r'M7')
  final NullableDecimalFieldUpdateOperationsInput? m7;

  @JsonKey(name: r'M8')
  final NullableDecimalFieldUpdateOperationsInput? m8;

  @JsonKey(name: r'M9')
  final NullableDecimalFieldUpdateOperationsInput? m9;

  @JsonKey(name: r'M10')
  final NullableDecimalFieldUpdateOperationsInput? m10;

  @JsonKey(name: r'M11')
  final NullableDecimalFieldUpdateOperationsInput? m11;

  @JsonKey(name: r'M12')
  final NullableDecimalFieldUpdateOperationsInput? m12;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'COMPLETE_DATE')
  final DateTimeFieldUpdateOperationsInput? completeDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() => _$APPROVALMASTERTBLUpdateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALMASTERTBLUncheckedUpdateInput implements _i1.JsonSerializable {
  const APPROVALMASTERTBLUncheckedUpdateInput({
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.docType,
    this.keepPriod,
    this.keepDate,
    this.grade,
    this.status,
    this.title,
    this.header,
    this.content,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
    this.regDate,
    this.completeDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALMASTERTBLUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALMASTERTBLUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final StringFieldUpdateOperationsInput? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final StringFieldUpdateOperationsInput? writerId;

  @JsonKey(name: r'WRITER_NM')
  final StringFieldUpdateOperationsInput? writerNm;

  @JsonKey(name: r'DOC_TYPE')
  final StringFieldUpdateOperationsInput? docType;

  @JsonKey(name: r'KEEP_PRIOD')
  final IntFieldUpdateOperationsInput? keepPriod;

  @JsonKey(name: r'KEEP_DATE')
  final DateTimeFieldUpdateOperationsInput? keepDate;

  @JsonKey(name: r'GRADE')
  final StringFieldUpdateOperationsInput? grade;

  @JsonKey(name: r'STATUS')
  final NullableStringFieldUpdateOperationsInput? status;

  @JsonKey(name: r'TITLE')
  final NullableStringFieldUpdateOperationsInput? title;

  @JsonKey(name: r'HEADER')
  final NullableStringFieldUpdateOperationsInput? header;

  @JsonKey(name: r'CONTENT')
  final NullableStringFieldUpdateOperationsInput? content;

  @JsonKey(name: r'M1')
  final NullableDecimalFieldUpdateOperationsInput? m1;

  @JsonKey(name: r'M2')
  final NullableDecimalFieldUpdateOperationsInput? m2;

  @JsonKey(name: r'M3')
  final NullableDecimalFieldUpdateOperationsInput? m3;

  @JsonKey(name: r'M4')
  final NullableDecimalFieldUpdateOperationsInput? m4;

  @JsonKey(name: r'M5')
  final NullableDecimalFieldUpdateOperationsInput? m5;

  @JsonKey(name: r'M6')
  final NullableDecimalFieldUpdateOperationsInput? m6;

  @JsonKey(name: r'M7')
  final NullableDecimalFieldUpdateOperationsInput? m7;

  @JsonKey(name: r'M8')
  final NullableDecimalFieldUpdateOperationsInput? m8;

  @JsonKey(name: r'M9')
  final NullableDecimalFieldUpdateOperationsInput? m9;

  @JsonKey(name: r'M10')
  final NullableDecimalFieldUpdateOperationsInput? m10;

  @JsonKey(name: r'M11')
  final NullableDecimalFieldUpdateOperationsInput? m11;

  @JsonKey(name: r'M12')
  final NullableDecimalFieldUpdateOperationsInput? m12;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'COMPLETE_DATE')
  final DateTimeFieldUpdateOperationsInput? completeDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALMASTERTBLUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALMASTERTBLCreateManyInput implements _i1.JsonSerializable {
  const APPROVALMASTERTBLCreateManyInput({
    required this.approvalId,
    required this.writerId,
    required this.writerNm,
    required this.docType,
    this.keepPriod,
    this.keepDate,
    this.grade,
    this.status,
    this.title,
    this.header,
    this.content,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
    this.regDate,
    this.completeDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALMASTERTBLCreateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALMASTERTBLCreateManyInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final String approvalId;

  @JsonKey(name: r'WRITER_ID')
  final String writerId;

  @JsonKey(name: r'WRITER_NM')
  final String writerNm;

  @JsonKey(name: r'DOC_TYPE')
  final String docType;

  @JsonKey(name: r'KEEP_PRIOD')
  final int? keepPriod;

  @JsonKey(name: r'KEEP_DATE')
  final DateTime? keepDate;

  @JsonKey(name: r'GRADE')
  final String? grade;

  @JsonKey(name: r'STATUS')
  final String? status;

  @JsonKey(name: r'TITLE')
  final String? title;

  @JsonKey(name: r'HEADER')
  final String? header;

  @JsonKey(name: r'CONTENT')
  final String? content;

  @JsonKey(name: r'M1')
  final double? m1;

  @JsonKey(name: r'M2')
  final double? m2;

  @JsonKey(name: r'M3')
  final double? m3;

  @JsonKey(name: r'M4')
  final double? m4;

  @JsonKey(name: r'M5')
  final double? m5;

  @JsonKey(name: r'M6')
  final double? m6;

  @JsonKey(name: r'M7')
  final double? m7;

  @JsonKey(name: r'M8')
  final double? m8;

  @JsonKey(name: r'M9')
  final double? m9;

  @JsonKey(name: r'M10')
  final double? m10;

  @JsonKey(name: r'M11')
  final double? m11;

  @JsonKey(name: r'M12')
  final double? m12;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'COMPLETE_DATE')
  final DateTime? completeDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALMASTERTBLCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALMASTERTBLUpdateManyMutationInput implements _i1.JsonSerializable {
  const APPROVALMASTERTBLUpdateManyMutationInput({
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.docType,
    this.keepPriod,
    this.keepDate,
    this.grade,
    this.status,
    this.title,
    this.header,
    this.content,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
    this.regDate,
    this.completeDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALMASTERTBLUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALMASTERTBLUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final StringFieldUpdateOperationsInput? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final StringFieldUpdateOperationsInput? writerId;

  @JsonKey(name: r'WRITER_NM')
  final StringFieldUpdateOperationsInput? writerNm;

  @JsonKey(name: r'DOC_TYPE')
  final StringFieldUpdateOperationsInput? docType;

  @JsonKey(name: r'KEEP_PRIOD')
  final IntFieldUpdateOperationsInput? keepPriod;

  @JsonKey(name: r'KEEP_DATE')
  final DateTimeFieldUpdateOperationsInput? keepDate;

  @JsonKey(name: r'GRADE')
  final StringFieldUpdateOperationsInput? grade;

  @JsonKey(name: r'STATUS')
  final NullableStringFieldUpdateOperationsInput? status;

  @JsonKey(name: r'TITLE')
  final NullableStringFieldUpdateOperationsInput? title;

  @JsonKey(name: r'HEADER')
  final NullableStringFieldUpdateOperationsInput? header;

  @JsonKey(name: r'CONTENT')
  final NullableStringFieldUpdateOperationsInput? content;

  @JsonKey(name: r'M1')
  final NullableDecimalFieldUpdateOperationsInput? m1;

  @JsonKey(name: r'M2')
  final NullableDecimalFieldUpdateOperationsInput? m2;

  @JsonKey(name: r'M3')
  final NullableDecimalFieldUpdateOperationsInput? m3;

  @JsonKey(name: r'M4')
  final NullableDecimalFieldUpdateOperationsInput? m4;

  @JsonKey(name: r'M5')
  final NullableDecimalFieldUpdateOperationsInput? m5;

  @JsonKey(name: r'M6')
  final NullableDecimalFieldUpdateOperationsInput? m6;

  @JsonKey(name: r'M7')
  final NullableDecimalFieldUpdateOperationsInput? m7;

  @JsonKey(name: r'M8')
  final NullableDecimalFieldUpdateOperationsInput? m8;

  @JsonKey(name: r'M9')
  final NullableDecimalFieldUpdateOperationsInput? m9;

  @JsonKey(name: r'M10')
  final NullableDecimalFieldUpdateOperationsInput? m10;

  @JsonKey(name: r'M11')
  final NullableDecimalFieldUpdateOperationsInput? m11;

  @JsonKey(name: r'M12')
  final NullableDecimalFieldUpdateOperationsInput? m12;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'COMPLETE_DATE')
  final DateTimeFieldUpdateOperationsInput? completeDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALMASTERTBLUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALMASTERTBLUncheckedUpdateManyInput
    implements _i1.JsonSerializable {
  const APPROVALMASTERTBLUncheckedUpdateManyInput({
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.docType,
    this.keepPriod,
    this.keepDate,
    this.grade,
    this.status,
    this.title,
    this.header,
    this.content,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
    this.regDate,
    this.completeDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALMASTERTBLUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALMASTERTBLUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final StringFieldUpdateOperationsInput? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final StringFieldUpdateOperationsInput? writerId;

  @JsonKey(name: r'WRITER_NM')
  final StringFieldUpdateOperationsInput? writerNm;

  @JsonKey(name: r'DOC_TYPE')
  final StringFieldUpdateOperationsInput? docType;

  @JsonKey(name: r'KEEP_PRIOD')
  final IntFieldUpdateOperationsInput? keepPriod;

  @JsonKey(name: r'KEEP_DATE')
  final DateTimeFieldUpdateOperationsInput? keepDate;

  @JsonKey(name: r'GRADE')
  final StringFieldUpdateOperationsInput? grade;

  @JsonKey(name: r'STATUS')
  final NullableStringFieldUpdateOperationsInput? status;

  @JsonKey(name: r'TITLE')
  final NullableStringFieldUpdateOperationsInput? title;

  @JsonKey(name: r'HEADER')
  final NullableStringFieldUpdateOperationsInput? header;

  @JsonKey(name: r'CONTENT')
  final NullableStringFieldUpdateOperationsInput? content;

  @JsonKey(name: r'M1')
  final NullableDecimalFieldUpdateOperationsInput? m1;

  @JsonKey(name: r'M2')
  final NullableDecimalFieldUpdateOperationsInput? m2;

  @JsonKey(name: r'M3')
  final NullableDecimalFieldUpdateOperationsInput? m3;

  @JsonKey(name: r'M4')
  final NullableDecimalFieldUpdateOperationsInput? m4;

  @JsonKey(name: r'M5')
  final NullableDecimalFieldUpdateOperationsInput? m5;

  @JsonKey(name: r'M6')
  final NullableDecimalFieldUpdateOperationsInput? m6;

  @JsonKey(name: r'M7')
  final NullableDecimalFieldUpdateOperationsInput? m7;

  @JsonKey(name: r'M8')
  final NullableDecimalFieldUpdateOperationsInput? m8;

  @JsonKey(name: r'M9')
  final NullableDecimalFieldUpdateOperationsInput? m9;

  @JsonKey(name: r'M10')
  final NullableDecimalFieldUpdateOperationsInput? m10;

  @JsonKey(name: r'M11')
  final NullableDecimalFieldUpdateOperationsInput? m11;

  @JsonKey(name: r'M12')
  final NullableDecimalFieldUpdateOperationsInput? m12;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'COMPLETE_DATE')
  final DateTimeFieldUpdateOperationsInput? completeDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALMASTERTBLUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALMEMOTBLCreateInput implements _i1.JsonSerializable {
  const APPROVALMEMOTBLCreateInput({
    this.seq,
    required this.approvalId,
    required this.writerId,
    required this.writerNm,
    this.content,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALMEMOTBLCreateInput.fromJson(Map<String, dynamic> json) =>
      _$APPROVALMEMOTBLCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'APPROVAL_ID')
  final String approvalId;

  @JsonKey(name: r'WRITER_ID')
  final String writerId;

  @JsonKey(name: r'WRITER_NM')
  final String writerNm;

  @JsonKey(name: r'CONTENT')
  final String? content;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() => _$APPROVALMEMOTBLCreateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALMEMOTBLUncheckedCreateInput implements _i1.JsonSerializable {
  const APPROVALMEMOTBLUncheckedCreateInput({
    this.seq,
    required this.approvalId,
    required this.writerId,
    required this.writerNm,
    this.content,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALMEMOTBLUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALMEMOTBLUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'APPROVAL_ID')
  final String approvalId;

  @JsonKey(name: r'WRITER_ID')
  final String writerId;

  @JsonKey(name: r'WRITER_NM')
  final String writerNm;

  @JsonKey(name: r'CONTENT')
  final String? content;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALMEMOTBLUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALMEMOTBLUpdateInput implements _i1.JsonSerializable {
  const APPROVALMEMOTBLUpdateInput({
    this.seq,
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.content,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALMEMOTBLUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$APPROVALMEMOTBLUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'APPROVAL_ID')
  final StringFieldUpdateOperationsInput? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final StringFieldUpdateOperationsInput? writerId;

  @JsonKey(name: r'WRITER_NM')
  final StringFieldUpdateOperationsInput? writerNm;

  @JsonKey(name: r'CONTENT')
  final NullableStringFieldUpdateOperationsInput? content;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() => _$APPROVALMEMOTBLUpdateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALMEMOTBLUncheckedUpdateInput implements _i1.JsonSerializable {
  const APPROVALMEMOTBLUncheckedUpdateInput({
    this.seq,
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.content,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALMEMOTBLUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALMEMOTBLUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'APPROVAL_ID')
  final StringFieldUpdateOperationsInput? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final StringFieldUpdateOperationsInput? writerId;

  @JsonKey(name: r'WRITER_NM')
  final StringFieldUpdateOperationsInput? writerNm;

  @JsonKey(name: r'CONTENT')
  final NullableStringFieldUpdateOperationsInput? content;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALMEMOTBLUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALMEMOTBLCreateManyInput implements _i1.JsonSerializable {
  const APPROVALMEMOTBLCreateManyInput({
    this.seq,
    required this.approvalId,
    required this.writerId,
    required this.writerNm,
    this.content,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALMEMOTBLCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$APPROVALMEMOTBLCreateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'APPROVAL_ID')
  final String approvalId;

  @JsonKey(name: r'WRITER_ID')
  final String writerId;

  @JsonKey(name: r'WRITER_NM')
  final String writerNm;

  @JsonKey(name: r'CONTENT')
  final String? content;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() => _$APPROVALMEMOTBLCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALMEMOTBLUpdateManyMutationInput implements _i1.JsonSerializable {
  const APPROVALMEMOTBLUpdateManyMutationInput({
    this.seq,
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.content,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALMEMOTBLUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALMEMOTBLUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'APPROVAL_ID')
  final StringFieldUpdateOperationsInput? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final StringFieldUpdateOperationsInput? writerId;

  @JsonKey(name: r'WRITER_NM')
  final StringFieldUpdateOperationsInput? writerNm;

  @JsonKey(name: r'CONTENT')
  final NullableStringFieldUpdateOperationsInput? content;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALMEMOTBLUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALMEMOTBLUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const APPROVALMEMOTBLUncheckedUpdateManyInput({
    this.seq,
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.content,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALMEMOTBLUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALMEMOTBLUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'APPROVAL_ID')
  final StringFieldUpdateOperationsInput? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final StringFieldUpdateOperationsInput? writerId;

  @JsonKey(name: r'WRITER_NM')
  final StringFieldUpdateOperationsInput? writerNm;

  @JsonKey(name: r'CONTENT')
  final NullableStringFieldUpdateOperationsInput? content;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALMEMOTBLUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALTYPETBLCreateInput implements _i1.JsonSerializable {
  const APPROVALTYPETBLCreateInput({
    required this.type,
    this.content,
    this.contentBak,
    this.useYn,
    this.delYn,
  });

  factory APPROVALTYPETBLCreateInput.fromJson(Map<String, dynamic> json) =>
      _$APPROVALTYPETBLCreateInputFromJson(json);

  @JsonKey(name: r'TYPE')
  final String type;

  @JsonKey(name: r'CONTENT')
  final String? content;

  @JsonKey(name: r'CONTENT_BAK')
  final String? contentBak;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() => _$APPROVALTYPETBLCreateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALTYPETBLUncheckedCreateInput implements _i1.JsonSerializable {
  const APPROVALTYPETBLUncheckedCreateInput({
    required this.type,
    this.content,
    this.contentBak,
    this.useYn,
    this.delYn,
  });

  factory APPROVALTYPETBLUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALTYPETBLUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'TYPE')
  final String type;

  @JsonKey(name: r'CONTENT')
  final String? content;

  @JsonKey(name: r'CONTENT_BAK')
  final String? contentBak;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALTYPETBLUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALTYPETBLUpdateInput implements _i1.JsonSerializable {
  const APPROVALTYPETBLUpdateInput({
    this.type,
    this.content,
    this.contentBak,
    this.useYn,
    this.delYn,
  });

  factory APPROVALTYPETBLUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$APPROVALTYPETBLUpdateInputFromJson(json);

  @JsonKey(name: r'TYPE')
  final StringFieldUpdateOperationsInput? type;

  @JsonKey(name: r'CONTENT')
  final NullableStringFieldUpdateOperationsInput? content;

  @JsonKey(name: r'CONTENT_BAK')
  final NullableStringFieldUpdateOperationsInput? contentBak;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() => _$APPROVALTYPETBLUpdateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALTYPETBLUncheckedUpdateInput implements _i1.JsonSerializable {
  const APPROVALTYPETBLUncheckedUpdateInput({
    this.type,
    this.content,
    this.contentBak,
    this.useYn,
    this.delYn,
  });

  factory APPROVALTYPETBLUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALTYPETBLUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'TYPE')
  final StringFieldUpdateOperationsInput? type;

  @JsonKey(name: r'CONTENT')
  final NullableStringFieldUpdateOperationsInput? content;

  @JsonKey(name: r'CONTENT_BAK')
  final NullableStringFieldUpdateOperationsInput? contentBak;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALTYPETBLUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALTYPETBLCreateManyInput implements _i1.JsonSerializable {
  const APPROVALTYPETBLCreateManyInput({
    required this.type,
    this.content,
    this.contentBak,
    this.useYn,
    this.delYn,
  });

  factory APPROVALTYPETBLCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$APPROVALTYPETBLCreateManyInputFromJson(json);

  @JsonKey(name: r'TYPE')
  final String type;

  @JsonKey(name: r'CONTENT')
  final String? content;

  @JsonKey(name: r'CONTENT_BAK')
  final String? contentBak;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() => _$APPROVALTYPETBLCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALTYPETBLUpdateManyMutationInput implements _i1.JsonSerializable {
  const APPROVALTYPETBLUpdateManyMutationInput({
    this.type,
    this.content,
    this.contentBak,
    this.useYn,
    this.delYn,
  });

  factory APPROVALTYPETBLUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALTYPETBLUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'TYPE')
  final StringFieldUpdateOperationsInput? type;

  @JsonKey(name: r'CONTENT')
  final NullableStringFieldUpdateOperationsInput? content;

  @JsonKey(name: r'CONTENT_BAK')
  final NullableStringFieldUpdateOperationsInput? contentBak;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALTYPETBLUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALTYPETBLUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const APPROVALTYPETBLUncheckedUpdateManyInput({
    this.type,
    this.content,
    this.contentBak,
    this.useYn,
    this.delYn,
  });

  factory APPROVALTYPETBLUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALTYPETBLUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'TYPE')
  final StringFieldUpdateOperationsInput? type;

  @JsonKey(name: r'CONTENT')
  final NullableStringFieldUpdateOperationsInput? content;

  @JsonKey(name: r'CONTENT_BAK')
  final NullableStringFieldUpdateOperationsInput? contentBak;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALTYPETBLUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALUSERTBLCreateInput implements _i1.JsonSerializable {
  const APPROVALUSERTBLCreateInput({
    required this.approvalId,
    required this.approvalUsrId,
    this.approvalUsrGradeCd,
    this.approvalUsrType,
    required this.approvalUsrSort,
    this.approvalProcUserYn,
    this.approvalProcYn,
    this.approvalProcDate,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALUSERTBLCreateInput.fromJson(Map<String, dynamic> json) =>
      _$APPROVALUSERTBLCreateInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final String approvalId;

  @JsonKey(name: r'APPROVAL_USR_ID')
  final String approvalUsrId;

  @JsonKey(name: r'APPROVAL_USR_GRADE_CD')
  final String? approvalUsrGradeCd;

  @JsonKey(name: r'APPROVAL_USR_TYPE')
  final String? approvalUsrType;

  @JsonKey(name: r'APPROVAL_USR_SORT')
  final int approvalUsrSort;

  @JsonKey(name: r'APPROVAL_PROC_USER_YN')
  final String? approvalProcUserYn;

  @JsonKey(name: r'APPROVAL_PROC_YN')
  final String? approvalProcYn;

  @JsonKey(name: r'APPROVAL_PROC_DATE')
  final DateTime? approvalProcDate;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() => _$APPROVALUSERTBLCreateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALUSERTBLUncheckedCreateInput implements _i1.JsonSerializable {
  const APPROVALUSERTBLUncheckedCreateInput({
    required this.approvalId,
    required this.approvalUsrId,
    this.approvalUsrGradeCd,
    this.approvalUsrType,
    required this.approvalUsrSort,
    this.approvalProcUserYn,
    this.approvalProcYn,
    this.approvalProcDate,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALUSERTBLUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALUSERTBLUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final String approvalId;

  @JsonKey(name: r'APPROVAL_USR_ID')
  final String approvalUsrId;

  @JsonKey(name: r'APPROVAL_USR_GRADE_CD')
  final String? approvalUsrGradeCd;

  @JsonKey(name: r'APPROVAL_USR_TYPE')
  final String? approvalUsrType;

  @JsonKey(name: r'APPROVAL_USR_SORT')
  final int approvalUsrSort;

  @JsonKey(name: r'APPROVAL_PROC_USER_YN')
  final String? approvalProcUserYn;

  @JsonKey(name: r'APPROVAL_PROC_YN')
  final String? approvalProcYn;

  @JsonKey(name: r'APPROVAL_PROC_DATE')
  final DateTime? approvalProcDate;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALUSERTBLUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALUSERTBLUpdateInput implements _i1.JsonSerializable {
  const APPROVALUSERTBLUpdateInput({
    this.approvalId,
    this.approvalUsrId,
    this.approvalUsrGradeCd,
    this.approvalUsrType,
    this.approvalUsrSort,
    this.approvalProcUserYn,
    this.approvalProcYn,
    this.approvalProcDate,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALUSERTBLUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$APPROVALUSERTBLUpdateInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final StringFieldUpdateOperationsInput? approvalId;

  @JsonKey(name: r'APPROVAL_USR_ID')
  final StringFieldUpdateOperationsInput? approvalUsrId;

  @JsonKey(name: r'APPROVAL_USR_GRADE_CD')
  final NullableStringFieldUpdateOperationsInput? approvalUsrGradeCd;

  @JsonKey(name: r'APPROVAL_USR_TYPE')
  final StringFieldUpdateOperationsInput? approvalUsrType;

  @JsonKey(name: r'APPROVAL_USR_SORT')
  final IntFieldUpdateOperationsInput? approvalUsrSort;

  @JsonKey(name: r'APPROVAL_PROC_USER_YN')
  final NullableStringFieldUpdateOperationsInput? approvalProcUserYn;

  @JsonKey(name: r'APPROVAL_PROC_YN')
  final StringFieldUpdateOperationsInput? approvalProcYn;

  @JsonKey(name: r'APPROVAL_PROC_DATE')
  final DateTimeFieldUpdateOperationsInput? approvalProcDate;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() => _$APPROVALUSERTBLUpdateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALUSERTBLUncheckedUpdateInput implements _i1.JsonSerializable {
  const APPROVALUSERTBLUncheckedUpdateInput({
    this.approvalId,
    this.approvalUsrId,
    this.approvalUsrGradeCd,
    this.approvalUsrType,
    this.approvalUsrSort,
    this.approvalProcUserYn,
    this.approvalProcYn,
    this.approvalProcDate,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALUSERTBLUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALUSERTBLUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final StringFieldUpdateOperationsInput? approvalId;

  @JsonKey(name: r'APPROVAL_USR_ID')
  final StringFieldUpdateOperationsInput? approvalUsrId;

  @JsonKey(name: r'APPROVAL_USR_GRADE_CD')
  final NullableStringFieldUpdateOperationsInput? approvalUsrGradeCd;

  @JsonKey(name: r'APPROVAL_USR_TYPE')
  final StringFieldUpdateOperationsInput? approvalUsrType;

  @JsonKey(name: r'APPROVAL_USR_SORT')
  final IntFieldUpdateOperationsInput? approvalUsrSort;

  @JsonKey(name: r'APPROVAL_PROC_USER_YN')
  final NullableStringFieldUpdateOperationsInput? approvalProcUserYn;

  @JsonKey(name: r'APPROVAL_PROC_YN')
  final StringFieldUpdateOperationsInput? approvalProcYn;

  @JsonKey(name: r'APPROVAL_PROC_DATE')
  final DateTimeFieldUpdateOperationsInput? approvalProcDate;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALUSERTBLUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALUSERTBLCreateManyInput implements _i1.JsonSerializable {
  const APPROVALUSERTBLCreateManyInput({
    required this.approvalId,
    required this.approvalUsrId,
    this.approvalUsrGradeCd,
    this.approvalUsrType,
    required this.approvalUsrSort,
    this.approvalProcUserYn,
    this.approvalProcYn,
    this.approvalProcDate,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALUSERTBLCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$APPROVALUSERTBLCreateManyInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final String approvalId;

  @JsonKey(name: r'APPROVAL_USR_ID')
  final String approvalUsrId;

  @JsonKey(name: r'APPROVAL_USR_GRADE_CD')
  final String? approvalUsrGradeCd;

  @JsonKey(name: r'APPROVAL_USR_TYPE')
  final String? approvalUsrType;

  @JsonKey(name: r'APPROVAL_USR_SORT')
  final int approvalUsrSort;

  @JsonKey(name: r'APPROVAL_PROC_USER_YN')
  final String? approvalProcUserYn;

  @JsonKey(name: r'APPROVAL_PROC_YN')
  final String? approvalProcYn;

  @JsonKey(name: r'APPROVAL_PROC_DATE')
  final DateTime? approvalProcDate;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() => _$APPROVALUSERTBLCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALUSERTBLUpdateManyMutationInput implements _i1.JsonSerializable {
  const APPROVALUSERTBLUpdateManyMutationInput({
    this.approvalId,
    this.approvalUsrId,
    this.approvalUsrGradeCd,
    this.approvalUsrType,
    this.approvalUsrSort,
    this.approvalProcUserYn,
    this.approvalProcYn,
    this.approvalProcDate,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALUSERTBLUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALUSERTBLUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final StringFieldUpdateOperationsInput? approvalId;

  @JsonKey(name: r'APPROVAL_USR_ID')
  final StringFieldUpdateOperationsInput? approvalUsrId;

  @JsonKey(name: r'APPROVAL_USR_GRADE_CD')
  final NullableStringFieldUpdateOperationsInput? approvalUsrGradeCd;

  @JsonKey(name: r'APPROVAL_USR_TYPE')
  final StringFieldUpdateOperationsInput? approvalUsrType;

  @JsonKey(name: r'APPROVAL_USR_SORT')
  final IntFieldUpdateOperationsInput? approvalUsrSort;

  @JsonKey(name: r'APPROVAL_PROC_USER_YN')
  final NullableStringFieldUpdateOperationsInput? approvalProcUserYn;

  @JsonKey(name: r'APPROVAL_PROC_YN')
  final StringFieldUpdateOperationsInput? approvalProcYn;

  @JsonKey(name: r'APPROVAL_PROC_DATE')
  final DateTimeFieldUpdateOperationsInput? approvalProcDate;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALUSERTBLUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALUSERTBLUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const APPROVALUSERTBLUncheckedUpdateManyInput({
    this.approvalId,
    this.approvalUsrId,
    this.approvalUsrGradeCd,
    this.approvalUsrType,
    this.approvalUsrSort,
    this.approvalProcUserYn,
    this.approvalProcYn,
    this.approvalProcDate,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALUSERTBLUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALUSERTBLUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final StringFieldUpdateOperationsInput? approvalId;

  @JsonKey(name: r'APPROVAL_USR_ID')
  final StringFieldUpdateOperationsInput? approvalUsrId;

  @JsonKey(name: r'APPROVAL_USR_GRADE_CD')
  final NullableStringFieldUpdateOperationsInput? approvalUsrGradeCd;

  @JsonKey(name: r'APPROVAL_USR_TYPE')
  final StringFieldUpdateOperationsInput? approvalUsrType;

  @JsonKey(name: r'APPROVAL_USR_SORT')
  final IntFieldUpdateOperationsInput? approvalUsrSort;

  @JsonKey(name: r'APPROVAL_PROC_USER_YN')
  final NullableStringFieldUpdateOperationsInput? approvalProcUserYn;

  @JsonKey(name: r'APPROVAL_PROC_YN')
  final StringFieldUpdateOperationsInput? approvalProcYn;

  @JsonKey(name: r'APPROVAL_PROC_DATE')
  final DateTimeFieldUpdateOperationsInput? approvalProcDate;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALUSERTBLUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class BOOKASSETTBLCreateInput implements _i1.JsonSerializable {
  const BOOKASSETTBLCreateInput({
    this.seq,
    required this.assetNo,
    this.bookNm,
    this.cnt,
    this.publisher,
    this.amount,
    this.buyDate,
    this.mngDept,
    this.rentYn,
    this.rentUser,
    this.remarks,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory BOOKASSETTBLCreateInput.fromJson(Map<String, dynamic> json) =>
      _$BOOKASSETTBLCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'ASSET_NO')
  final String assetNo;

  @JsonKey(name: r'BOOK_NM')
  final String? bookNm;

  @JsonKey(name: r'CNT')
  final int? cnt;

  @JsonKey(name: r'PUBLISHER')
  final String? publisher;

  @JsonKey(name: r'AMOUNT')
  final int? amount;

  @JsonKey(name: r'BUY_DATE')
  final String? buyDate;

  @JsonKey(name: r'MNG_DEPT')
  final String? mngDept;

  @JsonKey(name: r'RENT_YN')
  final String? rentYn;

  @JsonKey(name: r'RENT_USER')
  final String? rentUser;

  @JsonKey(name: r'REMARKS')
  final String? remarks;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() => _$BOOKASSETTBLCreateInputToJson(this);
}

@_i1.jsonSerializable
class BOOKASSETTBLUncheckedCreateInput implements _i1.JsonSerializable {
  const BOOKASSETTBLUncheckedCreateInput({
    this.seq,
    required this.assetNo,
    this.bookNm,
    this.cnt,
    this.publisher,
    this.amount,
    this.buyDate,
    this.mngDept,
    this.rentYn,
    this.rentUser,
    this.remarks,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory BOOKASSETTBLUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$BOOKASSETTBLUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'ASSET_NO')
  final String assetNo;

  @JsonKey(name: r'BOOK_NM')
  final String? bookNm;

  @JsonKey(name: r'CNT')
  final int? cnt;

  @JsonKey(name: r'PUBLISHER')
  final String? publisher;

  @JsonKey(name: r'AMOUNT')
  final int? amount;

  @JsonKey(name: r'BUY_DATE')
  final String? buyDate;

  @JsonKey(name: r'MNG_DEPT')
  final String? mngDept;

  @JsonKey(name: r'RENT_YN')
  final String? rentYn;

  @JsonKey(name: r'RENT_USER')
  final String? rentUser;

  @JsonKey(name: r'REMARKS')
  final String? remarks;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$BOOKASSETTBLUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class BOOKASSETTBLUpdateInput implements _i1.JsonSerializable {
  const BOOKASSETTBLUpdateInput({
    this.seq,
    this.assetNo,
    this.bookNm,
    this.cnt,
    this.publisher,
    this.amount,
    this.buyDate,
    this.mngDept,
    this.rentYn,
    this.rentUser,
    this.remarks,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory BOOKASSETTBLUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$BOOKASSETTBLUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'ASSET_NO')
  final StringFieldUpdateOperationsInput? assetNo;

  @JsonKey(name: r'BOOK_NM')
  final NullableStringFieldUpdateOperationsInput? bookNm;

  @JsonKey(name: r'CNT')
  final NullableIntFieldUpdateOperationsInput? cnt;

  @JsonKey(name: r'PUBLISHER')
  final NullableStringFieldUpdateOperationsInput? publisher;

  @JsonKey(name: r'AMOUNT')
  final NullableIntFieldUpdateOperationsInput? amount;

  @JsonKey(name: r'BUY_DATE')
  final NullableStringFieldUpdateOperationsInput? buyDate;

  @JsonKey(name: r'MNG_DEPT')
  final NullableStringFieldUpdateOperationsInput? mngDept;

  @JsonKey(name: r'RENT_YN')
  final NullableStringFieldUpdateOperationsInput? rentYn;

  @JsonKey(name: r'RENT_USER')
  final NullableStringFieldUpdateOperationsInput? rentUser;

  @JsonKey(name: r'REMARKS')
  final NullableStringFieldUpdateOperationsInput? remarks;

  @JsonKey(name: r'USE_YN')
  final StringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @override
  Map<String, dynamic> toJson() => _$BOOKASSETTBLUpdateInputToJson(this);
}

@_i1.jsonSerializable
class BOOKASSETTBLUncheckedUpdateInput implements _i1.JsonSerializable {
  const BOOKASSETTBLUncheckedUpdateInput({
    this.seq,
    this.assetNo,
    this.bookNm,
    this.cnt,
    this.publisher,
    this.amount,
    this.buyDate,
    this.mngDept,
    this.rentYn,
    this.rentUser,
    this.remarks,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory BOOKASSETTBLUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$BOOKASSETTBLUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'ASSET_NO')
  final StringFieldUpdateOperationsInput? assetNo;

  @JsonKey(name: r'BOOK_NM')
  final NullableStringFieldUpdateOperationsInput? bookNm;

  @JsonKey(name: r'CNT')
  final NullableIntFieldUpdateOperationsInput? cnt;

  @JsonKey(name: r'PUBLISHER')
  final NullableStringFieldUpdateOperationsInput? publisher;

  @JsonKey(name: r'AMOUNT')
  final NullableIntFieldUpdateOperationsInput? amount;

  @JsonKey(name: r'BUY_DATE')
  final NullableStringFieldUpdateOperationsInput? buyDate;

  @JsonKey(name: r'MNG_DEPT')
  final NullableStringFieldUpdateOperationsInput? mngDept;

  @JsonKey(name: r'RENT_YN')
  final NullableStringFieldUpdateOperationsInput? rentYn;

  @JsonKey(name: r'RENT_USER')
  final NullableStringFieldUpdateOperationsInput? rentUser;

  @JsonKey(name: r'REMARKS')
  final NullableStringFieldUpdateOperationsInput? remarks;

  @JsonKey(name: r'USE_YN')
  final StringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$BOOKASSETTBLUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class BOOKASSETTBLCreateManyInput implements _i1.JsonSerializable {
  const BOOKASSETTBLCreateManyInput({
    this.seq,
    required this.assetNo,
    this.bookNm,
    this.cnt,
    this.publisher,
    this.amount,
    this.buyDate,
    this.mngDept,
    this.rentYn,
    this.rentUser,
    this.remarks,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory BOOKASSETTBLCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$BOOKASSETTBLCreateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'ASSET_NO')
  final String assetNo;

  @JsonKey(name: r'BOOK_NM')
  final String? bookNm;

  @JsonKey(name: r'CNT')
  final int? cnt;

  @JsonKey(name: r'PUBLISHER')
  final String? publisher;

  @JsonKey(name: r'AMOUNT')
  final int? amount;

  @JsonKey(name: r'BUY_DATE')
  final String? buyDate;

  @JsonKey(name: r'MNG_DEPT')
  final String? mngDept;

  @JsonKey(name: r'RENT_YN')
  final String? rentYn;

  @JsonKey(name: r'RENT_USER')
  final String? rentUser;

  @JsonKey(name: r'REMARKS')
  final String? remarks;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() => _$BOOKASSETTBLCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class BOOKASSETTBLUpdateManyMutationInput implements _i1.JsonSerializable {
  const BOOKASSETTBLUpdateManyMutationInput({
    this.seq,
    this.assetNo,
    this.bookNm,
    this.cnt,
    this.publisher,
    this.amount,
    this.buyDate,
    this.mngDept,
    this.rentYn,
    this.rentUser,
    this.remarks,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory BOOKASSETTBLUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$BOOKASSETTBLUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'ASSET_NO')
  final StringFieldUpdateOperationsInput? assetNo;

  @JsonKey(name: r'BOOK_NM')
  final NullableStringFieldUpdateOperationsInput? bookNm;

  @JsonKey(name: r'CNT')
  final NullableIntFieldUpdateOperationsInput? cnt;

  @JsonKey(name: r'PUBLISHER')
  final NullableStringFieldUpdateOperationsInput? publisher;

  @JsonKey(name: r'AMOUNT')
  final NullableIntFieldUpdateOperationsInput? amount;

  @JsonKey(name: r'BUY_DATE')
  final NullableStringFieldUpdateOperationsInput? buyDate;

  @JsonKey(name: r'MNG_DEPT')
  final NullableStringFieldUpdateOperationsInput? mngDept;

  @JsonKey(name: r'RENT_YN')
  final NullableStringFieldUpdateOperationsInput? rentYn;

  @JsonKey(name: r'RENT_USER')
  final NullableStringFieldUpdateOperationsInput? rentUser;

  @JsonKey(name: r'REMARKS')
  final NullableStringFieldUpdateOperationsInput? remarks;

  @JsonKey(name: r'USE_YN')
  final StringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$BOOKASSETTBLUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class BOOKASSETTBLUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const BOOKASSETTBLUncheckedUpdateManyInput({
    this.seq,
    this.assetNo,
    this.bookNm,
    this.cnt,
    this.publisher,
    this.amount,
    this.buyDate,
    this.mngDept,
    this.rentYn,
    this.rentUser,
    this.remarks,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory BOOKASSETTBLUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$BOOKASSETTBLUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'ASSET_NO')
  final StringFieldUpdateOperationsInput? assetNo;

  @JsonKey(name: r'BOOK_NM')
  final NullableStringFieldUpdateOperationsInput? bookNm;

  @JsonKey(name: r'CNT')
  final NullableIntFieldUpdateOperationsInput? cnt;

  @JsonKey(name: r'PUBLISHER')
  final NullableStringFieldUpdateOperationsInput? publisher;

  @JsonKey(name: r'AMOUNT')
  final NullableIntFieldUpdateOperationsInput? amount;

  @JsonKey(name: r'BUY_DATE')
  final NullableStringFieldUpdateOperationsInput? buyDate;

  @JsonKey(name: r'MNG_DEPT')
  final NullableStringFieldUpdateOperationsInput? mngDept;

  @JsonKey(name: r'RENT_YN')
  final NullableStringFieldUpdateOperationsInput? rentYn;

  @JsonKey(name: r'RENT_USER')
  final NullableStringFieldUpdateOperationsInput? rentUser;

  @JsonKey(name: r'REMARKS')
  final NullableStringFieldUpdateOperationsInput? remarks;

  @JsonKey(name: r'USE_YN')
  final StringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$BOOKASSETTBLUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETINSURTBLCreateInput implements _i1.JsonSerializable {
  const CARASSETINSURTBLCreateInput({
    this.seq,
    required this.mseq,
    required this.guarantee,
  });

  factory CARASSETINSURTBLCreateInput.fromJson(Map<String, dynamic> json) =>
      _$CARASSETINSURTBLCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'MSEQ')
  final BigInt mseq;

  @JsonKey(name: r'GUARANTEE')
  final String guarantee;

  @override
  Map<String, dynamic> toJson() => _$CARASSETINSURTBLCreateInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETINSURTBLUncheckedCreateInput implements _i1.JsonSerializable {
  const CARASSETINSURTBLUncheckedCreateInput({
    this.seq,
    required this.mseq,
    required this.guarantee,
  });

  factory CARASSETINSURTBLUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARASSETINSURTBLUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'MSEQ')
  final BigInt mseq;

  @JsonKey(name: r'GUARANTEE')
  final String guarantee;

  @override
  Map<String, dynamic> toJson() =>
      _$CARASSETINSURTBLUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETINSURTBLUpdateInput implements _i1.JsonSerializable {
  const CARASSETINSURTBLUpdateInput({
    this.seq,
    this.mseq,
    this.guarantee,
  });

  factory CARASSETINSURTBLUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$CARASSETINSURTBLUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'MSEQ')
  final BigIntFieldUpdateOperationsInput? mseq;

  @JsonKey(name: r'GUARANTEE')
  final StringFieldUpdateOperationsInput? guarantee;

  @override
  Map<String, dynamic> toJson() => _$CARASSETINSURTBLUpdateInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETINSURTBLUncheckedUpdateInput implements _i1.JsonSerializable {
  const CARASSETINSURTBLUncheckedUpdateInput({
    this.seq,
    this.mseq,
    this.guarantee,
  });

  factory CARASSETINSURTBLUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARASSETINSURTBLUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'MSEQ')
  final BigIntFieldUpdateOperationsInput? mseq;

  @JsonKey(name: r'GUARANTEE')
  final StringFieldUpdateOperationsInput? guarantee;

  @override
  Map<String, dynamic> toJson() =>
      _$CARASSETINSURTBLUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETINSURTBLCreateManyInput implements _i1.JsonSerializable {
  const CARASSETINSURTBLCreateManyInput({
    this.seq,
    required this.mseq,
    required this.guarantee,
  });

  factory CARASSETINSURTBLCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$CARASSETINSURTBLCreateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'MSEQ')
  final BigInt mseq;

  @JsonKey(name: r'GUARANTEE')
  final String guarantee;

  @override
  Map<String, dynamic> toJson() =>
      _$CARASSETINSURTBLCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETINSURTBLUpdateManyMutationInput implements _i1.JsonSerializable {
  const CARASSETINSURTBLUpdateManyMutationInput({
    this.seq,
    this.mseq,
    this.guarantee,
  });

  factory CARASSETINSURTBLUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARASSETINSURTBLUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'MSEQ')
  final BigIntFieldUpdateOperationsInput? mseq;

  @JsonKey(name: r'GUARANTEE')
  final StringFieldUpdateOperationsInput? guarantee;

  @override
  Map<String, dynamic> toJson() =>
      _$CARASSETINSURTBLUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETINSURTBLUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const CARASSETINSURTBLUncheckedUpdateManyInput({
    this.seq,
    this.mseq,
    this.guarantee,
  });

  factory CARASSETINSURTBLUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARASSETINSURTBLUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'MSEQ')
  final BigIntFieldUpdateOperationsInput? mseq;

  @JsonKey(name: r'GUARANTEE')
  final StringFieldUpdateOperationsInput? guarantee;

  @override
  Map<String, dynamic> toJson() =>
      _$CARASSETINSURTBLUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETTBLCreateInput implements _i1.JsonSerializable {
  const CARASSETTBLCreateInput({
    this.seq,
    required this.assetNo,
    this.modelNo,
    this.carNo,
    this.owner,
    this.ownerType,
    this.amount,
    this.buyDate,
    this.seller,
    this.remarks,
    this.mngrNm,
    this.fuel,
    this.manuDt,
    this.effic,
    this.insur,
    this.insurMngr,
    this.emgTel,
    this.storeNm,
    this.storeTel,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory CARASSETTBLCreateInput.fromJson(Map<String, dynamic> json) =>
      _$CARASSETTBLCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'ASSET_NO')
  final String assetNo;

  @JsonKey(name: r'MODEL_NO')
  final String? modelNo;

  @JsonKey(name: r'CAR_NO')
  final String? carNo;

  @JsonKey(name: r'OWNER')
  final String? owner;

  @JsonKey(name: r'OWNER_TYPE')
  final String? ownerType;

  @JsonKey(name: r'AMOUNT')
  final int? amount;

  @JsonKey(name: r'BUY_DATE')
  final String? buyDate;

  @JsonKey(name: r'SELLER')
  final String? seller;

  @JsonKey(name: r'REMARKS')
  final String? remarks;

  @JsonKey(name: r'MNGR_NM')
  final String? mngrNm;

  @JsonKey(name: r'FUEL')
  final String? fuel;

  @JsonKey(name: r'MANU_DT')
  final String? manuDt;

  @JsonKey(name: r'EFFIC')
  final String? effic;

  @JsonKey(name: r'INSUR')
  final String? insur;

  @JsonKey(name: r'INSUR_MNGR')
  final String? insurMngr;

  @JsonKey(name: r'EMG_TEL')
  final String? emgTel;

  @JsonKey(name: r'STORE_NM')
  final String? storeNm;

  @JsonKey(name: r'STORE_TEL')
  final String? storeTel;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() => _$CARASSETTBLCreateInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETTBLUncheckedCreateInput implements _i1.JsonSerializable {
  const CARASSETTBLUncheckedCreateInput({
    this.seq,
    required this.assetNo,
    this.modelNo,
    this.carNo,
    this.owner,
    this.ownerType,
    this.amount,
    this.buyDate,
    this.seller,
    this.remarks,
    this.mngrNm,
    this.fuel,
    this.manuDt,
    this.effic,
    this.insur,
    this.insurMngr,
    this.emgTel,
    this.storeNm,
    this.storeTel,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory CARASSETTBLUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$CARASSETTBLUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'ASSET_NO')
  final String assetNo;

  @JsonKey(name: r'MODEL_NO')
  final String? modelNo;

  @JsonKey(name: r'CAR_NO')
  final String? carNo;

  @JsonKey(name: r'OWNER')
  final String? owner;

  @JsonKey(name: r'OWNER_TYPE')
  final String? ownerType;

  @JsonKey(name: r'AMOUNT')
  final int? amount;

  @JsonKey(name: r'BUY_DATE')
  final String? buyDate;

  @JsonKey(name: r'SELLER')
  final String? seller;

  @JsonKey(name: r'REMARKS')
  final String? remarks;

  @JsonKey(name: r'MNGR_NM')
  final String? mngrNm;

  @JsonKey(name: r'FUEL')
  final String? fuel;

  @JsonKey(name: r'MANU_DT')
  final String? manuDt;

  @JsonKey(name: r'EFFIC')
  final String? effic;

  @JsonKey(name: r'INSUR')
  final String? insur;

  @JsonKey(name: r'INSUR_MNGR')
  final String? insurMngr;

  @JsonKey(name: r'EMG_TEL')
  final String? emgTel;

  @JsonKey(name: r'STORE_NM')
  final String? storeNm;

  @JsonKey(name: r'STORE_TEL')
  final String? storeTel;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARASSETTBLUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETTBLUpdateInput implements _i1.JsonSerializable {
  const CARASSETTBLUpdateInput({
    this.seq,
    this.assetNo,
    this.modelNo,
    this.carNo,
    this.owner,
    this.ownerType,
    this.amount,
    this.buyDate,
    this.seller,
    this.remarks,
    this.mngrNm,
    this.fuel,
    this.manuDt,
    this.effic,
    this.insur,
    this.insurMngr,
    this.emgTel,
    this.storeNm,
    this.storeTel,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory CARASSETTBLUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$CARASSETTBLUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'ASSET_NO')
  final StringFieldUpdateOperationsInput? assetNo;

  @JsonKey(name: r'MODEL_NO')
  final NullableStringFieldUpdateOperationsInput? modelNo;

  @JsonKey(name: r'CAR_NO')
  final NullableStringFieldUpdateOperationsInput? carNo;

  @JsonKey(name: r'OWNER')
  final NullableStringFieldUpdateOperationsInput? owner;

  @JsonKey(name: r'OWNER_TYPE')
  final NullableStringFieldUpdateOperationsInput? ownerType;

  @JsonKey(name: r'AMOUNT')
  final NullableIntFieldUpdateOperationsInput? amount;

  @JsonKey(name: r'BUY_DATE')
  final NullableStringFieldUpdateOperationsInput? buyDate;

  @JsonKey(name: r'SELLER')
  final NullableStringFieldUpdateOperationsInput? seller;

  @JsonKey(name: r'REMARKS')
  final NullableStringFieldUpdateOperationsInput? remarks;

  @JsonKey(name: r'MNGR_NM')
  final NullableStringFieldUpdateOperationsInput? mngrNm;

  @JsonKey(name: r'FUEL')
  final NullableStringFieldUpdateOperationsInput? fuel;

  @JsonKey(name: r'MANU_DT')
  final NullableStringFieldUpdateOperationsInput? manuDt;

  @JsonKey(name: r'EFFIC')
  final NullableStringFieldUpdateOperationsInput? effic;

  @JsonKey(name: r'INSUR')
  final NullableStringFieldUpdateOperationsInput? insur;

  @JsonKey(name: r'INSUR_MNGR')
  final NullableStringFieldUpdateOperationsInput? insurMngr;

  @JsonKey(name: r'EMG_TEL')
  final NullableStringFieldUpdateOperationsInput? emgTel;

  @JsonKey(name: r'STORE_NM')
  final NullableStringFieldUpdateOperationsInput? storeNm;

  @JsonKey(name: r'STORE_TEL')
  final NullableStringFieldUpdateOperationsInput? storeTel;

  @JsonKey(name: r'USE_YN')
  final StringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @override
  Map<String, dynamic> toJson() => _$CARASSETTBLUpdateInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETTBLUncheckedUpdateInput implements _i1.JsonSerializable {
  const CARASSETTBLUncheckedUpdateInput({
    this.seq,
    this.assetNo,
    this.modelNo,
    this.carNo,
    this.owner,
    this.ownerType,
    this.amount,
    this.buyDate,
    this.seller,
    this.remarks,
    this.mngrNm,
    this.fuel,
    this.manuDt,
    this.effic,
    this.insur,
    this.insurMngr,
    this.emgTel,
    this.storeNm,
    this.storeTel,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory CARASSETTBLUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$CARASSETTBLUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'ASSET_NO')
  final StringFieldUpdateOperationsInput? assetNo;

  @JsonKey(name: r'MODEL_NO')
  final NullableStringFieldUpdateOperationsInput? modelNo;

  @JsonKey(name: r'CAR_NO')
  final NullableStringFieldUpdateOperationsInput? carNo;

  @JsonKey(name: r'OWNER')
  final NullableStringFieldUpdateOperationsInput? owner;

  @JsonKey(name: r'OWNER_TYPE')
  final NullableStringFieldUpdateOperationsInput? ownerType;

  @JsonKey(name: r'AMOUNT')
  final NullableIntFieldUpdateOperationsInput? amount;

  @JsonKey(name: r'BUY_DATE')
  final NullableStringFieldUpdateOperationsInput? buyDate;

  @JsonKey(name: r'SELLER')
  final NullableStringFieldUpdateOperationsInput? seller;

  @JsonKey(name: r'REMARKS')
  final NullableStringFieldUpdateOperationsInput? remarks;

  @JsonKey(name: r'MNGR_NM')
  final NullableStringFieldUpdateOperationsInput? mngrNm;

  @JsonKey(name: r'FUEL')
  final NullableStringFieldUpdateOperationsInput? fuel;

  @JsonKey(name: r'MANU_DT')
  final NullableStringFieldUpdateOperationsInput? manuDt;

  @JsonKey(name: r'EFFIC')
  final NullableStringFieldUpdateOperationsInput? effic;

  @JsonKey(name: r'INSUR')
  final NullableStringFieldUpdateOperationsInput? insur;

  @JsonKey(name: r'INSUR_MNGR')
  final NullableStringFieldUpdateOperationsInput? insurMngr;

  @JsonKey(name: r'EMG_TEL')
  final NullableStringFieldUpdateOperationsInput? emgTel;

  @JsonKey(name: r'STORE_NM')
  final NullableStringFieldUpdateOperationsInput? storeNm;

  @JsonKey(name: r'STORE_TEL')
  final NullableStringFieldUpdateOperationsInput? storeTel;

  @JsonKey(name: r'USE_YN')
  final StringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARASSETTBLUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETTBLCreateManyInput implements _i1.JsonSerializable {
  const CARASSETTBLCreateManyInput({
    this.seq,
    required this.assetNo,
    this.modelNo,
    this.carNo,
    this.owner,
    this.ownerType,
    this.amount,
    this.buyDate,
    this.seller,
    this.remarks,
    this.mngrNm,
    this.fuel,
    this.manuDt,
    this.effic,
    this.insur,
    this.insurMngr,
    this.emgTel,
    this.storeNm,
    this.storeTel,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory CARASSETTBLCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$CARASSETTBLCreateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'ASSET_NO')
  final String assetNo;

  @JsonKey(name: r'MODEL_NO')
  final String? modelNo;

  @JsonKey(name: r'CAR_NO')
  final String? carNo;

  @JsonKey(name: r'OWNER')
  final String? owner;

  @JsonKey(name: r'OWNER_TYPE')
  final String? ownerType;

  @JsonKey(name: r'AMOUNT')
  final int? amount;

  @JsonKey(name: r'BUY_DATE')
  final String? buyDate;

  @JsonKey(name: r'SELLER')
  final String? seller;

  @JsonKey(name: r'REMARKS')
  final String? remarks;

  @JsonKey(name: r'MNGR_NM')
  final String? mngrNm;

  @JsonKey(name: r'FUEL')
  final String? fuel;

  @JsonKey(name: r'MANU_DT')
  final String? manuDt;

  @JsonKey(name: r'EFFIC')
  final String? effic;

  @JsonKey(name: r'INSUR')
  final String? insur;

  @JsonKey(name: r'INSUR_MNGR')
  final String? insurMngr;

  @JsonKey(name: r'EMG_TEL')
  final String? emgTel;

  @JsonKey(name: r'STORE_NM')
  final String? storeNm;

  @JsonKey(name: r'STORE_TEL')
  final String? storeTel;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() => _$CARASSETTBLCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETTBLUpdateManyMutationInput implements _i1.JsonSerializable {
  const CARASSETTBLUpdateManyMutationInput({
    this.seq,
    this.assetNo,
    this.modelNo,
    this.carNo,
    this.owner,
    this.ownerType,
    this.amount,
    this.buyDate,
    this.seller,
    this.remarks,
    this.mngrNm,
    this.fuel,
    this.manuDt,
    this.effic,
    this.insur,
    this.insurMngr,
    this.emgTel,
    this.storeNm,
    this.storeTel,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory CARASSETTBLUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARASSETTBLUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'ASSET_NO')
  final StringFieldUpdateOperationsInput? assetNo;

  @JsonKey(name: r'MODEL_NO')
  final NullableStringFieldUpdateOperationsInput? modelNo;

  @JsonKey(name: r'CAR_NO')
  final NullableStringFieldUpdateOperationsInput? carNo;

  @JsonKey(name: r'OWNER')
  final NullableStringFieldUpdateOperationsInput? owner;

  @JsonKey(name: r'OWNER_TYPE')
  final NullableStringFieldUpdateOperationsInput? ownerType;

  @JsonKey(name: r'AMOUNT')
  final NullableIntFieldUpdateOperationsInput? amount;

  @JsonKey(name: r'BUY_DATE')
  final NullableStringFieldUpdateOperationsInput? buyDate;

  @JsonKey(name: r'SELLER')
  final NullableStringFieldUpdateOperationsInput? seller;

  @JsonKey(name: r'REMARKS')
  final NullableStringFieldUpdateOperationsInput? remarks;

  @JsonKey(name: r'MNGR_NM')
  final NullableStringFieldUpdateOperationsInput? mngrNm;

  @JsonKey(name: r'FUEL')
  final NullableStringFieldUpdateOperationsInput? fuel;

  @JsonKey(name: r'MANU_DT')
  final NullableStringFieldUpdateOperationsInput? manuDt;

  @JsonKey(name: r'EFFIC')
  final NullableStringFieldUpdateOperationsInput? effic;

  @JsonKey(name: r'INSUR')
  final NullableStringFieldUpdateOperationsInput? insur;

  @JsonKey(name: r'INSUR_MNGR')
  final NullableStringFieldUpdateOperationsInput? insurMngr;

  @JsonKey(name: r'EMG_TEL')
  final NullableStringFieldUpdateOperationsInput? emgTel;

  @JsonKey(name: r'STORE_NM')
  final NullableStringFieldUpdateOperationsInput? storeNm;

  @JsonKey(name: r'STORE_TEL')
  final NullableStringFieldUpdateOperationsInput? storeTel;

  @JsonKey(name: r'USE_YN')
  final StringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARASSETTBLUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETTBLUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const CARASSETTBLUncheckedUpdateManyInput({
    this.seq,
    this.assetNo,
    this.modelNo,
    this.carNo,
    this.owner,
    this.ownerType,
    this.amount,
    this.buyDate,
    this.seller,
    this.remarks,
    this.mngrNm,
    this.fuel,
    this.manuDt,
    this.effic,
    this.insur,
    this.insurMngr,
    this.emgTel,
    this.storeNm,
    this.storeTel,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory CARASSETTBLUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARASSETTBLUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'ASSET_NO')
  final StringFieldUpdateOperationsInput? assetNo;

  @JsonKey(name: r'MODEL_NO')
  final NullableStringFieldUpdateOperationsInput? modelNo;

  @JsonKey(name: r'CAR_NO')
  final NullableStringFieldUpdateOperationsInput? carNo;

  @JsonKey(name: r'OWNER')
  final NullableStringFieldUpdateOperationsInput? owner;

  @JsonKey(name: r'OWNER_TYPE')
  final NullableStringFieldUpdateOperationsInput? ownerType;

  @JsonKey(name: r'AMOUNT')
  final NullableIntFieldUpdateOperationsInput? amount;

  @JsonKey(name: r'BUY_DATE')
  final NullableStringFieldUpdateOperationsInput? buyDate;

  @JsonKey(name: r'SELLER')
  final NullableStringFieldUpdateOperationsInput? seller;

  @JsonKey(name: r'REMARKS')
  final NullableStringFieldUpdateOperationsInput? remarks;

  @JsonKey(name: r'MNGR_NM')
  final NullableStringFieldUpdateOperationsInput? mngrNm;

  @JsonKey(name: r'FUEL')
  final NullableStringFieldUpdateOperationsInput? fuel;

  @JsonKey(name: r'MANU_DT')
  final NullableStringFieldUpdateOperationsInput? manuDt;

  @JsonKey(name: r'EFFIC')
  final NullableStringFieldUpdateOperationsInput? effic;

  @JsonKey(name: r'INSUR')
  final NullableStringFieldUpdateOperationsInput? insur;

  @JsonKey(name: r'INSUR_MNGR')
  final NullableStringFieldUpdateOperationsInput? insurMngr;

  @JsonKey(name: r'EMG_TEL')
  final NullableStringFieldUpdateOperationsInput? emgTel;

  @JsonKey(name: r'STORE_NM')
  final NullableStringFieldUpdateOperationsInput? storeNm;

  @JsonKey(name: r'STORE_TEL')
  final NullableStringFieldUpdateOperationsInput? storeTel;

  @JsonKey(name: r'USE_YN')
  final StringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARASSETTBLUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class CARCHARGETBLCreateInput implements _i1.JsonSerializable {
  const CARCHARGETBLCreateInput({
    this.seq,
    required this.item,
    required this.charge,
    required this.writerId,
    required this.memo,
    required this.regDate,
  });

  factory CARCHARGETBLCreateInput.fromJson(Map<String, dynamic> json) =>
      _$CARCHARGETBLCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'ITEM')
  final String item;

  @JsonKey(name: r'CHARGE')
  final BigInt charge;

  @JsonKey(name: r'WRITER_ID')
  final String writerId;

  @JsonKey(name: r'MEMO')
  final String memo;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @override
  Map<String, dynamic> toJson() => _$CARCHARGETBLCreateInputToJson(this);
}

@_i1.jsonSerializable
class CARCHARGETBLUncheckedCreateInput implements _i1.JsonSerializable {
  const CARCHARGETBLUncheckedCreateInput({
    this.seq,
    required this.item,
    required this.charge,
    required this.writerId,
    required this.memo,
    required this.regDate,
  });

  factory CARCHARGETBLUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARCHARGETBLUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'ITEM')
  final String item;

  @JsonKey(name: r'CHARGE')
  final BigInt charge;

  @JsonKey(name: r'WRITER_ID')
  final String writerId;

  @JsonKey(name: r'MEMO')
  final String memo;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARCHARGETBLUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class CARCHARGETBLUpdateInput implements _i1.JsonSerializable {
  const CARCHARGETBLUpdateInput({
    this.seq,
    this.item,
    this.charge,
    this.writerId,
    this.memo,
    this.regDate,
  });

  factory CARCHARGETBLUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$CARCHARGETBLUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'ITEM')
  final StringFieldUpdateOperationsInput? item;

  @JsonKey(name: r'CHARGE')
  final BigIntFieldUpdateOperationsInput? charge;

  @JsonKey(name: r'WRITER_ID')
  final StringFieldUpdateOperationsInput? writerId;

  @JsonKey(name: r'MEMO')
  final StringFieldUpdateOperationsInput? memo;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @override
  Map<String, dynamic> toJson() => _$CARCHARGETBLUpdateInputToJson(this);
}

@_i1.jsonSerializable
class CARCHARGETBLUncheckedUpdateInput implements _i1.JsonSerializable {
  const CARCHARGETBLUncheckedUpdateInput({
    this.seq,
    this.item,
    this.charge,
    this.writerId,
    this.memo,
    this.regDate,
  });

  factory CARCHARGETBLUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARCHARGETBLUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'ITEM')
  final StringFieldUpdateOperationsInput? item;

  @JsonKey(name: r'CHARGE')
  final BigIntFieldUpdateOperationsInput? charge;

  @JsonKey(name: r'WRITER_ID')
  final StringFieldUpdateOperationsInput? writerId;

  @JsonKey(name: r'MEMO')
  final StringFieldUpdateOperationsInput? memo;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARCHARGETBLUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class CARCHARGETBLCreateManyInput implements _i1.JsonSerializable {
  const CARCHARGETBLCreateManyInput({
    this.seq,
    required this.item,
    required this.charge,
    required this.writerId,
    required this.memo,
    required this.regDate,
  });

  factory CARCHARGETBLCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$CARCHARGETBLCreateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'ITEM')
  final String item;

  @JsonKey(name: r'CHARGE')
  final BigInt charge;

  @JsonKey(name: r'WRITER_ID')
  final String writerId;

  @JsonKey(name: r'MEMO')
  final String memo;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @override
  Map<String, dynamic> toJson() => _$CARCHARGETBLCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class CARCHARGETBLUpdateManyMutationInput implements _i1.JsonSerializable {
  const CARCHARGETBLUpdateManyMutationInput({
    this.seq,
    this.item,
    this.charge,
    this.writerId,
    this.memo,
    this.regDate,
  });

  factory CARCHARGETBLUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARCHARGETBLUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'ITEM')
  final StringFieldUpdateOperationsInput? item;

  @JsonKey(name: r'CHARGE')
  final BigIntFieldUpdateOperationsInput? charge;

  @JsonKey(name: r'WRITER_ID')
  final StringFieldUpdateOperationsInput? writerId;

  @JsonKey(name: r'MEMO')
  final StringFieldUpdateOperationsInput? memo;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARCHARGETBLUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class CARCHARGETBLUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const CARCHARGETBLUncheckedUpdateManyInput({
    this.seq,
    this.item,
    this.charge,
    this.writerId,
    this.memo,
    this.regDate,
  });

  factory CARCHARGETBLUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARCHARGETBLUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'ITEM')
  final StringFieldUpdateOperationsInput? item;

  @JsonKey(name: r'CHARGE')
  final BigIntFieldUpdateOperationsInput? charge;

  @JsonKey(name: r'WRITER_ID')
  final StringFieldUpdateOperationsInput? writerId;

  @JsonKey(name: r'MEMO')
  final StringFieldUpdateOperationsInput? memo;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARCHARGETBLUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class CARINFOTBLCreateInput implements _i1.JsonSerializable {
  const CARINFOTBLCreateInput({
    this.sort,
    required this.carManageNo,
    required this.model,
    required this.userId,
    required this.regDate,
    this.disusedYn,
  });

  factory CARINFOTBLCreateInput.fromJson(Map<String, dynamic> json) =>
      _$CARINFOTBLCreateInputFromJson(json);

  @JsonKey(name: r'SORT')
  final BigInt? sort;

  @JsonKey(name: r'CAR_MANAGE_NO')
  final String carManageNo;

  @JsonKey(name: r'MODEL')
  final String model;

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'DISUSED_YN')
  final String? disusedYn;

  @override
  Map<String, dynamic> toJson() => _$CARINFOTBLCreateInputToJson(this);
}

@_i1.jsonSerializable
class CARINFOTBLUncheckedCreateInput implements _i1.JsonSerializable {
  const CARINFOTBLUncheckedCreateInput({
    this.sort,
    required this.carManageNo,
    required this.model,
    required this.userId,
    required this.regDate,
    this.disusedYn,
  });

  factory CARINFOTBLUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$CARINFOTBLUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'SORT')
  final BigInt? sort;

  @JsonKey(name: r'CAR_MANAGE_NO')
  final String carManageNo;

  @JsonKey(name: r'MODEL')
  final String model;

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'DISUSED_YN')
  final String? disusedYn;

  @override
  Map<String, dynamic> toJson() => _$CARINFOTBLUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class CARINFOTBLUpdateInput implements _i1.JsonSerializable {
  const CARINFOTBLUpdateInput({
    this.sort,
    this.carManageNo,
    this.model,
    this.userId,
    this.regDate,
    this.disusedYn,
  });

  factory CARINFOTBLUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$CARINFOTBLUpdateInputFromJson(json);

  @JsonKey(name: r'SORT')
  final BigIntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'CAR_MANAGE_NO')
  final StringFieldUpdateOperationsInput? carManageNo;

  @JsonKey(name: r'MODEL')
  final StringFieldUpdateOperationsInput? model;

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'DISUSED_YN')
  final StringFieldUpdateOperationsInput? disusedYn;

  @override
  Map<String, dynamic> toJson() => _$CARINFOTBLUpdateInputToJson(this);
}

@_i1.jsonSerializable
class CARINFOTBLUncheckedUpdateInput implements _i1.JsonSerializable {
  const CARINFOTBLUncheckedUpdateInput({
    this.sort,
    this.carManageNo,
    this.model,
    this.userId,
    this.regDate,
    this.disusedYn,
  });

  factory CARINFOTBLUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$CARINFOTBLUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'SORT')
  final BigIntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'CAR_MANAGE_NO')
  final StringFieldUpdateOperationsInput? carManageNo;

  @JsonKey(name: r'MODEL')
  final StringFieldUpdateOperationsInput? model;

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'DISUSED_YN')
  final StringFieldUpdateOperationsInput? disusedYn;

  @override
  Map<String, dynamic> toJson() => _$CARINFOTBLUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class CARINFOTBLCreateManyInput implements _i1.JsonSerializable {
  const CARINFOTBLCreateManyInput({
    this.sort,
    required this.carManageNo,
    required this.model,
    required this.userId,
    required this.regDate,
    this.disusedYn,
  });

  factory CARINFOTBLCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$CARINFOTBLCreateManyInputFromJson(json);

  @JsonKey(name: r'SORT')
  final BigInt? sort;

  @JsonKey(name: r'CAR_MANAGE_NO')
  final String carManageNo;

  @JsonKey(name: r'MODEL')
  final String model;

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'DISUSED_YN')
  final String? disusedYn;

  @override
  Map<String, dynamic> toJson() => _$CARINFOTBLCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class CARINFOTBLUpdateManyMutationInput implements _i1.JsonSerializable {
  const CARINFOTBLUpdateManyMutationInput({
    this.sort,
    this.carManageNo,
    this.model,
    this.userId,
    this.regDate,
    this.disusedYn,
  });

  factory CARINFOTBLUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARINFOTBLUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'SORT')
  final BigIntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'CAR_MANAGE_NO')
  final StringFieldUpdateOperationsInput? carManageNo;

  @JsonKey(name: r'MODEL')
  final StringFieldUpdateOperationsInput? model;

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'DISUSED_YN')
  final StringFieldUpdateOperationsInput? disusedYn;

  @override
  Map<String, dynamic> toJson() =>
      _$CARINFOTBLUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class CARINFOTBLUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const CARINFOTBLUncheckedUpdateManyInput({
    this.sort,
    this.carManageNo,
    this.model,
    this.userId,
    this.regDate,
    this.disusedYn,
  });

  factory CARINFOTBLUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARINFOTBLUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'SORT')
  final BigIntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'CAR_MANAGE_NO')
  final StringFieldUpdateOperationsInput? carManageNo;

  @JsonKey(name: r'MODEL')
  final StringFieldUpdateOperationsInput? model;

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'DISUSED_YN')
  final StringFieldUpdateOperationsInput? disusedYn;

  @override
  Map<String, dynamic> toJson() =>
      _$CARINFOTBLUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class CARMILEAGETBLCreateInput implements _i1.JsonSerializable {
  const CARMILEAGETBLCreateInput({
    this.seq,
    required this.carManageNo,
    required this.forUse,
    required this.stPoint,
    required this.destination,
    required this.mileage,
    required this.totalMileage,
    required this.recordDate,
    required this.writerId,
    required this.editorId,
    required this.regDate,
    required this.apprYn,
  });

  factory CARMILEAGETBLCreateInput.fromJson(Map<String, dynamic> json) =>
      _$CARMILEAGETBLCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'CAR_MANAGE_NO')
  final String carManageNo;

  @JsonKey(name: r'FOR_USE')
  final String forUse;

  @JsonKey(name: r'ST_POINT')
  final String stPoint;

  @JsonKey(name: r'DESTINATION')
  final String destination;

  @JsonKey(name: r'MILEAGE')
  final BigInt mileage;

  @JsonKey(name: r'TOTAL_MILEAGE')
  final BigInt totalMileage;

  @JsonKey(name: r'RECORD_DATE')
  final String recordDate;

  @JsonKey(name: r'WRITER_ID')
  final String writerId;

  @JsonKey(name: r'EDITOR_ID')
  final String editorId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'APPR_YN')
  final String apprYn;

  @override
  Map<String, dynamic> toJson() => _$CARMILEAGETBLCreateInputToJson(this);
}

@_i1.jsonSerializable
class CARMILEAGETBLUncheckedCreateInput implements _i1.JsonSerializable {
  const CARMILEAGETBLUncheckedCreateInput({
    this.seq,
    required this.carManageNo,
    required this.forUse,
    required this.stPoint,
    required this.destination,
    required this.mileage,
    required this.totalMileage,
    required this.recordDate,
    required this.writerId,
    required this.editorId,
    required this.regDate,
    required this.apprYn,
  });

  factory CARMILEAGETBLUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARMILEAGETBLUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'CAR_MANAGE_NO')
  final String carManageNo;

  @JsonKey(name: r'FOR_USE')
  final String forUse;

  @JsonKey(name: r'ST_POINT')
  final String stPoint;

  @JsonKey(name: r'DESTINATION')
  final String destination;

  @JsonKey(name: r'MILEAGE')
  final BigInt mileage;

  @JsonKey(name: r'TOTAL_MILEAGE')
  final BigInt totalMileage;

  @JsonKey(name: r'RECORD_DATE')
  final String recordDate;

  @JsonKey(name: r'WRITER_ID')
  final String writerId;

  @JsonKey(name: r'EDITOR_ID')
  final String editorId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'APPR_YN')
  final String apprYn;

  @override
  Map<String, dynamic> toJson() =>
      _$CARMILEAGETBLUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class CARMILEAGETBLUpdateInput implements _i1.JsonSerializable {
  const CARMILEAGETBLUpdateInput({
    this.seq,
    this.carManageNo,
    this.forUse,
    this.stPoint,
    this.destination,
    this.mileage,
    this.totalMileage,
    this.recordDate,
    this.writerId,
    this.editorId,
    this.regDate,
    this.apprYn,
  });

  factory CARMILEAGETBLUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$CARMILEAGETBLUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'CAR_MANAGE_NO')
  final StringFieldUpdateOperationsInput? carManageNo;

  @JsonKey(name: r'FOR_USE')
  final StringFieldUpdateOperationsInput? forUse;

  @JsonKey(name: r'ST_POINT')
  final StringFieldUpdateOperationsInput? stPoint;

  @JsonKey(name: r'DESTINATION')
  final StringFieldUpdateOperationsInput? destination;

  @JsonKey(name: r'MILEAGE')
  final BigIntFieldUpdateOperationsInput? mileage;

  @JsonKey(name: r'TOTAL_MILEAGE')
  final BigIntFieldUpdateOperationsInput? totalMileage;

  @JsonKey(name: r'RECORD_DATE')
  final StringFieldUpdateOperationsInput? recordDate;

  @JsonKey(name: r'WRITER_ID')
  final StringFieldUpdateOperationsInput? writerId;

  @JsonKey(name: r'EDITOR_ID')
  final StringFieldUpdateOperationsInput? editorId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'APPR_YN')
  final StringFieldUpdateOperationsInput? apprYn;

  @override
  Map<String, dynamic> toJson() => _$CARMILEAGETBLUpdateInputToJson(this);
}

@_i1.jsonSerializable
class CARMILEAGETBLUncheckedUpdateInput implements _i1.JsonSerializable {
  const CARMILEAGETBLUncheckedUpdateInput({
    this.seq,
    this.carManageNo,
    this.forUse,
    this.stPoint,
    this.destination,
    this.mileage,
    this.totalMileage,
    this.recordDate,
    this.writerId,
    this.editorId,
    this.regDate,
    this.apprYn,
  });

  factory CARMILEAGETBLUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARMILEAGETBLUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'CAR_MANAGE_NO')
  final StringFieldUpdateOperationsInput? carManageNo;

  @JsonKey(name: r'FOR_USE')
  final StringFieldUpdateOperationsInput? forUse;

  @JsonKey(name: r'ST_POINT')
  final StringFieldUpdateOperationsInput? stPoint;

  @JsonKey(name: r'DESTINATION')
  final StringFieldUpdateOperationsInput? destination;

  @JsonKey(name: r'MILEAGE')
  final BigIntFieldUpdateOperationsInput? mileage;

  @JsonKey(name: r'TOTAL_MILEAGE')
  final BigIntFieldUpdateOperationsInput? totalMileage;

  @JsonKey(name: r'RECORD_DATE')
  final StringFieldUpdateOperationsInput? recordDate;

  @JsonKey(name: r'WRITER_ID')
  final StringFieldUpdateOperationsInput? writerId;

  @JsonKey(name: r'EDITOR_ID')
  final StringFieldUpdateOperationsInput? editorId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'APPR_YN')
  final StringFieldUpdateOperationsInput? apprYn;

  @override
  Map<String, dynamic> toJson() =>
      _$CARMILEAGETBLUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class CARMILEAGETBLCreateManyInput implements _i1.JsonSerializable {
  const CARMILEAGETBLCreateManyInput({
    this.seq,
    required this.carManageNo,
    required this.forUse,
    required this.stPoint,
    required this.destination,
    required this.mileage,
    required this.totalMileage,
    required this.recordDate,
    required this.writerId,
    required this.editorId,
    required this.regDate,
    required this.apprYn,
  });

  factory CARMILEAGETBLCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$CARMILEAGETBLCreateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'CAR_MANAGE_NO')
  final String carManageNo;

  @JsonKey(name: r'FOR_USE')
  final String forUse;

  @JsonKey(name: r'ST_POINT')
  final String stPoint;

  @JsonKey(name: r'DESTINATION')
  final String destination;

  @JsonKey(name: r'MILEAGE')
  final BigInt mileage;

  @JsonKey(name: r'TOTAL_MILEAGE')
  final BigInt totalMileage;

  @JsonKey(name: r'RECORD_DATE')
  final String recordDate;

  @JsonKey(name: r'WRITER_ID')
  final String writerId;

  @JsonKey(name: r'EDITOR_ID')
  final String editorId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'APPR_YN')
  final String apprYn;

  @override
  Map<String, dynamic> toJson() => _$CARMILEAGETBLCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class CARMILEAGETBLUpdateManyMutationInput implements _i1.JsonSerializable {
  const CARMILEAGETBLUpdateManyMutationInput({
    this.seq,
    this.carManageNo,
    this.forUse,
    this.stPoint,
    this.destination,
    this.mileage,
    this.totalMileage,
    this.recordDate,
    this.writerId,
    this.editorId,
    this.regDate,
    this.apprYn,
  });

  factory CARMILEAGETBLUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARMILEAGETBLUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'CAR_MANAGE_NO')
  final StringFieldUpdateOperationsInput? carManageNo;

  @JsonKey(name: r'FOR_USE')
  final StringFieldUpdateOperationsInput? forUse;

  @JsonKey(name: r'ST_POINT')
  final StringFieldUpdateOperationsInput? stPoint;

  @JsonKey(name: r'DESTINATION')
  final StringFieldUpdateOperationsInput? destination;

  @JsonKey(name: r'MILEAGE')
  final BigIntFieldUpdateOperationsInput? mileage;

  @JsonKey(name: r'TOTAL_MILEAGE')
  final BigIntFieldUpdateOperationsInput? totalMileage;

  @JsonKey(name: r'RECORD_DATE')
  final StringFieldUpdateOperationsInput? recordDate;

  @JsonKey(name: r'WRITER_ID')
  final StringFieldUpdateOperationsInput? writerId;

  @JsonKey(name: r'EDITOR_ID')
  final StringFieldUpdateOperationsInput? editorId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'APPR_YN')
  final StringFieldUpdateOperationsInput? apprYn;

  @override
  Map<String, dynamic> toJson() =>
      _$CARMILEAGETBLUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class CARMILEAGETBLUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const CARMILEAGETBLUncheckedUpdateManyInput({
    this.seq,
    this.carManageNo,
    this.forUse,
    this.stPoint,
    this.destination,
    this.mileage,
    this.totalMileage,
    this.recordDate,
    this.writerId,
    this.editorId,
    this.regDate,
    this.apprYn,
  });

  factory CARMILEAGETBLUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARMILEAGETBLUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'CAR_MANAGE_NO')
  final StringFieldUpdateOperationsInput? carManageNo;

  @JsonKey(name: r'FOR_USE')
  final StringFieldUpdateOperationsInput? forUse;

  @JsonKey(name: r'ST_POINT')
  final StringFieldUpdateOperationsInput? stPoint;

  @JsonKey(name: r'DESTINATION')
  final StringFieldUpdateOperationsInput? destination;

  @JsonKey(name: r'MILEAGE')
  final BigIntFieldUpdateOperationsInput? mileage;

  @JsonKey(name: r'TOTAL_MILEAGE')
  final BigIntFieldUpdateOperationsInput? totalMileage;

  @JsonKey(name: r'RECORD_DATE')
  final StringFieldUpdateOperationsInput? recordDate;

  @JsonKey(name: r'WRITER_ID')
  final StringFieldUpdateOperationsInput? writerId;

  @JsonKey(name: r'EDITOR_ID')
  final StringFieldUpdateOperationsInput? editorId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'APPR_YN')
  final StringFieldUpdateOperationsInput? apprYn;

  @override
  Map<String, dynamic> toJson() =>
      _$CARMILEAGETBLUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class CARPARTREPLACETBLCreateInput implements _i1.JsonSerializable {
  const CARPARTREPLACETBLCreateInput({
    this.seq,
    required this.partNm,
    required this.replacePeriod,
    required this.reTotalMileage,
    required this.nowTotalMileage,
    required this.remainMileage,
    required this.replaceCount,
    required this.partReDate,
    required this.writerId,
    required this.regDate,
  });

  factory CARPARTREPLACETBLCreateInput.fromJson(Map<String, dynamic> json) =>
      _$CARPARTREPLACETBLCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'PART_NM')
  final String partNm;

  @JsonKey(name: r'REPLACE_PERIOD')
  final BigInt replacePeriod;

  @JsonKey(name: r'RE_TOTAL_MILEAGE')
  final BigInt reTotalMileage;

  @JsonKey(name: r'NOW_TOTAL_MILEAGE')
  final BigInt nowTotalMileage;

  @JsonKey(name: r'REMAIN_MILEAGE')
  final BigInt remainMileage;

  @JsonKey(name: r'REPLACE_COUNT')
  final BigInt replaceCount;

  @JsonKey(name: r'PART_RE_DATE')
  final String partReDate;

  @JsonKey(name: r'WRITER_ID')
  final String writerId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @override
  Map<String, dynamic> toJson() => _$CARPARTREPLACETBLCreateInputToJson(this);
}

@_i1.jsonSerializable
class CARPARTREPLACETBLUncheckedCreateInput implements _i1.JsonSerializable {
  const CARPARTREPLACETBLUncheckedCreateInput({
    this.seq,
    required this.partNm,
    required this.replacePeriod,
    required this.reTotalMileage,
    required this.nowTotalMileage,
    required this.remainMileage,
    required this.replaceCount,
    required this.partReDate,
    required this.writerId,
    required this.regDate,
  });

  factory CARPARTREPLACETBLUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARPARTREPLACETBLUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'PART_NM')
  final String partNm;

  @JsonKey(name: r'REPLACE_PERIOD')
  final BigInt replacePeriod;

  @JsonKey(name: r'RE_TOTAL_MILEAGE')
  final BigInt reTotalMileage;

  @JsonKey(name: r'NOW_TOTAL_MILEAGE')
  final BigInt nowTotalMileage;

  @JsonKey(name: r'REMAIN_MILEAGE')
  final BigInt remainMileage;

  @JsonKey(name: r'REPLACE_COUNT')
  final BigInt replaceCount;

  @JsonKey(name: r'PART_RE_DATE')
  final String partReDate;

  @JsonKey(name: r'WRITER_ID')
  final String writerId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARPARTREPLACETBLUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class CARPARTREPLACETBLUpdateInput implements _i1.JsonSerializable {
  const CARPARTREPLACETBLUpdateInput({
    this.seq,
    this.partNm,
    this.replacePeriod,
    this.reTotalMileage,
    this.nowTotalMileage,
    this.remainMileage,
    this.replaceCount,
    this.partReDate,
    this.writerId,
    this.regDate,
  });

  factory CARPARTREPLACETBLUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$CARPARTREPLACETBLUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'PART_NM')
  final StringFieldUpdateOperationsInput? partNm;

  @JsonKey(name: r'REPLACE_PERIOD')
  final BigIntFieldUpdateOperationsInput? replacePeriod;

  @JsonKey(name: r'RE_TOTAL_MILEAGE')
  final BigIntFieldUpdateOperationsInput? reTotalMileage;

  @JsonKey(name: r'NOW_TOTAL_MILEAGE')
  final BigIntFieldUpdateOperationsInput? nowTotalMileage;

  @JsonKey(name: r'REMAIN_MILEAGE')
  final BigIntFieldUpdateOperationsInput? remainMileage;

  @JsonKey(name: r'REPLACE_COUNT')
  final BigIntFieldUpdateOperationsInput? replaceCount;

  @JsonKey(name: r'PART_RE_DATE')
  final StringFieldUpdateOperationsInput? partReDate;

  @JsonKey(name: r'WRITER_ID')
  final StringFieldUpdateOperationsInput? writerId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @override
  Map<String, dynamic> toJson() => _$CARPARTREPLACETBLUpdateInputToJson(this);
}

@_i1.jsonSerializable
class CARPARTREPLACETBLUncheckedUpdateInput implements _i1.JsonSerializable {
  const CARPARTREPLACETBLUncheckedUpdateInput({
    this.seq,
    this.partNm,
    this.replacePeriod,
    this.reTotalMileage,
    this.nowTotalMileage,
    this.remainMileage,
    this.replaceCount,
    this.partReDate,
    this.writerId,
    this.regDate,
  });

  factory CARPARTREPLACETBLUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARPARTREPLACETBLUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'PART_NM')
  final StringFieldUpdateOperationsInput? partNm;

  @JsonKey(name: r'REPLACE_PERIOD')
  final BigIntFieldUpdateOperationsInput? replacePeriod;

  @JsonKey(name: r'RE_TOTAL_MILEAGE')
  final BigIntFieldUpdateOperationsInput? reTotalMileage;

  @JsonKey(name: r'NOW_TOTAL_MILEAGE')
  final BigIntFieldUpdateOperationsInput? nowTotalMileage;

  @JsonKey(name: r'REMAIN_MILEAGE')
  final BigIntFieldUpdateOperationsInput? remainMileage;

  @JsonKey(name: r'REPLACE_COUNT')
  final BigIntFieldUpdateOperationsInput? replaceCount;

  @JsonKey(name: r'PART_RE_DATE')
  final StringFieldUpdateOperationsInput? partReDate;

  @JsonKey(name: r'WRITER_ID')
  final StringFieldUpdateOperationsInput? writerId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARPARTREPLACETBLUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class CARPARTREPLACETBLCreateManyInput implements _i1.JsonSerializable {
  const CARPARTREPLACETBLCreateManyInput({
    this.seq,
    required this.partNm,
    required this.replacePeriod,
    required this.reTotalMileage,
    required this.nowTotalMileage,
    required this.remainMileage,
    required this.replaceCount,
    required this.partReDate,
    required this.writerId,
    required this.regDate,
  });

  factory CARPARTREPLACETBLCreateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARPARTREPLACETBLCreateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'PART_NM')
  final String partNm;

  @JsonKey(name: r'REPLACE_PERIOD')
  final BigInt replacePeriod;

  @JsonKey(name: r'RE_TOTAL_MILEAGE')
  final BigInt reTotalMileage;

  @JsonKey(name: r'NOW_TOTAL_MILEAGE')
  final BigInt nowTotalMileage;

  @JsonKey(name: r'REMAIN_MILEAGE')
  final BigInt remainMileage;

  @JsonKey(name: r'REPLACE_COUNT')
  final BigInt replaceCount;

  @JsonKey(name: r'PART_RE_DATE')
  final String partReDate;

  @JsonKey(name: r'WRITER_ID')
  final String writerId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARPARTREPLACETBLCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class CARPARTREPLACETBLUpdateManyMutationInput implements _i1.JsonSerializable {
  const CARPARTREPLACETBLUpdateManyMutationInput({
    this.seq,
    this.partNm,
    this.replacePeriod,
    this.reTotalMileage,
    this.nowTotalMileage,
    this.remainMileage,
    this.replaceCount,
    this.partReDate,
    this.writerId,
    this.regDate,
  });

  factory CARPARTREPLACETBLUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARPARTREPLACETBLUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'PART_NM')
  final StringFieldUpdateOperationsInput? partNm;

  @JsonKey(name: r'REPLACE_PERIOD')
  final BigIntFieldUpdateOperationsInput? replacePeriod;

  @JsonKey(name: r'RE_TOTAL_MILEAGE')
  final BigIntFieldUpdateOperationsInput? reTotalMileage;

  @JsonKey(name: r'NOW_TOTAL_MILEAGE')
  final BigIntFieldUpdateOperationsInput? nowTotalMileage;

  @JsonKey(name: r'REMAIN_MILEAGE')
  final BigIntFieldUpdateOperationsInput? remainMileage;

  @JsonKey(name: r'REPLACE_COUNT')
  final BigIntFieldUpdateOperationsInput? replaceCount;

  @JsonKey(name: r'PART_RE_DATE')
  final StringFieldUpdateOperationsInput? partReDate;

  @JsonKey(name: r'WRITER_ID')
  final StringFieldUpdateOperationsInput? writerId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARPARTREPLACETBLUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class CARPARTREPLACETBLUncheckedUpdateManyInput
    implements _i1.JsonSerializable {
  const CARPARTREPLACETBLUncheckedUpdateManyInput({
    this.seq,
    this.partNm,
    this.replacePeriod,
    this.reTotalMileage,
    this.nowTotalMileage,
    this.remainMileage,
    this.replaceCount,
    this.partReDate,
    this.writerId,
    this.regDate,
  });

  factory CARPARTREPLACETBLUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARPARTREPLACETBLUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'PART_NM')
  final StringFieldUpdateOperationsInput? partNm;

  @JsonKey(name: r'REPLACE_PERIOD')
  final BigIntFieldUpdateOperationsInput? replacePeriod;

  @JsonKey(name: r'RE_TOTAL_MILEAGE')
  final BigIntFieldUpdateOperationsInput? reTotalMileage;

  @JsonKey(name: r'NOW_TOTAL_MILEAGE')
  final BigIntFieldUpdateOperationsInput? nowTotalMileage;

  @JsonKey(name: r'REMAIN_MILEAGE')
  final BigIntFieldUpdateOperationsInput? remainMileage;

  @JsonKey(name: r'REPLACE_COUNT')
  final BigIntFieldUpdateOperationsInput? replaceCount;

  @JsonKey(name: r'PART_RE_DATE')
  final StringFieldUpdateOperationsInput? partReDate;

  @JsonKey(name: r'WRITER_ID')
  final StringFieldUpdateOperationsInput? writerId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARPARTREPLACETBLUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class CARREPAIRLOGCreateInput implements _i1.JsonSerializable {
  const CARREPAIRLOGCreateInput({
    this.seq,
    this.mseq,
    this.assetNo,
    this.repairDe,
    this.repairAmount,
    this.repairStore,
    this.repairLog,
    this.repairOwner,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory CARREPAIRLOGCreateInput.fromJson(Map<String, dynamic> json) =>
      _$CARREPAIRLOGCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'MSEQ')
  final BigInt? mseq;

  @JsonKey(name: r'ASSET_NO')
  final String? assetNo;

  @JsonKey(name: r'REPAIR_DE')
  final String? repairDe;

  @JsonKey(name: r'REPAIR_AMOUNT')
  final String? repairAmount;

  @JsonKey(name: r'REPAIR_STORE')
  final String? repairStore;

  @JsonKey(name: r'REPAIR_LOG')
  final String? repairLog;

  @JsonKey(name: r'REPAIR_OWNER')
  final String? repairOwner;

  @JsonKey(name: r'FILE_TP')
  final String? fileTp;

  @JsonKey(name: r'FLPTH')
  final String? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final String? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final String? streFileNm;

  @JsonKey(name: r'REG_ID')
  final String? regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$CARREPAIRLOGCreateInputToJson(this);
}

@_i1.jsonSerializable
class CARREPAIRLOGUncheckedCreateInput implements _i1.JsonSerializable {
  const CARREPAIRLOGUncheckedCreateInput({
    this.seq,
    this.mseq,
    this.assetNo,
    this.repairDe,
    this.repairAmount,
    this.repairStore,
    this.repairLog,
    this.repairOwner,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory CARREPAIRLOGUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARREPAIRLOGUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'MSEQ')
  final BigInt? mseq;

  @JsonKey(name: r'ASSET_NO')
  final String? assetNo;

  @JsonKey(name: r'REPAIR_DE')
  final String? repairDe;

  @JsonKey(name: r'REPAIR_AMOUNT')
  final String? repairAmount;

  @JsonKey(name: r'REPAIR_STORE')
  final String? repairStore;

  @JsonKey(name: r'REPAIR_LOG')
  final String? repairLog;

  @JsonKey(name: r'REPAIR_OWNER')
  final String? repairOwner;

  @JsonKey(name: r'FILE_TP')
  final String? fileTp;

  @JsonKey(name: r'FLPTH')
  final String? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final String? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final String? streFileNm;

  @JsonKey(name: r'REG_ID')
  final String? regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARREPAIRLOGUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class CARREPAIRLOGUpdateInput implements _i1.JsonSerializable {
  const CARREPAIRLOGUpdateInput({
    this.seq,
    this.mseq,
    this.assetNo,
    this.repairDe,
    this.repairAmount,
    this.repairStore,
    this.repairLog,
    this.repairOwner,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory CARREPAIRLOGUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$CARREPAIRLOGUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'MSEQ')
  final NullableBigIntFieldUpdateOperationsInput? mseq;

  @JsonKey(name: r'ASSET_NO')
  final NullableStringFieldUpdateOperationsInput? assetNo;

  @JsonKey(name: r'REPAIR_DE')
  final NullableStringFieldUpdateOperationsInput? repairDe;

  @JsonKey(name: r'REPAIR_AMOUNT')
  final NullableStringFieldUpdateOperationsInput? repairAmount;

  @JsonKey(name: r'REPAIR_STORE')
  final NullableStringFieldUpdateOperationsInput? repairStore;

  @JsonKey(name: r'REPAIR_LOG')
  final NullableStringFieldUpdateOperationsInput? repairLog;

  @JsonKey(name: r'REPAIR_OWNER')
  final NullableStringFieldUpdateOperationsInput? repairOwner;

  @JsonKey(name: r'FILE_TP')
  final NullableStringFieldUpdateOperationsInput? fileTp;

  @JsonKey(name: r'FLPTH')
  final NullableStringFieldUpdateOperationsInput? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final NullableStringFieldUpdateOperationsInput? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final NullableStringFieldUpdateOperationsInput? streFileNm;

  @JsonKey(name: r'REG_ID')
  final NullableStringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$CARREPAIRLOGUpdateInputToJson(this);
}

@_i1.jsonSerializable
class CARREPAIRLOGUncheckedUpdateInput implements _i1.JsonSerializable {
  const CARREPAIRLOGUncheckedUpdateInput({
    this.seq,
    this.mseq,
    this.assetNo,
    this.repairDe,
    this.repairAmount,
    this.repairStore,
    this.repairLog,
    this.repairOwner,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory CARREPAIRLOGUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARREPAIRLOGUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'MSEQ')
  final NullableBigIntFieldUpdateOperationsInput? mseq;

  @JsonKey(name: r'ASSET_NO')
  final NullableStringFieldUpdateOperationsInput? assetNo;

  @JsonKey(name: r'REPAIR_DE')
  final NullableStringFieldUpdateOperationsInput? repairDe;

  @JsonKey(name: r'REPAIR_AMOUNT')
  final NullableStringFieldUpdateOperationsInput? repairAmount;

  @JsonKey(name: r'REPAIR_STORE')
  final NullableStringFieldUpdateOperationsInput? repairStore;

  @JsonKey(name: r'REPAIR_LOG')
  final NullableStringFieldUpdateOperationsInput? repairLog;

  @JsonKey(name: r'REPAIR_OWNER')
  final NullableStringFieldUpdateOperationsInput? repairOwner;

  @JsonKey(name: r'FILE_TP')
  final NullableStringFieldUpdateOperationsInput? fileTp;

  @JsonKey(name: r'FLPTH')
  final NullableStringFieldUpdateOperationsInput? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final NullableStringFieldUpdateOperationsInput? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final NullableStringFieldUpdateOperationsInput? streFileNm;

  @JsonKey(name: r'REG_ID')
  final NullableStringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARREPAIRLOGUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class CARREPAIRLOGCreateManyInput implements _i1.JsonSerializable {
  const CARREPAIRLOGCreateManyInput({
    this.seq,
    this.mseq,
    this.assetNo,
    this.repairDe,
    this.repairAmount,
    this.repairStore,
    this.repairLog,
    this.repairOwner,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory CARREPAIRLOGCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$CARREPAIRLOGCreateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'MSEQ')
  final BigInt? mseq;

  @JsonKey(name: r'ASSET_NO')
  final String? assetNo;

  @JsonKey(name: r'REPAIR_DE')
  final String? repairDe;

  @JsonKey(name: r'REPAIR_AMOUNT')
  final String? repairAmount;

  @JsonKey(name: r'REPAIR_STORE')
  final String? repairStore;

  @JsonKey(name: r'REPAIR_LOG')
  final String? repairLog;

  @JsonKey(name: r'REPAIR_OWNER')
  final String? repairOwner;

  @JsonKey(name: r'FILE_TP')
  final String? fileTp;

  @JsonKey(name: r'FLPTH')
  final String? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final String? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final String? streFileNm;

  @JsonKey(name: r'REG_ID')
  final String? regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$CARREPAIRLOGCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class CARREPAIRLOGUpdateManyMutationInput implements _i1.JsonSerializable {
  const CARREPAIRLOGUpdateManyMutationInput({
    this.seq,
    this.mseq,
    this.assetNo,
    this.repairDe,
    this.repairAmount,
    this.repairStore,
    this.repairLog,
    this.repairOwner,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory CARREPAIRLOGUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARREPAIRLOGUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'MSEQ')
  final NullableBigIntFieldUpdateOperationsInput? mseq;

  @JsonKey(name: r'ASSET_NO')
  final NullableStringFieldUpdateOperationsInput? assetNo;

  @JsonKey(name: r'REPAIR_DE')
  final NullableStringFieldUpdateOperationsInput? repairDe;

  @JsonKey(name: r'REPAIR_AMOUNT')
  final NullableStringFieldUpdateOperationsInput? repairAmount;

  @JsonKey(name: r'REPAIR_STORE')
  final NullableStringFieldUpdateOperationsInput? repairStore;

  @JsonKey(name: r'REPAIR_LOG')
  final NullableStringFieldUpdateOperationsInput? repairLog;

  @JsonKey(name: r'REPAIR_OWNER')
  final NullableStringFieldUpdateOperationsInput? repairOwner;

  @JsonKey(name: r'FILE_TP')
  final NullableStringFieldUpdateOperationsInput? fileTp;

  @JsonKey(name: r'FLPTH')
  final NullableStringFieldUpdateOperationsInput? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final NullableStringFieldUpdateOperationsInput? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final NullableStringFieldUpdateOperationsInput? streFileNm;

  @JsonKey(name: r'REG_ID')
  final NullableStringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARREPAIRLOGUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class CARREPAIRLOGUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const CARREPAIRLOGUncheckedUpdateManyInput({
    this.seq,
    this.mseq,
    this.assetNo,
    this.repairDe,
    this.repairAmount,
    this.repairStore,
    this.repairLog,
    this.repairOwner,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory CARREPAIRLOGUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARREPAIRLOGUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'MSEQ')
  final NullableBigIntFieldUpdateOperationsInput? mseq;

  @JsonKey(name: r'ASSET_NO')
  final NullableStringFieldUpdateOperationsInput? assetNo;

  @JsonKey(name: r'REPAIR_DE')
  final NullableStringFieldUpdateOperationsInput? repairDe;

  @JsonKey(name: r'REPAIR_AMOUNT')
  final NullableStringFieldUpdateOperationsInput? repairAmount;

  @JsonKey(name: r'REPAIR_STORE')
  final NullableStringFieldUpdateOperationsInput? repairStore;

  @JsonKey(name: r'REPAIR_LOG')
  final NullableStringFieldUpdateOperationsInput? repairLog;

  @JsonKey(name: r'REPAIR_OWNER')
  final NullableStringFieldUpdateOperationsInput? repairOwner;

  @JsonKey(name: r'FILE_TP')
  final NullableStringFieldUpdateOperationsInput? fileTp;

  @JsonKey(name: r'FLPTH')
  final NullableStringFieldUpdateOperationsInput? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final NullableStringFieldUpdateOperationsInput? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final NullableStringFieldUpdateOperationsInput? streFileNm;

  @JsonKey(name: r'REG_ID')
  final NullableStringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARREPAIRLOGUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class CARUSEMANAGETBLCreateInput implements _i1.JsonSerializable {
  const CARUSEMANAGETBLCreateInput({
    this.seq,
    required this.carNo,
    required this.carType,
    required this.destination,
    this.purpose,
    required this.users,
    this.useStartDate,
    this.useEndDate,
    this.useBeforeDistance,
    this.useAfterDistance,
    this.remarks,
    this.acceptYn,
    this.regUser,
    this.regDate,
    this.useStartHour,
    this.useEndHour,
    this.cardApply,
  });

  factory CARUSEMANAGETBLCreateInput.fromJson(Map<String, dynamic> json) =>
      _$CARUSEMANAGETBLCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'CAR_NO')
  final String carNo;

  @JsonKey(name: r'CAR_TYPE')
  final String carType;

  @JsonKey(name: r'DESTINATION')
  final String destination;

  @JsonKey(name: r'PURPOSE')
  final String? purpose;

  @JsonKey(name: r'USERS')
  final String users;

  @JsonKey(name: r'USE_START_DATE')
  final DateTime? useStartDate;

  @JsonKey(name: r'USE_END_DATE')
  final DateTime? useEndDate;

  @JsonKey(name: r'USE_BEFORE_DISTANCE')
  final double? useBeforeDistance;

  @JsonKey(name: r'USE_AFTER_DISTANCE')
  final double? useAfterDistance;

  @JsonKey(name: r'REMARKS')
  final String? remarks;

  @JsonKey(name: r'ACCEPT_YN')
  final String? acceptYn;

  @JsonKey(name: r'REG_USER')
  final String? regUser;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'USE_START_HOUR')
  final String? useStartHour;

  @JsonKey(name: r'USE_END_HOUR')
  final String? useEndHour;

  @JsonKey(name: r'CARD_APPLY')
  final String? cardApply;

  @override
  Map<String, dynamic> toJson() => _$CARUSEMANAGETBLCreateInputToJson(this);
}

@_i1.jsonSerializable
class CARUSEMANAGETBLUncheckedCreateInput implements _i1.JsonSerializable {
  const CARUSEMANAGETBLUncheckedCreateInput({
    this.seq,
    required this.carNo,
    required this.carType,
    required this.destination,
    this.purpose,
    required this.users,
    this.useStartDate,
    this.useEndDate,
    this.useBeforeDistance,
    this.useAfterDistance,
    this.remarks,
    this.acceptYn,
    this.regUser,
    this.regDate,
    this.useStartHour,
    this.useEndHour,
    this.cardApply,
  });

  factory CARUSEMANAGETBLUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARUSEMANAGETBLUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'CAR_NO')
  final String carNo;

  @JsonKey(name: r'CAR_TYPE')
  final String carType;

  @JsonKey(name: r'DESTINATION')
  final String destination;

  @JsonKey(name: r'PURPOSE')
  final String? purpose;

  @JsonKey(name: r'USERS')
  final String users;

  @JsonKey(name: r'USE_START_DATE')
  final DateTime? useStartDate;

  @JsonKey(name: r'USE_END_DATE')
  final DateTime? useEndDate;

  @JsonKey(name: r'USE_BEFORE_DISTANCE')
  final double? useBeforeDistance;

  @JsonKey(name: r'USE_AFTER_DISTANCE')
  final double? useAfterDistance;

  @JsonKey(name: r'REMARKS')
  final String? remarks;

  @JsonKey(name: r'ACCEPT_YN')
  final String? acceptYn;

  @JsonKey(name: r'REG_USER')
  final String? regUser;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'USE_START_HOUR')
  final String? useStartHour;

  @JsonKey(name: r'USE_END_HOUR')
  final String? useEndHour;

  @JsonKey(name: r'CARD_APPLY')
  final String? cardApply;

  @override
  Map<String, dynamic> toJson() =>
      _$CARUSEMANAGETBLUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class CARUSEMANAGETBLUpdateInput implements _i1.JsonSerializable {
  const CARUSEMANAGETBLUpdateInput({
    this.seq,
    this.carNo,
    this.carType,
    this.destination,
    this.purpose,
    this.users,
    this.useStartDate,
    this.useEndDate,
    this.useBeforeDistance,
    this.useAfterDistance,
    this.remarks,
    this.acceptYn,
    this.regUser,
    this.regDate,
    this.useStartHour,
    this.useEndHour,
    this.cardApply,
  });

  factory CARUSEMANAGETBLUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$CARUSEMANAGETBLUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'CAR_NO')
  final StringFieldUpdateOperationsInput? carNo;

  @JsonKey(name: r'CAR_TYPE')
  final StringFieldUpdateOperationsInput? carType;

  @JsonKey(name: r'DESTINATION')
  final StringFieldUpdateOperationsInput? destination;

  @JsonKey(name: r'PURPOSE')
  final NullableStringFieldUpdateOperationsInput? purpose;

  @JsonKey(name: r'USERS')
  final StringFieldUpdateOperationsInput? users;

  @JsonKey(name: r'USE_START_DATE')
  final DateTimeFieldUpdateOperationsInput? useStartDate;

  @JsonKey(name: r'USE_END_DATE')
  final DateTimeFieldUpdateOperationsInput? useEndDate;

  @JsonKey(name: r'USE_BEFORE_DISTANCE')
  final NullableDecimalFieldUpdateOperationsInput? useBeforeDistance;

  @JsonKey(name: r'USE_AFTER_DISTANCE')
  final NullableDecimalFieldUpdateOperationsInput? useAfterDistance;

  @JsonKey(name: r'REMARKS')
  final NullableStringFieldUpdateOperationsInput? remarks;

  @JsonKey(name: r'ACCEPT_YN')
  final NullableStringFieldUpdateOperationsInput? acceptYn;

  @JsonKey(name: r'REG_USER')
  final NullableStringFieldUpdateOperationsInput? regUser;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'USE_START_HOUR')
  final NullableStringFieldUpdateOperationsInput? useStartHour;

  @JsonKey(name: r'USE_END_HOUR')
  final NullableStringFieldUpdateOperationsInput? useEndHour;

  @JsonKey(name: r'CARD_APPLY')
  final StringFieldUpdateOperationsInput? cardApply;

  @override
  Map<String, dynamic> toJson() => _$CARUSEMANAGETBLUpdateInputToJson(this);
}

@_i1.jsonSerializable
class CARUSEMANAGETBLUncheckedUpdateInput implements _i1.JsonSerializable {
  const CARUSEMANAGETBLUncheckedUpdateInput({
    this.seq,
    this.carNo,
    this.carType,
    this.destination,
    this.purpose,
    this.users,
    this.useStartDate,
    this.useEndDate,
    this.useBeforeDistance,
    this.useAfterDistance,
    this.remarks,
    this.acceptYn,
    this.regUser,
    this.regDate,
    this.useStartHour,
    this.useEndHour,
    this.cardApply,
  });

  factory CARUSEMANAGETBLUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARUSEMANAGETBLUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'CAR_NO')
  final StringFieldUpdateOperationsInput? carNo;

  @JsonKey(name: r'CAR_TYPE')
  final StringFieldUpdateOperationsInput? carType;

  @JsonKey(name: r'DESTINATION')
  final StringFieldUpdateOperationsInput? destination;

  @JsonKey(name: r'PURPOSE')
  final NullableStringFieldUpdateOperationsInput? purpose;

  @JsonKey(name: r'USERS')
  final StringFieldUpdateOperationsInput? users;

  @JsonKey(name: r'USE_START_DATE')
  final DateTimeFieldUpdateOperationsInput? useStartDate;

  @JsonKey(name: r'USE_END_DATE')
  final DateTimeFieldUpdateOperationsInput? useEndDate;

  @JsonKey(name: r'USE_BEFORE_DISTANCE')
  final NullableDecimalFieldUpdateOperationsInput? useBeforeDistance;

  @JsonKey(name: r'USE_AFTER_DISTANCE')
  final NullableDecimalFieldUpdateOperationsInput? useAfterDistance;

  @JsonKey(name: r'REMARKS')
  final NullableStringFieldUpdateOperationsInput? remarks;

  @JsonKey(name: r'ACCEPT_YN')
  final NullableStringFieldUpdateOperationsInput? acceptYn;

  @JsonKey(name: r'REG_USER')
  final NullableStringFieldUpdateOperationsInput? regUser;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'USE_START_HOUR')
  final NullableStringFieldUpdateOperationsInput? useStartHour;

  @JsonKey(name: r'USE_END_HOUR')
  final NullableStringFieldUpdateOperationsInput? useEndHour;

  @JsonKey(name: r'CARD_APPLY')
  final StringFieldUpdateOperationsInput? cardApply;

  @override
  Map<String, dynamic> toJson() =>
      _$CARUSEMANAGETBLUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class CARUSEMANAGETBLCreateManyInput implements _i1.JsonSerializable {
  const CARUSEMANAGETBLCreateManyInput({
    this.seq,
    required this.carNo,
    required this.carType,
    required this.destination,
    this.purpose,
    required this.users,
    this.useStartDate,
    this.useEndDate,
    this.useBeforeDistance,
    this.useAfterDistance,
    this.remarks,
    this.acceptYn,
    this.regUser,
    this.regDate,
    this.useStartHour,
    this.useEndHour,
    this.cardApply,
  });

  factory CARUSEMANAGETBLCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$CARUSEMANAGETBLCreateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'CAR_NO')
  final String carNo;

  @JsonKey(name: r'CAR_TYPE')
  final String carType;

  @JsonKey(name: r'DESTINATION')
  final String destination;

  @JsonKey(name: r'PURPOSE')
  final String? purpose;

  @JsonKey(name: r'USERS')
  final String users;

  @JsonKey(name: r'USE_START_DATE')
  final DateTime? useStartDate;

  @JsonKey(name: r'USE_END_DATE')
  final DateTime? useEndDate;

  @JsonKey(name: r'USE_BEFORE_DISTANCE')
  final double? useBeforeDistance;

  @JsonKey(name: r'USE_AFTER_DISTANCE')
  final double? useAfterDistance;

  @JsonKey(name: r'REMARKS')
  final String? remarks;

  @JsonKey(name: r'ACCEPT_YN')
  final String? acceptYn;

  @JsonKey(name: r'REG_USER')
  final String? regUser;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'USE_START_HOUR')
  final String? useStartHour;

  @JsonKey(name: r'USE_END_HOUR')
  final String? useEndHour;

  @JsonKey(name: r'CARD_APPLY')
  final String? cardApply;

  @override
  Map<String, dynamic> toJson() => _$CARUSEMANAGETBLCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class CARUSEMANAGETBLUpdateManyMutationInput implements _i1.JsonSerializable {
  const CARUSEMANAGETBLUpdateManyMutationInput({
    this.seq,
    this.carNo,
    this.carType,
    this.destination,
    this.purpose,
    this.users,
    this.useStartDate,
    this.useEndDate,
    this.useBeforeDistance,
    this.useAfterDistance,
    this.remarks,
    this.acceptYn,
    this.regUser,
    this.regDate,
    this.useStartHour,
    this.useEndHour,
    this.cardApply,
  });

  factory CARUSEMANAGETBLUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARUSEMANAGETBLUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'CAR_NO')
  final StringFieldUpdateOperationsInput? carNo;

  @JsonKey(name: r'CAR_TYPE')
  final StringFieldUpdateOperationsInput? carType;

  @JsonKey(name: r'DESTINATION')
  final StringFieldUpdateOperationsInput? destination;

  @JsonKey(name: r'PURPOSE')
  final NullableStringFieldUpdateOperationsInput? purpose;

  @JsonKey(name: r'USERS')
  final StringFieldUpdateOperationsInput? users;

  @JsonKey(name: r'USE_START_DATE')
  final DateTimeFieldUpdateOperationsInput? useStartDate;

  @JsonKey(name: r'USE_END_DATE')
  final DateTimeFieldUpdateOperationsInput? useEndDate;

  @JsonKey(name: r'USE_BEFORE_DISTANCE')
  final NullableDecimalFieldUpdateOperationsInput? useBeforeDistance;

  @JsonKey(name: r'USE_AFTER_DISTANCE')
  final NullableDecimalFieldUpdateOperationsInput? useAfterDistance;

  @JsonKey(name: r'REMARKS')
  final NullableStringFieldUpdateOperationsInput? remarks;

  @JsonKey(name: r'ACCEPT_YN')
  final NullableStringFieldUpdateOperationsInput? acceptYn;

  @JsonKey(name: r'REG_USER')
  final NullableStringFieldUpdateOperationsInput? regUser;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'USE_START_HOUR')
  final NullableStringFieldUpdateOperationsInput? useStartHour;

  @JsonKey(name: r'USE_END_HOUR')
  final NullableStringFieldUpdateOperationsInput? useEndHour;

  @JsonKey(name: r'CARD_APPLY')
  final StringFieldUpdateOperationsInput? cardApply;

  @override
  Map<String, dynamic> toJson() =>
      _$CARUSEMANAGETBLUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class CARUSEMANAGETBLUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const CARUSEMANAGETBLUncheckedUpdateManyInput({
    this.seq,
    this.carNo,
    this.carType,
    this.destination,
    this.purpose,
    this.users,
    this.useStartDate,
    this.useEndDate,
    this.useBeforeDistance,
    this.useAfterDistance,
    this.remarks,
    this.acceptYn,
    this.regUser,
    this.regDate,
    this.useStartHour,
    this.useEndHour,
    this.cardApply,
  });

  factory CARUSEMANAGETBLUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARUSEMANAGETBLUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'CAR_NO')
  final StringFieldUpdateOperationsInput? carNo;

  @JsonKey(name: r'CAR_TYPE')
  final StringFieldUpdateOperationsInput? carType;

  @JsonKey(name: r'DESTINATION')
  final StringFieldUpdateOperationsInput? destination;

  @JsonKey(name: r'PURPOSE')
  final NullableStringFieldUpdateOperationsInput? purpose;

  @JsonKey(name: r'USERS')
  final StringFieldUpdateOperationsInput? users;

  @JsonKey(name: r'USE_START_DATE')
  final DateTimeFieldUpdateOperationsInput? useStartDate;

  @JsonKey(name: r'USE_END_DATE')
  final DateTimeFieldUpdateOperationsInput? useEndDate;

  @JsonKey(name: r'USE_BEFORE_DISTANCE')
  final NullableDecimalFieldUpdateOperationsInput? useBeforeDistance;

  @JsonKey(name: r'USE_AFTER_DISTANCE')
  final NullableDecimalFieldUpdateOperationsInput? useAfterDistance;

  @JsonKey(name: r'REMARKS')
  final NullableStringFieldUpdateOperationsInput? remarks;

  @JsonKey(name: r'ACCEPT_YN')
  final NullableStringFieldUpdateOperationsInput? acceptYn;

  @JsonKey(name: r'REG_USER')
  final NullableStringFieldUpdateOperationsInput? regUser;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'USE_START_HOUR')
  final NullableStringFieldUpdateOperationsInput? useStartHour;

  @JsonKey(name: r'USE_END_HOUR')
  final NullableStringFieldUpdateOperationsInput? useEndHour;

  @JsonKey(name: r'CARD_APPLY')
  final StringFieldUpdateOperationsInput? cardApply;

  @override
  Map<String, dynamic> toJson() =>
      _$CARUSEMANAGETBLUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class HOLIDAYTBLCreateInput implements _i1.JsonSerializable {
  const HOLIDAYTBLCreateInput({
    required this.userId,
    required this.stdYear,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory HOLIDAYTBLCreateInput.fromJson(Map<String, dynamic> json) =>
      _$HOLIDAYTBLCreateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'STD_YEAR')
  final String stdYear;

  @JsonKey(name: r'M1')
  final double? m1;

  @JsonKey(name: r'M2')
  final double? m2;

  @JsonKey(name: r'M3')
  final double? m3;

  @JsonKey(name: r'M4')
  final double? m4;

  @JsonKey(name: r'M5')
  final double? m5;

  @JsonKey(name: r'M6')
  final double? m6;

  @JsonKey(name: r'M7')
  final double? m7;

  @JsonKey(name: r'M8')
  final double? m8;

  @JsonKey(name: r'M9')
  final double? m9;

  @JsonKey(name: r'M10')
  final double? m10;

  @JsonKey(name: r'M11')
  final double? m11;

  @JsonKey(name: r'M12')
  final double? m12;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() => _$HOLIDAYTBLCreateInputToJson(this);
}

@_i1.jsonSerializable
class HOLIDAYTBLUncheckedCreateInput implements _i1.JsonSerializable {
  const HOLIDAYTBLUncheckedCreateInput({
    required this.userId,
    required this.stdYear,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory HOLIDAYTBLUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$HOLIDAYTBLUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'STD_YEAR')
  final String stdYear;

  @JsonKey(name: r'M1')
  final double? m1;

  @JsonKey(name: r'M2')
  final double? m2;

  @JsonKey(name: r'M3')
  final double? m3;

  @JsonKey(name: r'M4')
  final double? m4;

  @JsonKey(name: r'M5')
  final double? m5;

  @JsonKey(name: r'M6')
  final double? m6;

  @JsonKey(name: r'M7')
  final double? m7;

  @JsonKey(name: r'M8')
  final double? m8;

  @JsonKey(name: r'M9')
  final double? m9;

  @JsonKey(name: r'M10')
  final double? m10;

  @JsonKey(name: r'M11')
  final double? m11;

  @JsonKey(name: r'M12')
  final double? m12;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() => _$HOLIDAYTBLUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class HOLIDAYTBLUpdateInput implements _i1.JsonSerializable {
  const HOLIDAYTBLUpdateInput({
    this.userId,
    this.stdYear,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory HOLIDAYTBLUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$HOLIDAYTBLUpdateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'STD_YEAR')
  final StringFieldUpdateOperationsInput? stdYear;

  @JsonKey(name: r'M1')
  final NullableDecimalFieldUpdateOperationsInput? m1;

  @JsonKey(name: r'M2')
  final NullableDecimalFieldUpdateOperationsInput? m2;

  @JsonKey(name: r'M3')
  final NullableDecimalFieldUpdateOperationsInput? m3;

  @JsonKey(name: r'M4')
  final NullableDecimalFieldUpdateOperationsInput? m4;

  @JsonKey(name: r'M5')
  final NullableDecimalFieldUpdateOperationsInput? m5;

  @JsonKey(name: r'M6')
  final NullableDecimalFieldUpdateOperationsInput? m6;

  @JsonKey(name: r'M7')
  final NullableDecimalFieldUpdateOperationsInput? m7;

  @JsonKey(name: r'M8')
  final NullableDecimalFieldUpdateOperationsInput? m8;

  @JsonKey(name: r'M9')
  final NullableDecimalFieldUpdateOperationsInput? m9;

  @JsonKey(name: r'M10')
  final NullableDecimalFieldUpdateOperationsInput? m10;

  @JsonKey(name: r'M11')
  final NullableDecimalFieldUpdateOperationsInput? m11;

  @JsonKey(name: r'M12')
  final NullableDecimalFieldUpdateOperationsInput? m12;

  @JsonKey(name: r'USE_YN')
  final StringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @override
  Map<String, dynamic> toJson() => _$HOLIDAYTBLUpdateInputToJson(this);
}

@_i1.jsonSerializable
class HOLIDAYTBLUncheckedUpdateInput implements _i1.JsonSerializable {
  const HOLIDAYTBLUncheckedUpdateInput({
    this.userId,
    this.stdYear,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory HOLIDAYTBLUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$HOLIDAYTBLUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'STD_YEAR')
  final StringFieldUpdateOperationsInput? stdYear;

  @JsonKey(name: r'M1')
  final NullableDecimalFieldUpdateOperationsInput? m1;

  @JsonKey(name: r'M2')
  final NullableDecimalFieldUpdateOperationsInput? m2;

  @JsonKey(name: r'M3')
  final NullableDecimalFieldUpdateOperationsInput? m3;

  @JsonKey(name: r'M4')
  final NullableDecimalFieldUpdateOperationsInput? m4;

  @JsonKey(name: r'M5')
  final NullableDecimalFieldUpdateOperationsInput? m5;

  @JsonKey(name: r'M6')
  final NullableDecimalFieldUpdateOperationsInput? m6;

  @JsonKey(name: r'M7')
  final NullableDecimalFieldUpdateOperationsInput? m7;

  @JsonKey(name: r'M8')
  final NullableDecimalFieldUpdateOperationsInput? m8;

  @JsonKey(name: r'M9')
  final NullableDecimalFieldUpdateOperationsInput? m9;

  @JsonKey(name: r'M10')
  final NullableDecimalFieldUpdateOperationsInput? m10;

  @JsonKey(name: r'M11')
  final NullableDecimalFieldUpdateOperationsInput? m11;

  @JsonKey(name: r'M12')
  final NullableDecimalFieldUpdateOperationsInput? m12;

  @JsonKey(name: r'USE_YN')
  final StringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @override
  Map<String, dynamic> toJson() => _$HOLIDAYTBLUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class HOLIDAYTBLCreateManyInput implements _i1.JsonSerializable {
  const HOLIDAYTBLCreateManyInput({
    required this.userId,
    required this.stdYear,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory HOLIDAYTBLCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$HOLIDAYTBLCreateManyInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'STD_YEAR')
  final String stdYear;

  @JsonKey(name: r'M1')
  final double? m1;

  @JsonKey(name: r'M2')
  final double? m2;

  @JsonKey(name: r'M3')
  final double? m3;

  @JsonKey(name: r'M4')
  final double? m4;

  @JsonKey(name: r'M5')
  final double? m5;

  @JsonKey(name: r'M6')
  final double? m6;

  @JsonKey(name: r'M7')
  final double? m7;

  @JsonKey(name: r'M8')
  final double? m8;

  @JsonKey(name: r'M9')
  final double? m9;

  @JsonKey(name: r'M10')
  final double? m10;

  @JsonKey(name: r'M11')
  final double? m11;

  @JsonKey(name: r'M12')
  final double? m12;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() => _$HOLIDAYTBLCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class HOLIDAYTBLUpdateManyMutationInput implements _i1.JsonSerializable {
  const HOLIDAYTBLUpdateManyMutationInput({
    this.userId,
    this.stdYear,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory HOLIDAYTBLUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$HOLIDAYTBLUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'STD_YEAR')
  final StringFieldUpdateOperationsInput? stdYear;

  @JsonKey(name: r'M1')
  final NullableDecimalFieldUpdateOperationsInput? m1;

  @JsonKey(name: r'M2')
  final NullableDecimalFieldUpdateOperationsInput? m2;

  @JsonKey(name: r'M3')
  final NullableDecimalFieldUpdateOperationsInput? m3;

  @JsonKey(name: r'M4')
  final NullableDecimalFieldUpdateOperationsInput? m4;

  @JsonKey(name: r'M5')
  final NullableDecimalFieldUpdateOperationsInput? m5;

  @JsonKey(name: r'M6')
  final NullableDecimalFieldUpdateOperationsInput? m6;

  @JsonKey(name: r'M7')
  final NullableDecimalFieldUpdateOperationsInput? m7;

  @JsonKey(name: r'M8')
  final NullableDecimalFieldUpdateOperationsInput? m8;

  @JsonKey(name: r'M9')
  final NullableDecimalFieldUpdateOperationsInput? m9;

  @JsonKey(name: r'M10')
  final NullableDecimalFieldUpdateOperationsInput? m10;

  @JsonKey(name: r'M11')
  final NullableDecimalFieldUpdateOperationsInput? m11;

  @JsonKey(name: r'M12')
  final NullableDecimalFieldUpdateOperationsInput? m12;

  @JsonKey(name: r'USE_YN')
  final StringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$HOLIDAYTBLUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class HOLIDAYTBLUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const HOLIDAYTBLUncheckedUpdateManyInput({
    this.userId,
    this.stdYear,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory HOLIDAYTBLUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$HOLIDAYTBLUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'STD_YEAR')
  final StringFieldUpdateOperationsInput? stdYear;

  @JsonKey(name: r'M1')
  final NullableDecimalFieldUpdateOperationsInput? m1;

  @JsonKey(name: r'M2')
  final NullableDecimalFieldUpdateOperationsInput? m2;

  @JsonKey(name: r'M3')
  final NullableDecimalFieldUpdateOperationsInput? m3;

  @JsonKey(name: r'M4')
  final NullableDecimalFieldUpdateOperationsInput? m4;

  @JsonKey(name: r'M5')
  final NullableDecimalFieldUpdateOperationsInput? m5;

  @JsonKey(name: r'M6')
  final NullableDecimalFieldUpdateOperationsInput? m6;

  @JsonKey(name: r'M7')
  final NullableDecimalFieldUpdateOperationsInput? m7;

  @JsonKey(name: r'M8')
  final NullableDecimalFieldUpdateOperationsInput? m8;

  @JsonKey(name: r'M9')
  final NullableDecimalFieldUpdateOperationsInput? m9;

  @JsonKey(name: r'M10')
  final NullableDecimalFieldUpdateOperationsInput? m10;

  @JsonKey(name: r'M11')
  final NullableDecimalFieldUpdateOperationsInput? m11;

  @JsonKey(name: r'M12')
  final NullableDecimalFieldUpdateOperationsInput? m12;

  @JsonKey(name: r'USE_YN')
  final StringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$HOLIDAYTBLUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class MEMBERTBLCreateInput implements _i1.JsonSerializable {
  const MEMBERTBLCreateInput({
    required this.userId,
    required this.passwd,
    required this.userNm,
    this.dept,
    this.grade,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
    this.lastLoginDate,
    this.memo,
    this.menuTbl,
  });

  factory MEMBERTBLCreateInput.fromJson(Map<String, dynamic> json) =>
      _$MEMBERTBLCreateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'PASSWD')
  final String passwd;

  @JsonKey(name: r'USER_NM')
  final String userNm;

  @JsonKey(name: r'DEPT')
  final String? dept;

  @JsonKey(name: r'GRADE')
  final String? grade;

  @JsonKey(name: r'JOIN_DATE')
  final DateTime? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final DateTime? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final DateTime? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final int? pwdWrongCnt;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'LAST_LOGIN_DATE')
  final DateTime? lastLoginDate;

  @JsonKey(name: r'MEMO')
  final String? memo;

  @JsonKey(name: r'MENU_TBL')
  final MENUTBLCreateNestedManyWithoutMEMBERTBLInput? menuTbl;

  @override
  Map<String, dynamic> toJson() => _$MEMBERTBLCreateInputToJson(this);
}

@_i1.jsonSerializable
class MEMBERTBLUncheckedCreateInput implements _i1.JsonSerializable {
  const MEMBERTBLUncheckedCreateInput({
    required this.userId,
    required this.passwd,
    required this.userNm,
    this.dept,
    this.grade,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
    this.lastLoginDate,
    this.memo,
    this.menuTbl,
  });

  factory MEMBERTBLUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$MEMBERTBLUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'PASSWD')
  final String passwd;

  @JsonKey(name: r'USER_NM')
  final String userNm;

  @JsonKey(name: r'DEPT')
  final String? dept;

  @JsonKey(name: r'GRADE')
  final String? grade;

  @JsonKey(name: r'JOIN_DATE')
  final DateTime? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final DateTime? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final DateTime? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final int? pwdWrongCnt;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'LAST_LOGIN_DATE')
  final DateTime? lastLoginDate;

  @JsonKey(name: r'MEMO')
  final String? memo;

  @JsonKey(name: r'MENU_TBL')
  final MENUTBLUncheckedCreateNestedManyWithoutMEMBERTBLInput? menuTbl;

  @override
  Map<String, dynamic> toJson() => _$MEMBERTBLUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class MEMBERTBLUpdateInput implements _i1.JsonSerializable {
  const MEMBERTBLUpdateInput({
    this.userId,
    this.passwd,
    this.userNm,
    this.dept,
    this.grade,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
    this.lastLoginDate,
    this.memo,
    this.menuTbl,
  });

  factory MEMBERTBLUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$MEMBERTBLUpdateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'PASSWD')
  final StringFieldUpdateOperationsInput? passwd;

  @JsonKey(name: r'USER_NM')
  final StringFieldUpdateOperationsInput? userNm;

  @JsonKey(name: r'DEPT')
  final NullableStringFieldUpdateOperationsInput? dept;

  @JsonKey(name: r'GRADE')
  final NullableStringFieldUpdateOperationsInput? grade;

  @JsonKey(name: r'JOIN_DATE')
  final DateTimeFieldUpdateOperationsInput? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final DateTimeFieldUpdateOperationsInput? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final DateTimeFieldUpdateOperationsInput? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final NullableIntFieldUpdateOperationsInput? pwdWrongCnt;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'LAST_LOGIN_DATE')
  final DateTimeFieldUpdateOperationsInput? lastLoginDate;

  @JsonKey(name: r'MEMO')
  final NullableStringFieldUpdateOperationsInput? memo;

  @JsonKey(name: r'MENU_TBL')
  final MENUTBLUpdateManyWithoutMEMBERTBLNestedInput? menuTbl;

  @override
  Map<String, dynamic> toJson() => _$MEMBERTBLUpdateInputToJson(this);
}

@_i1.jsonSerializable
class MEMBERTBLUncheckedUpdateInput implements _i1.JsonSerializable {
  const MEMBERTBLUncheckedUpdateInput({
    this.userId,
    this.passwd,
    this.userNm,
    this.dept,
    this.grade,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
    this.lastLoginDate,
    this.memo,
    this.menuTbl,
  });

  factory MEMBERTBLUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$MEMBERTBLUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'PASSWD')
  final StringFieldUpdateOperationsInput? passwd;

  @JsonKey(name: r'USER_NM')
  final StringFieldUpdateOperationsInput? userNm;

  @JsonKey(name: r'DEPT')
  final NullableStringFieldUpdateOperationsInput? dept;

  @JsonKey(name: r'GRADE')
  final NullableStringFieldUpdateOperationsInput? grade;

  @JsonKey(name: r'JOIN_DATE')
  final DateTimeFieldUpdateOperationsInput? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final DateTimeFieldUpdateOperationsInput? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final DateTimeFieldUpdateOperationsInput? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final NullableIntFieldUpdateOperationsInput? pwdWrongCnt;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'LAST_LOGIN_DATE')
  final DateTimeFieldUpdateOperationsInput? lastLoginDate;

  @JsonKey(name: r'MEMO')
  final NullableStringFieldUpdateOperationsInput? memo;

  @JsonKey(name: r'MENU_TBL')
  final MENUTBLUncheckedUpdateManyWithoutMEMBERTBLNestedInput? menuTbl;

  @override
  Map<String, dynamic> toJson() => _$MEMBERTBLUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class MEMBERTBLCreateManyInput implements _i1.JsonSerializable {
  const MEMBERTBLCreateManyInput({
    required this.userId,
    required this.passwd,
    required this.userNm,
    this.dept,
    this.grade,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
    this.lastLoginDate,
    this.memo,
  });

  factory MEMBERTBLCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$MEMBERTBLCreateManyInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'PASSWD')
  final String passwd;

  @JsonKey(name: r'USER_NM')
  final String userNm;

  @JsonKey(name: r'DEPT')
  final String? dept;

  @JsonKey(name: r'GRADE')
  final String? grade;

  @JsonKey(name: r'JOIN_DATE')
  final DateTime? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final DateTime? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final DateTime? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final int? pwdWrongCnt;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'LAST_LOGIN_DATE')
  final DateTime? lastLoginDate;

  @JsonKey(name: r'MEMO')
  final String? memo;

  @override
  Map<String, dynamic> toJson() => _$MEMBERTBLCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class MEMBERTBLUpdateManyMutationInput implements _i1.JsonSerializable {
  const MEMBERTBLUpdateManyMutationInput({
    this.userId,
    this.passwd,
    this.userNm,
    this.dept,
    this.grade,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
    this.lastLoginDate,
    this.memo,
  });

  factory MEMBERTBLUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$MEMBERTBLUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'PASSWD')
  final StringFieldUpdateOperationsInput? passwd;

  @JsonKey(name: r'USER_NM')
  final StringFieldUpdateOperationsInput? userNm;

  @JsonKey(name: r'DEPT')
  final NullableStringFieldUpdateOperationsInput? dept;

  @JsonKey(name: r'GRADE')
  final NullableStringFieldUpdateOperationsInput? grade;

  @JsonKey(name: r'JOIN_DATE')
  final DateTimeFieldUpdateOperationsInput? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final DateTimeFieldUpdateOperationsInput? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final DateTimeFieldUpdateOperationsInput? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final NullableIntFieldUpdateOperationsInput? pwdWrongCnt;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'LAST_LOGIN_DATE')
  final DateTimeFieldUpdateOperationsInput? lastLoginDate;

  @JsonKey(name: r'MEMO')
  final NullableStringFieldUpdateOperationsInput? memo;

  @override
  Map<String, dynamic> toJson() =>
      _$MEMBERTBLUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class MEMBERTBLUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const MEMBERTBLUncheckedUpdateManyInput({
    this.userId,
    this.passwd,
    this.userNm,
    this.dept,
    this.grade,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
    this.lastLoginDate,
    this.memo,
  });

  factory MEMBERTBLUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$MEMBERTBLUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'PASSWD')
  final StringFieldUpdateOperationsInput? passwd;

  @JsonKey(name: r'USER_NM')
  final StringFieldUpdateOperationsInput? userNm;

  @JsonKey(name: r'DEPT')
  final NullableStringFieldUpdateOperationsInput? dept;

  @JsonKey(name: r'GRADE')
  final NullableStringFieldUpdateOperationsInput? grade;

  @JsonKey(name: r'JOIN_DATE')
  final DateTimeFieldUpdateOperationsInput? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final DateTimeFieldUpdateOperationsInput? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final DateTimeFieldUpdateOperationsInput? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final NullableIntFieldUpdateOperationsInput? pwdWrongCnt;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'LAST_LOGIN_DATE')
  final DateTimeFieldUpdateOperationsInput? lastLoginDate;

  @JsonKey(name: r'MEMO')
  final NullableStringFieldUpdateOperationsInput? memo;

  @override
  Map<String, dynamic> toJson() =>
      _$MEMBERTBLUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class MENUAUTHTBLCreateInput implements _i1.JsonSerializable {
  const MENUAUTHTBLCreateInput({
    required this.userId,
    required this.menuId,
    this.readYn,
    this.writeYn,
    this.regId,
    this.updId,
    this.regDate,
    this.updDate,
  });

  factory MENUAUTHTBLCreateInput.fromJson(Map<String, dynamic> json) =>
      _$MENUAUTHTBLCreateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'MENU_ID')
  final String menuId;

  @JsonKey(name: r'READ_YN')
  final String? readYn;

  @JsonKey(name: r'WRITE_YN')
  final String? writeYn;

  @JsonKey(name: r'REG_ID')
  final String? regId;

  @JsonKey(name: r'UPD_ID')
  final String? updId;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() => _$MENUAUTHTBLCreateInputToJson(this);
}

@_i1.jsonSerializable
class MENUAUTHTBLUncheckedCreateInput implements _i1.JsonSerializable {
  const MENUAUTHTBLUncheckedCreateInput({
    required this.userId,
    required this.menuId,
    this.readYn,
    this.writeYn,
    this.regId,
    this.updId,
    this.regDate,
    this.updDate,
  });

  factory MENUAUTHTBLUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$MENUAUTHTBLUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'MENU_ID')
  final String menuId;

  @JsonKey(name: r'READ_YN')
  final String? readYn;

  @JsonKey(name: r'WRITE_YN')
  final String? writeYn;

  @JsonKey(name: r'REG_ID')
  final String? regId;

  @JsonKey(name: r'UPD_ID')
  final String? updId;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUAUTHTBLUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class MENUAUTHTBLUpdateInput implements _i1.JsonSerializable {
  const MENUAUTHTBLUpdateInput({
    this.userId,
    this.menuId,
    this.readYn,
    this.writeYn,
    this.regId,
    this.updId,
    this.regDate,
    this.updDate,
  });

  factory MENUAUTHTBLUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$MENUAUTHTBLUpdateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'MENU_ID')
  final StringFieldUpdateOperationsInput? menuId;

  @JsonKey(name: r'READ_YN')
  final NullableStringFieldUpdateOperationsInput? readYn;

  @JsonKey(name: r'WRITE_YN')
  final NullableStringFieldUpdateOperationsInput? writeYn;

  @JsonKey(name: r'REG_ID')
  final NullableStringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'UPD_ID')
  final NullableStringFieldUpdateOperationsInput? updId;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @override
  Map<String, dynamic> toJson() => _$MENUAUTHTBLUpdateInputToJson(this);
}

@_i1.jsonSerializable
class MENUAUTHTBLUncheckedUpdateInput implements _i1.JsonSerializable {
  const MENUAUTHTBLUncheckedUpdateInput({
    this.userId,
    this.menuId,
    this.readYn,
    this.writeYn,
    this.regId,
    this.updId,
    this.regDate,
    this.updDate,
  });

  factory MENUAUTHTBLUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$MENUAUTHTBLUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'MENU_ID')
  final StringFieldUpdateOperationsInput? menuId;

  @JsonKey(name: r'READ_YN')
  final NullableStringFieldUpdateOperationsInput? readYn;

  @JsonKey(name: r'WRITE_YN')
  final NullableStringFieldUpdateOperationsInput? writeYn;

  @JsonKey(name: r'REG_ID')
  final NullableStringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'UPD_ID')
  final NullableStringFieldUpdateOperationsInput? updId;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUAUTHTBLUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class MENUAUTHTBLCreateManyInput implements _i1.JsonSerializable {
  const MENUAUTHTBLCreateManyInput({
    required this.userId,
    required this.menuId,
    this.readYn,
    this.writeYn,
    this.regId,
    this.updId,
    this.regDate,
    this.updDate,
  });

  factory MENUAUTHTBLCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$MENUAUTHTBLCreateManyInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'MENU_ID')
  final String menuId;

  @JsonKey(name: r'READ_YN')
  final String? readYn;

  @JsonKey(name: r'WRITE_YN')
  final String? writeYn;

  @JsonKey(name: r'REG_ID')
  final String? regId;

  @JsonKey(name: r'UPD_ID')
  final String? updId;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() => _$MENUAUTHTBLCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class MENUAUTHTBLUpdateManyMutationInput implements _i1.JsonSerializable {
  const MENUAUTHTBLUpdateManyMutationInput({
    this.userId,
    this.menuId,
    this.readYn,
    this.writeYn,
    this.regId,
    this.updId,
    this.regDate,
    this.updDate,
  });

  factory MENUAUTHTBLUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$MENUAUTHTBLUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'MENU_ID')
  final StringFieldUpdateOperationsInput? menuId;

  @JsonKey(name: r'READ_YN')
  final NullableStringFieldUpdateOperationsInput? readYn;

  @JsonKey(name: r'WRITE_YN')
  final NullableStringFieldUpdateOperationsInput? writeYn;

  @JsonKey(name: r'REG_ID')
  final NullableStringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'UPD_ID')
  final NullableStringFieldUpdateOperationsInput? updId;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUAUTHTBLUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class MENUAUTHTBLUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const MENUAUTHTBLUncheckedUpdateManyInput({
    this.userId,
    this.menuId,
    this.readYn,
    this.writeYn,
    this.regId,
    this.updId,
    this.regDate,
    this.updDate,
  });

  factory MENUAUTHTBLUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$MENUAUTHTBLUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'MENU_ID')
  final StringFieldUpdateOperationsInput? menuId;

  @JsonKey(name: r'READ_YN')
  final NullableStringFieldUpdateOperationsInput? readYn;

  @JsonKey(name: r'WRITE_YN')
  final NullableStringFieldUpdateOperationsInput? writeYn;

  @JsonKey(name: r'REG_ID')
  final NullableStringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'UPD_ID')
  final NullableStringFieldUpdateOperationsInput? updId;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUAUTHTBLUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class MENUTBLCreateInput implements _i1.JsonSerializable {
  const MENUTBLCreateInput({
    required this.menuId,
    required this.menuNm,
    required this.depth,
    required this.sort,
    this.ownerId,
    this.url,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
    this.dispYn,
    this.menuIcon,
    this.memberTbl,
  });

  factory MENUTBLCreateInput.fromJson(Map<String, dynamic> json) =>
      _$MENUTBLCreateInputFromJson(json);

  @JsonKey(name: r'MENU_ID')
  final String menuId;

  @JsonKey(name: r'MENU_NM')
  final String menuNm;

  @JsonKey(name: r'DEPTH')
  final int depth;

  @JsonKey(name: r'SORT')
  final int sort;

  @JsonKey(name: r'OWNER_ID')
  final String? ownerId;

  @JsonKey(name: r'URL')
  final String? url;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'DISP_YN')
  final String? dispYn;

  @JsonKey(name: r'MENU_ICON')
  final String? menuIcon;

  @JsonKey(name: r'MEMBER_TBL')
  final MEMBERTBLCreateNestedOneWithoutMENUTBLInput? memberTbl;

  @override
  Map<String, dynamic> toJson() => _$MENUTBLCreateInputToJson(this);
}

@_i1.jsonSerializable
class MENUTBLUncheckedCreateInput implements _i1.JsonSerializable {
  const MENUTBLUncheckedCreateInput({
    required this.menuId,
    required this.menuNm,
    required this.depth,
    required this.sort,
    this.ownerId,
    this.url,
    this.writerId,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
    this.dispYn,
    this.menuIcon,
  });

  factory MENUTBLUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$MENUTBLUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'MENU_ID')
  final String menuId;

  @JsonKey(name: r'MENU_NM')
  final String menuNm;

  @JsonKey(name: r'DEPTH')
  final int depth;

  @JsonKey(name: r'SORT')
  final int sort;

  @JsonKey(name: r'OWNER_ID')
  final String? ownerId;

  @JsonKey(name: r'URL')
  final String? url;

  @JsonKey(name: r'WRITER_ID')
  final String? writerId;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'DISP_YN')
  final String? dispYn;

  @JsonKey(name: r'MENU_ICON')
  final String? menuIcon;

  @override
  Map<String, dynamic> toJson() => _$MENUTBLUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class MENUTBLUpdateInput implements _i1.JsonSerializable {
  const MENUTBLUpdateInput({
    this.menuId,
    this.menuNm,
    this.depth,
    this.sort,
    this.ownerId,
    this.url,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
    this.dispYn,
    this.menuIcon,
    this.memberTbl,
  });

  factory MENUTBLUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$MENUTBLUpdateInputFromJson(json);

  @JsonKey(name: r'MENU_ID')
  final StringFieldUpdateOperationsInput? menuId;

  @JsonKey(name: r'MENU_NM')
  final StringFieldUpdateOperationsInput? menuNm;

  @JsonKey(name: r'DEPTH')
  final IntFieldUpdateOperationsInput? depth;

  @JsonKey(name: r'SORT')
  final IntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'OWNER_ID')
  final NullableStringFieldUpdateOperationsInput? ownerId;

  @JsonKey(name: r'URL')
  final NullableStringFieldUpdateOperationsInput? url;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'DISP_YN')
  final NullableStringFieldUpdateOperationsInput? dispYn;

  @JsonKey(name: r'MENU_ICON')
  final NullableStringFieldUpdateOperationsInput? menuIcon;

  @JsonKey(name: r'MEMBER_TBL')
  final MEMBERTBLUpdateOneWithoutMENUTBLNestedInput? memberTbl;

  @override
  Map<String, dynamic> toJson() => _$MENUTBLUpdateInputToJson(this);
}

@_i1.jsonSerializable
class MENUTBLUncheckedUpdateInput implements _i1.JsonSerializable {
  const MENUTBLUncheckedUpdateInput({
    this.menuId,
    this.menuNm,
    this.depth,
    this.sort,
    this.ownerId,
    this.url,
    this.writerId,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
    this.dispYn,
    this.menuIcon,
  });

  factory MENUTBLUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$MENUTBLUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'MENU_ID')
  final StringFieldUpdateOperationsInput? menuId;

  @JsonKey(name: r'MENU_NM')
  final StringFieldUpdateOperationsInput? menuNm;

  @JsonKey(name: r'DEPTH')
  final IntFieldUpdateOperationsInput? depth;

  @JsonKey(name: r'SORT')
  final IntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'OWNER_ID')
  final NullableStringFieldUpdateOperationsInput? ownerId;

  @JsonKey(name: r'URL')
  final NullableStringFieldUpdateOperationsInput? url;

  @JsonKey(name: r'WRITER_ID')
  final NullableStringFieldUpdateOperationsInput? writerId;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'DISP_YN')
  final NullableStringFieldUpdateOperationsInput? dispYn;

  @JsonKey(name: r'MENU_ICON')
  final NullableStringFieldUpdateOperationsInput? menuIcon;

  @override
  Map<String, dynamic> toJson() => _$MENUTBLUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class MENUTBLCreateManyInput implements _i1.JsonSerializable {
  const MENUTBLCreateManyInput({
    required this.menuId,
    required this.menuNm,
    required this.depth,
    required this.sort,
    this.ownerId,
    this.url,
    this.writerId,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
    this.dispYn,
    this.menuIcon,
  });

  factory MENUTBLCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$MENUTBLCreateManyInputFromJson(json);

  @JsonKey(name: r'MENU_ID')
  final String menuId;

  @JsonKey(name: r'MENU_NM')
  final String menuNm;

  @JsonKey(name: r'DEPTH')
  final int depth;

  @JsonKey(name: r'SORT')
  final int sort;

  @JsonKey(name: r'OWNER_ID')
  final String? ownerId;

  @JsonKey(name: r'URL')
  final String? url;

  @JsonKey(name: r'WRITER_ID')
  final String? writerId;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'DISP_YN')
  final String? dispYn;

  @JsonKey(name: r'MENU_ICON')
  final String? menuIcon;

  @override
  Map<String, dynamic> toJson() => _$MENUTBLCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class MENUTBLUpdateManyMutationInput implements _i1.JsonSerializable {
  const MENUTBLUpdateManyMutationInput({
    this.menuId,
    this.menuNm,
    this.depth,
    this.sort,
    this.ownerId,
    this.url,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
    this.dispYn,
    this.menuIcon,
  });

  factory MENUTBLUpdateManyMutationInput.fromJson(Map<String, dynamic> json) =>
      _$MENUTBLUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'MENU_ID')
  final StringFieldUpdateOperationsInput? menuId;

  @JsonKey(name: r'MENU_NM')
  final StringFieldUpdateOperationsInput? menuNm;

  @JsonKey(name: r'DEPTH')
  final IntFieldUpdateOperationsInput? depth;

  @JsonKey(name: r'SORT')
  final IntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'OWNER_ID')
  final NullableStringFieldUpdateOperationsInput? ownerId;

  @JsonKey(name: r'URL')
  final NullableStringFieldUpdateOperationsInput? url;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'DISP_YN')
  final NullableStringFieldUpdateOperationsInput? dispYn;

  @JsonKey(name: r'MENU_ICON')
  final NullableStringFieldUpdateOperationsInput? menuIcon;

  @override
  Map<String, dynamic> toJson() => _$MENUTBLUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class MENUTBLUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const MENUTBLUncheckedUpdateManyInput({
    this.menuId,
    this.menuNm,
    this.depth,
    this.sort,
    this.ownerId,
    this.url,
    this.writerId,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
    this.dispYn,
    this.menuIcon,
  });

  factory MENUTBLUncheckedUpdateManyInput.fromJson(Map<String, dynamic> json) =>
      _$MENUTBLUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'MENU_ID')
  final StringFieldUpdateOperationsInput? menuId;

  @JsonKey(name: r'MENU_NM')
  final StringFieldUpdateOperationsInput? menuNm;

  @JsonKey(name: r'DEPTH')
  final IntFieldUpdateOperationsInput? depth;

  @JsonKey(name: r'SORT')
  final IntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'OWNER_ID')
  final NullableStringFieldUpdateOperationsInput? ownerId;

  @JsonKey(name: r'URL')
  final NullableStringFieldUpdateOperationsInput? url;

  @JsonKey(name: r'WRITER_ID')
  final NullableStringFieldUpdateOperationsInput? writerId;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'DISP_YN')
  final NullableStringFieldUpdateOperationsInput? dispYn;

  @JsonKey(name: r'MENU_ICON')
  final NullableStringFieldUpdateOperationsInput? menuIcon;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUTBLUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class OFFICEASSETTBLCreateInput implements _i1.JsonSerializable {
  const OFFICEASSETTBLCreateInput({
    this.seq,
    required this.assetNo,
    required this.assetType,
    this.seller,
    this.buyDate,
    this.modelNo,
    this.serialNo,
    this.amount,
    this.keepYear,
    this.mngDept,
    this.assetAccount,
    this.remarks,
    this.carryOut,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory OFFICEASSETTBLCreateInput.fromJson(Map<String, dynamic> json) =>
      _$OFFICEASSETTBLCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'ASSET_NO')
  final String assetNo;

  @JsonKey(name: r'ASSET_TYPE')
  final String assetType;

  @JsonKey(name: r'SELLER')
  final String? seller;

  @JsonKey(name: r'BUY_DATE')
  final String? buyDate;

  @JsonKey(name: r'MODEL_NO')
  final String? modelNo;

  @JsonKey(name: r'SERIAL_NO')
  final String? serialNo;

  @JsonKey(name: r'AMOUNT')
  final int? amount;

  @JsonKey(name: r'KEEP_YEAR')
  final double? keepYear;

  @JsonKey(name: r'MNG_DEPT')
  final String? mngDept;

  @JsonKey(name: r'ASSET_ACCOUNT')
  final String? assetAccount;

  @JsonKey(name: r'REMARKS')
  final String? remarks;

  @JsonKey(name: r'CARRY_OUT')
  final String? carryOut;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() => _$OFFICEASSETTBLCreateInputToJson(this);
}

@_i1.jsonSerializable
class OFFICEASSETTBLUncheckedCreateInput implements _i1.JsonSerializable {
  const OFFICEASSETTBLUncheckedCreateInput({
    this.seq,
    required this.assetNo,
    required this.assetType,
    this.seller,
    this.buyDate,
    this.modelNo,
    this.serialNo,
    this.amount,
    this.keepYear,
    this.mngDept,
    this.assetAccount,
    this.remarks,
    this.carryOut,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory OFFICEASSETTBLUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$OFFICEASSETTBLUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'ASSET_NO')
  final String assetNo;

  @JsonKey(name: r'ASSET_TYPE')
  final String assetType;

  @JsonKey(name: r'SELLER')
  final String? seller;

  @JsonKey(name: r'BUY_DATE')
  final String? buyDate;

  @JsonKey(name: r'MODEL_NO')
  final String? modelNo;

  @JsonKey(name: r'SERIAL_NO')
  final String? serialNo;

  @JsonKey(name: r'AMOUNT')
  final int? amount;

  @JsonKey(name: r'KEEP_YEAR')
  final double? keepYear;

  @JsonKey(name: r'MNG_DEPT')
  final String? mngDept;

  @JsonKey(name: r'ASSET_ACCOUNT')
  final String? assetAccount;

  @JsonKey(name: r'REMARKS')
  final String? remarks;

  @JsonKey(name: r'CARRY_OUT')
  final String? carryOut;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$OFFICEASSETTBLUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class OFFICEASSETTBLUpdateInput implements _i1.JsonSerializable {
  const OFFICEASSETTBLUpdateInput({
    this.seq,
    this.assetNo,
    this.assetType,
    this.seller,
    this.buyDate,
    this.modelNo,
    this.serialNo,
    this.amount,
    this.keepYear,
    this.mngDept,
    this.assetAccount,
    this.remarks,
    this.carryOut,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory OFFICEASSETTBLUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$OFFICEASSETTBLUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'ASSET_NO')
  final StringFieldUpdateOperationsInput? assetNo;

  @JsonKey(name: r'ASSET_TYPE')
  final StringFieldUpdateOperationsInput? assetType;

  @JsonKey(name: r'SELLER')
  final NullableStringFieldUpdateOperationsInput? seller;

  @JsonKey(name: r'BUY_DATE')
  final NullableStringFieldUpdateOperationsInput? buyDate;

  @JsonKey(name: r'MODEL_NO')
  final NullableStringFieldUpdateOperationsInput? modelNo;

  @JsonKey(name: r'SERIAL_NO')
  final NullableStringFieldUpdateOperationsInput? serialNo;

  @JsonKey(name: r'AMOUNT')
  final NullableIntFieldUpdateOperationsInput? amount;

  @JsonKey(name: r'KEEP_YEAR')
  final NullableDecimalFieldUpdateOperationsInput? keepYear;

  @JsonKey(name: r'MNG_DEPT')
  final NullableStringFieldUpdateOperationsInput? mngDept;

  @JsonKey(name: r'ASSET_ACCOUNT')
  final NullableStringFieldUpdateOperationsInput? assetAccount;

  @JsonKey(name: r'REMARKS')
  final NullableStringFieldUpdateOperationsInput? remarks;

  @JsonKey(name: r'CARRY_OUT')
  final NullableStringFieldUpdateOperationsInput? carryOut;

  @JsonKey(name: r'USE_YN')
  final StringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @override
  Map<String, dynamic> toJson() => _$OFFICEASSETTBLUpdateInputToJson(this);
}

@_i1.jsonSerializable
class OFFICEASSETTBLUncheckedUpdateInput implements _i1.JsonSerializable {
  const OFFICEASSETTBLUncheckedUpdateInput({
    this.seq,
    this.assetNo,
    this.assetType,
    this.seller,
    this.buyDate,
    this.modelNo,
    this.serialNo,
    this.amount,
    this.keepYear,
    this.mngDept,
    this.assetAccount,
    this.remarks,
    this.carryOut,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory OFFICEASSETTBLUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$OFFICEASSETTBLUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'ASSET_NO')
  final StringFieldUpdateOperationsInput? assetNo;

  @JsonKey(name: r'ASSET_TYPE')
  final StringFieldUpdateOperationsInput? assetType;

  @JsonKey(name: r'SELLER')
  final NullableStringFieldUpdateOperationsInput? seller;

  @JsonKey(name: r'BUY_DATE')
  final NullableStringFieldUpdateOperationsInput? buyDate;

  @JsonKey(name: r'MODEL_NO')
  final NullableStringFieldUpdateOperationsInput? modelNo;

  @JsonKey(name: r'SERIAL_NO')
  final NullableStringFieldUpdateOperationsInput? serialNo;

  @JsonKey(name: r'AMOUNT')
  final NullableIntFieldUpdateOperationsInput? amount;

  @JsonKey(name: r'KEEP_YEAR')
  final NullableDecimalFieldUpdateOperationsInput? keepYear;

  @JsonKey(name: r'MNG_DEPT')
  final NullableStringFieldUpdateOperationsInput? mngDept;

  @JsonKey(name: r'ASSET_ACCOUNT')
  final NullableStringFieldUpdateOperationsInput? assetAccount;

  @JsonKey(name: r'REMARKS')
  final NullableStringFieldUpdateOperationsInput? remarks;

  @JsonKey(name: r'CARRY_OUT')
  final NullableStringFieldUpdateOperationsInput? carryOut;

  @JsonKey(name: r'USE_YN')
  final StringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$OFFICEASSETTBLUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class OFFICEASSETTBLCreateManyInput implements _i1.JsonSerializable {
  const OFFICEASSETTBLCreateManyInput({
    this.seq,
    required this.assetNo,
    required this.assetType,
    this.seller,
    this.buyDate,
    this.modelNo,
    this.serialNo,
    this.amount,
    this.keepYear,
    this.mngDept,
    this.assetAccount,
    this.remarks,
    this.carryOut,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory OFFICEASSETTBLCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$OFFICEASSETTBLCreateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'ASSET_NO')
  final String assetNo;

  @JsonKey(name: r'ASSET_TYPE')
  final String assetType;

  @JsonKey(name: r'SELLER')
  final String? seller;

  @JsonKey(name: r'BUY_DATE')
  final String? buyDate;

  @JsonKey(name: r'MODEL_NO')
  final String? modelNo;

  @JsonKey(name: r'SERIAL_NO')
  final String? serialNo;

  @JsonKey(name: r'AMOUNT')
  final int? amount;

  @JsonKey(name: r'KEEP_YEAR')
  final double? keepYear;

  @JsonKey(name: r'MNG_DEPT')
  final String? mngDept;

  @JsonKey(name: r'ASSET_ACCOUNT')
  final String? assetAccount;

  @JsonKey(name: r'REMARKS')
  final String? remarks;

  @JsonKey(name: r'CARRY_OUT')
  final String? carryOut;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() => _$OFFICEASSETTBLCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class OFFICEASSETTBLUpdateManyMutationInput implements _i1.JsonSerializable {
  const OFFICEASSETTBLUpdateManyMutationInput({
    this.seq,
    this.assetNo,
    this.assetType,
    this.seller,
    this.buyDate,
    this.modelNo,
    this.serialNo,
    this.amount,
    this.keepYear,
    this.mngDept,
    this.assetAccount,
    this.remarks,
    this.carryOut,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory OFFICEASSETTBLUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$OFFICEASSETTBLUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'ASSET_NO')
  final StringFieldUpdateOperationsInput? assetNo;

  @JsonKey(name: r'ASSET_TYPE')
  final StringFieldUpdateOperationsInput? assetType;

  @JsonKey(name: r'SELLER')
  final NullableStringFieldUpdateOperationsInput? seller;

  @JsonKey(name: r'BUY_DATE')
  final NullableStringFieldUpdateOperationsInput? buyDate;

  @JsonKey(name: r'MODEL_NO')
  final NullableStringFieldUpdateOperationsInput? modelNo;

  @JsonKey(name: r'SERIAL_NO')
  final NullableStringFieldUpdateOperationsInput? serialNo;

  @JsonKey(name: r'AMOUNT')
  final NullableIntFieldUpdateOperationsInput? amount;

  @JsonKey(name: r'KEEP_YEAR')
  final NullableDecimalFieldUpdateOperationsInput? keepYear;

  @JsonKey(name: r'MNG_DEPT')
  final NullableStringFieldUpdateOperationsInput? mngDept;

  @JsonKey(name: r'ASSET_ACCOUNT')
  final NullableStringFieldUpdateOperationsInput? assetAccount;

  @JsonKey(name: r'REMARKS')
  final NullableStringFieldUpdateOperationsInput? remarks;

  @JsonKey(name: r'CARRY_OUT')
  final NullableStringFieldUpdateOperationsInput? carryOut;

  @JsonKey(name: r'USE_YN')
  final StringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$OFFICEASSETTBLUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class OFFICEASSETTBLUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const OFFICEASSETTBLUncheckedUpdateManyInput({
    this.seq,
    this.assetNo,
    this.assetType,
    this.seller,
    this.buyDate,
    this.modelNo,
    this.serialNo,
    this.amount,
    this.keepYear,
    this.mngDept,
    this.assetAccount,
    this.remarks,
    this.carryOut,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory OFFICEASSETTBLUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$OFFICEASSETTBLUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'ASSET_NO')
  final StringFieldUpdateOperationsInput? assetNo;

  @JsonKey(name: r'ASSET_TYPE')
  final StringFieldUpdateOperationsInput? assetType;

  @JsonKey(name: r'SELLER')
  final NullableStringFieldUpdateOperationsInput? seller;

  @JsonKey(name: r'BUY_DATE')
  final NullableStringFieldUpdateOperationsInput? buyDate;

  @JsonKey(name: r'MODEL_NO')
  final NullableStringFieldUpdateOperationsInput? modelNo;

  @JsonKey(name: r'SERIAL_NO')
  final NullableStringFieldUpdateOperationsInput? serialNo;

  @JsonKey(name: r'AMOUNT')
  final NullableIntFieldUpdateOperationsInput? amount;

  @JsonKey(name: r'KEEP_YEAR')
  final NullableDecimalFieldUpdateOperationsInput? keepYear;

  @JsonKey(name: r'MNG_DEPT')
  final NullableStringFieldUpdateOperationsInput? mngDept;

  @JsonKey(name: r'ASSET_ACCOUNT')
  final NullableStringFieldUpdateOperationsInput? assetAccount;

  @JsonKey(name: r'REMARKS')
  final NullableStringFieldUpdateOperationsInput? remarks;

  @JsonKey(name: r'CARRY_OUT')
  final NullableStringFieldUpdateOperationsInput? carryOut;

  @JsonKey(name: r'USE_YN')
  final StringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$OFFICEASSETTBLUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class SERVERASSETTBLCreateInput implements _i1.JsonSerializable {
  const SERVERASSETTBLCreateInput({
    this.seq,
    required this.assetNo,
    required this.assetType,
    this.maker,
    this.cnt,
    this.amount,
    this.buyDate,
    this.seller,
    this.modelNo,
    this.serialNo,
    this.hostname,
    this.builtLoc,
    this.useDesc,
    this.osInfo,
    this.cpuInfo,
    this.ramInfo,
    this.hddInfo,
    this.ssdInfo,
    this.odd,
    this.remarks,
    this.carryOut,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory SERVERASSETTBLCreateInput.fromJson(Map<String, dynamic> json) =>
      _$SERVERASSETTBLCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'ASSET_NO')
  final String assetNo;

  @JsonKey(name: r'ASSET_TYPE')
  final String assetType;

  @JsonKey(name: r'MAKER')
  final String? maker;

  @JsonKey(name: r'CNT')
  final double? cnt;

  @JsonKey(name: r'AMOUNT')
  final int? amount;

  @JsonKey(name: r'BUY_DATE')
  final String? buyDate;

  @JsonKey(name: r'SELLER')
  final String? seller;

  @JsonKey(name: r'MODEL_NO')
  final String? modelNo;

  @JsonKey(name: r'SERIAL_NO')
  final String? serialNo;

  @JsonKey(name: r'HOSTNAME')
  final String? hostname;

  @JsonKey(name: r'BUILT_LOC')
  final String? builtLoc;

  @JsonKey(name: r'USE_DESC')
  final String? useDesc;

  @JsonKey(name: r'OS_INFO')
  final String? osInfo;

  @JsonKey(name: r'CPU_INFO')
  final String? cpuInfo;

  @JsonKey(name: r'RAM_INFO')
  final String? ramInfo;

  @JsonKey(name: r'HDD_INFO')
  final String? hddInfo;

  @JsonKey(name: r'SSD_INFO')
  final String? ssdInfo;

  @JsonKey(name: r'ODD')
  final String? odd;

  @JsonKey(name: r'REMARKS')
  final String? remarks;

  @JsonKey(name: r'CARRY_OUT')
  final String? carryOut;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() => _$SERVERASSETTBLCreateInputToJson(this);
}

@_i1.jsonSerializable
class SERVERASSETTBLUncheckedCreateInput implements _i1.JsonSerializable {
  const SERVERASSETTBLUncheckedCreateInput({
    this.seq,
    required this.assetNo,
    required this.assetType,
    this.maker,
    this.cnt,
    this.amount,
    this.buyDate,
    this.seller,
    this.modelNo,
    this.serialNo,
    this.hostname,
    this.builtLoc,
    this.useDesc,
    this.osInfo,
    this.cpuInfo,
    this.ramInfo,
    this.hddInfo,
    this.ssdInfo,
    this.odd,
    this.remarks,
    this.carryOut,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory SERVERASSETTBLUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$SERVERASSETTBLUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'ASSET_NO')
  final String assetNo;

  @JsonKey(name: r'ASSET_TYPE')
  final String assetType;

  @JsonKey(name: r'MAKER')
  final String? maker;

  @JsonKey(name: r'CNT')
  final double? cnt;

  @JsonKey(name: r'AMOUNT')
  final int? amount;

  @JsonKey(name: r'BUY_DATE')
  final String? buyDate;

  @JsonKey(name: r'SELLER')
  final String? seller;

  @JsonKey(name: r'MODEL_NO')
  final String? modelNo;

  @JsonKey(name: r'SERIAL_NO')
  final String? serialNo;

  @JsonKey(name: r'HOSTNAME')
  final String? hostname;

  @JsonKey(name: r'BUILT_LOC')
  final String? builtLoc;

  @JsonKey(name: r'USE_DESC')
  final String? useDesc;

  @JsonKey(name: r'OS_INFO')
  final String? osInfo;

  @JsonKey(name: r'CPU_INFO')
  final String? cpuInfo;

  @JsonKey(name: r'RAM_INFO')
  final String? ramInfo;

  @JsonKey(name: r'HDD_INFO')
  final String? hddInfo;

  @JsonKey(name: r'SSD_INFO')
  final String? ssdInfo;

  @JsonKey(name: r'ODD')
  final String? odd;

  @JsonKey(name: r'REMARKS')
  final String? remarks;

  @JsonKey(name: r'CARRY_OUT')
  final String? carryOut;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$SERVERASSETTBLUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class SERVERASSETTBLUpdateInput implements _i1.JsonSerializable {
  const SERVERASSETTBLUpdateInput({
    this.seq,
    this.assetNo,
    this.assetType,
    this.maker,
    this.cnt,
    this.amount,
    this.buyDate,
    this.seller,
    this.modelNo,
    this.serialNo,
    this.hostname,
    this.builtLoc,
    this.useDesc,
    this.osInfo,
    this.cpuInfo,
    this.ramInfo,
    this.hddInfo,
    this.ssdInfo,
    this.odd,
    this.remarks,
    this.carryOut,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory SERVERASSETTBLUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$SERVERASSETTBLUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'ASSET_NO')
  final StringFieldUpdateOperationsInput? assetNo;

  @JsonKey(name: r'ASSET_TYPE')
  final StringFieldUpdateOperationsInput? assetType;

  @JsonKey(name: r'MAKER')
  final NullableStringFieldUpdateOperationsInput? maker;

  @JsonKey(name: r'CNT')
  final NullableDecimalFieldUpdateOperationsInput? cnt;

  @JsonKey(name: r'AMOUNT')
  final NullableIntFieldUpdateOperationsInput? amount;

  @JsonKey(name: r'BUY_DATE')
  final NullableStringFieldUpdateOperationsInput? buyDate;

  @JsonKey(name: r'SELLER')
  final NullableStringFieldUpdateOperationsInput? seller;

  @JsonKey(name: r'MODEL_NO')
  final NullableStringFieldUpdateOperationsInput? modelNo;

  @JsonKey(name: r'SERIAL_NO')
  final NullableStringFieldUpdateOperationsInput? serialNo;

  @JsonKey(name: r'HOSTNAME')
  final NullableStringFieldUpdateOperationsInput? hostname;

  @JsonKey(name: r'BUILT_LOC')
  final NullableStringFieldUpdateOperationsInput? builtLoc;

  @JsonKey(name: r'USE_DESC')
  final NullableStringFieldUpdateOperationsInput? useDesc;

  @JsonKey(name: r'OS_INFO')
  final NullableStringFieldUpdateOperationsInput? osInfo;

  @JsonKey(name: r'CPU_INFO')
  final NullableStringFieldUpdateOperationsInput? cpuInfo;

  @JsonKey(name: r'RAM_INFO')
  final NullableStringFieldUpdateOperationsInput? ramInfo;

  @JsonKey(name: r'HDD_INFO')
  final NullableStringFieldUpdateOperationsInput? hddInfo;

  @JsonKey(name: r'SSD_INFO')
  final NullableStringFieldUpdateOperationsInput? ssdInfo;

  @JsonKey(name: r'ODD')
  final NullableStringFieldUpdateOperationsInput? odd;

  @JsonKey(name: r'REMARKS')
  final NullableStringFieldUpdateOperationsInput? remarks;

  @JsonKey(name: r'CARRY_OUT')
  final NullableStringFieldUpdateOperationsInput? carryOut;

  @JsonKey(name: r'USE_YN')
  final StringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @override
  Map<String, dynamic> toJson() => _$SERVERASSETTBLUpdateInputToJson(this);
}

@_i1.jsonSerializable
class SERVERASSETTBLUncheckedUpdateInput implements _i1.JsonSerializable {
  const SERVERASSETTBLUncheckedUpdateInput({
    this.seq,
    this.assetNo,
    this.assetType,
    this.maker,
    this.cnt,
    this.amount,
    this.buyDate,
    this.seller,
    this.modelNo,
    this.serialNo,
    this.hostname,
    this.builtLoc,
    this.useDesc,
    this.osInfo,
    this.cpuInfo,
    this.ramInfo,
    this.hddInfo,
    this.ssdInfo,
    this.odd,
    this.remarks,
    this.carryOut,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory SERVERASSETTBLUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$SERVERASSETTBLUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'ASSET_NO')
  final StringFieldUpdateOperationsInput? assetNo;

  @JsonKey(name: r'ASSET_TYPE')
  final StringFieldUpdateOperationsInput? assetType;

  @JsonKey(name: r'MAKER')
  final NullableStringFieldUpdateOperationsInput? maker;

  @JsonKey(name: r'CNT')
  final NullableDecimalFieldUpdateOperationsInput? cnt;

  @JsonKey(name: r'AMOUNT')
  final NullableIntFieldUpdateOperationsInput? amount;

  @JsonKey(name: r'BUY_DATE')
  final NullableStringFieldUpdateOperationsInput? buyDate;

  @JsonKey(name: r'SELLER')
  final NullableStringFieldUpdateOperationsInput? seller;

  @JsonKey(name: r'MODEL_NO')
  final NullableStringFieldUpdateOperationsInput? modelNo;

  @JsonKey(name: r'SERIAL_NO')
  final NullableStringFieldUpdateOperationsInput? serialNo;

  @JsonKey(name: r'HOSTNAME')
  final NullableStringFieldUpdateOperationsInput? hostname;

  @JsonKey(name: r'BUILT_LOC')
  final NullableStringFieldUpdateOperationsInput? builtLoc;

  @JsonKey(name: r'USE_DESC')
  final NullableStringFieldUpdateOperationsInput? useDesc;

  @JsonKey(name: r'OS_INFO')
  final NullableStringFieldUpdateOperationsInput? osInfo;

  @JsonKey(name: r'CPU_INFO')
  final NullableStringFieldUpdateOperationsInput? cpuInfo;

  @JsonKey(name: r'RAM_INFO')
  final NullableStringFieldUpdateOperationsInput? ramInfo;

  @JsonKey(name: r'HDD_INFO')
  final NullableStringFieldUpdateOperationsInput? hddInfo;

  @JsonKey(name: r'SSD_INFO')
  final NullableStringFieldUpdateOperationsInput? ssdInfo;

  @JsonKey(name: r'ODD')
  final NullableStringFieldUpdateOperationsInput? odd;

  @JsonKey(name: r'REMARKS')
  final NullableStringFieldUpdateOperationsInput? remarks;

  @JsonKey(name: r'CARRY_OUT')
  final NullableStringFieldUpdateOperationsInput? carryOut;

  @JsonKey(name: r'USE_YN')
  final StringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$SERVERASSETTBLUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class SERVERASSETTBLCreateManyInput implements _i1.JsonSerializable {
  const SERVERASSETTBLCreateManyInput({
    this.seq,
    required this.assetNo,
    required this.assetType,
    this.maker,
    this.cnt,
    this.amount,
    this.buyDate,
    this.seller,
    this.modelNo,
    this.serialNo,
    this.hostname,
    this.builtLoc,
    this.useDesc,
    this.osInfo,
    this.cpuInfo,
    this.ramInfo,
    this.hddInfo,
    this.ssdInfo,
    this.odd,
    this.remarks,
    this.carryOut,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory SERVERASSETTBLCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$SERVERASSETTBLCreateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'ASSET_NO')
  final String assetNo;

  @JsonKey(name: r'ASSET_TYPE')
  final String assetType;

  @JsonKey(name: r'MAKER')
  final String? maker;

  @JsonKey(name: r'CNT')
  final double? cnt;

  @JsonKey(name: r'AMOUNT')
  final int? amount;

  @JsonKey(name: r'BUY_DATE')
  final String? buyDate;

  @JsonKey(name: r'SELLER')
  final String? seller;

  @JsonKey(name: r'MODEL_NO')
  final String? modelNo;

  @JsonKey(name: r'SERIAL_NO')
  final String? serialNo;

  @JsonKey(name: r'HOSTNAME')
  final String? hostname;

  @JsonKey(name: r'BUILT_LOC')
  final String? builtLoc;

  @JsonKey(name: r'USE_DESC')
  final String? useDesc;

  @JsonKey(name: r'OS_INFO')
  final String? osInfo;

  @JsonKey(name: r'CPU_INFO')
  final String? cpuInfo;

  @JsonKey(name: r'RAM_INFO')
  final String? ramInfo;

  @JsonKey(name: r'HDD_INFO')
  final String? hddInfo;

  @JsonKey(name: r'SSD_INFO')
  final String? ssdInfo;

  @JsonKey(name: r'ODD')
  final String? odd;

  @JsonKey(name: r'REMARKS')
  final String? remarks;

  @JsonKey(name: r'CARRY_OUT')
  final String? carryOut;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() => _$SERVERASSETTBLCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class SERVERASSETTBLUpdateManyMutationInput implements _i1.JsonSerializable {
  const SERVERASSETTBLUpdateManyMutationInput({
    this.seq,
    this.assetNo,
    this.assetType,
    this.maker,
    this.cnt,
    this.amount,
    this.buyDate,
    this.seller,
    this.modelNo,
    this.serialNo,
    this.hostname,
    this.builtLoc,
    this.useDesc,
    this.osInfo,
    this.cpuInfo,
    this.ramInfo,
    this.hddInfo,
    this.ssdInfo,
    this.odd,
    this.remarks,
    this.carryOut,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory SERVERASSETTBLUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$SERVERASSETTBLUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'ASSET_NO')
  final StringFieldUpdateOperationsInput? assetNo;

  @JsonKey(name: r'ASSET_TYPE')
  final StringFieldUpdateOperationsInput? assetType;

  @JsonKey(name: r'MAKER')
  final NullableStringFieldUpdateOperationsInput? maker;

  @JsonKey(name: r'CNT')
  final NullableDecimalFieldUpdateOperationsInput? cnt;

  @JsonKey(name: r'AMOUNT')
  final NullableIntFieldUpdateOperationsInput? amount;

  @JsonKey(name: r'BUY_DATE')
  final NullableStringFieldUpdateOperationsInput? buyDate;

  @JsonKey(name: r'SELLER')
  final NullableStringFieldUpdateOperationsInput? seller;

  @JsonKey(name: r'MODEL_NO')
  final NullableStringFieldUpdateOperationsInput? modelNo;

  @JsonKey(name: r'SERIAL_NO')
  final NullableStringFieldUpdateOperationsInput? serialNo;

  @JsonKey(name: r'HOSTNAME')
  final NullableStringFieldUpdateOperationsInput? hostname;

  @JsonKey(name: r'BUILT_LOC')
  final NullableStringFieldUpdateOperationsInput? builtLoc;

  @JsonKey(name: r'USE_DESC')
  final NullableStringFieldUpdateOperationsInput? useDesc;

  @JsonKey(name: r'OS_INFO')
  final NullableStringFieldUpdateOperationsInput? osInfo;

  @JsonKey(name: r'CPU_INFO')
  final NullableStringFieldUpdateOperationsInput? cpuInfo;

  @JsonKey(name: r'RAM_INFO')
  final NullableStringFieldUpdateOperationsInput? ramInfo;

  @JsonKey(name: r'HDD_INFO')
  final NullableStringFieldUpdateOperationsInput? hddInfo;

  @JsonKey(name: r'SSD_INFO')
  final NullableStringFieldUpdateOperationsInput? ssdInfo;

  @JsonKey(name: r'ODD')
  final NullableStringFieldUpdateOperationsInput? odd;

  @JsonKey(name: r'REMARKS')
  final NullableStringFieldUpdateOperationsInput? remarks;

  @JsonKey(name: r'CARRY_OUT')
  final NullableStringFieldUpdateOperationsInput? carryOut;

  @JsonKey(name: r'USE_YN')
  final StringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$SERVERASSETTBLUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class SERVERASSETTBLUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const SERVERASSETTBLUncheckedUpdateManyInput({
    this.seq,
    this.assetNo,
    this.assetType,
    this.maker,
    this.cnt,
    this.amount,
    this.buyDate,
    this.seller,
    this.modelNo,
    this.serialNo,
    this.hostname,
    this.builtLoc,
    this.useDesc,
    this.osInfo,
    this.cpuInfo,
    this.ramInfo,
    this.hddInfo,
    this.ssdInfo,
    this.odd,
    this.remarks,
    this.carryOut,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory SERVERASSETTBLUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$SERVERASSETTBLUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'ASSET_NO')
  final StringFieldUpdateOperationsInput? assetNo;

  @JsonKey(name: r'ASSET_TYPE')
  final StringFieldUpdateOperationsInput? assetType;

  @JsonKey(name: r'MAKER')
  final NullableStringFieldUpdateOperationsInput? maker;

  @JsonKey(name: r'CNT')
  final NullableDecimalFieldUpdateOperationsInput? cnt;

  @JsonKey(name: r'AMOUNT')
  final NullableIntFieldUpdateOperationsInput? amount;

  @JsonKey(name: r'BUY_DATE')
  final NullableStringFieldUpdateOperationsInput? buyDate;

  @JsonKey(name: r'SELLER')
  final NullableStringFieldUpdateOperationsInput? seller;

  @JsonKey(name: r'MODEL_NO')
  final NullableStringFieldUpdateOperationsInput? modelNo;

  @JsonKey(name: r'SERIAL_NO')
  final NullableStringFieldUpdateOperationsInput? serialNo;

  @JsonKey(name: r'HOSTNAME')
  final NullableStringFieldUpdateOperationsInput? hostname;

  @JsonKey(name: r'BUILT_LOC')
  final NullableStringFieldUpdateOperationsInput? builtLoc;

  @JsonKey(name: r'USE_DESC')
  final NullableStringFieldUpdateOperationsInput? useDesc;

  @JsonKey(name: r'OS_INFO')
  final NullableStringFieldUpdateOperationsInput? osInfo;

  @JsonKey(name: r'CPU_INFO')
  final NullableStringFieldUpdateOperationsInput? cpuInfo;

  @JsonKey(name: r'RAM_INFO')
  final NullableStringFieldUpdateOperationsInput? ramInfo;

  @JsonKey(name: r'HDD_INFO')
  final NullableStringFieldUpdateOperationsInput? hddInfo;

  @JsonKey(name: r'SSD_INFO')
  final NullableStringFieldUpdateOperationsInput? ssdInfo;

  @JsonKey(name: r'ODD')
  final NullableStringFieldUpdateOperationsInput? odd;

  @JsonKey(name: r'REMARKS')
  final NullableStringFieldUpdateOperationsInput? remarks;

  @JsonKey(name: r'CARRY_OUT')
  final NullableStringFieldUpdateOperationsInput? carryOut;

  @JsonKey(name: r'USE_YN')
  final StringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$SERVERASSETTBLUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class SOFTWAREASSETTBLCreateInput implements _i1.JsonSerializable {
  const SOFTWAREASSETTBLCreateInput({
    this.seq,
    required this.assetNo,
    required this.softwareNm,
    this.versionNm,
    this.cnt,
    this.amount,
    this.buyDate,
    this.serialNo,
    this.licenseNo,
    this.userNm,
    this.remarks,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory SOFTWAREASSETTBLCreateInput.fromJson(Map<String, dynamic> json) =>
      _$SOFTWAREASSETTBLCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'ASSET_NO')
  final String assetNo;

  @JsonKey(name: r'SOFTWARE_NM')
  final String softwareNm;

  @JsonKey(name: r'VERSION_NM')
  final String? versionNm;

  @JsonKey(name: r'CNT')
  final double? cnt;

  @JsonKey(name: r'AMOUNT')
  final int? amount;

  @JsonKey(name: r'BUY_DATE')
  final String? buyDate;

  @JsonKey(name: r'SERIAL_NO')
  final String? serialNo;

  @JsonKey(name: r'LICENSE_NO')
  final String? licenseNo;

  @JsonKey(name: r'USER_NM')
  final String? userNm;

  @JsonKey(name: r'REMARKS')
  final String? remarks;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() => _$SOFTWAREASSETTBLCreateInputToJson(this);
}

@_i1.jsonSerializable
class SOFTWAREASSETTBLUncheckedCreateInput implements _i1.JsonSerializable {
  const SOFTWAREASSETTBLUncheckedCreateInput({
    this.seq,
    required this.assetNo,
    required this.softwareNm,
    this.versionNm,
    this.cnt,
    this.amount,
    this.buyDate,
    this.serialNo,
    this.licenseNo,
    this.userNm,
    this.remarks,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory SOFTWAREASSETTBLUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$SOFTWAREASSETTBLUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'ASSET_NO')
  final String assetNo;

  @JsonKey(name: r'SOFTWARE_NM')
  final String softwareNm;

  @JsonKey(name: r'VERSION_NM')
  final String? versionNm;

  @JsonKey(name: r'CNT')
  final double? cnt;

  @JsonKey(name: r'AMOUNT')
  final int? amount;

  @JsonKey(name: r'BUY_DATE')
  final String? buyDate;

  @JsonKey(name: r'SERIAL_NO')
  final String? serialNo;

  @JsonKey(name: r'LICENSE_NO')
  final String? licenseNo;

  @JsonKey(name: r'USER_NM')
  final String? userNm;

  @JsonKey(name: r'REMARKS')
  final String? remarks;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$SOFTWAREASSETTBLUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class SOFTWAREASSETTBLUpdateInput implements _i1.JsonSerializable {
  const SOFTWAREASSETTBLUpdateInput({
    this.seq,
    this.assetNo,
    this.softwareNm,
    this.versionNm,
    this.cnt,
    this.amount,
    this.buyDate,
    this.serialNo,
    this.licenseNo,
    this.userNm,
    this.remarks,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory SOFTWAREASSETTBLUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$SOFTWAREASSETTBLUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'ASSET_NO')
  final StringFieldUpdateOperationsInput? assetNo;

  @JsonKey(name: r'SOFTWARE_NM')
  final StringFieldUpdateOperationsInput? softwareNm;

  @JsonKey(name: r'VERSION_NM')
  final NullableStringFieldUpdateOperationsInput? versionNm;

  @JsonKey(name: r'CNT')
  final NullableDecimalFieldUpdateOperationsInput? cnt;

  @JsonKey(name: r'AMOUNT')
  final NullableIntFieldUpdateOperationsInput? amount;

  @JsonKey(name: r'BUY_DATE')
  final NullableStringFieldUpdateOperationsInput? buyDate;

  @JsonKey(name: r'SERIAL_NO')
  final NullableStringFieldUpdateOperationsInput? serialNo;

  @JsonKey(name: r'LICENSE_NO')
  final NullableStringFieldUpdateOperationsInput? licenseNo;

  @JsonKey(name: r'USER_NM')
  final NullableStringFieldUpdateOperationsInput? userNm;

  @JsonKey(name: r'REMARKS')
  final NullableStringFieldUpdateOperationsInput? remarks;

  @JsonKey(name: r'USE_YN')
  final StringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @override
  Map<String, dynamic> toJson() => _$SOFTWAREASSETTBLUpdateInputToJson(this);
}

@_i1.jsonSerializable
class SOFTWAREASSETTBLUncheckedUpdateInput implements _i1.JsonSerializable {
  const SOFTWAREASSETTBLUncheckedUpdateInput({
    this.seq,
    this.assetNo,
    this.softwareNm,
    this.versionNm,
    this.cnt,
    this.amount,
    this.buyDate,
    this.serialNo,
    this.licenseNo,
    this.userNm,
    this.remarks,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory SOFTWAREASSETTBLUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$SOFTWAREASSETTBLUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'ASSET_NO')
  final StringFieldUpdateOperationsInput? assetNo;

  @JsonKey(name: r'SOFTWARE_NM')
  final StringFieldUpdateOperationsInput? softwareNm;

  @JsonKey(name: r'VERSION_NM')
  final NullableStringFieldUpdateOperationsInput? versionNm;

  @JsonKey(name: r'CNT')
  final NullableDecimalFieldUpdateOperationsInput? cnt;

  @JsonKey(name: r'AMOUNT')
  final NullableIntFieldUpdateOperationsInput? amount;

  @JsonKey(name: r'BUY_DATE')
  final NullableStringFieldUpdateOperationsInput? buyDate;

  @JsonKey(name: r'SERIAL_NO')
  final NullableStringFieldUpdateOperationsInput? serialNo;

  @JsonKey(name: r'LICENSE_NO')
  final NullableStringFieldUpdateOperationsInput? licenseNo;

  @JsonKey(name: r'USER_NM')
  final NullableStringFieldUpdateOperationsInput? userNm;

  @JsonKey(name: r'REMARKS')
  final NullableStringFieldUpdateOperationsInput? remarks;

  @JsonKey(name: r'USE_YN')
  final StringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$SOFTWAREASSETTBLUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class SOFTWAREASSETTBLCreateManyInput implements _i1.JsonSerializable {
  const SOFTWAREASSETTBLCreateManyInput({
    this.seq,
    required this.assetNo,
    required this.softwareNm,
    this.versionNm,
    this.cnt,
    this.amount,
    this.buyDate,
    this.serialNo,
    this.licenseNo,
    this.userNm,
    this.remarks,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory SOFTWAREASSETTBLCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$SOFTWAREASSETTBLCreateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'ASSET_NO')
  final String assetNo;

  @JsonKey(name: r'SOFTWARE_NM')
  final String softwareNm;

  @JsonKey(name: r'VERSION_NM')
  final String? versionNm;

  @JsonKey(name: r'CNT')
  final double? cnt;

  @JsonKey(name: r'AMOUNT')
  final int? amount;

  @JsonKey(name: r'BUY_DATE')
  final String? buyDate;

  @JsonKey(name: r'SERIAL_NO')
  final String? serialNo;

  @JsonKey(name: r'LICENSE_NO')
  final String? licenseNo;

  @JsonKey(name: r'USER_NM')
  final String? userNm;

  @JsonKey(name: r'REMARKS')
  final String? remarks;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$SOFTWAREASSETTBLCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class SOFTWAREASSETTBLUpdateManyMutationInput implements _i1.JsonSerializable {
  const SOFTWAREASSETTBLUpdateManyMutationInput({
    this.seq,
    this.assetNo,
    this.softwareNm,
    this.versionNm,
    this.cnt,
    this.amount,
    this.buyDate,
    this.serialNo,
    this.licenseNo,
    this.userNm,
    this.remarks,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory SOFTWAREASSETTBLUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$SOFTWAREASSETTBLUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'ASSET_NO')
  final StringFieldUpdateOperationsInput? assetNo;

  @JsonKey(name: r'SOFTWARE_NM')
  final StringFieldUpdateOperationsInput? softwareNm;

  @JsonKey(name: r'VERSION_NM')
  final NullableStringFieldUpdateOperationsInput? versionNm;

  @JsonKey(name: r'CNT')
  final NullableDecimalFieldUpdateOperationsInput? cnt;

  @JsonKey(name: r'AMOUNT')
  final NullableIntFieldUpdateOperationsInput? amount;

  @JsonKey(name: r'BUY_DATE')
  final NullableStringFieldUpdateOperationsInput? buyDate;

  @JsonKey(name: r'SERIAL_NO')
  final NullableStringFieldUpdateOperationsInput? serialNo;

  @JsonKey(name: r'LICENSE_NO')
  final NullableStringFieldUpdateOperationsInput? licenseNo;

  @JsonKey(name: r'USER_NM')
  final NullableStringFieldUpdateOperationsInput? userNm;

  @JsonKey(name: r'REMARKS')
  final NullableStringFieldUpdateOperationsInput? remarks;

  @JsonKey(name: r'USE_YN')
  final StringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$SOFTWAREASSETTBLUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class SOFTWAREASSETTBLUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const SOFTWAREASSETTBLUncheckedUpdateManyInput({
    this.seq,
    this.assetNo,
    this.softwareNm,
    this.versionNm,
    this.cnt,
    this.amount,
    this.buyDate,
    this.serialNo,
    this.licenseNo,
    this.userNm,
    this.remarks,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory SOFTWAREASSETTBLUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$SOFTWAREASSETTBLUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'ASSET_NO')
  final StringFieldUpdateOperationsInput? assetNo;

  @JsonKey(name: r'SOFTWARE_NM')
  final StringFieldUpdateOperationsInput? softwareNm;

  @JsonKey(name: r'VERSION_NM')
  final NullableStringFieldUpdateOperationsInput? versionNm;

  @JsonKey(name: r'CNT')
  final NullableDecimalFieldUpdateOperationsInput? cnt;

  @JsonKey(name: r'AMOUNT')
  final NullableIntFieldUpdateOperationsInput? amount;

  @JsonKey(name: r'BUY_DATE')
  final NullableStringFieldUpdateOperationsInput? buyDate;

  @JsonKey(name: r'SERIAL_NO')
  final NullableStringFieldUpdateOperationsInput? serialNo;

  @JsonKey(name: r'LICENSE_NO')
  final NullableStringFieldUpdateOperationsInput? licenseNo;

  @JsonKey(name: r'USER_NM')
  final NullableStringFieldUpdateOperationsInput? userNm;

  @JsonKey(name: r'REMARKS')
  final NullableStringFieldUpdateOperationsInput? remarks;

  @JsonKey(name: r'USE_YN')
  final StringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$SOFTWAREASSETTBLUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class STADMINMENUCreateInput implements _i1.JsonSerializable {
  const STADMINMENUCreateInput({
    required this.menuCd,
    required this.menuNm,
    this.menuPath,
    required this.menuSrt,
    required this.menuDeps,
    this.menuIcon,
    this.menuTp,
    required this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STADMINMENUCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STADMINMENUCreateInputFromJson(json);

  @JsonKey(name: r'MENU_CD')
  final String menuCd;

  @JsonKey(name: r'MENU_NM')
  final String menuNm;

  @JsonKey(name: r'MENU_PATH')
  final String? menuPath;

  @JsonKey(name: r'MENU_SRT')
  final int menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final int menuDeps;

  @JsonKey(name: r'MENU_ICON')
  final String? menuIcon;

  @JsonKey(name: r'MENU_TP')
  final String? menuTp;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STADMINMENUCreateInputToJson(this);
}

@_i1.jsonSerializable
class STADMINMENUUncheckedCreateInput implements _i1.JsonSerializable {
  const STADMINMENUUncheckedCreateInput({
    required this.menuCd,
    required this.menuNm,
    this.menuPath,
    required this.menuSrt,
    required this.menuDeps,
    this.menuIcon,
    this.menuTp,
    required this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STADMINMENUUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STADMINMENUUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'MENU_CD')
  final String menuCd;

  @JsonKey(name: r'MENU_NM')
  final String menuNm;

  @JsonKey(name: r'MENU_PATH')
  final String? menuPath;

  @JsonKey(name: r'MENU_SRT')
  final int menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final int menuDeps;

  @JsonKey(name: r'MENU_ICON')
  final String? menuIcon;

  @JsonKey(name: r'MENU_TP')
  final String? menuTp;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STADMINMENUUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class STADMINMENUUpdateInput implements _i1.JsonSerializable {
  const STADMINMENUUpdateInput({
    this.menuCd,
    this.menuNm,
    this.menuPath,
    this.menuSrt,
    this.menuDeps,
    this.menuIcon,
    this.menuTp,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STADMINMENUUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STADMINMENUUpdateInputFromJson(json);

  @JsonKey(name: r'MENU_CD')
  final StringFieldUpdateOperationsInput? menuCd;

  @JsonKey(name: r'MENU_NM')
  final StringFieldUpdateOperationsInput? menuNm;

  @JsonKey(name: r'MENU_PATH')
  final NullableStringFieldUpdateOperationsInput? menuPath;

  @JsonKey(name: r'MENU_SRT')
  final IntFieldUpdateOperationsInput? menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final IntFieldUpdateOperationsInput? menuDeps;

  @JsonKey(name: r'MENU_ICON')
  final NullableStringFieldUpdateOperationsInput? menuIcon;

  @JsonKey(name: r'MENU_TP')
  final StringFieldUpdateOperationsInput? menuTp;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STADMINMENUUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STADMINMENUUncheckedUpdateInput implements _i1.JsonSerializable {
  const STADMINMENUUncheckedUpdateInput({
    this.menuCd,
    this.menuNm,
    this.menuPath,
    this.menuSrt,
    this.menuDeps,
    this.menuIcon,
    this.menuTp,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STADMINMENUUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STADMINMENUUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'MENU_CD')
  final StringFieldUpdateOperationsInput? menuCd;

  @JsonKey(name: r'MENU_NM')
  final StringFieldUpdateOperationsInput? menuNm;

  @JsonKey(name: r'MENU_PATH')
  final NullableStringFieldUpdateOperationsInput? menuPath;

  @JsonKey(name: r'MENU_SRT')
  final IntFieldUpdateOperationsInput? menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final IntFieldUpdateOperationsInput? menuDeps;

  @JsonKey(name: r'MENU_ICON')
  final NullableStringFieldUpdateOperationsInput? menuIcon;

  @JsonKey(name: r'MENU_TP')
  final StringFieldUpdateOperationsInput? menuTp;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STADMINMENUUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STADMINMENUCreateManyInput implements _i1.JsonSerializable {
  const STADMINMENUCreateManyInput({
    required this.menuCd,
    required this.menuNm,
    this.menuPath,
    required this.menuSrt,
    required this.menuDeps,
    this.menuIcon,
    this.menuTp,
    required this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STADMINMENUCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STADMINMENUCreateManyInputFromJson(json);

  @JsonKey(name: r'MENU_CD')
  final String menuCd;

  @JsonKey(name: r'MENU_NM')
  final String menuNm;

  @JsonKey(name: r'MENU_PATH')
  final String? menuPath;

  @JsonKey(name: r'MENU_SRT')
  final int menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final int menuDeps;

  @JsonKey(name: r'MENU_ICON')
  final String? menuIcon;

  @JsonKey(name: r'MENU_TP')
  final String? menuTp;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STADMINMENUCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class STADMINMENUUpdateManyMutationInput implements _i1.JsonSerializable {
  const STADMINMENUUpdateManyMutationInput({
    this.menuCd,
    this.menuNm,
    this.menuPath,
    this.menuSrt,
    this.menuDeps,
    this.menuIcon,
    this.menuTp,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STADMINMENUUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STADMINMENUUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'MENU_CD')
  final StringFieldUpdateOperationsInput? menuCd;

  @JsonKey(name: r'MENU_NM')
  final StringFieldUpdateOperationsInput? menuNm;

  @JsonKey(name: r'MENU_PATH')
  final NullableStringFieldUpdateOperationsInput? menuPath;

  @JsonKey(name: r'MENU_SRT')
  final IntFieldUpdateOperationsInput? menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final IntFieldUpdateOperationsInput? menuDeps;

  @JsonKey(name: r'MENU_ICON')
  final NullableStringFieldUpdateOperationsInput? menuIcon;

  @JsonKey(name: r'MENU_TP')
  final StringFieldUpdateOperationsInput? menuTp;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STADMINMENUUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class STADMINMENUUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const STADMINMENUUncheckedUpdateManyInput({
    this.menuCd,
    this.menuNm,
    this.menuPath,
    this.menuSrt,
    this.menuDeps,
    this.menuIcon,
    this.menuTp,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STADMINMENUUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$STADMINMENUUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'MENU_CD')
  final StringFieldUpdateOperationsInput? menuCd;

  @JsonKey(name: r'MENU_NM')
  final StringFieldUpdateOperationsInput? menuNm;

  @JsonKey(name: r'MENU_PATH')
  final NullableStringFieldUpdateOperationsInput? menuPath;

  @JsonKey(name: r'MENU_SRT')
  final IntFieldUpdateOperationsInput? menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final IntFieldUpdateOperationsInput? menuDeps;

  @JsonKey(name: r'MENU_ICON')
  final NullableStringFieldUpdateOperationsInput? menuIcon;

  @JsonKey(name: r'MENU_TP')
  final StringFieldUpdateOperationsInput? menuTp;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STADMINMENUUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class STALARMCreateInput implements _i1.JsonSerializable {
  const STALARMCreateInput({
    required this.seq,
    this.msgCd,
    this.msgCnts,
    this.sendDate,
    this.sendDiv,
    this.sendDeptCd,
    this.sendId,
    this.recvId,
    this.popYn,
    this.editId,
    this.editDate,
  });

  factory STALARMCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STALARMCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'MSG_CD')
  final String? msgCd;

  @JsonKey(name: r'MSG_CNTS')
  final String? msgCnts;

  @JsonKey(name: r'SEND_DATE')
  final String? sendDate;

  @JsonKey(name: r'SEND_DIV')
  final String? sendDiv;

  @JsonKey(name: r'SEND_DEPT_CD')
  final String? sendDeptCd;

  @JsonKey(name: r'SEND_ID')
  final String? sendId;

  @JsonKey(name: r'RECV_ID')
  final String? recvId;

  @JsonKey(name: r'POP_YN')
  final String? popYn;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @override
  Map<String, dynamic> toJson() => _$STALARMCreateInputToJson(this);
}

@_i1.jsonSerializable
class STALARMUncheckedCreateInput implements _i1.JsonSerializable {
  const STALARMUncheckedCreateInput({
    required this.seq,
    this.msgCd,
    this.msgCnts,
    this.sendDate,
    this.sendDiv,
    this.sendDeptCd,
    this.sendId,
    this.recvId,
    this.popYn,
    this.editId,
    this.editDate,
  });

  factory STALARMUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STALARMUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'MSG_CD')
  final String? msgCd;

  @JsonKey(name: r'MSG_CNTS')
  final String? msgCnts;

  @JsonKey(name: r'SEND_DATE')
  final String? sendDate;

  @JsonKey(name: r'SEND_DIV')
  final String? sendDiv;

  @JsonKey(name: r'SEND_DEPT_CD')
  final String? sendDeptCd;

  @JsonKey(name: r'SEND_ID')
  final String? sendId;

  @JsonKey(name: r'RECV_ID')
  final String? recvId;

  @JsonKey(name: r'POP_YN')
  final String? popYn;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @override
  Map<String, dynamic> toJson() => _$STALARMUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class STALARMUpdateInput implements _i1.JsonSerializable {
  const STALARMUpdateInput({
    this.seq,
    this.msgCd,
    this.msgCnts,
    this.sendDate,
    this.sendDiv,
    this.sendDeptCd,
    this.sendId,
    this.recvId,
    this.popYn,
    this.editId,
    this.editDate,
  });

  factory STALARMUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STALARMUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'MSG_CD')
  final NullableStringFieldUpdateOperationsInput? msgCd;

  @JsonKey(name: r'MSG_CNTS')
  final NullableStringFieldUpdateOperationsInput? msgCnts;

  @JsonKey(name: r'SEND_DATE')
  final NullableStringFieldUpdateOperationsInput? sendDate;

  @JsonKey(name: r'SEND_DIV')
  final NullableStringFieldUpdateOperationsInput? sendDiv;

  @JsonKey(name: r'SEND_DEPT_CD')
  final NullableStringFieldUpdateOperationsInput? sendDeptCd;

  @JsonKey(name: r'SEND_ID')
  final NullableStringFieldUpdateOperationsInput? sendId;

  @JsonKey(name: r'RECV_ID')
  final NullableStringFieldUpdateOperationsInput? recvId;

  @JsonKey(name: r'POP_YN')
  final NullableStringFieldUpdateOperationsInput? popYn;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @override
  Map<String, dynamic> toJson() => _$STALARMUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STALARMUncheckedUpdateInput implements _i1.JsonSerializable {
  const STALARMUncheckedUpdateInput({
    this.seq,
    this.msgCd,
    this.msgCnts,
    this.sendDate,
    this.sendDiv,
    this.sendDeptCd,
    this.sendId,
    this.recvId,
    this.popYn,
    this.editId,
    this.editDate,
  });

  factory STALARMUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STALARMUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'MSG_CD')
  final NullableStringFieldUpdateOperationsInput? msgCd;

  @JsonKey(name: r'MSG_CNTS')
  final NullableStringFieldUpdateOperationsInput? msgCnts;

  @JsonKey(name: r'SEND_DATE')
  final NullableStringFieldUpdateOperationsInput? sendDate;

  @JsonKey(name: r'SEND_DIV')
  final NullableStringFieldUpdateOperationsInput? sendDiv;

  @JsonKey(name: r'SEND_DEPT_CD')
  final NullableStringFieldUpdateOperationsInput? sendDeptCd;

  @JsonKey(name: r'SEND_ID')
  final NullableStringFieldUpdateOperationsInput? sendId;

  @JsonKey(name: r'RECV_ID')
  final NullableStringFieldUpdateOperationsInput? recvId;

  @JsonKey(name: r'POP_YN')
  final NullableStringFieldUpdateOperationsInput? popYn;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @override
  Map<String, dynamic> toJson() => _$STALARMUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STALARMCreateManyInput implements _i1.JsonSerializable {
  const STALARMCreateManyInput({
    required this.seq,
    this.msgCd,
    this.msgCnts,
    this.sendDate,
    this.sendDiv,
    this.sendDeptCd,
    this.sendId,
    this.recvId,
    this.popYn,
    this.editId,
    this.editDate,
  });

  factory STALARMCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STALARMCreateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'MSG_CD')
  final String? msgCd;

  @JsonKey(name: r'MSG_CNTS')
  final String? msgCnts;

  @JsonKey(name: r'SEND_DATE')
  final String? sendDate;

  @JsonKey(name: r'SEND_DIV')
  final String? sendDiv;

  @JsonKey(name: r'SEND_DEPT_CD')
  final String? sendDeptCd;

  @JsonKey(name: r'SEND_ID')
  final String? sendId;

  @JsonKey(name: r'RECV_ID')
  final String? recvId;

  @JsonKey(name: r'POP_YN')
  final String? popYn;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @override
  Map<String, dynamic> toJson() => _$STALARMCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class STALARMUpdateManyMutationInput implements _i1.JsonSerializable {
  const STALARMUpdateManyMutationInput({
    this.seq,
    this.msgCd,
    this.msgCnts,
    this.sendDate,
    this.sendDiv,
    this.sendDeptCd,
    this.sendId,
    this.recvId,
    this.popYn,
    this.editId,
    this.editDate,
  });

  factory STALARMUpdateManyMutationInput.fromJson(Map<String, dynamic> json) =>
      _$STALARMUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'MSG_CD')
  final NullableStringFieldUpdateOperationsInput? msgCd;

  @JsonKey(name: r'MSG_CNTS')
  final NullableStringFieldUpdateOperationsInput? msgCnts;

  @JsonKey(name: r'SEND_DATE')
  final NullableStringFieldUpdateOperationsInput? sendDate;

  @JsonKey(name: r'SEND_DIV')
  final NullableStringFieldUpdateOperationsInput? sendDiv;

  @JsonKey(name: r'SEND_DEPT_CD')
  final NullableStringFieldUpdateOperationsInput? sendDeptCd;

  @JsonKey(name: r'SEND_ID')
  final NullableStringFieldUpdateOperationsInput? sendId;

  @JsonKey(name: r'RECV_ID')
  final NullableStringFieldUpdateOperationsInput? recvId;

  @JsonKey(name: r'POP_YN')
  final NullableStringFieldUpdateOperationsInput? popYn;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @override
  Map<String, dynamic> toJson() => _$STALARMUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class STALARMUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const STALARMUncheckedUpdateManyInput({
    this.seq,
    this.msgCd,
    this.msgCnts,
    this.sendDate,
    this.sendDiv,
    this.sendDeptCd,
    this.sendId,
    this.recvId,
    this.popYn,
    this.editId,
    this.editDate,
  });

  factory STALARMUncheckedUpdateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STALARMUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'MSG_CD')
  final NullableStringFieldUpdateOperationsInput? msgCd;

  @JsonKey(name: r'MSG_CNTS')
  final NullableStringFieldUpdateOperationsInput? msgCnts;

  @JsonKey(name: r'SEND_DATE')
  final NullableStringFieldUpdateOperationsInput? sendDate;

  @JsonKey(name: r'SEND_DIV')
  final NullableStringFieldUpdateOperationsInput? sendDiv;

  @JsonKey(name: r'SEND_DEPT_CD')
  final NullableStringFieldUpdateOperationsInput? sendDeptCd;

  @JsonKey(name: r'SEND_ID')
  final NullableStringFieldUpdateOperationsInput? sendId;

  @JsonKey(name: r'RECV_ID')
  final NullableStringFieldUpdateOperationsInput? recvId;

  @JsonKey(name: r'POP_YN')
  final NullableStringFieldUpdateOperationsInput? popYn;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STALARMUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class STAUDITLOGCreateInput implements _i1.JsonSerializable {
  const STAUDITLOGCreateInput({
    required this.seq,
    required this.logCode,
    required this.logCnts,
    this.errCode,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STAUDITLOGCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STAUDITLOGCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'LOG_CODE')
  final String logCode;

  @JsonKey(name: r'LOG_CNTS')
  final String logCnts;

  @JsonKey(name: r'ERR_CODE')
  final String? errCode;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STAUDITLOGCreateInputToJson(this);
}

@_i1.jsonSerializable
class STAUDITLOGUncheckedCreateInput implements _i1.JsonSerializable {
  const STAUDITLOGUncheckedCreateInput({
    required this.seq,
    required this.logCode,
    required this.logCnts,
    this.errCode,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STAUDITLOGUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STAUDITLOGUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'LOG_CODE')
  final String logCode;

  @JsonKey(name: r'LOG_CNTS')
  final String logCnts;

  @JsonKey(name: r'ERR_CODE')
  final String? errCode;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STAUDITLOGUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class STAUDITLOGUpdateInput implements _i1.JsonSerializable {
  const STAUDITLOGUpdateInput({
    this.seq,
    this.logCode,
    this.logCnts,
    this.errCode,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STAUDITLOGUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STAUDITLOGUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'LOG_CODE')
  final StringFieldUpdateOperationsInput? logCode;

  @JsonKey(name: r'LOG_CNTS')
  final StringFieldUpdateOperationsInput? logCnts;

  @JsonKey(name: r'ERR_CODE')
  final NullableStringFieldUpdateOperationsInput? errCode;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STAUDITLOGUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STAUDITLOGUncheckedUpdateInput implements _i1.JsonSerializable {
  const STAUDITLOGUncheckedUpdateInput({
    this.seq,
    this.logCode,
    this.logCnts,
    this.errCode,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STAUDITLOGUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STAUDITLOGUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'LOG_CODE')
  final StringFieldUpdateOperationsInput? logCode;

  @JsonKey(name: r'LOG_CNTS')
  final StringFieldUpdateOperationsInput? logCnts;

  @JsonKey(name: r'ERR_CODE')
  final NullableStringFieldUpdateOperationsInput? errCode;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STAUDITLOGUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STAUDITLOGCreateManyInput implements _i1.JsonSerializable {
  const STAUDITLOGCreateManyInput({
    required this.seq,
    required this.logCode,
    required this.logCnts,
    this.errCode,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STAUDITLOGCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STAUDITLOGCreateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'LOG_CODE')
  final String logCode;

  @JsonKey(name: r'LOG_CNTS')
  final String logCnts;

  @JsonKey(name: r'ERR_CODE')
  final String? errCode;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STAUDITLOGCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class STAUDITLOGUpdateManyMutationInput implements _i1.JsonSerializable {
  const STAUDITLOGUpdateManyMutationInput({
    this.seq,
    this.logCode,
    this.logCnts,
    this.errCode,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STAUDITLOGUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STAUDITLOGUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'LOG_CODE')
  final StringFieldUpdateOperationsInput? logCode;

  @JsonKey(name: r'LOG_CNTS')
  final StringFieldUpdateOperationsInput? logCnts;

  @JsonKey(name: r'ERR_CODE')
  final NullableStringFieldUpdateOperationsInput? errCode;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STAUDITLOGUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class STAUDITLOGUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const STAUDITLOGUncheckedUpdateManyInput({
    this.seq,
    this.logCode,
    this.logCnts,
    this.errCode,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STAUDITLOGUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$STAUDITLOGUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'LOG_CODE')
  final StringFieldUpdateOperationsInput? logCode;

  @JsonKey(name: r'LOG_CNTS')
  final StringFieldUpdateOperationsInput? logCnts;

  @JsonKey(name: r'ERR_CODE')
  final NullableStringFieldUpdateOperationsInput? errCode;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STAUDITLOGUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class STBANNERCreateInput implements _i1.JsonSerializable {
  const STBANNERCreateInput({
    required this.bannerCd,
    this.lkUrl,
    this.lkTarget,
    this.flpth,
    this.fileNm,
    this.useYn,
    required this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBANNERCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STBANNERCreateInputFromJson(json);

  @JsonKey(name: r'BANNER_CD')
  final String bannerCd;

  @JsonKey(name: r'LK_URL')
  final String? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final String? lkTarget;

  @JsonKey(name: r'FLPTH')
  final String? flpth;

  @JsonKey(name: r'FILE_NM')
  final String? fileNm;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STBANNERCreateInputToJson(this);
}

@_i1.jsonSerializable
class STBANNERUncheckedCreateInput implements _i1.JsonSerializable {
  const STBANNERUncheckedCreateInput({
    required this.bannerCd,
    this.lkUrl,
    this.lkTarget,
    this.flpth,
    this.fileNm,
    this.useYn,
    required this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBANNERUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STBANNERUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'BANNER_CD')
  final String bannerCd;

  @JsonKey(name: r'LK_URL')
  final String? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final String? lkTarget;

  @JsonKey(name: r'FLPTH')
  final String? flpth;

  @JsonKey(name: r'FILE_NM')
  final String? fileNm;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STBANNERUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class STBANNERUpdateInput implements _i1.JsonSerializable {
  const STBANNERUpdateInput({
    this.bannerCd,
    this.lkUrl,
    this.lkTarget,
    this.flpth,
    this.fileNm,
    this.useYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBANNERUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STBANNERUpdateInputFromJson(json);

  @JsonKey(name: r'BANNER_CD')
  final StringFieldUpdateOperationsInput? bannerCd;

  @JsonKey(name: r'LK_URL')
  final NullableStringFieldUpdateOperationsInput? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final NullableStringFieldUpdateOperationsInput? lkTarget;

  @JsonKey(name: r'FLPTH')
  final NullableStringFieldUpdateOperationsInput? flpth;

  @JsonKey(name: r'FILE_NM')
  final NullableStringFieldUpdateOperationsInput? fileNm;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STBANNERUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STBANNERUncheckedUpdateInput implements _i1.JsonSerializable {
  const STBANNERUncheckedUpdateInput({
    this.bannerCd,
    this.lkUrl,
    this.lkTarget,
    this.flpth,
    this.fileNm,
    this.useYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBANNERUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STBANNERUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'BANNER_CD')
  final StringFieldUpdateOperationsInput? bannerCd;

  @JsonKey(name: r'LK_URL')
  final NullableStringFieldUpdateOperationsInput? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final NullableStringFieldUpdateOperationsInput? lkTarget;

  @JsonKey(name: r'FLPTH')
  final NullableStringFieldUpdateOperationsInput? flpth;

  @JsonKey(name: r'FILE_NM')
  final NullableStringFieldUpdateOperationsInput? fileNm;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STBANNERUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STBANNERCreateManyInput implements _i1.JsonSerializable {
  const STBANNERCreateManyInput({
    required this.bannerCd,
    this.lkUrl,
    this.lkTarget,
    this.flpth,
    this.fileNm,
    this.useYn,
    required this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBANNERCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STBANNERCreateManyInputFromJson(json);

  @JsonKey(name: r'BANNER_CD')
  final String bannerCd;

  @JsonKey(name: r'LK_URL')
  final String? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final String? lkTarget;

  @JsonKey(name: r'FLPTH')
  final String? flpth;

  @JsonKey(name: r'FILE_NM')
  final String? fileNm;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STBANNERCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class STBANNERUpdateManyMutationInput implements _i1.JsonSerializable {
  const STBANNERUpdateManyMutationInput({
    this.bannerCd,
    this.lkUrl,
    this.lkTarget,
    this.flpth,
    this.fileNm,
    this.useYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBANNERUpdateManyMutationInput.fromJson(Map<String, dynamic> json) =>
      _$STBANNERUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'BANNER_CD')
  final StringFieldUpdateOperationsInput? bannerCd;

  @JsonKey(name: r'LK_URL')
  final NullableStringFieldUpdateOperationsInput? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final NullableStringFieldUpdateOperationsInput? lkTarget;

  @JsonKey(name: r'FLPTH')
  final NullableStringFieldUpdateOperationsInput? flpth;

  @JsonKey(name: r'FILE_NM')
  final NullableStringFieldUpdateOperationsInput? fileNm;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBANNERUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class STBANNERUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const STBANNERUncheckedUpdateManyInput({
    this.bannerCd,
    this.lkUrl,
    this.lkTarget,
    this.flpth,
    this.fileNm,
    this.useYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBANNERUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBANNERUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'BANNER_CD')
  final StringFieldUpdateOperationsInput? bannerCd;

  @JsonKey(name: r'LK_URL')
  final NullableStringFieldUpdateOperationsInput? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final NullableStringFieldUpdateOperationsInput? lkTarget;

  @JsonKey(name: r'FLPTH')
  final NullableStringFieldUpdateOperationsInput? flpth;

  @JsonKey(name: r'FILE_NM')
  final NullableStringFieldUpdateOperationsInput? fileNm;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBANNERUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNCreateInput implements _i1.JsonSerializable {
  const STBOARDCOLUMNCreateInput({
    required this.boardCd,
    required this.sort,
    required this.colCd,
    required this.colNm,
    required this.regId,
    required this.regDate,
  });

  factory STBOARDCOLUMNCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDCOLUMNCreateInputFromJson(json);

  @JsonKey(name: r'BOARD_CD')
  final String boardCd;

  @JsonKey(name: r'SORT')
  final int sort;

  @JsonKey(name: r'COL_CD')
  final String colCd;

  @JsonKey(name: r'COL_NM')
  final String colNm;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @override
  Map<String, dynamic> toJson() => _$STBOARDCOLUMNCreateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNUncheckedCreateInput implements _i1.JsonSerializable {
  const STBOARDCOLUMNUncheckedCreateInput({
    required this.boardCd,
    required this.sort,
    required this.colCd,
    required this.colNm,
    required this.regId,
    required this.regDate,
  });

  factory STBOARDCOLUMNUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOLUMNUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'BOARD_CD')
  final String boardCd;

  @JsonKey(name: r'SORT')
  final int sort;

  @JsonKey(name: r'COL_CD')
  final String colCd;

  @JsonKey(name: r'COL_NM')
  final String colNm;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOLUMNUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNUpdateInput implements _i1.JsonSerializable {
  const STBOARDCOLUMNUpdateInput({
    this.boardCd,
    this.sort,
    this.colCd,
    this.colNm,
    this.regId,
    this.regDate,
  });

  factory STBOARDCOLUMNUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDCOLUMNUpdateInputFromJson(json);

  @JsonKey(name: r'BOARD_CD')
  final StringFieldUpdateOperationsInput? boardCd;

  @JsonKey(name: r'SORT')
  final IntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'COL_CD')
  final StringFieldUpdateOperationsInput? colCd;

  @JsonKey(name: r'COL_NM')
  final StringFieldUpdateOperationsInput? colNm;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @override
  Map<String, dynamic> toJson() => _$STBOARDCOLUMNUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNUncheckedUpdateInput implements _i1.JsonSerializable {
  const STBOARDCOLUMNUncheckedUpdateInput({
    this.boardCd,
    this.sort,
    this.colCd,
    this.colNm,
    this.regId,
    this.regDate,
  });

  factory STBOARDCOLUMNUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOLUMNUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'BOARD_CD')
  final StringFieldUpdateOperationsInput? boardCd;

  @JsonKey(name: r'SORT')
  final IntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'COL_CD')
  final StringFieldUpdateOperationsInput? colCd;

  @JsonKey(name: r'COL_NM')
  final StringFieldUpdateOperationsInput? colNm;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOLUMNUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNCreateManyInput implements _i1.JsonSerializable {
  const STBOARDCOLUMNCreateManyInput({
    required this.boardCd,
    required this.sort,
    required this.colCd,
    required this.colNm,
    required this.regId,
    required this.regDate,
  });

  factory STBOARDCOLUMNCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDCOLUMNCreateManyInputFromJson(json);

  @JsonKey(name: r'BOARD_CD')
  final String boardCd;

  @JsonKey(name: r'SORT')
  final int sort;

  @JsonKey(name: r'COL_CD')
  final String colCd;

  @JsonKey(name: r'COL_NM')
  final String colNm;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @override
  Map<String, dynamic> toJson() => _$STBOARDCOLUMNCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNUpdateManyMutationInput implements _i1.JsonSerializable {
  const STBOARDCOLUMNUpdateManyMutationInput({
    this.boardCd,
    this.sort,
    this.colCd,
    this.colNm,
    this.regId,
    this.regDate,
  });

  factory STBOARDCOLUMNUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOLUMNUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'BOARD_CD')
  final StringFieldUpdateOperationsInput? boardCd;

  @JsonKey(name: r'SORT')
  final IntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'COL_CD')
  final StringFieldUpdateOperationsInput? colCd;

  @JsonKey(name: r'COL_NM')
  final StringFieldUpdateOperationsInput? colNm;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOLUMNUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const STBOARDCOLUMNUncheckedUpdateManyInput({
    this.boardCd,
    this.sort,
    this.colCd,
    this.colNm,
    this.regId,
    this.regDate,
  });

  factory STBOARDCOLUMNUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOLUMNUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'BOARD_CD')
  final StringFieldUpdateOperationsInput? boardCd;

  @JsonKey(name: r'SORT')
  final IntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'COL_CD')
  final StringFieldUpdateOperationsInput? colCd;

  @JsonKey(name: r'COL_NM')
  final StringFieldUpdateOperationsInput? colNm;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOLUMNUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNDFTCreateInput implements _i1.JsonSerializable {
  const STBOARDCOLUMNDFTCreateInput({
    required this.boardTy,
    required this.sort,
    required this.colCd,
    required this.colNm,
    this.editId,
    this.editDate,
    this.delYn,
  });

  factory STBOARDCOLUMNDFTCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDCOLUMNDFTCreateInputFromJson(json);

  @JsonKey(name: r'BOARD_TY')
  final String boardTy;

  @JsonKey(name: r'SORT')
  final int sort;

  @JsonKey(name: r'COL_CD')
  final String colCd;

  @JsonKey(name: r'COL_NM')
  final String colNm;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() => _$STBOARDCOLUMNDFTCreateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNDFTUncheckedCreateInput implements _i1.JsonSerializable {
  const STBOARDCOLUMNDFTUncheckedCreateInput({
    required this.boardTy,
    required this.sort,
    required this.colCd,
    required this.colNm,
    this.editId,
    this.editDate,
    this.delYn,
  });

  factory STBOARDCOLUMNDFTUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOLUMNDFTUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'BOARD_TY')
  final String boardTy;

  @JsonKey(name: r'SORT')
  final int sort;

  @JsonKey(name: r'COL_CD')
  final String colCd;

  @JsonKey(name: r'COL_NM')
  final String colNm;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOLUMNDFTUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNDFTUpdateInput implements _i1.JsonSerializable {
  const STBOARDCOLUMNDFTUpdateInput({
    this.boardTy,
    this.sort,
    this.colCd,
    this.colNm,
    this.editId,
    this.editDate,
    this.delYn,
  });

  factory STBOARDCOLUMNDFTUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDCOLUMNDFTUpdateInputFromJson(json);

  @JsonKey(name: r'BOARD_TY')
  final StringFieldUpdateOperationsInput? boardTy;

  @JsonKey(name: r'SORT')
  final IntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'COL_CD')
  final StringFieldUpdateOperationsInput? colCd;

  @JsonKey(name: r'COL_NM')
  final StringFieldUpdateOperationsInput? colNm;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_YN')
  final StringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() => _$STBOARDCOLUMNDFTUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNDFTUncheckedUpdateInput implements _i1.JsonSerializable {
  const STBOARDCOLUMNDFTUncheckedUpdateInput({
    this.boardTy,
    this.sort,
    this.colCd,
    this.colNm,
    this.editId,
    this.editDate,
    this.delYn,
  });

  factory STBOARDCOLUMNDFTUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOLUMNDFTUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'BOARD_TY')
  final StringFieldUpdateOperationsInput? boardTy;

  @JsonKey(name: r'SORT')
  final IntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'COL_CD')
  final StringFieldUpdateOperationsInput? colCd;

  @JsonKey(name: r'COL_NM')
  final StringFieldUpdateOperationsInput? colNm;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_YN')
  final StringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOLUMNDFTUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNDFTCreateManyInput implements _i1.JsonSerializable {
  const STBOARDCOLUMNDFTCreateManyInput({
    required this.boardTy,
    required this.sort,
    required this.colCd,
    required this.colNm,
    this.editId,
    this.editDate,
    this.delYn,
  });

  factory STBOARDCOLUMNDFTCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDCOLUMNDFTCreateManyInputFromJson(json);

  @JsonKey(name: r'BOARD_TY')
  final String boardTy;

  @JsonKey(name: r'SORT')
  final int sort;

  @JsonKey(name: r'COL_CD')
  final String colCd;

  @JsonKey(name: r'COL_NM')
  final String colNm;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOLUMNDFTCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNDFTUpdateManyMutationInput implements _i1.JsonSerializable {
  const STBOARDCOLUMNDFTUpdateManyMutationInput({
    this.boardTy,
    this.sort,
    this.colCd,
    this.colNm,
    this.editId,
    this.editDate,
    this.delYn,
  });

  factory STBOARDCOLUMNDFTUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOLUMNDFTUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'BOARD_TY')
  final StringFieldUpdateOperationsInput? boardTy;

  @JsonKey(name: r'SORT')
  final IntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'COL_CD')
  final StringFieldUpdateOperationsInput? colCd;

  @JsonKey(name: r'COL_NM')
  final StringFieldUpdateOperationsInput? colNm;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_YN')
  final StringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOLUMNDFTUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNDFTUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const STBOARDCOLUMNDFTUncheckedUpdateManyInput({
    this.boardTy,
    this.sort,
    this.colCd,
    this.colNm,
    this.editId,
    this.editDate,
    this.delYn,
  });

  factory STBOARDCOLUMNDFTUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOLUMNDFTUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'BOARD_TY')
  final StringFieldUpdateOperationsInput? boardTy;

  @JsonKey(name: r'SORT')
  final IntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'COL_CD')
  final StringFieldUpdateOperationsInput? colCd;

  @JsonKey(name: r'COL_NM')
  final StringFieldUpdateOperationsInput? colNm;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_YN')
  final StringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOLUMNDFTUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOMMENTCreateInput implements _i1.JsonSerializable {
  const STBOARDCOMMENTCreateInput({
    required this.seq,
    required this.mseq,
    required this.boardCd,
    this.cnts,
    this.upperSeq,
    this.replyYn,
    this.regAdminYn,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDCOMMENTCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDCOMMENTCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'MSEQ')
  final int mseq;

  @JsonKey(name: r'BOARD_CD')
  final String boardCd;

  @JsonKey(name: r'CNTS')
  final String? cnts;

  @JsonKey(name: r'UPPER_SEQ')
  final int? upperSeq;

  @JsonKey(name: r'REPLY_YN')
  final String? replyYn;

  @JsonKey(name: r'REG_ADMIN_YN')
  final String? regAdminYn;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STBOARDCOMMENTCreateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOMMENTUncheckedCreateInput implements _i1.JsonSerializable {
  const STBOARDCOMMENTUncheckedCreateInput({
    required this.seq,
    required this.mseq,
    required this.boardCd,
    this.cnts,
    this.upperSeq,
    this.replyYn,
    this.regAdminYn,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDCOMMENTUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOMMENTUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'MSEQ')
  final int mseq;

  @JsonKey(name: r'BOARD_CD')
  final String boardCd;

  @JsonKey(name: r'CNTS')
  final String? cnts;

  @JsonKey(name: r'UPPER_SEQ')
  final int? upperSeq;

  @JsonKey(name: r'REPLY_YN')
  final String? replyYn;

  @JsonKey(name: r'REG_ADMIN_YN')
  final String? regAdminYn;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOMMENTUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOMMENTUpdateInput implements _i1.JsonSerializable {
  const STBOARDCOMMENTUpdateInput({
    this.seq,
    this.mseq,
    this.boardCd,
    this.cnts,
    this.upperSeq,
    this.replyYn,
    this.regAdminYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDCOMMENTUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDCOMMENTUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'MSEQ')
  final IntFieldUpdateOperationsInput? mseq;

  @JsonKey(name: r'BOARD_CD')
  final StringFieldUpdateOperationsInput? boardCd;

  @JsonKey(name: r'CNTS')
  final NullableStringFieldUpdateOperationsInput? cnts;

  @JsonKey(name: r'UPPER_SEQ')
  final NullableIntFieldUpdateOperationsInput? upperSeq;

  @JsonKey(name: r'REPLY_YN')
  final NullableStringFieldUpdateOperationsInput? replyYn;

  @JsonKey(name: r'REG_ADMIN_YN')
  final NullableStringFieldUpdateOperationsInput? regAdminYn;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STBOARDCOMMENTUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOMMENTUncheckedUpdateInput implements _i1.JsonSerializable {
  const STBOARDCOMMENTUncheckedUpdateInput({
    this.seq,
    this.mseq,
    this.boardCd,
    this.cnts,
    this.upperSeq,
    this.replyYn,
    this.regAdminYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDCOMMENTUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOMMENTUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'MSEQ')
  final IntFieldUpdateOperationsInput? mseq;

  @JsonKey(name: r'BOARD_CD')
  final StringFieldUpdateOperationsInput? boardCd;

  @JsonKey(name: r'CNTS')
  final NullableStringFieldUpdateOperationsInput? cnts;

  @JsonKey(name: r'UPPER_SEQ')
  final NullableIntFieldUpdateOperationsInput? upperSeq;

  @JsonKey(name: r'REPLY_YN')
  final NullableStringFieldUpdateOperationsInput? replyYn;

  @JsonKey(name: r'REG_ADMIN_YN')
  final NullableStringFieldUpdateOperationsInput? regAdminYn;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOMMENTUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOMMENTCreateManyInput implements _i1.JsonSerializable {
  const STBOARDCOMMENTCreateManyInput({
    required this.seq,
    required this.mseq,
    required this.boardCd,
    this.cnts,
    this.upperSeq,
    this.replyYn,
    this.regAdminYn,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDCOMMENTCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDCOMMENTCreateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'MSEQ')
  final int mseq;

  @JsonKey(name: r'BOARD_CD')
  final String boardCd;

  @JsonKey(name: r'CNTS')
  final String? cnts;

  @JsonKey(name: r'UPPER_SEQ')
  final int? upperSeq;

  @JsonKey(name: r'REPLY_YN')
  final String? replyYn;

  @JsonKey(name: r'REG_ADMIN_YN')
  final String? regAdminYn;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STBOARDCOMMENTCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOMMENTUpdateManyMutationInput implements _i1.JsonSerializable {
  const STBOARDCOMMENTUpdateManyMutationInput({
    this.seq,
    this.mseq,
    this.boardCd,
    this.cnts,
    this.upperSeq,
    this.replyYn,
    this.regAdminYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDCOMMENTUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOMMENTUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'MSEQ')
  final IntFieldUpdateOperationsInput? mseq;

  @JsonKey(name: r'BOARD_CD')
  final StringFieldUpdateOperationsInput? boardCd;

  @JsonKey(name: r'CNTS')
  final NullableStringFieldUpdateOperationsInput? cnts;

  @JsonKey(name: r'UPPER_SEQ')
  final NullableIntFieldUpdateOperationsInput? upperSeq;

  @JsonKey(name: r'REPLY_YN')
  final NullableStringFieldUpdateOperationsInput? replyYn;

  @JsonKey(name: r'REG_ADMIN_YN')
  final NullableStringFieldUpdateOperationsInput? regAdminYn;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOMMENTUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOMMENTUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const STBOARDCOMMENTUncheckedUpdateManyInput({
    this.seq,
    this.mseq,
    this.boardCd,
    this.cnts,
    this.upperSeq,
    this.replyYn,
    this.regAdminYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDCOMMENTUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOMMENTUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'MSEQ')
  final IntFieldUpdateOperationsInput? mseq;

  @JsonKey(name: r'BOARD_CD')
  final StringFieldUpdateOperationsInput? boardCd;

  @JsonKey(name: r'CNTS')
  final NullableStringFieldUpdateOperationsInput? cnts;

  @JsonKey(name: r'UPPER_SEQ')
  final NullableIntFieldUpdateOperationsInput? upperSeq;

  @JsonKey(name: r'REPLY_YN')
  final NullableStringFieldUpdateOperationsInput? replyYn;

  @JsonKey(name: r'REG_ADMIN_YN')
  final NullableStringFieldUpdateOperationsInput? regAdminYn;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOMMENTUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDFILECreateInput implements _i1.JsonSerializable {
  const STBOARDFILECreateInput({
    required this.seq,
    required this.mseq,
    required this.boardCd,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileSize,
    this.repreYn,
    this.dwldCo,
  });

  factory STBOARDFILECreateInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDFILECreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'MSEQ')
  final int mseq;

  @JsonKey(name: r'BOARD_CD')
  final String boardCd;

  @JsonKey(name: r'FILE_TP')
  final String? fileTp;

  @JsonKey(name: r'FLPTH')
  final String? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final String? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final String? streFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final int? fileSize;

  @JsonKey(name: r'REPRE_YN')
  final String? repreYn;

  @JsonKey(name: r'DWLD_CO')
  final int? dwldCo;

  @override
  Map<String, dynamic> toJson() => _$STBOARDFILECreateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDFILEUncheckedCreateInput implements _i1.JsonSerializable {
  const STBOARDFILEUncheckedCreateInput({
    required this.seq,
    required this.mseq,
    required this.boardCd,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileSize,
    this.repreYn,
    this.dwldCo,
  });

  factory STBOARDFILEUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDFILEUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'MSEQ')
  final int mseq;

  @JsonKey(name: r'BOARD_CD')
  final String boardCd;

  @JsonKey(name: r'FILE_TP')
  final String? fileTp;

  @JsonKey(name: r'FLPTH')
  final String? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final String? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final String? streFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final int? fileSize;

  @JsonKey(name: r'REPRE_YN')
  final String? repreYn;

  @JsonKey(name: r'DWLD_CO')
  final int? dwldCo;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDFILEUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDFILEUpdateInput implements _i1.JsonSerializable {
  const STBOARDFILEUpdateInput({
    this.seq,
    this.mseq,
    this.boardCd,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileSize,
    this.repreYn,
    this.dwldCo,
  });

  factory STBOARDFILEUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDFILEUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'MSEQ')
  final IntFieldUpdateOperationsInput? mseq;

  @JsonKey(name: r'BOARD_CD')
  final StringFieldUpdateOperationsInput? boardCd;

  @JsonKey(name: r'FILE_TP')
  final NullableStringFieldUpdateOperationsInput? fileTp;

  @JsonKey(name: r'FLPTH')
  final NullableStringFieldUpdateOperationsInput? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final NullableStringFieldUpdateOperationsInput? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final NullableStringFieldUpdateOperationsInput? streFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final NullableIntFieldUpdateOperationsInput? fileSize;

  @JsonKey(name: r'REPRE_YN')
  final NullableStringFieldUpdateOperationsInput? repreYn;

  @JsonKey(name: r'DWLD_CO')
  final NullableIntFieldUpdateOperationsInput? dwldCo;

  @override
  Map<String, dynamic> toJson() => _$STBOARDFILEUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDFILEUncheckedUpdateInput implements _i1.JsonSerializable {
  const STBOARDFILEUncheckedUpdateInput({
    this.seq,
    this.mseq,
    this.boardCd,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileSize,
    this.repreYn,
    this.dwldCo,
  });

  factory STBOARDFILEUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDFILEUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'MSEQ')
  final IntFieldUpdateOperationsInput? mseq;

  @JsonKey(name: r'BOARD_CD')
  final StringFieldUpdateOperationsInput? boardCd;

  @JsonKey(name: r'FILE_TP')
  final NullableStringFieldUpdateOperationsInput? fileTp;

  @JsonKey(name: r'FLPTH')
  final NullableStringFieldUpdateOperationsInput? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final NullableStringFieldUpdateOperationsInput? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final NullableStringFieldUpdateOperationsInput? streFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final NullableIntFieldUpdateOperationsInput? fileSize;

  @JsonKey(name: r'REPRE_YN')
  final NullableStringFieldUpdateOperationsInput? repreYn;

  @JsonKey(name: r'DWLD_CO')
  final NullableIntFieldUpdateOperationsInput? dwldCo;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDFILEUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDFILECreateManyInput implements _i1.JsonSerializable {
  const STBOARDFILECreateManyInput({
    required this.seq,
    required this.mseq,
    required this.boardCd,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileSize,
    this.repreYn,
    this.dwldCo,
  });

  factory STBOARDFILECreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDFILECreateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'MSEQ')
  final int mseq;

  @JsonKey(name: r'BOARD_CD')
  final String boardCd;

  @JsonKey(name: r'FILE_TP')
  final String? fileTp;

  @JsonKey(name: r'FLPTH')
  final String? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final String? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final String? streFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final int? fileSize;

  @JsonKey(name: r'REPRE_YN')
  final String? repreYn;

  @JsonKey(name: r'DWLD_CO')
  final int? dwldCo;

  @override
  Map<String, dynamic> toJson() => _$STBOARDFILECreateManyInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDFILEUpdateManyMutationInput implements _i1.JsonSerializable {
  const STBOARDFILEUpdateManyMutationInput({
    this.seq,
    this.mseq,
    this.boardCd,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileSize,
    this.repreYn,
    this.dwldCo,
  });

  factory STBOARDFILEUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDFILEUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'MSEQ')
  final IntFieldUpdateOperationsInput? mseq;

  @JsonKey(name: r'BOARD_CD')
  final StringFieldUpdateOperationsInput? boardCd;

  @JsonKey(name: r'FILE_TP')
  final NullableStringFieldUpdateOperationsInput? fileTp;

  @JsonKey(name: r'FLPTH')
  final NullableStringFieldUpdateOperationsInput? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final NullableStringFieldUpdateOperationsInput? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final NullableStringFieldUpdateOperationsInput? streFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final NullableIntFieldUpdateOperationsInput? fileSize;

  @JsonKey(name: r'REPRE_YN')
  final NullableStringFieldUpdateOperationsInput? repreYn;

  @JsonKey(name: r'DWLD_CO')
  final NullableIntFieldUpdateOperationsInput? dwldCo;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDFILEUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDFILEUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const STBOARDFILEUncheckedUpdateManyInput({
    this.seq,
    this.mseq,
    this.boardCd,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileSize,
    this.repreYn,
    this.dwldCo,
  });

  factory STBOARDFILEUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDFILEUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'MSEQ')
  final IntFieldUpdateOperationsInput? mseq;

  @JsonKey(name: r'BOARD_CD')
  final StringFieldUpdateOperationsInput? boardCd;

  @JsonKey(name: r'FILE_TP')
  final NullableStringFieldUpdateOperationsInput? fileTp;

  @JsonKey(name: r'FLPTH')
  final NullableStringFieldUpdateOperationsInput? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final NullableStringFieldUpdateOperationsInput? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final NullableStringFieldUpdateOperationsInput? streFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final NullableIntFieldUpdateOperationsInput? fileSize;

  @JsonKey(name: r'REPRE_YN')
  final NullableStringFieldUpdateOperationsInput? repreYn;

  @JsonKey(name: r'DWLD_CO')
  final NullableIntFieldUpdateOperationsInput? dwldCo;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDFILEUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDMSTCreateInput implements _i1.JsonSerializable {
  const STBOARDMSTCreateInput({
    required this.seq,
    required this.boardCd,
    this.clsCd,
    required this.ttl,
    required this.cnts,
    this.fileYn,
    this.imageYn,
    this.noticeYn,
    this.lkUrl,
    this.lkTarget,
    this.readCnt,
    this.regAdminYn,
    this.replyYn,
    this.upperSeq,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDMSTCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDMSTCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'BOARD_CD')
  final String boardCd;

  @JsonKey(name: r'CLS_CD')
  final String? clsCd;

  @JsonKey(name: r'TTL')
  final String ttl;

  @JsonKey(name: r'CNTS')
  final String cnts;

  @JsonKey(name: r'FILE_YN')
  final String? fileYn;

  @JsonKey(name: r'IMAGE_YN')
  final String? imageYn;

  @JsonKey(name: r'NOTICE_YN')
  final String? noticeYn;

  @JsonKey(name: r'LK_URL')
  final String? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final String? lkTarget;

  @JsonKey(name: r'READ_CNT')
  final int? readCnt;

  @JsonKey(name: r'REG_ADMIN_YN')
  final String? regAdminYn;

  @JsonKey(name: r'REPLY_YN')
  final String? replyYn;

  @JsonKey(name: r'UPPER_SEQ')
  final int? upperSeq;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STBOARDMSTCreateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDMSTUncheckedCreateInput implements _i1.JsonSerializable {
  const STBOARDMSTUncheckedCreateInput({
    required this.seq,
    required this.boardCd,
    this.clsCd,
    required this.ttl,
    required this.cnts,
    this.fileYn,
    this.imageYn,
    this.noticeYn,
    this.lkUrl,
    this.lkTarget,
    this.readCnt,
    this.regAdminYn,
    this.replyYn,
    this.upperSeq,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDMSTUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDMSTUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'BOARD_CD')
  final String boardCd;

  @JsonKey(name: r'CLS_CD')
  final String? clsCd;

  @JsonKey(name: r'TTL')
  final String ttl;

  @JsonKey(name: r'CNTS')
  final String cnts;

  @JsonKey(name: r'FILE_YN')
  final String? fileYn;

  @JsonKey(name: r'IMAGE_YN')
  final String? imageYn;

  @JsonKey(name: r'NOTICE_YN')
  final String? noticeYn;

  @JsonKey(name: r'LK_URL')
  final String? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final String? lkTarget;

  @JsonKey(name: r'READ_CNT')
  final int? readCnt;

  @JsonKey(name: r'REG_ADMIN_YN')
  final String? regAdminYn;

  @JsonKey(name: r'REPLY_YN')
  final String? replyYn;

  @JsonKey(name: r'UPPER_SEQ')
  final int? upperSeq;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STBOARDMSTUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDMSTUpdateInput implements _i1.JsonSerializable {
  const STBOARDMSTUpdateInput({
    this.seq,
    this.boardCd,
    this.clsCd,
    this.ttl,
    this.cnts,
    this.fileYn,
    this.imageYn,
    this.noticeYn,
    this.lkUrl,
    this.lkTarget,
    this.readCnt,
    this.regAdminYn,
    this.replyYn,
    this.upperSeq,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDMSTUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDMSTUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'BOARD_CD')
  final StringFieldUpdateOperationsInput? boardCd;

  @JsonKey(name: r'CLS_CD')
  final NullableStringFieldUpdateOperationsInput? clsCd;

  @JsonKey(name: r'TTL')
  final StringFieldUpdateOperationsInput? ttl;

  @JsonKey(name: r'CNTS')
  final StringFieldUpdateOperationsInput? cnts;

  @JsonKey(name: r'FILE_YN')
  final NullableStringFieldUpdateOperationsInput? fileYn;

  @JsonKey(name: r'IMAGE_YN')
  final NullableStringFieldUpdateOperationsInput? imageYn;

  @JsonKey(name: r'NOTICE_YN')
  final NullableStringFieldUpdateOperationsInput? noticeYn;

  @JsonKey(name: r'LK_URL')
  final NullableStringFieldUpdateOperationsInput? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final NullableStringFieldUpdateOperationsInput? lkTarget;

  @JsonKey(name: r'READ_CNT')
  final NullableIntFieldUpdateOperationsInput? readCnt;

  @JsonKey(name: r'REG_ADMIN_YN')
  final NullableStringFieldUpdateOperationsInput? regAdminYn;

  @JsonKey(name: r'REPLY_YN')
  final NullableStringFieldUpdateOperationsInput? replyYn;

  @JsonKey(name: r'UPPER_SEQ')
  final NullableIntFieldUpdateOperationsInput? upperSeq;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STBOARDMSTUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDMSTUncheckedUpdateInput implements _i1.JsonSerializable {
  const STBOARDMSTUncheckedUpdateInput({
    this.seq,
    this.boardCd,
    this.clsCd,
    this.ttl,
    this.cnts,
    this.fileYn,
    this.imageYn,
    this.noticeYn,
    this.lkUrl,
    this.lkTarget,
    this.readCnt,
    this.regAdminYn,
    this.replyYn,
    this.upperSeq,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDMSTUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDMSTUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'BOARD_CD')
  final StringFieldUpdateOperationsInput? boardCd;

  @JsonKey(name: r'CLS_CD')
  final NullableStringFieldUpdateOperationsInput? clsCd;

  @JsonKey(name: r'TTL')
  final StringFieldUpdateOperationsInput? ttl;

  @JsonKey(name: r'CNTS')
  final StringFieldUpdateOperationsInput? cnts;

  @JsonKey(name: r'FILE_YN')
  final NullableStringFieldUpdateOperationsInput? fileYn;

  @JsonKey(name: r'IMAGE_YN')
  final NullableStringFieldUpdateOperationsInput? imageYn;

  @JsonKey(name: r'NOTICE_YN')
  final NullableStringFieldUpdateOperationsInput? noticeYn;

  @JsonKey(name: r'LK_URL')
  final NullableStringFieldUpdateOperationsInput? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final NullableStringFieldUpdateOperationsInput? lkTarget;

  @JsonKey(name: r'READ_CNT')
  final NullableIntFieldUpdateOperationsInput? readCnt;

  @JsonKey(name: r'REG_ADMIN_YN')
  final NullableStringFieldUpdateOperationsInput? regAdminYn;

  @JsonKey(name: r'REPLY_YN')
  final NullableStringFieldUpdateOperationsInput? replyYn;

  @JsonKey(name: r'UPPER_SEQ')
  final NullableIntFieldUpdateOperationsInput? upperSeq;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STBOARDMSTUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDMSTCreateManyInput implements _i1.JsonSerializable {
  const STBOARDMSTCreateManyInput({
    required this.seq,
    required this.boardCd,
    this.clsCd,
    required this.ttl,
    required this.cnts,
    this.fileYn,
    this.imageYn,
    this.noticeYn,
    this.lkUrl,
    this.lkTarget,
    this.readCnt,
    this.regAdminYn,
    this.replyYn,
    this.upperSeq,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDMSTCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDMSTCreateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'BOARD_CD')
  final String boardCd;

  @JsonKey(name: r'CLS_CD')
  final String? clsCd;

  @JsonKey(name: r'TTL')
  final String ttl;

  @JsonKey(name: r'CNTS')
  final String cnts;

  @JsonKey(name: r'FILE_YN')
  final String? fileYn;

  @JsonKey(name: r'IMAGE_YN')
  final String? imageYn;

  @JsonKey(name: r'NOTICE_YN')
  final String? noticeYn;

  @JsonKey(name: r'LK_URL')
  final String? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final String? lkTarget;

  @JsonKey(name: r'READ_CNT')
  final int? readCnt;

  @JsonKey(name: r'REG_ADMIN_YN')
  final String? regAdminYn;

  @JsonKey(name: r'REPLY_YN')
  final String? replyYn;

  @JsonKey(name: r'UPPER_SEQ')
  final int? upperSeq;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STBOARDMSTCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDMSTUpdateManyMutationInput implements _i1.JsonSerializable {
  const STBOARDMSTUpdateManyMutationInput({
    this.seq,
    this.boardCd,
    this.clsCd,
    this.ttl,
    this.cnts,
    this.fileYn,
    this.imageYn,
    this.noticeYn,
    this.lkUrl,
    this.lkTarget,
    this.readCnt,
    this.regAdminYn,
    this.replyYn,
    this.upperSeq,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDMSTUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDMSTUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'BOARD_CD')
  final StringFieldUpdateOperationsInput? boardCd;

  @JsonKey(name: r'CLS_CD')
  final NullableStringFieldUpdateOperationsInput? clsCd;

  @JsonKey(name: r'TTL')
  final StringFieldUpdateOperationsInput? ttl;

  @JsonKey(name: r'CNTS')
  final StringFieldUpdateOperationsInput? cnts;

  @JsonKey(name: r'FILE_YN')
  final NullableStringFieldUpdateOperationsInput? fileYn;

  @JsonKey(name: r'IMAGE_YN')
  final NullableStringFieldUpdateOperationsInput? imageYn;

  @JsonKey(name: r'NOTICE_YN')
  final NullableStringFieldUpdateOperationsInput? noticeYn;

  @JsonKey(name: r'LK_URL')
  final NullableStringFieldUpdateOperationsInput? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final NullableStringFieldUpdateOperationsInput? lkTarget;

  @JsonKey(name: r'READ_CNT')
  final NullableIntFieldUpdateOperationsInput? readCnt;

  @JsonKey(name: r'REG_ADMIN_YN')
  final NullableStringFieldUpdateOperationsInput? regAdminYn;

  @JsonKey(name: r'REPLY_YN')
  final NullableStringFieldUpdateOperationsInput? replyYn;

  @JsonKey(name: r'UPPER_SEQ')
  final NullableIntFieldUpdateOperationsInput? upperSeq;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDMSTUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDMSTUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const STBOARDMSTUncheckedUpdateManyInput({
    this.seq,
    this.boardCd,
    this.clsCd,
    this.ttl,
    this.cnts,
    this.fileYn,
    this.imageYn,
    this.noticeYn,
    this.lkUrl,
    this.lkTarget,
    this.readCnt,
    this.regAdminYn,
    this.replyYn,
    this.upperSeq,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDMSTUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDMSTUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'BOARD_CD')
  final StringFieldUpdateOperationsInput? boardCd;

  @JsonKey(name: r'CLS_CD')
  final NullableStringFieldUpdateOperationsInput? clsCd;

  @JsonKey(name: r'TTL')
  final StringFieldUpdateOperationsInput? ttl;

  @JsonKey(name: r'CNTS')
  final StringFieldUpdateOperationsInput? cnts;

  @JsonKey(name: r'FILE_YN')
  final NullableStringFieldUpdateOperationsInput? fileYn;

  @JsonKey(name: r'IMAGE_YN')
  final NullableStringFieldUpdateOperationsInput? imageYn;

  @JsonKey(name: r'NOTICE_YN')
  final NullableStringFieldUpdateOperationsInput? noticeYn;

  @JsonKey(name: r'LK_URL')
  final NullableStringFieldUpdateOperationsInput? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final NullableStringFieldUpdateOperationsInput? lkTarget;

  @JsonKey(name: r'READ_CNT')
  final NullableIntFieldUpdateOperationsInput? readCnt;

  @JsonKey(name: r'REG_ADMIN_YN')
  final NullableStringFieldUpdateOperationsInput? regAdminYn;

  @JsonKey(name: r'REPLY_YN')
  final NullableStringFieldUpdateOperationsInput? replyYn;

  @JsonKey(name: r'UPPER_SEQ')
  final NullableIntFieldUpdateOperationsInput? upperSeq;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDMSTUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDSTNGCreateInput implements _i1.JsonSerializable {
  const STBOARDSTNGCreateInput({
    required this.boardCd,
    required this.boardNm,
    this.boardTy,
    this.editorYn,
    this.rlsYn,
    this.cclSeq,
    this.listCnt,
    this.writeYn,
    this.commentYn,
    this.replyYn,
    this.attachYn,
    this.attachSize,
    this.attachCnt,
    this.attachExt,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDSTNGCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDSTNGCreateInputFromJson(json);

  @JsonKey(name: r'BOARD_CD')
  final String boardCd;

  @JsonKey(name: r'BOARD_NM')
  final String boardNm;

  @JsonKey(name: r'BOARD_TY')
  final String? boardTy;

  @JsonKey(name: r'EDITOR_YN')
  final String? editorYn;

  @JsonKey(name: r'RLS_YN')
  final String? rlsYn;

  @JsonKey(name: r'CCL_SEQ')
  final int? cclSeq;

  @JsonKey(name: r'LIST_CNT')
  final int? listCnt;

  @JsonKey(name: r'WRITE_YN')
  final String? writeYn;

  @JsonKey(name: r'COMMENT_YN')
  final String? commentYn;

  @JsonKey(name: r'REPLY_YN')
  final String? replyYn;

  @JsonKey(name: r'ATTACH_YN')
  final String? attachYn;

  @JsonKey(name: r'ATTACH_SIZE')
  final String? attachSize;

  @JsonKey(name: r'ATTACH_CNT')
  final String? attachCnt;

  @JsonKey(name: r'ATTACH_EXT')
  final String? attachExt;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STBOARDSTNGCreateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDSTNGUncheckedCreateInput implements _i1.JsonSerializable {
  const STBOARDSTNGUncheckedCreateInput({
    required this.boardCd,
    required this.boardNm,
    this.boardTy,
    this.editorYn,
    this.rlsYn,
    this.cclSeq,
    this.listCnt,
    this.writeYn,
    this.commentYn,
    this.replyYn,
    this.attachYn,
    this.attachSize,
    this.attachCnt,
    this.attachExt,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDSTNGUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDSTNGUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'BOARD_CD')
  final String boardCd;

  @JsonKey(name: r'BOARD_NM')
  final String boardNm;

  @JsonKey(name: r'BOARD_TY')
  final String? boardTy;

  @JsonKey(name: r'EDITOR_YN')
  final String? editorYn;

  @JsonKey(name: r'RLS_YN')
  final String? rlsYn;

  @JsonKey(name: r'CCL_SEQ')
  final int? cclSeq;

  @JsonKey(name: r'LIST_CNT')
  final int? listCnt;

  @JsonKey(name: r'WRITE_YN')
  final String? writeYn;

  @JsonKey(name: r'COMMENT_YN')
  final String? commentYn;

  @JsonKey(name: r'REPLY_YN')
  final String? replyYn;

  @JsonKey(name: r'ATTACH_YN')
  final String? attachYn;

  @JsonKey(name: r'ATTACH_SIZE')
  final String? attachSize;

  @JsonKey(name: r'ATTACH_CNT')
  final String? attachCnt;

  @JsonKey(name: r'ATTACH_EXT')
  final String? attachExt;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDSTNGUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDSTNGUpdateInput implements _i1.JsonSerializable {
  const STBOARDSTNGUpdateInput({
    this.boardCd,
    this.boardNm,
    this.boardTy,
    this.editorYn,
    this.rlsYn,
    this.cclSeq,
    this.listCnt,
    this.writeYn,
    this.commentYn,
    this.replyYn,
    this.attachYn,
    this.attachSize,
    this.attachCnt,
    this.attachExt,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDSTNGUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDSTNGUpdateInputFromJson(json);

  @JsonKey(name: r'BOARD_CD')
  final StringFieldUpdateOperationsInput? boardCd;

  @JsonKey(name: r'BOARD_NM')
  final StringFieldUpdateOperationsInput? boardNm;

  @JsonKey(name: r'BOARD_TY')
  final StringFieldUpdateOperationsInput? boardTy;

  @JsonKey(name: r'EDITOR_YN')
  final StringFieldUpdateOperationsInput? editorYn;

  @JsonKey(name: r'RLS_YN')
  final StringFieldUpdateOperationsInput? rlsYn;

  @JsonKey(name: r'CCL_SEQ')
  final NullableIntFieldUpdateOperationsInput? cclSeq;

  @JsonKey(name: r'LIST_CNT')
  final NullableIntFieldUpdateOperationsInput? listCnt;

  @JsonKey(name: r'WRITE_YN')
  final NullableStringFieldUpdateOperationsInput? writeYn;

  @JsonKey(name: r'COMMENT_YN')
  final NullableStringFieldUpdateOperationsInput? commentYn;

  @JsonKey(name: r'REPLY_YN')
  final NullableStringFieldUpdateOperationsInput? replyYn;

  @JsonKey(name: r'ATTACH_YN')
  final NullableStringFieldUpdateOperationsInput? attachYn;

  @JsonKey(name: r'ATTACH_SIZE')
  final NullableStringFieldUpdateOperationsInput? attachSize;

  @JsonKey(name: r'ATTACH_CNT')
  final NullableStringFieldUpdateOperationsInput? attachCnt;

  @JsonKey(name: r'ATTACH_EXT')
  final NullableStringFieldUpdateOperationsInput? attachExt;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STBOARDSTNGUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDSTNGUncheckedUpdateInput implements _i1.JsonSerializable {
  const STBOARDSTNGUncheckedUpdateInput({
    this.boardCd,
    this.boardNm,
    this.boardTy,
    this.editorYn,
    this.rlsYn,
    this.cclSeq,
    this.listCnt,
    this.writeYn,
    this.commentYn,
    this.replyYn,
    this.attachYn,
    this.attachSize,
    this.attachCnt,
    this.attachExt,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDSTNGUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDSTNGUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'BOARD_CD')
  final StringFieldUpdateOperationsInput? boardCd;

  @JsonKey(name: r'BOARD_NM')
  final StringFieldUpdateOperationsInput? boardNm;

  @JsonKey(name: r'BOARD_TY')
  final StringFieldUpdateOperationsInput? boardTy;

  @JsonKey(name: r'EDITOR_YN')
  final StringFieldUpdateOperationsInput? editorYn;

  @JsonKey(name: r'RLS_YN')
  final StringFieldUpdateOperationsInput? rlsYn;

  @JsonKey(name: r'CCL_SEQ')
  final NullableIntFieldUpdateOperationsInput? cclSeq;

  @JsonKey(name: r'LIST_CNT')
  final NullableIntFieldUpdateOperationsInput? listCnt;

  @JsonKey(name: r'WRITE_YN')
  final NullableStringFieldUpdateOperationsInput? writeYn;

  @JsonKey(name: r'COMMENT_YN')
  final NullableStringFieldUpdateOperationsInput? commentYn;

  @JsonKey(name: r'REPLY_YN')
  final NullableStringFieldUpdateOperationsInput? replyYn;

  @JsonKey(name: r'ATTACH_YN')
  final NullableStringFieldUpdateOperationsInput? attachYn;

  @JsonKey(name: r'ATTACH_SIZE')
  final NullableStringFieldUpdateOperationsInput? attachSize;

  @JsonKey(name: r'ATTACH_CNT')
  final NullableStringFieldUpdateOperationsInput? attachCnt;

  @JsonKey(name: r'ATTACH_EXT')
  final NullableStringFieldUpdateOperationsInput? attachExt;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDSTNGUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDSTNGCreateManyInput implements _i1.JsonSerializable {
  const STBOARDSTNGCreateManyInput({
    required this.boardCd,
    required this.boardNm,
    this.boardTy,
    this.editorYn,
    this.rlsYn,
    this.cclSeq,
    this.listCnt,
    this.writeYn,
    this.commentYn,
    this.replyYn,
    this.attachYn,
    this.attachSize,
    this.attachCnt,
    this.attachExt,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDSTNGCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STBOARDSTNGCreateManyInputFromJson(json);

  @JsonKey(name: r'BOARD_CD')
  final String boardCd;

  @JsonKey(name: r'BOARD_NM')
  final String boardNm;

  @JsonKey(name: r'BOARD_TY')
  final String? boardTy;

  @JsonKey(name: r'EDITOR_YN')
  final String? editorYn;

  @JsonKey(name: r'RLS_YN')
  final String? rlsYn;

  @JsonKey(name: r'CCL_SEQ')
  final int? cclSeq;

  @JsonKey(name: r'LIST_CNT')
  final int? listCnt;

  @JsonKey(name: r'WRITE_YN')
  final String? writeYn;

  @JsonKey(name: r'COMMENT_YN')
  final String? commentYn;

  @JsonKey(name: r'REPLY_YN')
  final String? replyYn;

  @JsonKey(name: r'ATTACH_YN')
  final String? attachYn;

  @JsonKey(name: r'ATTACH_SIZE')
  final String? attachSize;

  @JsonKey(name: r'ATTACH_CNT')
  final String? attachCnt;

  @JsonKey(name: r'ATTACH_EXT')
  final String? attachExt;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STBOARDSTNGCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDSTNGUpdateManyMutationInput implements _i1.JsonSerializable {
  const STBOARDSTNGUpdateManyMutationInput({
    this.boardCd,
    this.boardNm,
    this.boardTy,
    this.editorYn,
    this.rlsYn,
    this.cclSeq,
    this.listCnt,
    this.writeYn,
    this.commentYn,
    this.replyYn,
    this.attachYn,
    this.attachSize,
    this.attachCnt,
    this.attachExt,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDSTNGUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDSTNGUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'BOARD_CD')
  final StringFieldUpdateOperationsInput? boardCd;

  @JsonKey(name: r'BOARD_NM')
  final StringFieldUpdateOperationsInput? boardNm;

  @JsonKey(name: r'BOARD_TY')
  final StringFieldUpdateOperationsInput? boardTy;

  @JsonKey(name: r'EDITOR_YN')
  final StringFieldUpdateOperationsInput? editorYn;

  @JsonKey(name: r'RLS_YN')
  final StringFieldUpdateOperationsInput? rlsYn;

  @JsonKey(name: r'CCL_SEQ')
  final NullableIntFieldUpdateOperationsInput? cclSeq;

  @JsonKey(name: r'LIST_CNT')
  final NullableIntFieldUpdateOperationsInput? listCnt;

  @JsonKey(name: r'WRITE_YN')
  final NullableStringFieldUpdateOperationsInput? writeYn;

  @JsonKey(name: r'COMMENT_YN')
  final NullableStringFieldUpdateOperationsInput? commentYn;

  @JsonKey(name: r'REPLY_YN')
  final NullableStringFieldUpdateOperationsInput? replyYn;

  @JsonKey(name: r'ATTACH_YN')
  final NullableStringFieldUpdateOperationsInput? attachYn;

  @JsonKey(name: r'ATTACH_SIZE')
  final NullableStringFieldUpdateOperationsInput? attachSize;

  @JsonKey(name: r'ATTACH_CNT')
  final NullableStringFieldUpdateOperationsInput? attachCnt;

  @JsonKey(name: r'ATTACH_EXT')
  final NullableStringFieldUpdateOperationsInput? attachExt;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDSTNGUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDSTNGUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const STBOARDSTNGUncheckedUpdateManyInput({
    this.boardCd,
    this.boardNm,
    this.boardTy,
    this.editorYn,
    this.rlsYn,
    this.cclSeq,
    this.listCnt,
    this.writeYn,
    this.commentYn,
    this.replyYn,
    this.attachYn,
    this.attachSize,
    this.attachCnt,
    this.attachExt,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDSTNGUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDSTNGUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'BOARD_CD')
  final StringFieldUpdateOperationsInput? boardCd;

  @JsonKey(name: r'BOARD_NM')
  final StringFieldUpdateOperationsInput? boardNm;

  @JsonKey(name: r'BOARD_TY')
  final StringFieldUpdateOperationsInput? boardTy;

  @JsonKey(name: r'EDITOR_YN')
  final StringFieldUpdateOperationsInput? editorYn;

  @JsonKey(name: r'RLS_YN')
  final StringFieldUpdateOperationsInput? rlsYn;

  @JsonKey(name: r'CCL_SEQ')
  final NullableIntFieldUpdateOperationsInput? cclSeq;

  @JsonKey(name: r'LIST_CNT')
  final NullableIntFieldUpdateOperationsInput? listCnt;

  @JsonKey(name: r'WRITE_YN')
  final NullableStringFieldUpdateOperationsInput? writeYn;

  @JsonKey(name: r'COMMENT_YN')
  final NullableStringFieldUpdateOperationsInput? commentYn;

  @JsonKey(name: r'REPLY_YN')
  final NullableStringFieldUpdateOperationsInput? replyYn;

  @JsonKey(name: r'ATTACH_YN')
  final NullableStringFieldUpdateOperationsInput? attachYn;

  @JsonKey(name: r'ATTACH_SIZE')
  final NullableStringFieldUpdateOperationsInput? attachSize;

  @JsonKey(name: r'ATTACH_CNT')
  final NullableStringFieldUpdateOperationsInput? attachCnt;

  @JsonKey(name: r'ATTACH_EXT')
  final NullableStringFieldUpdateOperationsInput? attachExt;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDSTNGUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class STCCLCreateInput implements _i1.JsonSerializable {
  const STCCLCreateInput({
    required this.seq,
    required this.cclType,
    required this.cclNm,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileExtsn,
    this.fileSize,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCCLCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STCCLCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'CCL_TYPE')
  final String cclType;

  @JsonKey(name: r'CCL_NM')
  final String cclNm;

  @JsonKey(name: r'FLPTH')
  final String? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final String? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final String? streFileNm;

  @JsonKey(name: r'FILE_EXTSN')
  final String? fileExtsn;

  @JsonKey(name: r'FILE_SIZE')
  final int? fileSize;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STCCLCreateInputToJson(this);
}

@_i1.jsonSerializable
class STCCLUncheckedCreateInput implements _i1.JsonSerializable {
  const STCCLUncheckedCreateInput({
    required this.seq,
    required this.cclType,
    required this.cclNm,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileExtsn,
    this.fileSize,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCCLUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STCCLUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'CCL_TYPE')
  final String cclType;

  @JsonKey(name: r'CCL_NM')
  final String cclNm;

  @JsonKey(name: r'FLPTH')
  final String? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final String? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final String? streFileNm;

  @JsonKey(name: r'FILE_EXTSN')
  final String? fileExtsn;

  @JsonKey(name: r'FILE_SIZE')
  final int? fileSize;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STCCLUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class STCCLUpdateInput implements _i1.JsonSerializable {
  const STCCLUpdateInput({
    this.seq,
    this.cclType,
    this.cclNm,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileExtsn,
    this.fileSize,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCCLUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STCCLUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'CCL_TYPE')
  final StringFieldUpdateOperationsInput? cclType;

  @JsonKey(name: r'CCL_NM')
  final StringFieldUpdateOperationsInput? cclNm;

  @JsonKey(name: r'FLPTH')
  final NullableStringFieldUpdateOperationsInput? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final NullableStringFieldUpdateOperationsInput? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final NullableStringFieldUpdateOperationsInput? streFileNm;

  @JsonKey(name: r'FILE_EXTSN')
  final NullableStringFieldUpdateOperationsInput? fileExtsn;

  @JsonKey(name: r'FILE_SIZE')
  final NullableIntFieldUpdateOperationsInput? fileSize;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STCCLUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STCCLUncheckedUpdateInput implements _i1.JsonSerializable {
  const STCCLUncheckedUpdateInput({
    this.seq,
    this.cclType,
    this.cclNm,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileExtsn,
    this.fileSize,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCCLUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STCCLUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'CCL_TYPE')
  final StringFieldUpdateOperationsInput? cclType;

  @JsonKey(name: r'CCL_NM')
  final StringFieldUpdateOperationsInput? cclNm;

  @JsonKey(name: r'FLPTH')
  final NullableStringFieldUpdateOperationsInput? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final NullableStringFieldUpdateOperationsInput? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final NullableStringFieldUpdateOperationsInput? streFileNm;

  @JsonKey(name: r'FILE_EXTSN')
  final NullableStringFieldUpdateOperationsInput? fileExtsn;

  @JsonKey(name: r'FILE_SIZE')
  final NullableIntFieldUpdateOperationsInput? fileSize;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STCCLUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STCCLCreateManyInput implements _i1.JsonSerializable {
  const STCCLCreateManyInput({
    required this.seq,
    required this.cclType,
    required this.cclNm,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileExtsn,
    this.fileSize,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCCLCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STCCLCreateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'CCL_TYPE')
  final String cclType;

  @JsonKey(name: r'CCL_NM')
  final String cclNm;

  @JsonKey(name: r'FLPTH')
  final String? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final String? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final String? streFileNm;

  @JsonKey(name: r'FILE_EXTSN')
  final String? fileExtsn;

  @JsonKey(name: r'FILE_SIZE')
  final int? fileSize;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STCCLCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class STCCLUpdateManyMutationInput implements _i1.JsonSerializable {
  const STCCLUpdateManyMutationInput({
    this.seq,
    this.cclType,
    this.cclNm,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileExtsn,
    this.fileSize,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCCLUpdateManyMutationInput.fromJson(Map<String, dynamic> json) =>
      _$STCCLUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'CCL_TYPE')
  final StringFieldUpdateOperationsInput? cclType;

  @JsonKey(name: r'CCL_NM')
  final StringFieldUpdateOperationsInput? cclNm;

  @JsonKey(name: r'FLPTH')
  final NullableStringFieldUpdateOperationsInput? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final NullableStringFieldUpdateOperationsInput? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final NullableStringFieldUpdateOperationsInput? streFileNm;

  @JsonKey(name: r'FILE_EXTSN')
  final NullableStringFieldUpdateOperationsInput? fileExtsn;

  @JsonKey(name: r'FILE_SIZE')
  final NullableIntFieldUpdateOperationsInput? fileSize;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STCCLUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class STCCLUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const STCCLUncheckedUpdateManyInput({
    this.seq,
    this.cclType,
    this.cclNm,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileExtsn,
    this.fileSize,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCCLUncheckedUpdateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STCCLUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'CCL_TYPE')
  final StringFieldUpdateOperationsInput? cclType;

  @JsonKey(name: r'CCL_NM')
  final StringFieldUpdateOperationsInput? cclNm;

  @JsonKey(name: r'FLPTH')
  final NullableStringFieldUpdateOperationsInput? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final NullableStringFieldUpdateOperationsInput? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final NullableStringFieldUpdateOperationsInput? streFileNm;

  @JsonKey(name: r'FILE_EXTSN')
  final NullableStringFieldUpdateOperationsInput? fileExtsn;

  @JsonKey(name: r'FILE_SIZE')
  final NullableIntFieldUpdateOperationsInput? fileSize;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STCCLUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class STCODEMSTCreateInput implements _i1.JsonSerializable {
  const STCODEMSTCreateInput({
    required this.cdGrp,
    required this.cdKey,
    required this.cdVal,
    this.cdDesc,
    required this.cdSrt,
    this.depth,
    required this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCODEMSTCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STCODEMSTCreateInputFromJson(json);

  @JsonKey(name: r'CD_GRP')
  final String cdGrp;

  @JsonKey(name: r'CD_KEY')
  final String cdKey;

  @JsonKey(name: r'CD_VAL')
  final String cdVal;

  @JsonKey(name: r'CD_DESC')
  final String? cdDesc;

  @JsonKey(name: r'CD_SRT')
  final int cdSrt;

  @JsonKey(name: r'DEPTH')
  final int? depth;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STCODEMSTCreateInputToJson(this);
}

@_i1.jsonSerializable
class STCODEMSTUncheckedCreateInput implements _i1.JsonSerializable {
  const STCODEMSTUncheckedCreateInput({
    required this.cdGrp,
    required this.cdKey,
    required this.cdVal,
    this.cdDesc,
    required this.cdSrt,
    this.depth,
    required this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCODEMSTUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STCODEMSTUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'CD_GRP')
  final String cdGrp;

  @JsonKey(name: r'CD_KEY')
  final String cdKey;

  @JsonKey(name: r'CD_VAL')
  final String cdVal;

  @JsonKey(name: r'CD_DESC')
  final String? cdDesc;

  @JsonKey(name: r'CD_SRT')
  final int cdSrt;

  @JsonKey(name: r'DEPTH')
  final int? depth;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STCODEMSTUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class STCODEMSTUpdateInput implements _i1.JsonSerializable {
  const STCODEMSTUpdateInput({
    this.cdGrp,
    this.cdKey,
    this.cdVal,
    this.cdDesc,
    this.cdSrt,
    this.depth,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCODEMSTUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STCODEMSTUpdateInputFromJson(json);

  @JsonKey(name: r'CD_GRP')
  final StringFieldUpdateOperationsInput? cdGrp;

  @JsonKey(name: r'CD_KEY')
  final StringFieldUpdateOperationsInput? cdKey;

  @JsonKey(name: r'CD_VAL')
  final StringFieldUpdateOperationsInput? cdVal;

  @JsonKey(name: r'CD_DESC')
  final NullableStringFieldUpdateOperationsInput? cdDesc;

  @JsonKey(name: r'CD_SRT')
  final IntFieldUpdateOperationsInput? cdSrt;

  @JsonKey(name: r'DEPTH')
  final NullableIntFieldUpdateOperationsInput? depth;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STCODEMSTUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STCODEMSTUncheckedUpdateInput implements _i1.JsonSerializable {
  const STCODEMSTUncheckedUpdateInput({
    this.cdGrp,
    this.cdKey,
    this.cdVal,
    this.cdDesc,
    this.cdSrt,
    this.depth,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCODEMSTUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STCODEMSTUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'CD_GRP')
  final StringFieldUpdateOperationsInput? cdGrp;

  @JsonKey(name: r'CD_KEY')
  final StringFieldUpdateOperationsInput? cdKey;

  @JsonKey(name: r'CD_VAL')
  final StringFieldUpdateOperationsInput? cdVal;

  @JsonKey(name: r'CD_DESC')
  final NullableStringFieldUpdateOperationsInput? cdDesc;

  @JsonKey(name: r'CD_SRT')
  final IntFieldUpdateOperationsInput? cdSrt;

  @JsonKey(name: r'DEPTH')
  final NullableIntFieldUpdateOperationsInput? depth;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STCODEMSTUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STCODEMSTCreateManyInput implements _i1.JsonSerializable {
  const STCODEMSTCreateManyInput({
    required this.cdGrp,
    required this.cdKey,
    required this.cdVal,
    this.cdDesc,
    required this.cdSrt,
    this.depth,
    required this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCODEMSTCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STCODEMSTCreateManyInputFromJson(json);

  @JsonKey(name: r'CD_GRP')
  final String cdGrp;

  @JsonKey(name: r'CD_KEY')
  final String cdKey;

  @JsonKey(name: r'CD_VAL')
  final String cdVal;

  @JsonKey(name: r'CD_DESC')
  final String? cdDesc;

  @JsonKey(name: r'CD_SRT')
  final int cdSrt;

  @JsonKey(name: r'DEPTH')
  final int? depth;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STCODEMSTCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class STCODEMSTUpdateManyMutationInput implements _i1.JsonSerializable {
  const STCODEMSTUpdateManyMutationInput({
    this.cdGrp,
    this.cdKey,
    this.cdVal,
    this.cdDesc,
    this.cdSrt,
    this.depth,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCODEMSTUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCODEMSTUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'CD_GRP')
  final StringFieldUpdateOperationsInput? cdGrp;

  @JsonKey(name: r'CD_KEY')
  final StringFieldUpdateOperationsInput? cdKey;

  @JsonKey(name: r'CD_VAL')
  final StringFieldUpdateOperationsInput? cdVal;

  @JsonKey(name: r'CD_DESC')
  final NullableStringFieldUpdateOperationsInput? cdDesc;

  @JsonKey(name: r'CD_SRT')
  final IntFieldUpdateOperationsInput? cdSrt;

  @JsonKey(name: r'DEPTH')
  final NullableIntFieldUpdateOperationsInput? depth;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STCODEMSTUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class STCODEMSTUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const STCODEMSTUncheckedUpdateManyInput({
    this.cdGrp,
    this.cdKey,
    this.cdVal,
    this.cdDesc,
    this.cdSrt,
    this.depth,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCODEMSTUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCODEMSTUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'CD_GRP')
  final StringFieldUpdateOperationsInput? cdGrp;

  @JsonKey(name: r'CD_KEY')
  final StringFieldUpdateOperationsInput? cdKey;

  @JsonKey(name: r'CD_VAL')
  final StringFieldUpdateOperationsInput? cdVal;

  @JsonKey(name: r'CD_DESC')
  final NullableStringFieldUpdateOperationsInput? cdDesc;

  @JsonKey(name: r'CD_SRT')
  final IntFieldUpdateOperationsInput? cdSrt;

  @JsonKey(name: r'DEPTH')
  final NullableIntFieldUpdateOperationsInput? depth;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STCODEMSTUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class STCONNECTLOGCreateInput implements _i1.JsonSerializable {
  const STCONNECTLOGCreateInput({
    required this.seq,
    required this.userId,
    this.connType,
    this.osType,
    this.browserType,
    this.conneIp,
    this.regDate,
  });

  factory STCONNECTLOGCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STCONNECTLOGCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'CONN_TYPE')
  final String? connType;

  @JsonKey(name: r'OS_TYPE')
  final String? osType;

  @JsonKey(name: r'BROWSER_TYPE')
  final String? browserType;

  @JsonKey(name: r'CONNE_IP')
  final String? conneIp;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @override
  Map<String, dynamic> toJson() => _$STCONNECTLOGCreateInputToJson(this);
}

@_i1.jsonSerializable
class STCONNECTLOGUncheckedCreateInput implements _i1.JsonSerializable {
  const STCONNECTLOGUncheckedCreateInput({
    required this.seq,
    required this.userId,
    this.connType,
    this.osType,
    this.browserType,
    this.conneIp,
    this.regDate,
  });

  factory STCONNECTLOGUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONNECTLOGUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'CONN_TYPE')
  final String? connType;

  @JsonKey(name: r'OS_TYPE')
  final String? osType;

  @JsonKey(name: r'BROWSER_TYPE')
  final String? browserType;

  @JsonKey(name: r'CONNE_IP')
  final String? conneIp;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONNECTLOGUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class STCONNECTLOGUpdateInput implements _i1.JsonSerializable {
  const STCONNECTLOGUpdateInput({
    this.seq,
    this.userId,
    this.connType,
    this.osType,
    this.browserType,
    this.conneIp,
    this.regDate,
  });

  factory STCONNECTLOGUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STCONNECTLOGUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'CONN_TYPE')
  final NullableStringFieldUpdateOperationsInput? connType;

  @JsonKey(name: r'OS_TYPE')
  final NullableStringFieldUpdateOperationsInput? osType;

  @JsonKey(name: r'BROWSER_TYPE')
  final NullableStringFieldUpdateOperationsInput? browserType;

  @JsonKey(name: r'CONNE_IP')
  final NullableStringFieldUpdateOperationsInput? conneIp;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @override
  Map<String, dynamic> toJson() => _$STCONNECTLOGUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STCONNECTLOGUncheckedUpdateInput implements _i1.JsonSerializable {
  const STCONNECTLOGUncheckedUpdateInput({
    this.seq,
    this.userId,
    this.connType,
    this.osType,
    this.browserType,
    this.conneIp,
    this.regDate,
  });

  factory STCONNECTLOGUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONNECTLOGUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'CONN_TYPE')
  final NullableStringFieldUpdateOperationsInput? connType;

  @JsonKey(name: r'OS_TYPE')
  final NullableStringFieldUpdateOperationsInput? osType;

  @JsonKey(name: r'BROWSER_TYPE')
  final NullableStringFieldUpdateOperationsInput? browserType;

  @JsonKey(name: r'CONNE_IP')
  final NullableStringFieldUpdateOperationsInput? conneIp;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONNECTLOGUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STCONNECTLOGCreateManyInput implements _i1.JsonSerializable {
  const STCONNECTLOGCreateManyInput({
    required this.seq,
    required this.userId,
    this.connType,
    this.osType,
    this.browserType,
    this.conneIp,
    this.regDate,
  });

  factory STCONNECTLOGCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STCONNECTLOGCreateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'CONN_TYPE')
  final String? connType;

  @JsonKey(name: r'OS_TYPE')
  final String? osType;

  @JsonKey(name: r'BROWSER_TYPE')
  final String? browserType;

  @JsonKey(name: r'CONNE_IP')
  final String? conneIp;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @override
  Map<String, dynamic> toJson() => _$STCONNECTLOGCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class STCONNECTLOGUpdateManyMutationInput implements _i1.JsonSerializable {
  const STCONNECTLOGUpdateManyMutationInput({
    this.seq,
    this.userId,
    this.connType,
    this.osType,
    this.browserType,
    this.conneIp,
    this.regDate,
  });

  factory STCONNECTLOGUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONNECTLOGUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'CONN_TYPE')
  final NullableStringFieldUpdateOperationsInput? connType;

  @JsonKey(name: r'OS_TYPE')
  final NullableStringFieldUpdateOperationsInput? osType;

  @JsonKey(name: r'BROWSER_TYPE')
  final NullableStringFieldUpdateOperationsInput? browserType;

  @JsonKey(name: r'CONNE_IP')
  final NullableStringFieldUpdateOperationsInput? conneIp;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONNECTLOGUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class STCONNECTLOGUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const STCONNECTLOGUncheckedUpdateManyInput({
    this.seq,
    this.userId,
    this.connType,
    this.osType,
    this.browserType,
    this.conneIp,
    this.regDate,
  });

  factory STCONNECTLOGUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONNECTLOGUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'CONN_TYPE')
  final NullableStringFieldUpdateOperationsInput? connType;

  @JsonKey(name: r'OS_TYPE')
  final NullableStringFieldUpdateOperationsInput? osType;

  @JsonKey(name: r'BROWSER_TYPE')
  final NullableStringFieldUpdateOperationsInput? browserType;

  @JsonKey(name: r'CONNE_IP')
  final NullableStringFieldUpdateOperationsInput? conneIp;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONNECTLOGUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSFILECreateInput implements _i1.JsonSerializable {
  const STCONTENTSFILECreateInput({
    required this.mseq,
    this.fileTp,
    required this.flpth,
    required this.orginalFileNm,
    required this.streFileNm,
    required this.fileSize,
  });

  factory STCONTENTSFILECreateInput.fromJson(Map<String, dynamic> json) =>
      _$STCONTENTSFILECreateInputFromJson(json);

  @JsonKey(name: r'MSEQ')
  final String mseq;

  @JsonKey(name: r'FILE_TP')
  final String? fileTp;

  @JsonKey(name: r'FLPTH')
  final String flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final String orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final String streFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final int fileSize;

  @override
  Map<String, dynamic> toJson() => _$STCONTENTSFILECreateInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSFILEUncheckedCreateInput implements _i1.JsonSerializable {
  const STCONTENTSFILEUncheckedCreateInput({
    this.seq,
    required this.mseq,
    this.fileTp,
    required this.flpth,
    required this.orginalFileNm,
    required this.streFileNm,
    required this.fileSize,
  });

  factory STCONTENTSFILEUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONTENTSFILEUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int? seq;

  @JsonKey(name: r'MSEQ')
  final String mseq;

  @JsonKey(name: r'FILE_TP')
  final String? fileTp;

  @JsonKey(name: r'FLPTH')
  final String flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final String orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final String streFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final int fileSize;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONTENTSFILEUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSFILEUpdateInput implements _i1.JsonSerializable {
  const STCONTENTSFILEUpdateInput({
    this.mseq,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileSize,
  });

  factory STCONTENTSFILEUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STCONTENTSFILEUpdateInputFromJson(json);

  @JsonKey(name: r'MSEQ')
  final StringFieldUpdateOperationsInput? mseq;

  @JsonKey(name: r'FILE_TP')
  final NullableStringFieldUpdateOperationsInput? fileTp;

  @JsonKey(name: r'FLPTH')
  final StringFieldUpdateOperationsInput? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final StringFieldUpdateOperationsInput? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final StringFieldUpdateOperationsInput? streFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final IntFieldUpdateOperationsInput? fileSize;

  @override
  Map<String, dynamic> toJson() => _$STCONTENTSFILEUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSFILEUncheckedUpdateInput implements _i1.JsonSerializable {
  const STCONTENTSFILEUncheckedUpdateInput({
    this.seq,
    this.mseq,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileSize,
  });

  factory STCONTENTSFILEUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONTENTSFILEUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'MSEQ')
  final StringFieldUpdateOperationsInput? mseq;

  @JsonKey(name: r'FILE_TP')
  final NullableStringFieldUpdateOperationsInput? fileTp;

  @JsonKey(name: r'FLPTH')
  final StringFieldUpdateOperationsInput? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final StringFieldUpdateOperationsInput? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final StringFieldUpdateOperationsInput? streFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final IntFieldUpdateOperationsInput? fileSize;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONTENTSFILEUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSFILECreateManyInput implements _i1.JsonSerializable {
  const STCONTENTSFILECreateManyInput({
    this.seq,
    required this.mseq,
    this.fileTp,
    required this.flpth,
    required this.orginalFileNm,
    required this.streFileNm,
    required this.fileSize,
  });

  factory STCONTENTSFILECreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STCONTENTSFILECreateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int? seq;

  @JsonKey(name: r'MSEQ')
  final String mseq;

  @JsonKey(name: r'FILE_TP')
  final String? fileTp;

  @JsonKey(name: r'FLPTH')
  final String flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final String orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final String streFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final int fileSize;

  @override
  Map<String, dynamic> toJson() => _$STCONTENTSFILECreateManyInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSFILEUpdateManyMutationInput implements _i1.JsonSerializable {
  const STCONTENTSFILEUpdateManyMutationInput({
    this.mseq,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileSize,
  });

  factory STCONTENTSFILEUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONTENTSFILEUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'MSEQ')
  final StringFieldUpdateOperationsInput? mseq;

  @JsonKey(name: r'FILE_TP')
  final NullableStringFieldUpdateOperationsInput? fileTp;

  @JsonKey(name: r'FLPTH')
  final StringFieldUpdateOperationsInput? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final StringFieldUpdateOperationsInput? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final StringFieldUpdateOperationsInput? streFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final IntFieldUpdateOperationsInput? fileSize;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONTENTSFILEUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSFILEUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const STCONTENTSFILEUncheckedUpdateManyInput({
    this.seq,
    this.mseq,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileSize,
  });

  factory STCONTENTSFILEUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONTENTSFILEUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'MSEQ')
  final StringFieldUpdateOperationsInput? mseq;

  @JsonKey(name: r'FILE_TP')
  final NullableStringFieldUpdateOperationsInput? fileTp;

  @JsonKey(name: r'FLPTH')
  final StringFieldUpdateOperationsInput? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final StringFieldUpdateOperationsInput? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final StringFieldUpdateOperationsInput? streFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final IntFieldUpdateOperationsInput? fileSize;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONTENTSFILEUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSMSTCreateInput implements _i1.JsonSerializable {
  const STCONTENTSMSTCreateInput({
    required this.seq,
    required this.cntsNm,
    this.pubDate,
    this.pubState,
    this.cn,
    this.srchYn,
    this.fileYn,
    this.imageYn,
    required this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCONTENTSMSTCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STCONTENTSMSTCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'CNTS_NM')
  final String cntsNm;

  @JsonKey(name: r'PUB_DATE')
  final String? pubDate;

  @JsonKey(name: r'PUB_STATE')
  final String? pubState;

  @JsonKey(name: r'CN')
  final String? cn;

  @JsonKey(name: r'SRCH_YN')
  final String? srchYn;

  @JsonKey(name: r'FILE_YN')
  final String? fileYn;

  @JsonKey(name: r'IMAGE_YN')
  final String? imageYn;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STCONTENTSMSTCreateInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSMSTUncheckedCreateInput implements _i1.JsonSerializable {
  const STCONTENTSMSTUncheckedCreateInput({
    required this.seq,
    required this.cntsNm,
    this.pubDate,
    this.pubState,
    this.cn,
    this.srchYn,
    this.fileYn,
    this.imageYn,
    required this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCONTENTSMSTUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONTENTSMSTUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'CNTS_NM')
  final String cntsNm;

  @JsonKey(name: r'PUB_DATE')
  final String? pubDate;

  @JsonKey(name: r'PUB_STATE')
  final String? pubState;

  @JsonKey(name: r'CN')
  final String? cn;

  @JsonKey(name: r'SRCH_YN')
  final String? srchYn;

  @JsonKey(name: r'FILE_YN')
  final String? fileYn;

  @JsonKey(name: r'IMAGE_YN')
  final String? imageYn;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONTENTSMSTUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSMSTUpdateInput implements _i1.JsonSerializable {
  const STCONTENTSMSTUpdateInput({
    this.seq,
    this.cntsNm,
    this.pubDate,
    this.pubState,
    this.cn,
    this.srchYn,
    this.fileYn,
    this.imageYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCONTENTSMSTUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STCONTENTSMSTUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'CNTS_NM')
  final StringFieldUpdateOperationsInput? cntsNm;

  @JsonKey(name: r'PUB_DATE')
  final NullableStringFieldUpdateOperationsInput? pubDate;

  @JsonKey(name: r'PUB_STATE')
  final NullableStringFieldUpdateOperationsInput? pubState;

  @JsonKey(name: r'CN')
  final NullableStringFieldUpdateOperationsInput? cn;

  @JsonKey(name: r'SRCH_YN')
  final NullableStringFieldUpdateOperationsInput? srchYn;

  @JsonKey(name: r'FILE_YN')
  final NullableStringFieldUpdateOperationsInput? fileYn;

  @JsonKey(name: r'IMAGE_YN')
  final NullableStringFieldUpdateOperationsInput? imageYn;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STCONTENTSMSTUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSMSTUncheckedUpdateInput implements _i1.JsonSerializable {
  const STCONTENTSMSTUncheckedUpdateInput({
    this.seq,
    this.cntsNm,
    this.pubDate,
    this.pubState,
    this.cn,
    this.srchYn,
    this.fileYn,
    this.imageYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCONTENTSMSTUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONTENTSMSTUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'CNTS_NM')
  final StringFieldUpdateOperationsInput? cntsNm;

  @JsonKey(name: r'PUB_DATE')
  final NullableStringFieldUpdateOperationsInput? pubDate;

  @JsonKey(name: r'PUB_STATE')
  final NullableStringFieldUpdateOperationsInput? pubState;

  @JsonKey(name: r'CN')
  final NullableStringFieldUpdateOperationsInput? cn;

  @JsonKey(name: r'SRCH_YN')
  final NullableStringFieldUpdateOperationsInput? srchYn;

  @JsonKey(name: r'FILE_YN')
  final NullableStringFieldUpdateOperationsInput? fileYn;

  @JsonKey(name: r'IMAGE_YN')
  final NullableStringFieldUpdateOperationsInput? imageYn;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONTENTSMSTUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSMSTCreateManyInput implements _i1.JsonSerializable {
  const STCONTENTSMSTCreateManyInput({
    required this.seq,
    required this.cntsNm,
    this.pubDate,
    this.pubState,
    this.cn,
    this.srchYn,
    this.fileYn,
    this.imageYn,
    required this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCONTENTSMSTCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STCONTENTSMSTCreateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'CNTS_NM')
  final String cntsNm;

  @JsonKey(name: r'PUB_DATE')
  final String? pubDate;

  @JsonKey(name: r'PUB_STATE')
  final String? pubState;

  @JsonKey(name: r'CN')
  final String? cn;

  @JsonKey(name: r'SRCH_YN')
  final String? srchYn;

  @JsonKey(name: r'FILE_YN')
  final String? fileYn;

  @JsonKey(name: r'IMAGE_YN')
  final String? imageYn;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STCONTENTSMSTCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSMSTUpdateManyMutationInput implements _i1.JsonSerializable {
  const STCONTENTSMSTUpdateManyMutationInput({
    this.seq,
    this.cntsNm,
    this.pubDate,
    this.pubState,
    this.cn,
    this.srchYn,
    this.fileYn,
    this.imageYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCONTENTSMSTUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONTENTSMSTUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'CNTS_NM')
  final StringFieldUpdateOperationsInput? cntsNm;

  @JsonKey(name: r'PUB_DATE')
  final NullableStringFieldUpdateOperationsInput? pubDate;

  @JsonKey(name: r'PUB_STATE')
  final NullableStringFieldUpdateOperationsInput? pubState;

  @JsonKey(name: r'CN')
  final NullableStringFieldUpdateOperationsInput? cn;

  @JsonKey(name: r'SRCH_YN')
  final NullableStringFieldUpdateOperationsInput? srchYn;

  @JsonKey(name: r'FILE_YN')
  final NullableStringFieldUpdateOperationsInput? fileYn;

  @JsonKey(name: r'IMAGE_YN')
  final NullableStringFieldUpdateOperationsInput? imageYn;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONTENTSMSTUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSMSTUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const STCONTENTSMSTUncheckedUpdateManyInput({
    this.seq,
    this.cntsNm,
    this.pubDate,
    this.pubState,
    this.cn,
    this.srchYn,
    this.fileYn,
    this.imageYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCONTENTSMSTUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONTENTSMSTUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'CNTS_NM')
  final StringFieldUpdateOperationsInput? cntsNm;

  @JsonKey(name: r'PUB_DATE')
  final NullableStringFieldUpdateOperationsInput? pubDate;

  @JsonKey(name: r'PUB_STATE')
  final NullableStringFieldUpdateOperationsInput? pubState;

  @JsonKey(name: r'CN')
  final NullableStringFieldUpdateOperationsInput? cn;

  @JsonKey(name: r'SRCH_YN')
  final NullableStringFieldUpdateOperationsInput? srchYn;

  @JsonKey(name: r'FILE_YN')
  final NullableStringFieldUpdateOperationsInput? fileYn;

  @JsonKey(name: r'IMAGE_YN')
  final NullableStringFieldUpdateOperationsInput? imageYn;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONTENTSMSTUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class STDEPTCreateInput implements _i1.JsonSerializable {
  const STDEPTCreateInput({
    required this.deptCd,
    required this.deptNm,
    this.upperDeptCd,
    this.upperDeptNm,
    this.sort,
    this.mainYn,
    this.deptDesc,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STDEPTCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STDEPTCreateInputFromJson(json);

  @JsonKey(name: r'DEPT_CD')
  final String deptCd;

  @JsonKey(name: r'DEPT_NM')
  final String deptNm;

  @JsonKey(name: r'UPPER_DEPT_CD')
  final String? upperDeptCd;

  @JsonKey(name: r'UPPER_DEPT_NM')
  final String? upperDeptNm;

  @JsonKey(name: r'SORT')
  final int? sort;

  @JsonKey(name: r'MAIN_YN')
  final String? mainYn;

  @JsonKey(name: r'DEPT_DESC')
  final String? deptDesc;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STDEPTCreateInputToJson(this);
}

@_i1.jsonSerializable
class STDEPTUncheckedCreateInput implements _i1.JsonSerializable {
  const STDEPTUncheckedCreateInput({
    required this.deptCd,
    required this.deptNm,
    this.upperDeptCd,
    this.upperDeptNm,
    this.sort,
    this.mainYn,
    this.deptDesc,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STDEPTUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STDEPTUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'DEPT_CD')
  final String deptCd;

  @JsonKey(name: r'DEPT_NM')
  final String deptNm;

  @JsonKey(name: r'UPPER_DEPT_CD')
  final String? upperDeptCd;

  @JsonKey(name: r'UPPER_DEPT_NM')
  final String? upperDeptNm;

  @JsonKey(name: r'SORT')
  final int? sort;

  @JsonKey(name: r'MAIN_YN')
  final String? mainYn;

  @JsonKey(name: r'DEPT_DESC')
  final String? deptDesc;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STDEPTUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class STDEPTUpdateInput implements _i1.JsonSerializable {
  const STDEPTUpdateInput({
    this.deptCd,
    this.deptNm,
    this.upperDeptCd,
    this.upperDeptNm,
    this.sort,
    this.mainYn,
    this.deptDesc,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STDEPTUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STDEPTUpdateInputFromJson(json);

  @JsonKey(name: r'DEPT_CD')
  final StringFieldUpdateOperationsInput? deptCd;

  @JsonKey(name: r'DEPT_NM')
  final StringFieldUpdateOperationsInput? deptNm;

  @JsonKey(name: r'UPPER_DEPT_CD')
  final NullableStringFieldUpdateOperationsInput? upperDeptCd;

  @JsonKey(name: r'UPPER_DEPT_NM')
  final NullableStringFieldUpdateOperationsInput? upperDeptNm;

  @JsonKey(name: r'SORT')
  final NullableIntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'MAIN_YN')
  final NullableStringFieldUpdateOperationsInput? mainYn;

  @JsonKey(name: r'DEPT_DESC')
  final NullableStringFieldUpdateOperationsInput? deptDesc;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STDEPTUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STDEPTUncheckedUpdateInput implements _i1.JsonSerializable {
  const STDEPTUncheckedUpdateInput({
    this.deptCd,
    this.deptNm,
    this.upperDeptCd,
    this.upperDeptNm,
    this.sort,
    this.mainYn,
    this.deptDesc,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STDEPTUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STDEPTUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'DEPT_CD')
  final StringFieldUpdateOperationsInput? deptCd;

  @JsonKey(name: r'DEPT_NM')
  final StringFieldUpdateOperationsInput? deptNm;

  @JsonKey(name: r'UPPER_DEPT_CD')
  final NullableStringFieldUpdateOperationsInput? upperDeptCd;

  @JsonKey(name: r'UPPER_DEPT_NM')
  final NullableStringFieldUpdateOperationsInput? upperDeptNm;

  @JsonKey(name: r'SORT')
  final NullableIntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'MAIN_YN')
  final NullableStringFieldUpdateOperationsInput? mainYn;

  @JsonKey(name: r'DEPT_DESC')
  final NullableStringFieldUpdateOperationsInput? deptDesc;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STDEPTUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STDEPTCreateManyInput implements _i1.JsonSerializable {
  const STDEPTCreateManyInput({
    required this.deptCd,
    required this.deptNm,
    this.upperDeptCd,
    this.upperDeptNm,
    this.sort,
    this.mainYn,
    this.deptDesc,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STDEPTCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STDEPTCreateManyInputFromJson(json);

  @JsonKey(name: r'DEPT_CD')
  final String deptCd;

  @JsonKey(name: r'DEPT_NM')
  final String deptNm;

  @JsonKey(name: r'UPPER_DEPT_CD')
  final String? upperDeptCd;

  @JsonKey(name: r'UPPER_DEPT_NM')
  final String? upperDeptNm;

  @JsonKey(name: r'SORT')
  final int? sort;

  @JsonKey(name: r'MAIN_YN')
  final String? mainYn;

  @JsonKey(name: r'DEPT_DESC')
  final String? deptDesc;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STDEPTCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class STDEPTUpdateManyMutationInput implements _i1.JsonSerializable {
  const STDEPTUpdateManyMutationInput({
    this.deptCd,
    this.deptNm,
    this.upperDeptCd,
    this.upperDeptNm,
    this.sort,
    this.mainYn,
    this.deptDesc,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STDEPTUpdateManyMutationInput.fromJson(Map<String, dynamic> json) =>
      _$STDEPTUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'DEPT_CD')
  final StringFieldUpdateOperationsInput? deptCd;

  @JsonKey(name: r'DEPT_NM')
  final StringFieldUpdateOperationsInput? deptNm;

  @JsonKey(name: r'UPPER_DEPT_CD')
  final NullableStringFieldUpdateOperationsInput? upperDeptCd;

  @JsonKey(name: r'UPPER_DEPT_NM')
  final NullableStringFieldUpdateOperationsInput? upperDeptNm;

  @JsonKey(name: r'SORT')
  final NullableIntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'MAIN_YN')
  final NullableStringFieldUpdateOperationsInput? mainYn;

  @JsonKey(name: r'DEPT_DESC')
  final NullableStringFieldUpdateOperationsInput? deptDesc;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STDEPTUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class STDEPTUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const STDEPTUncheckedUpdateManyInput({
    this.deptCd,
    this.deptNm,
    this.upperDeptCd,
    this.upperDeptNm,
    this.sort,
    this.mainYn,
    this.deptDesc,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STDEPTUncheckedUpdateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STDEPTUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'DEPT_CD')
  final StringFieldUpdateOperationsInput? deptCd;

  @JsonKey(name: r'DEPT_NM')
  final StringFieldUpdateOperationsInput? deptNm;

  @JsonKey(name: r'UPPER_DEPT_CD')
  final NullableStringFieldUpdateOperationsInput? upperDeptCd;

  @JsonKey(name: r'UPPER_DEPT_NM')
  final NullableStringFieldUpdateOperationsInput? upperDeptNm;

  @JsonKey(name: r'SORT')
  final NullableIntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'MAIN_YN')
  final NullableStringFieldUpdateOperationsInput? mainYn;

  @JsonKey(name: r'DEPT_DESC')
  final NullableStringFieldUpdateOperationsInput? deptDesc;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STDEPTUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class STDEPTEMPCreateInput implements _i1.JsonSerializable {
  const STDEPTEMPCreateInput({
    required this.empNo,
    required this.empNm,
    this.deptCd,
    this.deptNm,
    this.fctnCd,
    this.fctnNm,
    this.ofcpCd,
    this.ofcpNm,
    this.emailAddr,
    this.offmTelno,
    this.htelTelno,
    this.deptYn,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STDEPTEMPCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STDEPTEMPCreateInputFromJson(json);

  @JsonKey(name: r'EMP_NO')
  final String empNo;

  @JsonKey(name: r'EMP_NM')
  final String empNm;

  @JsonKey(name: r'DEPT_CD')
  final String? deptCd;

  @JsonKey(name: r'DEPT_NM')
  final String? deptNm;

  @JsonKey(name: r'FCTN_CD')
  final String? fctnCd;

  @JsonKey(name: r'FCTN_NM')
  final String? fctnNm;

  @JsonKey(name: r'OFCP_CD')
  final String? ofcpCd;

  @JsonKey(name: r'OFCP_NM')
  final String? ofcpNm;

  @JsonKey(name: r'EMAIL_ADDR')
  final String? emailAddr;

  @JsonKey(name: r'OFFM_TELNO')
  final String? offmTelno;

  @JsonKey(name: r'HTEL_TELNO')
  final String? htelTelno;

  @JsonKey(name: r'DEPT_YN')
  final String? deptYn;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STDEPTEMPCreateInputToJson(this);
}

@_i1.jsonSerializable
class STDEPTEMPUncheckedCreateInput implements _i1.JsonSerializable {
  const STDEPTEMPUncheckedCreateInput({
    required this.empNo,
    required this.empNm,
    this.deptCd,
    this.deptNm,
    this.fctnCd,
    this.fctnNm,
    this.ofcpCd,
    this.ofcpNm,
    this.emailAddr,
    this.offmTelno,
    this.htelTelno,
    this.deptYn,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STDEPTEMPUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STDEPTEMPUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'EMP_NO')
  final String empNo;

  @JsonKey(name: r'EMP_NM')
  final String empNm;

  @JsonKey(name: r'DEPT_CD')
  final String? deptCd;

  @JsonKey(name: r'DEPT_NM')
  final String? deptNm;

  @JsonKey(name: r'FCTN_CD')
  final String? fctnCd;

  @JsonKey(name: r'FCTN_NM')
  final String? fctnNm;

  @JsonKey(name: r'OFCP_CD')
  final String? ofcpCd;

  @JsonKey(name: r'OFCP_NM')
  final String? ofcpNm;

  @JsonKey(name: r'EMAIL_ADDR')
  final String? emailAddr;

  @JsonKey(name: r'OFFM_TELNO')
  final String? offmTelno;

  @JsonKey(name: r'HTEL_TELNO')
  final String? htelTelno;

  @JsonKey(name: r'DEPT_YN')
  final String? deptYn;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STDEPTEMPUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class STDEPTEMPUpdateInput implements _i1.JsonSerializable {
  const STDEPTEMPUpdateInput({
    this.empNo,
    this.empNm,
    this.deptCd,
    this.deptNm,
    this.fctnCd,
    this.fctnNm,
    this.ofcpCd,
    this.ofcpNm,
    this.emailAddr,
    this.offmTelno,
    this.htelTelno,
    this.deptYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STDEPTEMPUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STDEPTEMPUpdateInputFromJson(json);

  @JsonKey(name: r'EMP_NO')
  final StringFieldUpdateOperationsInput? empNo;

  @JsonKey(name: r'EMP_NM')
  final StringFieldUpdateOperationsInput? empNm;

  @JsonKey(name: r'DEPT_CD')
  final NullableStringFieldUpdateOperationsInput? deptCd;

  @JsonKey(name: r'DEPT_NM')
  final NullableStringFieldUpdateOperationsInput? deptNm;

  @JsonKey(name: r'FCTN_CD')
  final NullableStringFieldUpdateOperationsInput? fctnCd;

  @JsonKey(name: r'FCTN_NM')
  final NullableStringFieldUpdateOperationsInput? fctnNm;

  @JsonKey(name: r'OFCP_CD')
  final NullableStringFieldUpdateOperationsInput? ofcpCd;

  @JsonKey(name: r'OFCP_NM')
  final NullableStringFieldUpdateOperationsInput? ofcpNm;

  @JsonKey(name: r'EMAIL_ADDR')
  final NullableStringFieldUpdateOperationsInput? emailAddr;

  @JsonKey(name: r'OFFM_TELNO')
  final NullableStringFieldUpdateOperationsInput? offmTelno;

  @JsonKey(name: r'HTEL_TELNO')
  final NullableStringFieldUpdateOperationsInput? htelTelno;

  @JsonKey(name: r'DEPT_YN')
  final NullableStringFieldUpdateOperationsInput? deptYn;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STDEPTEMPUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STDEPTEMPUncheckedUpdateInput implements _i1.JsonSerializable {
  const STDEPTEMPUncheckedUpdateInput({
    this.empNo,
    this.empNm,
    this.deptCd,
    this.deptNm,
    this.fctnCd,
    this.fctnNm,
    this.ofcpCd,
    this.ofcpNm,
    this.emailAddr,
    this.offmTelno,
    this.htelTelno,
    this.deptYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STDEPTEMPUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STDEPTEMPUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'EMP_NO')
  final StringFieldUpdateOperationsInput? empNo;

  @JsonKey(name: r'EMP_NM')
  final StringFieldUpdateOperationsInput? empNm;

  @JsonKey(name: r'DEPT_CD')
  final NullableStringFieldUpdateOperationsInput? deptCd;

  @JsonKey(name: r'DEPT_NM')
  final NullableStringFieldUpdateOperationsInput? deptNm;

  @JsonKey(name: r'FCTN_CD')
  final NullableStringFieldUpdateOperationsInput? fctnCd;

  @JsonKey(name: r'FCTN_NM')
  final NullableStringFieldUpdateOperationsInput? fctnNm;

  @JsonKey(name: r'OFCP_CD')
  final NullableStringFieldUpdateOperationsInput? ofcpCd;

  @JsonKey(name: r'OFCP_NM')
  final NullableStringFieldUpdateOperationsInput? ofcpNm;

  @JsonKey(name: r'EMAIL_ADDR')
  final NullableStringFieldUpdateOperationsInput? emailAddr;

  @JsonKey(name: r'OFFM_TELNO')
  final NullableStringFieldUpdateOperationsInput? offmTelno;

  @JsonKey(name: r'HTEL_TELNO')
  final NullableStringFieldUpdateOperationsInput? htelTelno;

  @JsonKey(name: r'DEPT_YN')
  final NullableStringFieldUpdateOperationsInput? deptYn;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STDEPTEMPUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STDEPTEMPCreateManyInput implements _i1.JsonSerializable {
  const STDEPTEMPCreateManyInput({
    required this.empNo,
    required this.empNm,
    this.deptCd,
    this.deptNm,
    this.fctnCd,
    this.fctnNm,
    this.ofcpCd,
    this.ofcpNm,
    this.emailAddr,
    this.offmTelno,
    this.htelTelno,
    this.deptYn,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STDEPTEMPCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STDEPTEMPCreateManyInputFromJson(json);

  @JsonKey(name: r'EMP_NO')
  final String empNo;

  @JsonKey(name: r'EMP_NM')
  final String empNm;

  @JsonKey(name: r'DEPT_CD')
  final String? deptCd;

  @JsonKey(name: r'DEPT_NM')
  final String? deptNm;

  @JsonKey(name: r'FCTN_CD')
  final String? fctnCd;

  @JsonKey(name: r'FCTN_NM')
  final String? fctnNm;

  @JsonKey(name: r'OFCP_CD')
  final String? ofcpCd;

  @JsonKey(name: r'OFCP_NM')
  final String? ofcpNm;

  @JsonKey(name: r'EMAIL_ADDR')
  final String? emailAddr;

  @JsonKey(name: r'OFFM_TELNO')
  final String? offmTelno;

  @JsonKey(name: r'HTEL_TELNO')
  final String? htelTelno;

  @JsonKey(name: r'DEPT_YN')
  final String? deptYn;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STDEPTEMPCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class STDEPTEMPUpdateManyMutationInput implements _i1.JsonSerializable {
  const STDEPTEMPUpdateManyMutationInput({
    this.empNo,
    this.empNm,
    this.deptCd,
    this.deptNm,
    this.fctnCd,
    this.fctnNm,
    this.ofcpCd,
    this.ofcpNm,
    this.emailAddr,
    this.offmTelno,
    this.htelTelno,
    this.deptYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STDEPTEMPUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STDEPTEMPUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'EMP_NO')
  final StringFieldUpdateOperationsInput? empNo;

  @JsonKey(name: r'EMP_NM')
  final StringFieldUpdateOperationsInput? empNm;

  @JsonKey(name: r'DEPT_CD')
  final NullableStringFieldUpdateOperationsInput? deptCd;

  @JsonKey(name: r'DEPT_NM')
  final NullableStringFieldUpdateOperationsInput? deptNm;

  @JsonKey(name: r'FCTN_CD')
  final NullableStringFieldUpdateOperationsInput? fctnCd;

  @JsonKey(name: r'FCTN_NM')
  final NullableStringFieldUpdateOperationsInput? fctnNm;

  @JsonKey(name: r'OFCP_CD')
  final NullableStringFieldUpdateOperationsInput? ofcpCd;

  @JsonKey(name: r'OFCP_NM')
  final NullableStringFieldUpdateOperationsInput? ofcpNm;

  @JsonKey(name: r'EMAIL_ADDR')
  final NullableStringFieldUpdateOperationsInput? emailAddr;

  @JsonKey(name: r'OFFM_TELNO')
  final NullableStringFieldUpdateOperationsInput? offmTelno;

  @JsonKey(name: r'HTEL_TELNO')
  final NullableStringFieldUpdateOperationsInput? htelTelno;

  @JsonKey(name: r'DEPT_YN')
  final NullableStringFieldUpdateOperationsInput? deptYn;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STDEPTEMPUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class STDEPTEMPUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const STDEPTEMPUncheckedUpdateManyInput({
    this.empNo,
    this.empNm,
    this.deptCd,
    this.deptNm,
    this.fctnCd,
    this.fctnNm,
    this.ofcpCd,
    this.ofcpNm,
    this.emailAddr,
    this.offmTelno,
    this.htelTelno,
    this.deptYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STDEPTEMPUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$STDEPTEMPUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'EMP_NO')
  final StringFieldUpdateOperationsInput? empNo;

  @JsonKey(name: r'EMP_NM')
  final StringFieldUpdateOperationsInput? empNm;

  @JsonKey(name: r'DEPT_CD')
  final NullableStringFieldUpdateOperationsInput? deptCd;

  @JsonKey(name: r'DEPT_NM')
  final NullableStringFieldUpdateOperationsInput? deptNm;

  @JsonKey(name: r'FCTN_CD')
  final NullableStringFieldUpdateOperationsInput? fctnCd;

  @JsonKey(name: r'FCTN_NM')
  final NullableStringFieldUpdateOperationsInput? fctnNm;

  @JsonKey(name: r'OFCP_CD')
  final NullableStringFieldUpdateOperationsInput? ofcpCd;

  @JsonKey(name: r'OFCP_NM')
  final NullableStringFieldUpdateOperationsInput? ofcpNm;

  @JsonKey(name: r'EMAIL_ADDR')
  final NullableStringFieldUpdateOperationsInput? emailAddr;

  @JsonKey(name: r'OFFM_TELNO')
  final NullableStringFieldUpdateOperationsInput? offmTelno;

  @JsonKey(name: r'HTEL_TELNO')
  final NullableStringFieldUpdateOperationsInput? htelTelno;

  @JsonKey(name: r'DEPT_YN')
  final NullableStringFieldUpdateOperationsInput? deptYn;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STDEPTEMPUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class STMENUCreateInput implements _i1.JsonSerializable {
  const STMENUCreateInput({
    required this.menuCd,
    required this.menuNm,
    this.menuPath,
    this.menuMapping,
    required this.menuSrt,
    required this.menuDeps,
    this.menuIcon,
    this.menuTp,
    this.mainExpsrYn,
    this.subExpsrYn,
    this.upendClas,
    this.upendCn,
    this.cclType,
    required this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMENUCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STMENUCreateInputFromJson(json);

  @JsonKey(name: r'MENU_CD')
  final String menuCd;

  @JsonKey(name: r'MENU_NM')
  final String menuNm;

  @JsonKey(name: r'MENU_PATH')
  final String? menuPath;

  @JsonKey(name: r'MENU_MAPPING')
  final String? menuMapping;

  @JsonKey(name: r'MENU_SRT')
  final int menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final int menuDeps;

  @JsonKey(name: r'MENU_ICON')
  final String? menuIcon;

  @JsonKey(name: r'MENU_TP')
  final String? menuTp;

  @JsonKey(name: r'MAIN_EXPSR_YN')
  final String? mainExpsrYn;

  @JsonKey(name: r'SUB_EXPSR_YN')
  final String? subExpsrYn;

  @JsonKey(name: r'UPEND_CLAS')
  final String? upendClas;

  @JsonKey(name: r'UPEND_CN')
  final String? upendCn;

  @JsonKey(name: r'CCL_TYPE')
  final String? cclType;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STMENUCreateInputToJson(this);
}

@_i1.jsonSerializable
class STMENUUncheckedCreateInput implements _i1.JsonSerializable {
  const STMENUUncheckedCreateInput({
    required this.menuCd,
    required this.menuNm,
    this.menuPath,
    this.menuMapping,
    required this.menuSrt,
    required this.menuDeps,
    this.menuIcon,
    this.menuTp,
    this.mainExpsrYn,
    this.subExpsrYn,
    this.upendClas,
    this.upendCn,
    this.cclType,
    required this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMENUUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STMENUUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'MENU_CD')
  final String menuCd;

  @JsonKey(name: r'MENU_NM')
  final String menuNm;

  @JsonKey(name: r'MENU_PATH')
  final String? menuPath;

  @JsonKey(name: r'MENU_MAPPING')
  final String? menuMapping;

  @JsonKey(name: r'MENU_SRT')
  final int menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final int menuDeps;

  @JsonKey(name: r'MENU_ICON')
  final String? menuIcon;

  @JsonKey(name: r'MENU_TP')
  final String? menuTp;

  @JsonKey(name: r'MAIN_EXPSR_YN')
  final String? mainExpsrYn;

  @JsonKey(name: r'SUB_EXPSR_YN')
  final String? subExpsrYn;

  @JsonKey(name: r'UPEND_CLAS')
  final String? upendClas;

  @JsonKey(name: r'UPEND_CN')
  final String? upendCn;

  @JsonKey(name: r'CCL_TYPE')
  final String? cclType;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STMENUUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class STMENUUpdateInput implements _i1.JsonSerializable {
  const STMENUUpdateInput({
    this.menuCd,
    this.menuNm,
    this.menuPath,
    this.menuMapping,
    this.menuSrt,
    this.menuDeps,
    this.menuIcon,
    this.menuTp,
    this.mainExpsrYn,
    this.subExpsrYn,
    this.upendClas,
    this.upendCn,
    this.cclType,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMENUUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STMENUUpdateInputFromJson(json);

  @JsonKey(name: r'MENU_CD')
  final StringFieldUpdateOperationsInput? menuCd;

  @JsonKey(name: r'MENU_NM')
  final StringFieldUpdateOperationsInput? menuNm;

  @JsonKey(name: r'MENU_PATH')
  final NullableStringFieldUpdateOperationsInput? menuPath;

  @JsonKey(name: r'MENU_MAPPING')
  final NullableStringFieldUpdateOperationsInput? menuMapping;

  @JsonKey(name: r'MENU_SRT')
  final IntFieldUpdateOperationsInput? menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final IntFieldUpdateOperationsInput? menuDeps;

  @JsonKey(name: r'MENU_ICON')
  final NullableStringFieldUpdateOperationsInput? menuIcon;

  @JsonKey(name: r'MENU_TP')
  final StringFieldUpdateOperationsInput? menuTp;

  @JsonKey(name: r'MAIN_EXPSR_YN')
  final NullableStringFieldUpdateOperationsInput? mainExpsrYn;

  @JsonKey(name: r'SUB_EXPSR_YN')
  final NullableStringFieldUpdateOperationsInput? subExpsrYn;

  @JsonKey(name: r'UPEND_CLAS')
  final NullableStringFieldUpdateOperationsInput? upendClas;

  @JsonKey(name: r'UPEND_CN')
  final NullableStringFieldUpdateOperationsInput? upendCn;

  @JsonKey(name: r'CCL_TYPE')
  final NullableStringFieldUpdateOperationsInput? cclType;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STMENUUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STMENUUncheckedUpdateInput implements _i1.JsonSerializable {
  const STMENUUncheckedUpdateInput({
    this.menuCd,
    this.menuNm,
    this.menuPath,
    this.menuMapping,
    this.menuSrt,
    this.menuDeps,
    this.menuIcon,
    this.menuTp,
    this.mainExpsrYn,
    this.subExpsrYn,
    this.upendClas,
    this.upendCn,
    this.cclType,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMENUUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STMENUUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'MENU_CD')
  final StringFieldUpdateOperationsInput? menuCd;

  @JsonKey(name: r'MENU_NM')
  final StringFieldUpdateOperationsInput? menuNm;

  @JsonKey(name: r'MENU_PATH')
  final NullableStringFieldUpdateOperationsInput? menuPath;

  @JsonKey(name: r'MENU_MAPPING')
  final NullableStringFieldUpdateOperationsInput? menuMapping;

  @JsonKey(name: r'MENU_SRT')
  final IntFieldUpdateOperationsInput? menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final IntFieldUpdateOperationsInput? menuDeps;

  @JsonKey(name: r'MENU_ICON')
  final NullableStringFieldUpdateOperationsInput? menuIcon;

  @JsonKey(name: r'MENU_TP')
  final StringFieldUpdateOperationsInput? menuTp;

  @JsonKey(name: r'MAIN_EXPSR_YN')
  final NullableStringFieldUpdateOperationsInput? mainExpsrYn;

  @JsonKey(name: r'SUB_EXPSR_YN')
  final NullableStringFieldUpdateOperationsInput? subExpsrYn;

  @JsonKey(name: r'UPEND_CLAS')
  final NullableStringFieldUpdateOperationsInput? upendClas;

  @JsonKey(name: r'UPEND_CN')
  final NullableStringFieldUpdateOperationsInput? upendCn;

  @JsonKey(name: r'CCL_TYPE')
  final NullableStringFieldUpdateOperationsInput? cclType;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STMENUUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STMENUCreateManyInput implements _i1.JsonSerializable {
  const STMENUCreateManyInput({
    required this.menuCd,
    required this.menuNm,
    this.menuPath,
    this.menuMapping,
    required this.menuSrt,
    required this.menuDeps,
    this.menuIcon,
    this.menuTp,
    this.mainExpsrYn,
    this.subExpsrYn,
    this.upendClas,
    this.upendCn,
    this.cclType,
    required this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMENUCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STMENUCreateManyInputFromJson(json);

  @JsonKey(name: r'MENU_CD')
  final String menuCd;

  @JsonKey(name: r'MENU_NM')
  final String menuNm;

  @JsonKey(name: r'MENU_PATH')
  final String? menuPath;

  @JsonKey(name: r'MENU_MAPPING')
  final String? menuMapping;

  @JsonKey(name: r'MENU_SRT')
  final int menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final int menuDeps;

  @JsonKey(name: r'MENU_ICON')
  final String? menuIcon;

  @JsonKey(name: r'MENU_TP')
  final String? menuTp;

  @JsonKey(name: r'MAIN_EXPSR_YN')
  final String? mainExpsrYn;

  @JsonKey(name: r'SUB_EXPSR_YN')
  final String? subExpsrYn;

  @JsonKey(name: r'UPEND_CLAS')
  final String? upendClas;

  @JsonKey(name: r'UPEND_CN')
  final String? upendCn;

  @JsonKey(name: r'CCL_TYPE')
  final String? cclType;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STMENUCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class STMENUUpdateManyMutationInput implements _i1.JsonSerializable {
  const STMENUUpdateManyMutationInput({
    this.menuCd,
    this.menuNm,
    this.menuPath,
    this.menuMapping,
    this.menuSrt,
    this.menuDeps,
    this.menuIcon,
    this.menuTp,
    this.mainExpsrYn,
    this.subExpsrYn,
    this.upendClas,
    this.upendCn,
    this.cclType,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMENUUpdateManyMutationInput.fromJson(Map<String, dynamic> json) =>
      _$STMENUUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'MENU_CD')
  final StringFieldUpdateOperationsInput? menuCd;

  @JsonKey(name: r'MENU_NM')
  final StringFieldUpdateOperationsInput? menuNm;

  @JsonKey(name: r'MENU_PATH')
  final NullableStringFieldUpdateOperationsInput? menuPath;

  @JsonKey(name: r'MENU_MAPPING')
  final NullableStringFieldUpdateOperationsInput? menuMapping;

  @JsonKey(name: r'MENU_SRT')
  final IntFieldUpdateOperationsInput? menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final IntFieldUpdateOperationsInput? menuDeps;

  @JsonKey(name: r'MENU_ICON')
  final NullableStringFieldUpdateOperationsInput? menuIcon;

  @JsonKey(name: r'MENU_TP')
  final StringFieldUpdateOperationsInput? menuTp;

  @JsonKey(name: r'MAIN_EXPSR_YN')
  final NullableStringFieldUpdateOperationsInput? mainExpsrYn;

  @JsonKey(name: r'SUB_EXPSR_YN')
  final NullableStringFieldUpdateOperationsInput? subExpsrYn;

  @JsonKey(name: r'UPEND_CLAS')
  final NullableStringFieldUpdateOperationsInput? upendClas;

  @JsonKey(name: r'UPEND_CN')
  final NullableStringFieldUpdateOperationsInput? upendCn;

  @JsonKey(name: r'CCL_TYPE')
  final NullableStringFieldUpdateOperationsInput? cclType;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STMENUUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class STMENUUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const STMENUUncheckedUpdateManyInput({
    this.menuCd,
    this.menuNm,
    this.menuPath,
    this.menuMapping,
    this.menuSrt,
    this.menuDeps,
    this.menuIcon,
    this.menuTp,
    this.mainExpsrYn,
    this.subExpsrYn,
    this.upendClas,
    this.upendCn,
    this.cclType,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMENUUncheckedUpdateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STMENUUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'MENU_CD')
  final StringFieldUpdateOperationsInput? menuCd;

  @JsonKey(name: r'MENU_NM')
  final StringFieldUpdateOperationsInput? menuNm;

  @JsonKey(name: r'MENU_PATH')
  final NullableStringFieldUpdateOperationsInput? menuPath;

  @JsonKey(name: r'MENU_MAPPING')
  final NullableStringFieldUpdateOperationsInput? menuMapping;

  @JsonKey(name: r'MENU_SRT')
  final IntFieldUpdateOperationsInput? menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final IntFieldUpdateOperationsInput? menuDeps;

  @JsonKey(name: r'MENU_ICON')
  final NullableStringFieldUpdateOperationsInput? menuIcon;

  @JsonKey(name: r'MENU_TP')
  final StringFieldUpdateOperationsInput? menuTp;

  @JsonKey(name: r'MAIN_EXPSR_YN')
  final NullableStringFieldUpdateOperationsInput? mainExpsrYn;

  @JsonKey(name: r'SUB_EXPSR_YN')
  final NullableStringFieldUpdateOperationsInput? subExpsrYn;

  @JsonKey(name: r'UPEND_CLAS')
  final NullableStringFieldUpdateOperationsInput? upendClas;

  @JsonKey(name: r'UPEND_CN')
  final NullableStringFieldUpdateOperationsInput? upendCn;

  @JsonKey(name: r'CCL_TYPE')
  final NullableStringFieldUpdateOperationsInput? cclType;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STMENUUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class STMESSAGETMPLATCreateInput implements _i1.JsonSerializable {
  const STMESSAGETMPLATCreateInput({
    required this.msgDivCd,
    required this.msgCd,
    this.msgNm,
    this.msgTmplat,
    this.useYn,
    this.editId,
    this.editDate,
  });

  factory STMESSAGETMPLATCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STMESSAGETMPLATCreateInputFromJson(json);

  @JsonKey(name: r'MSG_DIV_CD')
  final String msgDivCd;

  @JsonKey(name: r'MSG_CD')
  final String msgCd;

  @JsonKey(name: r'MSG_NM')
  final String? msgNm;

  @JsonKey(name: r'MSG_TMPLAT')
  final String? msgTmplat;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @override
  Map<String, dynamic> toJson() => _$STMESSAGETMPLATCreateInputToJson(this);
}

@_i1.jsonSerializable
class STMESSAGETMPLATUncheckedCreateInput implements _i1.JsonSerializable {
  const STMESSAGETMPLATUncheckedCreateInput({
    required this.msgDivCd,
    required this.msgCd,
    this.msgNm,
    this.msgTmplat,
    this.useYn,
    this.editId,
    this.editDate,
  });

  factory STMESSAGETMPLATUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMESSAGETMPLATUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'MSG_DIV_CD')
  final String msgDivCd;

  @JsonKey(name: r'MSG_CD')
  final String msgCd;

  @JsonKey(name: r'MSG_NM')
  final String? msgNm;

  @JsonKey(name: r'MSG_TMPLAT')
  final String? msgTmplat;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STMESSAGETMPLATUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class STMESSAGETMPLATUpdateInput implements _i1.JsonSerializable {
  const STMESSAGETMPLATUpdateInput({
    this.msgDivCd,
    this.msgCd,
    this.msgNm,
    this.msgTmplat,
    this.useYn,
    this.editId,
    this.editDate,
  });

  factory STMESSAGETMPLATUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STMESSAGETMPLATUpdateInputFromJson(json);

  @JsonKey(name: r'MSG_DIV_CD')
  final StringFieldUpdateOperationsInput? msgDivCd;

  @JsonKey(name: r'MSG_CD')
  final StringFieldUpdateOperationsInput? msgCd;

  @JsonKey(name: r'MSG_NM')
  final NullableStringFieldUpdateOperationsInput? msgNm;

  @JsonKey(name: r'MSG_TMPLAT')
  final NullableStringFieldUpdateOperationsInput? msgTmplat;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @override
  Map<String, dynamic> toJson() => _$STMESSAGETMPLATUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STMESSAGETMPLATUncheckedUpdateInput implements _i1.JsonSerializable {
  const STMESSAGETMPLATUncheckedUpdateInput({
    this.msgDivCd,
    this.msgCd,
    this.msgNm,
    this.msgTmplat,
    this.useYn,
    this.editId,
    this.editDate,
  });

  factory STMESSAGETMPLATUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMESSAGETMPLATUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'MSG_DIV_CD')
  final StringFieldUpdateOperationsInput? msgDivCd;

  @JsonKey(name: r'MSG_CD')
  final StringFieldUpdateOperationsInput? msgCd;

  @JsonKey(name: r'MSG_NM')
  final NullableStringFieldUpdateOperationsInput? msgNm;

  @JsonKey(name: r'MSG_TMPLAT')
  final NullableStringFieldUpdateOperationsInput? msgTmplat;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STMESSAGETMPLATUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STMESSAGETMPLATCreateManyInput implements _i1.JsonSerializable {
  const STMESSAGETMPLATCreateManyInput({
    required this.msgDivCd,
    required this.msgCd,
    this.msgNm,
    this.msgTmplat,
    this.useYn,
    this.editId,
    this.editDate,
  });

  factory STMESSAGETMPLATCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STMESSAGETMPLATCreateManyInputFromJson(json);

  @JsonKey(name: r'MSG_DIV_CD')
  final String msgDivCd;

  @JsonKey(name: r'MSG_CD')
  final String msgCd;

  @JsonKey(name: r'MSG_NM')
  final String? msgNm;

  @JsonKey(name: r'MSG_TMPLAT')
  final String? msgTmplat;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @override
  Map<String, dynamic> toJson() => _$STMESSAGETMPLATCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class STMESSAGETMPLATUpdateManyMutationInput implements _i1.JsonSerializable {
  const STMESSAGETMPLATUpdateManyMutationInput({
    this.msgDivCd,
    this.msgCd,
    this.msgNm,
    this.msgTmplat,
    this.useYn,
    this.editId,
    this.editDate,
  });

  factory STMESSAGETMPLATUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMESSAGETMPLATUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'MSG_DIV_CD')
  final StringFieldUpdateOperationsInput? msgDivCd;

  @JsonKey(name: r'MSG_CD')
  final StringFieldUpdateOperationsInput? msgCd;

  @JsonKey(name: r'MSG_NM')
  final NullableStringFieldUpdateOperationsInput? msgNm;

  @JsonKey(name: r'MSG_TMPLAT')
  final NullableStringFieldUpdateOperationsInput? msgTmplat;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STMESSAGETMPLATUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class STMESSAGETMPLATUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const STMESSAGETMPLATUncheckedUpdateManyInput({
    this.msgDivCd,
    this.msgCd,
    this.msgNm,
    this.msgTmplat,
    this.useYn,
    this.editId,
    this.editDate,
  });

  factory STMESSAGETMPLATUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMESSAGETMPLATUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'MSG_DIV_CD')
  final StringFieldUpdateOperationsInput? msgDivCd;

  @JsonKey(name: r'MSG_CD')
  final StringFieldUpdateOperationsInput? msgCd;

  @JsonKey(name: r'MSG_NM')
  final NullableStringFieldUpdateOperationsInput? msgNm;

  @JsonKey(name: r'MSG_TMPLAT')
  final NullableStringFieldUpdateOperationsInput? msgTmplat;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STMESSAGETMPLATUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class STMIMETYPECreateInput implements _i1.JsonSerializable {
  const STMIMETYPECreateInput({
    required this.extnNm,
    required this.fileMt,
  });

  factory STMIMETYPECreateInput.fromJson(Map<String, dynamic> json) =>
      _$STMIMETYPECreateInputFromJson(json);

  @JsonKey(name: r'EXTN_NM')
  final String extnNm;

  @JsonKey(name: r'FILE_MT')
  final String fileMt;

  @override
  Map<String, dynamic> toJson() => _$STMIMETYPECreateInputToJson(this);
}

@_i1.jsonSerializable
class STMIMETYPEUncheckedCreateInput implements _i1.JsonSerializable {
  const STMIMETYPEUncheckedCreateInput({
    this.seq,
    required this.extnNm,
    required this.fileMt,
  });

  factory STMIMETYPEUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STMIMETYPEUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int? seq;

  @JsonKey(name: r'EXTN_NM')
  final String extnNm;

  @JsonKey(name: r'FILE_MT')
  final String fileMt;

  @override
  Map<String, dynamic> toJson() => _$STMIMETYPEUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class STMIMETYPEUpdateInput implements _i1.JsonSerializable {
  const STMIMETYPEUpdateInput({
    this.extnNm,
    this.fileMt,
  });

  factory STMIMETYPEUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STMIMETYPEUpdateInputFromJson(json);

  @JsonKey(name: r'EXTN_NM')
  final StringFieldUpdateOperationsInput? extnNm;

  @JsonKey(name: r'FILE_MT')
  final StringFieldUpdateOperationsInput? fileMt;

  @override
  Map<String, dynamic> toJson() => _$STMIMETYPEUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STMIMETYPEUncheckedUpdateInput implements _i1.JsonSerializable {
  const STMIMETYPEUncheckedUpdateInput({
    this.seq,
    this.extnNm,
    this.fileMt,
  });

  factory STMIMETYPEUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STMIMETYPEUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'EXTN_NM')
  final StringFieldUpdateOperationsInput? extnNm;

  @JsonKey(name: r'FILE_MT')
  final StringFieldUpdateOperationsInput? fileMt;

  @override
  Map<String, dynamic> toJson() => _$STMIMETYPEUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STMIMETYPECreateManyInput implements _i1.JsonSerializable {
  const STMIMETYPECreateManyInput({
    this.seq,
    required this.extnNm,
    required this.fileMt,
  });

  factory STMIMETYPECreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STMIMETYPECreateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int? seq;

  @JsonKey(name: r'EXTN_NM')
  final String extnNm;

  @JsonKey(name: r'FILE_MT')
  final String fileMt;

  @override
  Map<String, dynamic> toJson() => _$STMIMETYPECreateManyInputToJson(this);
}

@_i1.jsonSerializable
class STMIMETYPEUpdateManyMutationInput implements _i1.JsonSerializable {
  const STMIMETYPEUpdateManyMutationInput({
    this.extnNm,
    this.fileMt,
  });

  factory STMIMETYPEUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMIMETYPEUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'EXTN_NM')
  final StringFieldUpdateOperationsInput? extnNm;

  @JsonKey(name: r'FILE_MT')
  final StringFieldUpdateOperationsInput? fileMt;

  @override
  Map<String, dynamic> toJson() =>
      _$STMIMETYPEUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class STMIMETYPEUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const STMIMETYPEUncheckedUpdateManyInput({
    this.seq,
    this.extnNm,
    this.fileMt,
  });

  factory STMIMETYPEUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMIMETYPEUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'EXTN_NM')
  final StringFieldUpdateOperationsInput? extnNm;

  @JsonKey(name: r'FILE_MT')
  final StringFieldUpdateOperationsInput? fileMt;

  @override
  Map<String, dynamic> toJson() =>
      _$STMIMETYPEUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRGRPCreateInput implements _i1.JsonSerializable {
  const STMNGRGRPCreateInput({
    required this.grpCd,
    this.grpNm,
    this.grpDesc,
    this.sort,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMNGRGRPCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STMNGRGRPCreateInputFromJson(json);

  @JsonKey(name: r'GRP_CD')
  final String grpCd;

  @JsonKey(name: r'GRP_NM')
  final String? grpNm;

  @JsonKey(name: r'GRP_DESC')
  final String? grpDesc;

  @JsonKey(name: r'SORT')
  final int? sort;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STMNGRGRPCreateInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRGRPUncheckedCreateInput implements _i1.JsonSerializable {
  const STMNGRGRPUncheckedCreateInput({
    required this.grpCd,
    this.grpNm,
    this.grpDesc,
    this.sort,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMNGRGRPUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STMNGRGRPUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'GRP_CD')
  final String grpCd;

  @JsonKey(name: r'GRP_NM')
  final String? grpNm;

  @JsonKey(name: r'GRP_DESC')
  final String? grpDesc;

  @JsonKey(name: r'SORT')
  final int? sort;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STMNGRGRPUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRGRPUpdateInput implements _i1.JsonSerializable {
  const STMNGRGRPUpdateInput({
    this.grpCd,
    this.grpNm,
    this.grpDesc,
    this.sort,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMNGRGRPUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STMNGRGRPUpdateInputFromJson(json);

  @JsonKey(name: r'GRP_CD')
  final StringFieldUpdateOperationsInput? grpCd;

  @JsonKey(name: r'GRP_NM')
  final NullableStringFieldUpdateOperationsInput? grpNm;

  @JsonKey(name: r'GRP_DESC')
  final NullableStringFieldUpdateOperationsInput? grpDesc;

  @JsonKey(name: r'SORT')
  final NullableIntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STMNGRGRPUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRGRPUncheckedUpdateInput implements _i1.JsonSerializable {
  const STMNGRGRPUncheckedUpdateInput({
    this.grpCd,
    this.grpNm,
    this.grpDesc,
    this.sort,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMNGRGRPUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STMNGRGRPUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'GRP_CD')
  final StringFieldUpdateOperationsInput? grpCd;

  @JsonKey(name: r'GRP_NM')
  final NullableStringFieldUpdateOperationsInput? grpNm;

  @JsonKey(name: r'GRP_DESC')
  final NullableStringFieldUpdateOperationsInput? grpDesc;

  @JsonKey(name: r'SORT')
  final NullableIntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STMNGRGRPUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRGRPCreateManyInput implements _i1.JsonSerializable {
  const STMNGRGRPCreateManyInput({
    required this.grpCd,
    this.grpNm,
    this.grpDesc,
    this.sort,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMNGRGRPCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STMNGRGRPCreateManyInputFromJson(json);

  @JsonKey(name: r'GRP_CD')
  final String grpCd;

  @JsonKey(name: r'GRP_NM')
  final String? grpNm;

  @JsonKey(name: r'GRP_DESC')
  final String? grpDesc;

  @JsonKey(name: r'SORT')
  final int? sort;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STMNGRGRPCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRGRPUpdateManyMutationInput implements _i1.JsonSerializable {
  const STMNGRGRPUpdateManyMutationInput({
    this.grpCd,
    this.grpNm,
    this.grpDesc,
    this.sort,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMNGRGRPUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMNGRGRPUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'GRP_CD')
  final StringFieldUpdateOperationsInput? grpCd;

  @JsonKey(name: r'GRP_NM')
  final NullableStringFieldUpdateOperationsInput? grpNm;

  @JsonKey(name: r'GRP_DESC')
  final NullableStringFieldUpdateOperationsInput? grpDesc;

  @JsonKey(name: r'SORT')
  final NullableIntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STMNGRGRPUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRGRPUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const STMNGRGRPUncheckedUpdateManyInput({
    this.grpCd,
    this.grpNm,
    this.grpDesc,
    this.sort,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMNGRGRPUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMNGRGRPUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'GRP_CD')
  final StringFieldUpdateOperationsInput? grpCd;

  @JsonKey(name: r'GRP_NM')
  final NullableStringFieldUpdateOperationsInput? grpNm;

  @JsonKey(name: r'GRP_DESC')
  final NullableStringFieldUpdateOperationsInput? grpDesc;

  @JsonKey(name: r'SORT')
  final NullableIntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STMNGRGRPUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRMSTCreateInput implements _i1.JsonSerializable {
  const STMNGRMSTCreateInput({
    required this.mngrId,
    required this.mngrNm,
    this.mngrPw,
    this.grpCd,
    this.grade,
    required this.permCd,
    this.acsYn,
    this.clph,
    this.empNo,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.pwdWrongDate,
    this.lstLoginDate,
    this.flpth,
    this.fileNm,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMNGRMSTCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STMNGRMSTCreateInputFromJson(json);

  @JsonKey(name: r'MNGR_ID')
  final String mngrId;

  @JsonKey(name: r'MNGR_NM')
  final String mngrNm;

  @JsonKey(name: r'MNGR_PW')
  final String? mngrPw;

  @JsonKey(name: r'GRP_CD')
  final String? grpCd;

  @JsonKey(name: r'GRADE')
  final String? grade;

  @JsonKey(name: r'PERM_CD')
  final String permCd;

  @JsonKey(name: r'ACS_YN')
  final String? acsYn;

  @JsonKey(name: r'CLPH')
  final String? clph;

  @JsonKey(name: r'EMP_NO')
  final String? empNo;

  @JsonKey(name: r'JOIN_DATE')
  final String? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final DateTime? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final DateTime? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final int? pwdWrongCnt;

  @JsonKey(name: r'PWD_WRONG_DATE')
  final String? pwdWrongDate;

  @JsonKey(name: r'LST_LOGIN_DATE')
  final String? lstLoginDate;

  @JsonKey(name: r'FLPTH')
  final String? flpth;

  @JsonKey(name: r'FILE_NM')
  final String? fileNm;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STMNGRMSTCreateInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRMSTUncheckedCreateInput implements _i1.JsonSerializable {
  const STMNGRMSTUncheckedCreateInput({
    required this.mngrId,
    required this.mngrNm,
    this.mngrPw,
    this.grpCd,
    this.grade,
    required this.permCd,
    this.acsYn,
    this.clph,
    this.empNo,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.pwdWrongDate,
    this.lstLoginDate,
    this.flpth,
    this.fileNm,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMNGRMSTUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STMNGRMSTUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'MNGR_ID')
  final String mngrId;

  @JsonKey(name: r'MNGR_NM')
  final String mngrNm;

  @JsonKey(name: r'MNGR_PW')
  final String? mngrPw;

  @JsonKey(name: r'GRP_CD')
  final String? grpCd;

  @JsonKey(name: r'GRADE')
  final String? grade;

  @JsonKey(name: r'PERM_CD')
  final String permCd;

  @JsonKey(name: r'ACS_YN')
  final String? acsYn;

  @JsonKey(name: r'CLPH')
  final String? clph;

  @JsonKey(name: r'EMP_NO')
  final String? empNo;

  @JsonKey(name: r'JOIN_DATE')
  final String? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final DateTime? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final DateTime? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final int? pwdWrongCnt;

  @JsonKey(name: r'PWD_WRONG_DATE')
  final String? pwdWrongDate;

  @JsonKey(name: r'LST_LOGIN_DATE')
  final String? lstLoginDate;

  @JsonKey(name: r'FLPTH')
  final String? flpth;

  @JsonKey(name: r'FILE_NM')
  final String? fileNm;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STMNGRMSTUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRMSTUpdateInput implements _i1.JsonSerializable {
  const STMNGRMSTUpdateInput({
    this.mngrId,
    this.mngrNm,
    this.mngrPw,
    this.grpCd,
    this.grade,
    this.permCd,
    this.acsYn,
    this.clph,
    this.empNo,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.pwdWrongDate,
    this.lstLoginDate,
    this.flpth,
    this.fileNm,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMNGRMSTUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STMNGRMSTUpdateInputFromJson(json);

  @JsonKey(name: r'MNGR_ID')
  final StringFieldUpdateOperationsInput? mngrId;

  @JsonKey(name: r'MNGR_NM')
  final StringFieldUpdateOperationsInput? mngrNm;

  @JsonKey(name: r'MNGR_PW')
  final NullableStringFieldUpdateOperationsInput? mngrPw;

  @JsonKey(name: r'GRP_CD')
  final NullableStringFieldUpdateOperationsInput? grpCd;

  @JsonKey(name: r'GRADE')
  final NullableStringFieldUpdateOperationsInput? grade;

  @JsonKey(name: r'PERM_CD')
  final StringFieldUpdateOperationsInput? permCd;

  @JsonKey(name: r'ACS_YN')
  final NullableStringFieldUpdateOperationsInput? acsYn;

  @JsonKey(name: r'CLPH')
  final NullableStringFieldUpdateOperationsInput? clph;

  @JsonKey(name: r'EMP_NO')
  final NullableStringFieldUpdateOperationsInput? empNo;

  @JsonKey(name: r'JOIN_DATE')
  final StringFieldUpdateOperationsInput? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final DateTimeFieldUpdateOperationsInput? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final DateTimeFieldUpdateOperationsInput? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final NullableIntFieldUpdateOperationsInput? pwdWrongCnt;

  @JsonKey(name: r'PWD_WRONG_DATE')
  final NullableStringFieldUpdateOperationsInput? pwdWrongDate;

  @JsonKey(name: r'LST_LOGIN_DATE')
  final NullableStringFieldUpdateOperationsInput? lstLoginDate;

  @JsonKey(name: r'FLPTH')
  final NullableStringFieldUpdateOperationsInput? flpth;

  @JsonKey(name: r'FILE_NM')
  final NullableStringFieldUpdateOperationsInput? fileNm;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STMNGRMSTUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRMSTUncheckedUpdateInput implements _i1.JsonSerializable {
  const STMNGRMSTUncheckedUpdateInput({
    this.mngrId,
    this.mngrNm,
    this.mngrPw,
    this.grpCd,
    this.grade,
    this.permCd,
    this.acsYn,
    this.clph,
    this.empNo,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.pwdWrongDate,
    this.lstLoginDate,
    this.flpth,
    this.fileNm,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMNGRMSTUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STMNGRMSTUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'MNGR_ID')
  final StringFieldUpdateOperationsInput? mngrId;

  @JsonKey(name: r'MNGR_NM')
  final StringFieldUpdateOperationsInput? mngrNm;

  @JsonKey(name: r'MNGR_PW')
  final NullableStringFieldUpdateOperationsInput? mngrPw;

  @JsonKey(name: r'GRP_CD')
  final NullableStringFieldUpdateOperationsInput? grpCd;

  @JsonKey(name: r'GRADE')
  final NullableStringFieldUpdateOperationsInput? grade;

  @JsonKey(name: r'PERM_CD')
  final StringFieldUpdateOperationsInput? permCd;

  @JsonKey(name: r'ACS_YN')
  final NullableStringFieldUpdateOperationsInput? acsYn;

  @JsonKey(name: r'CLPH')
  final NullableStringFieldUpdateOperationsInput? clph;

  @JsonKey(name: r'EMP_NO')
  final NullableStringFieldUpdateOperationsInput? empNo;

  @JsonKey(name: r'JOIN_DATE')
  final StringFieldUpdateOperationsInput? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final DateTimeFieldUpdateOperationsInput? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final DateTimeFieldUpdateOperationsInput? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final NullableIntFieldUpdateOperationsInput? pwdWrongCnt;

  @JsonKey(name: r'PWD_WRONG_DATE')
  final NullableStringFieldUpdateOperationsInput? pwdWrongDate;

  @JsonKey(name: r'LST_LOGIN_DATE')
  final NullableStringFieldUpdateOperationsInput? lstLoginDate;

  @JsonKey(name: r'FLPTH')
  final NullableStringFieldUpdateOperationsInput? flpth;

  @JsonKey(name: r'FILE_NM')
  final NullableStringFieldUpdateOperationsInput? fileNm;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STMNGRMSTUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRMSTCreateManyInput implements _i1.JsonSerializable {
  const STMNGRMSTCreateManyInput({
    required this.mngrId,
    required this.mngrNm,
    this.mngrPw,
    this.grpCd,
    this.grade,
    required this.permCd,
    this.acsYn,
    this.clph,
    this.empNo,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.pwdWrongDate,
    this.lstLoginDate,
    this.flpth,
    this.fileNm,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMNGRMSTCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STMNGRMSTCreateManyInputFromJson(json);

  @JsonKey(name: r'MNGR_ID')
  final String mngrId;

  @JsonKey(name: r'MNGR_NM')
  final String mngrNm;

  @JsonKey(name: r'MNGR_PW')
  final String? mngrPw;

  @JsonKey(name: r'GRP_CD')
  final String? grpCd;

  @JsonKey(name: r'GRADE')
  final String? grade;

  @JsonKey(name: r'PERM_CD')
  final String permCd;

  @JsonKey(name: r'ACS_YN')
  final String? acsYn;

  @JsonKey(name: r'CLPH')
  final String? clph;

  @JsonKey(name: r'EMP_NO')
  final String? empNo;

  @JsonKey(name: r'JOIN_DATE')
  final String? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final DateTime? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final DateTime? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final int? pwdWrongCnt;

  @JsonKey(name: r'PWD_WRONG_DATE')
  final String? pwdWrongDate;

  @JsonKey(name: r'LST_LOGIN_DATE')
  final String? lstLoginDate;

  @JsonKey(name: r'FLPTH')
  final String? flpth;

  @JsonKey(name: r'FILE_NM')
  final String? fileNm;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STMNGRMSTCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRMSTUpdateManyMutationInput implements _i1.JsonSerializable {
  const STMNGRMSTUpdateManyMutationInput({
    this.mngrId,
    this.mngrNm,
    this.mngrPw,
    this.grpCd,
    this.grade,
    this.permCd,
    this.acsYn,
    this.clph,
    this.empNo,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.pwdWrongDate,
    this.lstLoginDate,
    this.flpth,
    this.fileNm,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMNGRMSTUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMNGRMSTUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'MNGR_ID')
  final StringFieldUpdateOperationsInput? mngrId;

  @JsonKey(name: r'MNGR_NM')
  final StringFieldUpdateOperationsInput? mngrNm;

  @JsonKey(name: r'MNGR_PW')
  final NullableStringFieldUpdateOperationsInput? mngrPw;

  @JsonKey(name: r'GRP_CD')
  final NullableStringFieldUpdateOperationsInput? grpCd;

  @JsonKey(name: r'GRADE')
  final NullableStringFieldUpdateOperationsInput? grade;

  @JsonKey(name: r'PERM_CD')
  final StringFieldUpdateOperationsInput? permCd;

  @JsonKey(name: r'ACS_YN')
  final NullableStringFieldUpdateOperationsInput? acsYn;

  @JsonKey(name: r'CLPH')
  final NullableStringFieldUpdateOperationsInput? clph;

  @JsonKey(name: r'EMP_NO')
  final NullableStringFieldUpdateOperationsInput? empNo;

  @JsonKey(name: r'JOIN_DATE')
  final StringFieldUpdateOperationsInput? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final DateTimeFieldUpdateOperationsInput? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final DateTimeFieldUpdateOperationsInput? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final NullableIntFieldUpdateOperationsInput? pwdWrongCnt;

  @JsonKey(name: r'PWD_WRONG_DATE')
  final NullableStringFieldUpdateOperationsInput? pwdWrongDate;

  @JsonKey(name: r'LST_LOGIN_DATE')
  final NullableStringFieldUpdateOperationsInput? lstLoginDate;

  @JsonKey(name: r'FLPTH')
  final NullableStringFieldUpdateOperationsInput? flpth;

  @JsonKey(name: r'FILE_NM')
  final NullableStringFieldUpdateOperationsInput? fileNm;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STMNGRMSTUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRMSTUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const STMNGRMSTUncheckedUpdateManyInput({
    this.mngrId,
    this.mngrNm,
    this.mngrPw,
    this.grpCd,
    this.grade,
    this.permCd,
    this.acsYn,
    this.clph,
    this.empNo,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.pwdWrongDate,
    this.lstLoginDate,
    this.flpth,
    this.fileNm,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMNGRMSTUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMNGRMSTUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'MNGR_ID')
  final StringFieldUpdateOperationsInput? mngrId;

  @JsonKey(name: r'MNGR_NM')
  final StringFieldUpdateOperationsInput? mngrNm;

  @JsonKey(name: r'MNGR_PW')
  final NullableStringFieldUpdateOperationsInput? mngrPw;

  @JsonKey(name: r'GRP_CD')
  final NullableStringFieldUpdateOperationsInput? grpCd;

  @JsonKey(name: r'GRADE')
  final NullableStringFieldUpdateOperationsInput? grade;

  @JsonKey(name: r'PERM_CD')
  final StringFieldUpdateOperationsInput? permCd;

  @JsonKey(name: r'ACS_YN')
  final NullableStringFieldUpdateOperationsInput? acsYn;

  @JsonKey(name: r'CLPH')
  final NullableStringFieldUpdateOperationsInput? clph;

  @JsonKey(name: r'EMP_NO')
  final NullableStringFieldUpdateOperationsInput? empNo;

  @JsonKey(name: r'JOIN_DATE')
  final StringFieldUpdateOperationsInput? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final DateTimeFieldUpdateOperationsInput? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final DateTimeFieldUpdateOperationsInput? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final NullableIntFieldUpdateOperationsInput? pwdWrongCnt;

  @JsonKey(name: r'PWD_WRONG_DATE')
  final NullableStringFieldUpdateOperationsInput? pwdWrongDate;

  @JsonKey(name: r'LST_LOGIN_DATE')
  final NullableStringFieldUpdateOperationsInput? lstLoginDate;

  @JsonKey(name: r'FLPTH')
  final NullableStringFieldUpdateOperationsInput? flpth;

  @JsonKey(name: r'FILE_NM')
  final NullableStringFieldUpdateOperationsInput? fileNm;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STMNGRMSTUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class STMYSTNGCreateInput implements _i1.JsonSerializable {
  const STMYSTNGCreateInput({
    required this.userId,
    required this.stngCd,
    required this.userDiv,
    this.stngData,
  });

  factory STMYSTNGCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STMYSTNGCreateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'STNG_CD')
  final String stngCd;

  @JsonKey(name: r'USER_DIV')
  final String userDiv;

  @JsonKey(name: r'STNG_DATA')
  final String? stngData;

  @override
  Map<String, dynamic> toJson() => _$STMYSTNGCreateInputToJson(this);
}

@_i1.jsonSerializable
class STMYSTNGUncheckedCreateInput implements _i1.JsonSerializable {
  const STMYSTNGUncheckedCreateInput({
    required this.userId,
    required this.stngCd,
    required this.userDiv,
    this.stngData,
  });

  factory STMYSTNGUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STMYSTNGUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'STNG_CD')
  final String stngCd;

  @JsonKey(name: r'USER_DIV')
  final String userDiv;

  @JsonKey(name: r'STNG_DATA')
  final String? stngData;

  @override
  Map<String, dynamic> toJson() => _$STMYSTNGUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class STMYSTNGUpdateInput implements _i1.JsonSerializable {
  const STMYSTNGUpdateInput({
    this.userId,
    this.stngCd,
    this.userDiv,
    this.stngData,
  });

  factory STMYSTNGUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STMYSTNGUpdateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'STNG_CD')
  final StringFieldUpdateOperationsInput? stngCd;

  @JsonKey(name: r'USER_DIV')
  final StringFieldUpdateOperationsInput? userDiv;

  @JsonKey(name: r'STNG_DATA')
  final NullableStringFieldUpdateOperationsInput? stngData;

  @override
  Map<String, dynamic> toJson() => _$STMYSTNGUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STMYSTNGUncheckedUpdateInput implements _i1.JsonSerializable {
  const STMYSTNGUncheckedUpdateInput({
    this.userId,
    this.stngCd,
    this.userDiv,
    this.stngData,
  });

  factory STMYSTNGUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STMYSTNGUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'STNG_CD')
  final StringFieldUpdateOperationsInput? stngCd;

  @JsonKey(name: r'USER_DIV')
  final StringFieldUpdateOperationsInput? userDiv;

  @JsonKey(name: r'STNG_DATA')
  final NullableStringFieldUpdateOperationsInput? stngData;

  @override
  Map<String, dynamic> toJson() => _$STMYSTNGUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STMYSTNGCreateManyInput implements _i1.JsonSerializable {
  const STMYSTNGCreateManyInput({
    required this.userId,
    required this.stngCd,
    required this.userDiv,
    this.stngData,
  });

  factory STMYSTNGCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STMYSTNGCreateManyInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'STNG_CD')
  final String stngCd;

  @JsonKey(name: r'USER_DIV')
  final String userDiv;

  @JsonKey(name: r'STNG_DATA')
  final String? stngData;

  @override
  Map<String, dynamic> toJson() => _$STMYSTNGCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class STMYSTNGUpdateManyMutationInput implements _i1.JsonSerializable {
  const STMYSTNGUpdateManyMutationInput({
    this.userId,
    this.stngCd,
    this.userDiv,
    this.stngData,
  });

  factory STMYSTNGUpdateManyMutationInput.fromJson(Map<String, dynamic> json) =>
      _$STMYSTNGUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'STNG_CD')
  final StringFieldUpdateOperationsInput? stngCd;

  @JsonKey(name: r'USER_DIV')
  final StringFieldUpdateOperationsInput? userDiv;

  @JsonKey(name: r'STNG_DATA')
  final NullableStringFieldUpdateOperationsInput? stngData;

  @override
  Map<String, dynamic> toJson() =>
      _$STMYSTNGUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class STMYSTNGUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const STMYSTNGUncheckedUpdateManyInput({
    this.userId,
    this.stngCd,
    this.userDiv,
    this.stngData,
  });

  factory STMYSTNGUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMYSTNGUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'STNG_CD')
  final StringFieldUpdateOperationsInput? stngCd;

  @JsonKey(name: r'USER_DIV')
  final StringFieldUpdateOperationsInput? userDiv;

  @JsonKey(name: r'STNG_DATA')
  final NullableStringFieldUpdateOperationsInput? stngData;

  @override
  Map<String, dynamic> toJson() =>
      _$STMYSTNGUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class STPERMDTLCreateInput implements _i1.JsonSerializable {
  const STPERMDTLCreateInput({
    required this.permCd,
    required this.menuCd,
    this.readYn,
    this.regYn,
    this.mdfcnYn,
    this.delYn,
    this.manageYn,
    required this.regId,
    required this.regDate,
  });

  factory STPERMDTLCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STPERMDTLCreateInputFromJson(json);

  @JsonKey(name: r'PERM_CD')
  final String permCd;

  @JsonKey(name: r'MENU_CD')
  final String menuCd;

  @JsonKey(name: r'READ_YN')
  final String? readYn;

  @JsonKey(name: r'REG_YN')
  final String? regYn;

  @JsonKey(name: r'MDFCN_YN')
  final String? mdfcnYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'MANAGE_YN')
  final String? manageYn;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @override
  Map<String, dynamic> toJson() => _$STPERMDTLCreateInputToJson(this);
}

@_i1.jsonSerializable
class STPERMDTLUncheckedCreateInput implements _i1.JsonSerializable {
  const STPERMDTLUncheckedCreateInput({
    required this.permCd,
    required this.menuCd,
    this.readYn,
    this.regYn,
    this.mdfcnYn,
    this.delYn,
    this.manageYn,
    required this.regId,
    required this.regDate,
  });

  factory STPERMDTLUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STPERMDTLUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'PERM_CD')
  final String permCd;

  @JsonKey(name: r'MENU_CD')
  final String menuCd;

  @JsonKey(name: r'READ_YN')
  final String? readYn;

  @JsonKey(name: r'REG_YN')
  final String? regYn;

  @JsonKey(name: r'MDFCN_YN')
  final String? mdfcnYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'MANAGE_YN')
  final String? manageYn;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @override
  Map<String, dynamic> toJson() => _$STPERMDTLUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class STPERMDTLUpdateInput implements _i1.JsonSerializable {
  const STPERMDTLUpdateInput({
    this.permCd,
    this.menuCd,
    this.readYn,
    this.regYn,
    this.mdfcnYn,
    this.delYn,
    this.manageYn,
    this.regId,
    this.regDate,
  });

  factory STPERMDTLUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STPERMDTLUpdateInputFromJson(json);

  @JsonKey(name: r'PERM_CD')
  final StringFieldUpdateOperationsInput? permCd;

  @JsonKey(name: r'MENU_CD')
  final StringFieldUpdateOperationsInput? menuCd;

  @JsonKey(name: r'READ_YN')
  final NullableStringFieldUpdateOperationsInput? readYn;

  @JsonKey(name: r'REG_YN')
  final NullableStringFieldUpdateOperationsInput? regYn;

  @JsonKey(name: r'MDFCN_YN')
  final NullableStringFieldUpdateOperationsInput? mdfcnYn;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'MANAGE_YN')
  final NullableStringFieldUpdateOperationsInput? manageYn;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @override
  Map<String, dynamic> toJson() => _$STPERMDTLUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STPERMDTLUncheckedUpdateInput implements _i1.JsonSerializable {
  const STPERMDTLUncheckedUpdateInput({
    this.permCd,
    this.menuCd,
    this.readYn,
    this.regYn,
    this.mdfcnYn,
    this.delYn,
    this.manageYn,
    this.regId,
    this.regDate,
  });

  factory STPERMDTLUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STPERMDTLUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'PERM_CD')
  final StringFieldUpdateOperationsInput? permCd;

  @JsonKey(name: r'MENU_CD')
  final StringFieldUpdateOperationsInput? menuCd;

  @JsonKey(name: r'READ_YN')
  final NullableStringFieldUpdateOperationsInput? readYn;

  @JsonKey(name: r'REG_YN')
  final NullableStringFieldUpdateOperationsInput? regYn;

  @JsonKey(name: r'MDFCN_YN')
  final NullableStringFieldUpdateOperationsInput? mdfcnYn;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'MANAGE_YN')
  final NullableStringFieldUpdateOperationsInput? manageYn;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @override
  Map<String, dynamic> toJson() => _$STPERMDTLUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STPERMDTLCreateManyInput implements _i1.JsonSerializable {
  const STPERMDTLCreateManyInput({
    required this.permCd,
    required this.menuCd,
    this.readYn,
    this.regYn,
    this.mdfcnYn,
    this.delYn,
    this.manageYn,
    required this.regId,
    required this.regDate,
  });

  factory STPERMDTLCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STPERMDTLCreateManyInputFromJson(json);

  @JsonKey(name: r'PERM_CD')
  final String permCd;

  @JsonKey(name: r'MENU_CD')
  final String menuCd;

  @JsonKey(name: r'READ_YN')
  final String? readYn;

  @JsonKey(name: r'REG_YN')
  final String? regYn;

  @JsonKey(name: r'MDFCN_YN')
  final String? mdfcnYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'MANAGE_YN')
  final String? manageYn;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @override
  Map<String, dynamic> toJson() => _$STPERMDTLCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class STPERMDTLUpdateManyMutationInput implements _i1.JsonSerializable {
  const STPERMDTLUpdateManyMutationInput({
    this.permCd,
    this.menuCd,
    this.readYn,
    this.regYn,
    this.mdfcnYn,
    this.delYn,
    this.manageYn,
    this.regId,
    this.regDate,
  });

  factory STPERMDTLUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STPERMDTLUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'PERM_CD')
  final StringFieldUpdateOperationsInput? permCd;

  @JsonKey(name: r'MENU_CD')
  final StringFieldUpdateOperationsInput? menuCd;

  @JsonKey(name: r'READ_YN')
  final NullableStringFieldUpdateOperationsInput? readYn;

  @JsonKey(name: r'REG_YN')
  final NullableStringFieldUpdateOperationsInput? regYn;

  @JsonKey(name: r'MDFCN_YN')
  final NullableStringFieldUpdateOperationsInput? mdfcnYn;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'MANAGE_YN')
  final NullableStringFieldUpdateOperationsInput? manageYn;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STPERMDTLUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class STPERMDTLUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const STPERMDTLUncheckedUpdateManyInput({
    this.permCd,
    this.menuCd,
    this.readYn,
    this.regYn,
    this.mdfcnYn,
    this.delYn,
    this.manageYn,
    this.regId,
    this.regDate,
  });

  factory STPERMDTLUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$STPERMDTLUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'PERM_CD')
  final StringFieldUpdateOperationsInput? permCd;

  @JsonKey(name: r'MENU_CD')
  final StringFieldUpdateOperationsInput? menuCd;

  @JsonKey(name: r'READ_YN')
  final NullableStringFieldUpdateOperationsInput? readYn;

  @JsonKey(name: r'REG_YN')
  final NullableStringFieldUpdateOperationsInput? regYn;

  @JsonKey(name: r'MDFCN_YN')
  final NullableStringFieldUpdateOperationsInput? mdfcnYn;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'MANAGE_YN')
  final NullableStringFieldUpdateOperationsInput? manageYn;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STPERMDTLUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class STPERMMSTCreateInput implements _i1.JsonSerializable {
  const STPERMMSTCreateInput({
    required this.permCd,
    required this.permNm,
    this.sort,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STPERMMSTCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STPERMMSTCreateInputFromJson(json);

  @JsonKey(name: r'PERM_CD')
  final String permCd;

  @JsonKey(name: r'PERM_NM')
  final String permNm;

  @JsonKey(name: r'SORT')
  final String? sort;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STPERMMSTCreateInputToJson(this);
}

@_i1.jsonSerializable
class STPERMMSTUncheckedCreateInput implements _i1.JsonSerializable {
  const STPERMMSTUncheckedCreateInput({
    required this.permCd,
    required this.permNm,
    this.sort,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STPERMMSTUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STPERMMSTUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'PERM_CD')
  final String permCd;

  @JsonKey(name: r'PERM_NM')
  final String permNm;

  @JsonKey(name: r'SORT')
  final String? sort;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STPERMMSTUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class STPERMMSTUpdateInput implements _i1.JsonSerializable {
  const STPERMMSTUpdateInput({
    this.permCd,
    this.permNm,
    this.sort,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STPERMMSTUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STPERMMSTUpdateInputFromJson(json);

  @JsonKey(name: r'PERM_CD')
  final StringFieldUpdateOperationsInput? permCd;

  @JsonKey(name: r'PERM_NM')
  final StringFieldUpdateOperationsInput? permNm;

  @JsonKey(name: r'SORT')
  final NullableStringFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STPERMMSTUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STPERMMSTUncheckedUpdateInput implements _i1.JsonSerializable {
  const STPERMMSTUncheckedUpdateInput({
    this.permCd,
    this.permNm,
    this.sort,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STPERMMSTUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STPERMMSTUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'PERM_CD')
  final StringFieldUpdateOperationsInput? permCd;

  @JsonKey(name: r'PERM_NM')
  final StringFieldUpdateOperationsInput? permNm;

  @JsonKey(name: r'SORT')
  final NullableStringFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STPERMMSTUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STPERMMSTCreateManyInput implements _i1.JsonSerializable {
  const STPERMMSTCreateManyInput({
    required this.permCd,
    required this.permNm,
    this.sort,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STPERMMSTCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STPERMMSTCreateManyInputFromJson(json);

  @JsonKey(name: r'PERM_CD')
  final String permCd;

  @JsonKey(name: r'PERM_NM')
  final String permNm;

  @JsonKey(name: r'SORT')
  final String? sort;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STPERMMSTCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class STPERMMSTUpdateManyMutationInput implements _i1.JsonSerializable {
  const STPERMMSTUpdateManyMutationInput({
    this.permCd,
    this.permNm,
    this.sort,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STPERMMSTUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STPERMMSTUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'PERM_CD')
  final StringFieldUpdateOperationsInput? permCd;

  @JsonKey(name: r'PERM_NM')
  final StringFieldUpdateOperationsInput? permNm;

  @JsonKey(name: r'SORT')
  final NullableStringFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STPERMMSTUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class STPERMMSTUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const STPERMMSTUncheckedUpdateManyInput({
    this.permCd,
    this.permNm,
    this.sort,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STPERMMSTUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$STPERMMSTUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'PERM_CD')
  final StringFieldUpdateOperationsInput? permCd;

  @JsonKey(name: r'PERM_NM')
  final StringFieldUpdateOperationsInput? permNm;

  @JsonKey(name: r'SORT')
  final NullableStringFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STPERMMSTUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class STPOPUPCreateInput implements _i1.JsonSerializable {
  const STPOPUPCreateInput({
    required this.popCd,
    required this.popNm,
    required this.popTy,
    this.imgText,
    this.lkUrl,
    this.lkTarget,
    required this.bgngDate,
    required this.endDate,
    this.spwgPred,
    this.flpth,
    this.fileNm,
    this.useYn,
    this.beforeCd,
    required this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STPOPUPCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STPOPUPCreateInputFromJson(json);

  @JsonKey(name: r'POP_CD')
  final String popCd;

  @JsonKey(name: r'POP_NM')
  final String popNm;

  @JsonKey(name: r'POP_TY')
  final String popTy;

  @JsonKey(name: r'IMG_TEXT')
  final String? imgText;

  @JsonKey(name: r'LK_URL')
  final String? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final String? lkTarget;

  @JsonKey(name: r'BGNG_DATE')
  final String bgngDate;

  @JsonKey(name: r'END_DATE')
  final String endDate;

  @JsonKey(name: r'SPWG_PRED')
  final String? spwgPred;

  @JsonKey(name: r'FLPTH')
  final String? flpth;

  @JsonKey(name: r'FILE_NM')
  final String? fileNm;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'BEFORE_CD')
  final String? beforeCd;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STPOPUPCreateInputToJson(this);
}

@_i1.jsonSerializable
class STPOPUPUncheckedCreateInput implements _i1.JsonSerializable {
  const STPOPUPUncheckedCreateInput({
    required this.popCd,
    required this.popNm,
    required this.popTy,
    this.imgText,
    this.lkUrl,
    this.lkTarget,
    required this.bgngDate,
    required this.endDate,
    this.spwgPred,
    this.flpth,
    this.fileNm,
    this.useYn,
    this.beforeCd,
    required this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STPOPUPUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STPOPUPUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'POP_CD')
  final String popCd;

  @JsonKey(name: r'POP_NM')
  final String popNm;

  @JsonKey(name: r'POP_TY')
  final String popTy;

  @JsonKey(name: r'IMG_TEXT')
  final String? imgText;

  @JsonKey(name: r'LK_URL')
  final String? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final String? lkTarget;

  @JsonKey(name: r'BGNG_DATE')
  final String bgngDate;

  @JsonKey(name: r'END_DATE')
  final String endDate;

  @JsonKey(name: r'SPWG_PRED')
  final String? spwgPred;

  @JsonKey(name: r'FLPTH')
  final String? flpth;

  @JsonKey(name: r'FILE_NM')
  final String? fileNm;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'BEFORE_CD')
  final String? beforeCd;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STPOPUPUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class STPOPUPUpdateInput implements _i1.JsonSerializable {
  const STPOPUPUpdateInput({
    this.popCd,
    this.popNm,
    this.popTy,
    this.imgText,
    this.lkUrl,
    this.lkTarget,
    this.bgngDate,
    this.endDate,
    this.spwgPred,
    this.flpth,
    this.fileNm,
    this.useYn,
    this.beforeCd,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STPOPUPUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STPOPUPUpdateInputFromJson(json);

  @JsonKey(name: r'POP_CD')
  final StringFieldUpdateOperationsInput? popCd;

  @JsonKey(name: r'POP_NM')
  final StringFieldUpdateOperationsInput? popNm;

  @JsonKey(name: r'POP_TY')
  final StringFieldUpdateOperationsInput? popTy;

  @JsonKey(name: r'IMG_TEXT')
  final NullableStringFieldUpdateOperationsInput? imgText;

  @JsonKey(name: r'LK_URL')
  final NullableStringFieldUpdateOperationsInput? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final NullableStringFieldUpdateOperationsInput? lkTarget;

  @JsonKey(name: r'BGNG_DATE')
  final StringFieldUpdateOperationsInput? bgngDate;

  @JsonKey(name: r'END_DATE')
  final StringFieldUpdateOperationsInput? endDate;

  @JsonKey(name: r'SPWG_PRED')
  final NullableStringFieldUpdateOperationsInput? spwgPred;

  @JsonKey(name: r'FLPTH')
  final NullableStringFieldUpdateOperationsInput? flpth;

  @JsonKey(name: r'FILE_NM')
  final NullableStringFieldUpdateOperationsInput? fileNm;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'BEFORE_CD')
  final NullableStringFieldUpdateOperationsInput? beforeCd;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STPOPUPUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STPOPUPUncheckedUpdateInput implements _i1.JsonSerializable {
  const STPOPUPUncheckedUpdateInput({
    this.popCd,
    this.popNm,
    this.popTy,
    this.imgText,
    this.lkUrl,
    this.lkTarget,
    this.bgngDate,
    this.endDate,
    this.spwgPred,
    this.flpth,
    this.fileNm,
    this.useYn,
    this.beforeCd,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STPOPUPUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STPOPUPUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'POP_CD')
  final StringFieldUpdateOperationsInput? popCd;

  @JsonKey(name: r'POP_NM')
  final StringFieldUpdateOperationsInput? popNm;

  @JsonKey(name: r'POP_TY')
  final StringFieldUpdateOperationsInput? popTy;

  @JsonKey(name: r'IMG_TEXT')
  final NullableStringFieldUpdateOperationsInput? imgText;

  @JsonKey(name: r'LK_URL')
  final NullableStringFieldUpdateOperationsInput? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final NullableStringFieldUpdateOperationsInput? lkTarget;

  @JsonKey(name: r'BGNG_DATE')
  final StringFieldUpdateOperationsInput? bgngDate;

  @JsonKey(name: r'END_DATE')
  final StringFieldUpdateOperationsInput? endDate;

  @JsonKey(name: r'SPWG_PRED')
  final NullableStringFieldUpdateOperationsInput? spwgPred;

  @JsonKey(name: r'FLPTH')
  final NullableStringFieldUpdateOperationsInput? flpth;

  @JsonKey(name: r'FILE_NM')
  final NullableStringFieldUpdateOperationsInput? fileNm;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'BEFORE_CD')
  final NullableStringFieldUpdateOperationsInput? beforeCd;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STPOPUPUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STPOPUPCreateManyInput implements _i1.JsonSerializable {
  const STPOPUPCreateManyInput({
    required this.popCd,
    required this.popNm,
    required this.popTy,
    this.imgText,
    this.lkUrl,
    this.lkTarget,
    required this.bgngDate,
    required this.endDate,
    this.spwgPred,
    this.flpth,
    this.fileNm,
    this.useYn,
    this.beforeCd,
    required this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STPOPUPCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STPOPUPCreateManyInputFromJson(json);

  @JsonKey(name: r'POP_CD')
  final String popCd;

  @JsonKey(name: r'POP_NM')
  final String popNm;

  @JsonKey(name: r'POP_TY')
  final String popTy;

  @JsonKey(name: r'IMG_TEXT')
  final String? imgText;

  @JsonKey(name: r'LK_URL')
  final String? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final String? lkTarget;

  @JsonKey(name: r'BGNG_DATE')
  final String bgngDate;

  @JsonKey(name: r'END_DATE')
  final String endDate;

  @JsonKey(name: r'SPWG_PRED')
  final String? spwgPred;

  @JsonKey(name: r'FLPTH')
  final String? flpth;

  @JsonKey(name: r'FILE_NM')
  final String? fileNm;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'BEFORE_CD')
  final String? beforeCd;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STPOPUPCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class STPOPUPUpdateManyMutationInput implements _i1.JsonSerializable {
  const STPOPUPUpdateManyMutationInput({
    this.popCd,
    this.popNm,
    this.popTy,
    this.imgText,
    this.lkUrl,
    this.lkTarget,
    this.bgngDate,
    this.endDate,
    this.spwgPred,
    this.flpth,
    this.fileNm,
    this.useYn,
    this.beforeCd,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STPOPUPUpdateManyMutationInput.fromJson(Map<String, dynamic> json) =>
      _$STPOPUPUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'POP_CD')
  final StringFieldUpdateOperationsInput? popCd;

  @JsonKey(name: r'POP_NM')
  final StringFieldUpdateOperationsInput? popNm;

  @JsonKey(name: r'POP_TY')
  final StringFieldUpdateOperationsInput? popTy;

  @JsonKey(name: r'IMG_TEXT')
  final NullableStringFieldUpdateOperationsInput? imgText;

  @JsonKey(name: r'LK_URL')
  final NullableStringFieldUpdateOperationsInput? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final NullableStringFieldUpdateOperationsInput? lkTarget;

  @JsonKey(name: r'BGNG_DATE')
  final StringFieldUpdateOperationsInput? bgngDate;

  @JsonKey(name: r'END_DATE')
  final StringFieldUpdateOperationsInput? endDate;

  @JsonKey(name: r'SPWG_PRED')
  final NullableStringFieldUpdateOperationsInput? spwgPred;

  @JsonKey(name: r'FLPTH')
  final NullableStringFieldUpdateOperationsInput? flpth;

  @JsonKey(name: r'FILE_NM')
  final NullableStringFieldUpdateOperationsInput? fileNm;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'BEFORE_CD')
  final NullableStringFieldUpdateOperationsInput? beforeCd;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STPOPUPUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class STPOPUPUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const STPOPUPUncheckedUpdateManyInput({
    this.popCd,
    this.popNm,
    this.popTy,
    this.imgText,
    this.lkUrl,
    this.lkTarget,
    this.bgngDate,
    this.endDate,
    this.spwgPred,
    this.flpth,
    this.fileNm,
    this.useYn,
    this.beforeCd,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STPOPUPUncheckedUpdateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STPOPUPUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'POP_CD')
  final StringFieldUpdateOperationsInput? popCd;

  @JsonKey(name: r'POP_NM')
  final StringFieldUpdateOperationsInput? popNm;

  @JsonKey(name: r'POP_TY')
  final StringFieldUpdateOperationsInput? popTy;

  @JsonKey(name: r'IMG_TEXT')
  final NullableStringFieldUpdateOperationsInput? imgText;

  @JsonKey(name: r'LK_URL')
  final NullableStringFieldUpdateOperationsInput? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final NullableStringFieldUpdateOperationsInput? lkTarget;

  @JsonKey(name: r'BGNG_DATE')
  final StringFieldUpdateOperationsInput? bgngDate;

  @JsonKey(name: r'END_DATE')
  final StringFieldUpdateOperationsInput? endDate;

  @JsonKey(name: r'SPWG_PRED')
  final NullableStringFieldUpdateOperationsInput? spwgPred;

  @JsonKey(name: r'FLPTH')
  final NullableStringFieldUpdateOperationsInput? flpth;

  @JsonKey(name: r'FILE_NM')
  final NullableStringFieldUpdateOperationsInput? fileNm;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'BEFORE_CD')
  final NullableStringFieldUpdateOperationsInput? beforeCd;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STPOPUPUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class STSTNGCreateInput implements _i1.JsonSerializable {
  const STSTNGCreateInput({
    required this.stngCd,
    this.stngData,
    this.title,
    this.descCn,
    this.sort,
    this.editId,
    this.editDate,
  });

  factory STSTNGCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STSTNGCreateInputFromJson(json);

  @JsonKey(name: r'STNG_CD')
  final String stngCd;

  @JsonKey(name: r'STNG_DATA')
  final String? stngData;

  @JsonKey(name: r'TITLE')
  final String? title;

  @JsonKey(name: r'DESC_CN')
  final String? descCn;

  @JsonKey(name: r'SORT')
  final int? sort;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @override
  Map<String, dynamic> toJson() => _$STSTNGCreateInputToJson(this);
}

@_i1.jsonSerializable
class STSTNGUncheckedCreateInput implements _i1.JsonSerializable {
  const STSTNGUncheckedCreateInput({
    required this.stngCd,
    this.stngData,
    this.title,
    this.descCn,
    this.sort,
    this.editId,
    this.editDate,
  });

  factory STSTNGUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STSTNGUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'STNG_CD')
  final String stngCd;

  @JsonKey(name: r'STNG_DATA')
  final String? stngData;

  @JsonKey(name: r'TITLE')
  final String? title;

  @JsonKey(name: r'DESC_CN')
  final String? descCn;

  @JsonKey(name: r'SORT')
  final int? sort;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @override
  Map<String, dynamic> toJson() => _$STSTNGUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class STSTNGUpdateInput implements _i1.JsonSerializable {
  const STSTNGUpdateInput({
    this.stngCd,
    this.stngData,
    this.title,
    this.descCn,
    this.sort,
    this.editId,
    this.editDate,
  });

  factory STSTNGUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STSTNGUpdateInputFromJson(json);

  @JsonKey(name: r'STNG_CD')
  final StringFieldUpdateOperationsInput? stngCd;

  @JsonKey(name: r'STNG_DATA')
  final NullableStringFieldUpdateOperationsInput? stngData;

  @JsonKey(name: r'TITLE')
  final NullableStringFieldUpdateOperationsInput? title;

  @JsonKey(name: r'DESC_CN')
  final NullableStringFieldUpdateOperationsInput? descCn;

  @JsonKey(name: r'SORT')
  final NullableIntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @override
  Map<String, dynamic> toJson() => _$STSTNGUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STSTNGUncheckedUpdateInput implements _i1.JsonSerializable {
  const STSTNGUncheckedUpdateInput({
    this.stngCd,
    this.stngData,
    this.title,
    this.descCn,
    this.sort,
    this.editId,
    this.editDate,
  });

  factory STSTNGUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STSTNGUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'STNG_CD')
  final StringFieldUpdateOperationsInput? stngCd;

  @JsonKey(name: r'STNG_DATA')
  final NullableStringFieldUpdateOperationsInput? stngData;

  @JsonKey(name: r'TITLE')
  final NullableStringFieldUpdateOperationsInput? title;

  @JsonKey(name: r'DESC_CN')
  final NullableStringFieldUpdateOperationsInput? descCn;

  @JsonKey(name: r'SORT')
  final NullableIntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @override
  Map<String, dynamic> toJson() => _$STSTNGUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STSTNGCreateManyInput implements _i1.JsonSerializable {
  const STSTNGCreateManyInput({
    required this.stngCd,
    this.stngData,
    this.title,
    this.descCn,
    this.sort,
    this.editId,
    this.editDate,
  });

  factory STSTNGCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STSTNGCreateManyInputFromJson(json);

  @JsonKey(name: r'STNG_CD')
  final String stngCd;

  @JsonKey(name: r'STNG_DATA')
  final String? stngData;

  @JsonKey(name: r'TITLE')
  final String? title;

  @JsonKey(name: r'DESC_CN')
  final String? descCn;

  @JsonKey(name: r'SORT')
  final int? sort;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @override
  Map<String, dynamic> toJson() => _$STSTNGCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class STSTNGUpdateManyMutationInput implements _i1.JsonSerializable {
  const STSTNGUpdateManyMutationInput({
    this.stngCd,
    this.stngData,
    this.title,
    this.descCn,
    this.sort,
    this.editId,
    this.editDate,
  });

  factory STSTNGUpdateManyMutationInput.fromJson(Map<String, dynamic> json) =>
      _$STSTNGUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'STNG_CD')
  final StringFieldUpdateOperationsInput? stngCd;

  @JsonKey(name: r'STNG_DATA')
  final NullableStringFieldUpdateOperationsInput? stngData;

  @JsonKey(name: r'TITLE')
  final NullableStringFieldUpdateOperationsInput? title;

  @JsonKey(name: r'DESC_CN')
  final NullableStringFieldUpdateOperationsInput? descCn;

  @JsonKey(name: r'SORT')
  final NullableIntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @override
  Map<String, dynamic> toJson() => _$STSTNGUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class STSTNGUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const STSTNGUncheckedUpdateManyInput({
    this.stngCd,
    this.stngData,
    this.title,
    this.descCn,
    this.sort,
    this.editId,
    this.editDate,
  });

  factory STSTNGUncheckedUpdateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STSTNGUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'STNG_CD')
  final StringFieldUpdateOperationsInput? stngCd;

  @JsonKey(name: r'STNG_DATA')
  final NullableStringFieldUpdateOperationsInput? stngData;

  @JsonKey(name: r'TITLE')
  final NullableStringFieldUpdateOperationsInput? title;

  @JsonKey(name: r'DESC_CN')
  final NullableStringFieldUpdateOperationsInput? descCn;

  @JsonKey(name: r'SORT')
  final NullableIntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @override
  Map<String, dynamic> toJson() => _$STSTNGUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class STUSERMSTCreateInput implements _i1.JsonSerializable {
  const STUSERMSTCreateInput({
    required this.userId,
    this.userNm,
    required this.userPw,
    this.userDiv,
    this.status,
    this.prevLoginYn,
    this.withdrawnYn,
    this.clph,
    this.email,
    this.lstLoginDate,
    required this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STUSERMSTCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STUSERMSTCreateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'USER_NM')
  final String? userNm;

  @JsonKey(name: r'USER_PW')
  final String userPw;

  @JsonKey(name: r'USER_DIV')
  final String? userDiv;

  @JsonKey(name: r'STATUS')
  final String? status;

  @JsonKey(name: r'PREV_LOGIN_YN')
  final String? prevLoginYn;

  @JsonKey(name: r'WITHDRAWN_YN')
  final String? withdrawnYn;

  @JsonKey(name: r'CLPH')
  final String? clph;

  @JsonKey(name: r'EMAIL')
  final String? email;

  @JsonKey(name: r'LST_LOGIN_DATE')
  final String? lstLoginDate;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STUSERMSTCreateInputToJson(this);
}

@_i1.jsonSerializable
class STUSERMSTUncheckedCreateInput implements _i1.JsonSerializable {
  const STUSERMSTUncheckedCreateInput({
    required this.userId,
    this.userNm,
    required this.userPw,
    this.userDiv,
    this.status,
    this.prevLoginYn,
    this.withdrawnYn,
    this.clph,
    this.email,
    this.lstLoginDate,
    required this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STUSERMSTUncheckedCreateInput.fromJson(Map<String, dynamic> json) =>
      _$STUSERMSTUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'USER_NM')
  final String? userNm;

  @JsonKey(name: r'USER_PW')
  final String userPw;

  @JsonKey(name: r'USER_DIV')
  final String? userDiv;

  @JsonKey(name: r'STATUS')
  final String? status;

  @JsonKey(name: r'PREV_LOGIN_YN')
  final String? prevLoginYn;

  @JsonKey(name: r'WITHDRAWN_YN')
  final String? withdrawnYn;

  @JsonKey(name: r'CLPH')
  final String? clph;

  @JsonKey(name: r'EMAIL')
  final String? email;

  @JsonKey(name: r'LST_LOGIN_DATE')
  final String? lstLoginDate;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STUSERMSTUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class STUSERMSTUpdateInput implements _i1.JsonSerializable {
  const STUSERMSTUpdateInput({
    this.userId,
    this.userNm,
    this.userPw,
    this.userDiv,
    this.status,
    this.prevLoginYn,
    this.withdrawnYn,
    this.clph,
    this.email,
    this.lstLoginDate,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STUSERMSTUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STUSERMSTUpdateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'USER_NM')
  final NullableStringFieldUpdateOperationsInput? userNm;

  @JsonKey(name: r'USER_PW')
  final StringFieldUpdateOperationsInput? userPw;

  @JsonKey(name: r'USER_DIV')
  final NullableStringFieldUpdateOperationsInput? userDiv;

  @JsonKey(name: r'STATUS')
  final NullableStringFieldUpdateOperationsInput? status;

  @JsonKey(name: r'PREV_LOGIN_YN')
  final NullableStringFieldUpdateOperationsInput? prevLoginYn;

  @JsonKey(name: r'WITHDRAWN_YN')
  final NullableStringFieldUpdateOperationsInput? withdrawnYn;

  @JsonKey(name: r'CLPH')
  final NullableStringFieldUpdateOperationsInput? clph;

  @JsonKey(name: r'EMAIL')
  final NullableStringFieldUpdateOperationsInput? email;

  @JsonKey(name: r'LST_LOGIN_DATE')
  final NullableStringFieldUpdateOperationsInput? lstLoginDate;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STUSERMSTUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STUSERMSTUncheckedUpdateInput implements _i1.JsonSerializable {
  const STUSERMSTUncheckedUpdateInput({
    this.userId,
    this.userNm,
    this.userPw,
    this.userDiv,
    this.status,
    this.prevLoginYn,
    this.withdrawnYn,
    this.clph,
    this.email,
    this.lstLoginDate,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STUSERMSTUncheckedUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$STUSERMSTUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'USER_NM')
  final NullableStringFieldUpdateOperationsInput? userNm;

  @JsonKey(name: r'USER_PW')
  final StringFieldUpdateOperationsInput? userPw;

  @JsonKey(name: r'USER_DIV')
  final NullableStringFieldUpdateOperationsInput? userDiv;

  @JsonKey(name: r'STATUS')
  final NullableStringFieldUpdateOperationsInput? status;

  @JsonKey(name: r'PREV_LOGIN_YN')
  final NullableStringFieldUpdateOperationsInput? prevLoginYn;

  @JsonKey(name: r'WITHDRAWN_YN')
  final NullableStringFieldUpdateOperationsInput? withdrawnYn;

  @JsonKey(name: r'CLPH')
  final NullableStringFieldUpdateOperationsInput? clph;

  @JsonKey(name: r'EMAIL')
  final NullableStringFieldUpdateOperationsInput? email;

  @JsonKey(name: r'LST_LOGIN_DATE')
  final NullableStringFieldUpdateOperationsInput? lstLoginDate;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$STUSERMSTUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class STUSERMSTCreateManyInput implements _i1.JsonSerializable {
  const STUSERMSTCreateManyInput({
    required this.userId,
    this.userNm,
    required this.userPw,
    this.userDiv,
    this.status,
    this.prevLoginYn,
    this.withdrawnYn,
    this.clph,
    this.email,
    this.lstLoginDate,
    required this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STUSERMSTCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$STUSERMSTCreateManyInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'USER_NM')
  final String? userNm;

  @JsonKey(name: r'USER_PW')
  final String userPw;

  @JsonKey(name: r'USER_DIV')
  final String? userDiv;

  @JsonKey(name: r'STATUS')
  final String? status;

  @JsonKey(name: r'PREV_LOGIN_YN')
  final String? prevLoginYn;

  @JsonKey(name: r'WITHDRAWN_YN')
  final String? withdrawnYn;

  @JsonKey(name: r'CLPH')
  final String? clph;

  @JsonKey(name: r'EMAIL')
  final String? email;

  @JsonKey(name: r'LST_LOGIN_DATE')
  final String? lstLoginDate;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STUSERMSTCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class STUSERMSTUpdateManyMutationInput implements _i1.JsonSerializable {
  const STUSERMSTUpdateManyMutationInput({
    this.userId,
    this.userNm,
    this.userPw,
    this.userDiv,
    this.status,
    this.prevLoginYn,
    this.withdrawnYn,
    this.clph,
    this.email,
    this.lstLoginDate,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STUSERMSTUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$STUSERMSTUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'USER_NM')
  final NullableStringFieldUpdateOperationsInput? userNm;

  @JsonKey(name: r'USER_PW')
  final StringFieldUpdateOperationsInput? userPw;

  @JsonKey(name: r'USER_DIV')
  final NullableStringFieldUpdateOperationsInput? userDiv;

  @JsonKey(name: r'STATUS')
  final NullableStringFieldUpdateOperationsInput? status;

  @JsonKey(name: r'PREV_LOGIN_YN')
  final NullableStringFieldUpdateOperationsInput? prevLoginYn;

  @JsonKey(name: r'WITHDRAWN_YN')
  final NullableStringFieldUpdateOperationsInput? withdrawnYn;

  @JsonKey(name: r'CLPH')
  final NullableStringFieldUpdateOperationsInput? clph;

  @JsonKey(name: r'EMAIL')
  final NullableStringFieldUpdateOperationsInput? email;

  @JsonKey(name: r'LST_LOGIN_DATE')
  final NullableStringFieldUpdateOperationsInput? lstLoginDate;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STUSERMSTUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class STUSERMSTUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const STUSERMSTUncheckedUpdateManyInput({
    this.userId,
    this.userNm,
    this.userPw,
    this.userDiv,
    this.status,
    this.prevLoginYn,
    this.withdrawnYn,
    this.clph,
    this.email,
    this.lstLoginDate,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STUSERMSTUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$STUSERMSTUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'USER_NM')
  final NullableStringFieldUpdateOperationsInput? userNm;

  @JsonKey(name: r'USER_PW')
  final StringFieldUpdateOperationsInput? userPw;

  @JsonKey(name: r'USER_DIV')
  final NullableStringFieldUpdateOperationsInput? userDiv;

  @JsonKey(name: r'STATUS')
  final NullableStringFieldUpdateOperationsInput? status;

  @JsonKey(name: r'PREV_LOGIN_YN')
  final NullableStringFieldUpdateOperationsInput? prevLoginYn;

  @JsonKey(name: r'WITHDRAWN_YN')
  final NullableStringFieldUpdateOperationsInput? withdrawnYn;

  @JsonKey(name: r'CLPH')
  final NullableStringFieldUpdateOperationsInput? clph;

  @JsonKey(name: r'EMAIL')
  final NullableStringFieldUpdateOperationsInput? email;

  @JsonKey(name: r'LST_LOGIN_DATE')
  final NullableStringFieldUpdateOperationsInput? lstLoginDate;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final NullableStringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STUSERMSTUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTDETAILTBLCreateInput implements _i1.JsonSerializable {
  const WORKREPORTDETAILTBLCreateInput({
    required this.reportId,
    this.seq,
    required this.projectNm,
    required this.projectSubNm,
    this.detailContent,
    this.worker,
    this.grade,
    this.processRate,
    this.workDate,
    this.processType,
    this.subjectYn,
    required this.regUser,
    this.regDate,
    this.completeDate,
  });

  factory WORKREPORTDETAILTBLCreateInput.fromJson(Map<String, dynamic> json) =>
      _$WORKREPORTDETAILTBLCreateInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final String reportId;

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'PROJECT_NM')
  final String projectNm;

  @JsonKey(name: r'PROJECT_SUB_NM')
  final String projectSubNm;

  @JsonKey(name: r'DETAIL_CONTENT')
  final String? detailContent;

  @JsonKey(name: r'WORKER')
  final String? worker;

  @JsonKey(name: r'GRADE')
  final String? grade;

  @JsonKey(name: r'PROCESS_RATE')
  final String? processRate;

  @JsonKey(name: r'WORK_DATE')
  final String? workDate;

  @JsonKey(name: r'PROCESS_TYPE')
  final String? processType;

  @JsonKey(name: r'SUBJECT_YN')
  final String? subjectYn;

  @JsonKey(name: r'REG_USER')
  final String regUser;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'COMPLETE_DATE')
  final String? completeDate;

  @override
  Map<String, dynamic> toJson() => _$WORKREPORTDETAILTBLCreateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTDETAILTBLUncheckedCreateInput implements _i1.JsonSerializable {
  const WORKREPORTDETAILTBLUncheckedCreateInput({
    required this.reportId,
    this.seq,
    required this.projectNm,
    required this.projectSubNm,
    this.detailContent,
    this.worker,
    this.grade,
    this.processRate,
    this.workDate,
    this.processType,
    this.subjectYn,
    required this.regUser,
    this.regDate,
    this.completeDate,
  });

  factory WORKREPORTDETAILTBLUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTDETAILTBLUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final String reportId;

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'PROJECT_NM')
  final String projectNm;

  @JsonKey(name: r'PROJECT_SUB_NM')
  final String projectSubNm;

  @JsonKey(name: r'DETAIL_CONTENT')
  final String? detailContent;

  @JsonKey(name: r'WORKER')
  final String? worker;

  @JsonKey(name: r'GRADE')
  final String? grade;

  @JsonKey(name: r'PROCESS_RATE')
  final String? processRate;

  @JsonKey(name: r'WORK_DATE')
  final String? workDate;

  @JsonKey(name: r'PROCESS_TYPE')
  final String? processType;

  @JsonKey(name: r'SUBJECT_YN')
  final String? subjectYn;

  @JsonKey(name: r'REG_USER')
  final String regUser;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'COMPLETE_DATE')
  final String? completeDate;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTDETAILTBLUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTDETAILTBLUpdateInput implements _i1.JsonSerializable {
  const WORKREPORTDETAILTBLUpdateInput({
    this.reportId,
    this.seq,
    this.projectNm,
    this.projectSubNm,
    this.detailContent,
    this.worker,
    this.grade,
    this.processRate,
    this.workDate,
    this.processType,
    this.subjectYn,
    this.regUser,
    this.regDate,
    this.completeDate,
  });

  factory WORKREPORTDETAILTBLUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$WORKREPORTDETAILTBLUpdateInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final StringFieldUpdateOperationsInput? reportId;

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'PROJECT_NM')
  final StringFieldUpdateOperationsInput? projectNm;

  @JsonKey(name: r'PROJECT_SUB_NM')
  final StringFieldUpdateOperationsInput? projectSubNm;

  @JsonKey(name: r'DETAIL_CONTENT')
  final NullableStringFieldUpdateOperationsInput? detailContent;

  @JsonKey(name: r'WORKER')
  final NullableStringFieldUpdateOperationsInput? worker;

  @JsonKey(name: r'GRADE')
  final NullableStringFieldUpdateOperationsInput? grade;

  @JsonKey(name: r'PROCESS_RATE')
  final NullableStringFieldUpdateOperationsInput? processRate;

  @JsonKey(name: r'WORK_DATE')
  final NullableStringFieldUpdateOperationsInput? workDate;

  @JsonKey(name: r'PROCESS_TYPE')
  final NullableStringFieldUpdateOperationsInput? processType;

  @JsonKey(name: r'SUBJECT_YN')
  final StringFieldUpdateOperationsInput? subjectYn;

  @JsonKey(name: r'REG_USER')
  final StringFieldUpdateOperationsInput? regUser;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'COMPLETE_DATE')
  final NullableStringFieldUpdateOperationsInput? completeDate;

  @override
  Map<String, dynamic> toJson() => _$WORKREPORTDETAILTBLUpdateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTDETAILTBLUncheckedUpdateInput implements _i1.JsonSerializable {
  const WORKREPORTDETAILTBLUncheckedUpdateInput({
    this.reportId,
    this.seq,
    this.projectNm,
    this.projectSubNm,
    this.detailContent,
    this.worker,
    this.grade,
    this.processRate,
    this.workDate,
    this.processType,
    this.subjectYn,
    this.regUser,
    this.regDate,
    this.completeDate,
  });

  factory WORKREPORTDETAILTBLUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTDETAILTBLUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final StringFieldUpdateOperationsInput? reportId;

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'PROJECT_NM')
  final StringFieldUpdateOperationsInput? projectNm;

  @JsonKey(name: r'PROJECT_SUB_NM')
  final StringFieldUpdateOperationsInput? projectSubNm;

  @JsonKey(name: r'DETAIL_CONTENT')
  final NullableStringFieldUpdateOperationsInput? detailContent;

  @JsonKey(name: r'WORKER')
  final NullableStringFieldUpdateOperationsInput? worker;

  @JsonKey(name: r'GRADE')
  final NullableStringFieldUpdateOperationsInput? grade;

  @JsonKey(name: r'PROCESS_RATE')
  final NullableStringFieldUpdateOperationsInput? processRate;

  @JsonKey(name: r'WORK_DATE')
  final NullableStringFieldUpdateOperationsInput? workDate;

  @JsonKey(name: r'PROCESS_TYPE')
  final NullableStringFieldUpdateOperationsInput? processType;

  @JsonKey(name: r'SUBJECT_YN')
  final StringFieldUpdateOperationsInput? subjectYn;

  @JsonKey(name: r'REG_USER')
  final StringFieldUpdateOperationsInput? regUser;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'COMPLETE_DATE')
  final NullableStringFieldUpdateOperationsInput? completeDate;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTDETAILTBLUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTDETAILTBLCreateManyInput implements _i1.JsonSerializable {
  const WORKREPORTDETAILTBLCreateManyInput({
    required this.reportId,
    this.seq,
    required this.projectNm,
    required this.projectSubNm,
    this.detailContent,
    this.worker,
    this.grade,
    this.processRate,
    this.workDate,
    this.processType,
    this.subjectYn,
    required this.regUser,
    this.regDate,
    this.completeDate,
  });

  factory WORKREPORTDETAILTBLCreateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTDETAILTBLCreateManyInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final String reportId;

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'PROJECT_NM')
  final String projectNm;

  @JsonKey(name: r'PROJECT_SUB_NM')
  final String projectSubNm;

  @JsonKey(name: r'DETAIL_CONTENT')
  final String? detailContent;

  @JsonKey(name: r'WORKER')
  final String? worker;

  @JsonKey(name: r'GRADE')
  final String? grade;

  @JsonKey(name: r'PROCESS_RATE')
  final String? processRate;

  @JsonKey(name: r'WORK_DATE')
  final String? workDate;

  @JsonKey(name: r'PROCESS_TYPE')
  final String? processType;

  @JsonKey(name: r'SUBJECT_YN')
  final String? subjectYn;

  @JsonKey(name: r'REG_USER')
  final String regUser;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'COMPLETE_DATE')
  final String? completeDate;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTDETAILTBLCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTDETAILTBLUpdateManyMutationInput
    implements _i1.JsonSerializable {
  const WORKREPORTDETAILTBLUpdateManyMutationInput({
    this.reportId,
    this.seq,
    this.projectNm,
    this.projectSubNm,
    this.detailContent,
    this.worker,
    this.grade,
    this.processRate,
    this.workDate,
    this.processType,
    this.subjectYn,
    this.regUser,
    this.regDate,
    this.completeDate,
  });

  factory WORKREPORTDETAILTBLUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTDETAILTBLUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final StringFieldUpdateOperationsInput? reportId;

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'PROJECT_NM')
  final StringFieldUpdateOperationsInput? projectNm;

  @JsonKey(name: r'PROJECT_SUB_NM')
  final StringFieldUpdateOperationsInput? projectSubNm;

  @JsonKey(name: r'DETAIL_CONTENT')
  final NullableStringFieldUpdateOperationsInput? detailContent;

  @JsonKey(name: r'WORKER')
  final NullableStringFieldUpdateOperationsInput? worker;

  @JsonKey(name: r'GRADE')
  final NullableStringFieldUpdateOperationsInput? grade;

  @JsonKey(name: r'PROCESS_RATE')
  final NullableStringFieldUpdateOperationsInput? processRate;

  @JsonKey(name: r'WORK_DATE')
  final NullableStringFieldUpdateOperationsInput? workDate;

  @JsonKey(name: r'PROCESS_TYPE')
  final NullableStringFieldUpdateOperationsInput? processType;

  @JsonKey(name: r'SUBJECT_YN')
  final StringFieldUpdateOperationsInput? subjectYn;

  @JsonKey(name: r'REG_USER')
  final StringFieldUpdateOperationsInput? regUser;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'COMPLETE_DATE')
  final NullableStringFieldUpdateOperationsInput? completeDate;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTDETAILTBLUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTDETAILTBLUncheckedUpdateManyInput
    implements _i1.JsonSerializable {
  const WORKREPORTDETAILTBLUncheckedUpdateManyInput({
    this.reportId,
    this.seq,
    this.projectNm,
    this.projectSubNm,
    this.detailContent,
    this.worker,
    this.grade,
    this.processRate,
    this.workDate,
    this.processType,
    this.subjectYn,
    this.regUser,
    this.regDate,
    this.completeDate,
  });

  factory WORKREPORTDETAILTBLUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTDETAILTBLUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final StringFieldUpdateOperationsInput? reportId;

  @JsonKey(name: r'SEQ')
  final BigIntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'PROJECT_NM')
  final StringFieldUpdateOperationsInput? projectNm;

  @JsonKey(name: r'PROJECT_SUB_NM')
  final StringFieldUpdateOperationsInput? projectSubNm;

  @JsonKey(name: r'DETAIL_CONTENT')
  final NullableStringFieldUpdateOperationsInput? detailContent;

  @JsonKey(name: r'WORKER')
  final NullableStringFieldUpdateOperationsInput? worker;

  @JsonKey(name: r'GRADE')
  final NullableStringFieldUpdateOperationsInput? grade;

  @JsonKey(name: r'PROCESS_RATE')
  final NullableStringFieldUpdateOperationsInput? processRate;

  @JsonKey(name: r'WORK_DATE')
  final NullableStringFieldUpdateOperationsInput? workDate;

  @JsonKey(name: r'PROCESS_TYPE')
  final NullableStringFieldUpdateOperationsInput? processType;

  @JsonKey(name: r'SUBJECT_YN')
  final StringFieldUpdateOperationsInput? subjectYn;

  @JsonKey(name: r'REG_USER')
  final StringFieldUpdateOperationsInput? regUser;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'COMPLETE_DATE')
  final NullableStringFieldUpdateOperationsInput? completeDate;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTDETAILTBLUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLCreateInput implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLCreateInput({
    required this.reportId,
    required this.userId,
    required this.title,
    this.htmlContent,
    this.regDate,
    this.delYn,
  });

  factory WORKREPORTHTMLTBLCreateInput.fromJson(Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLCreateInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final String reportId;

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'TITLE')
  final String title;

  @JsonKey(name: r'HTML_CONTENT')
  final String? htmlContent;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() => _$WORKREPORTHTMLTBLCreateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLUncheckedCreateInput implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLUncheckedCreateInput({
    required this.reportId,
    required this.userId,
    required this.title,
    this.htmlContent,
    this.regDate,
    this.delYn,
  });

  factory WORKREPORTHTMLTBLUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final String reportId;

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'TITLE')
  final String title;

  @JsonKey(name: r'HTML_CONTENT')
  final String? htmlContent;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTHTMLTBLUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLUpdateInput implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLUpdateInput({
    this.reportId,
    this.userId,
    this.title,
    this.htmlContent,
    this.regDate,
    this.delYn,
  });

  factory WORKREPORTHTMLTBLUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLUpdateInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final StringFieldUpdateOperationsInput? reportId;

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'TITLE')
  final StringFieldUpdateOperationsInput? title;

  @JsonKey(name: r'HTML_CONTENT')
  final NullableStringFieldUpdateOperationsInput? htmlContent;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() => _$WORKREPORTHTMLTBLUpdateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLUncheckedUpdateInput implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLUncheckedUpdateInput({
    this.reportId,
    this.userId,
    this.title,
    this.htmlContent,
    this.regDate,
    this.delYn,
  });

  factory WORKREPORTHTMLTBLUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final StringFieldUpdateOperationsInput? reportId;

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'TITLE')
  final StringFieldUpdateOperationsInput? title;

  @JsonKey(name: r'HTML_CONTENT')
  final NullableStringFieldUpdateOperationsInput? htmlContent;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTHTMLTBLUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLCreateManyInput implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLCreateManyInput({
    required this.reportId,
    required this.userId,
    required this.title,
    this.htmlContent,
    this.regDate,
    this.delYn,
  });

  factory WORKREPORTHTMLTBLCreateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLCreateManyInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final String reportId;

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'TITLE')
  final String title;

  @JsonKey(name: r'HTML_CONTENT')
  final String? htmlContent;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTHTMLTBLCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLUpdateManyMutationInput implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLUpdateManyMutationInput({
    this.reportId,
    this.userId,
    this.title,
    this.htmlContent,
    this.regDate,
    this.delYn,
  });

  factory WORKREPORTHTMLTBLUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final StringFieldUpdateOperationsInput? reportId;

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'TITLE')
  final StringFieldUpdateOperationsInput? title;

  @JsonKey(name: r'HTML_CONTENT')
  final NullableStringFieldUpdateOperationsInput? htmlContent;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTHTMLTBLUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLUncheckedUpdateManyInput
    implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLUncheckedUpdateManyInput({
    this.reportId,
    this.userId,
    this.title,
    this.htmlContent,
    this.regDate,
    this.delYn,
  });

  factory WORKREPORTHTMLTBLUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final StringFieldUpdateOperationsInput? reportId;

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'TITLE')
  final StringFieldUpdateOperationsInput? title;

  @JsonKey(name: r'HTML_CONTENT')
  final NullableStringFieldUpdateOperationsInput? htmlContent;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTHTMLTBLUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLBACKCreateInput implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLBACKCreateInput({
    required this.reportId,
    required this.userId,
    required this.title,
    this.htmlContent,
    this.regDate,
    this.delYn,
  });

  factory WORKREPORTHTMLTBLBACKCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLBACKCreateInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final String reportId;

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'TITLE')
  final String title;

  @JsonKey(name: r'HTML_CONTENT')
  final String? htmlContent;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTHTMLTBLBACKCreateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLBACKUncheckedCreateInput
    implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLBACKUncheckedCreateInput({
    required this.reportId,
    required this.userId,
    required this.title,
    this.htmlContent,
    this.regDate,
    this.delYn,
  });

  factory WORKREPORTHTMLTBLBACKUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLBACKUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final String reportId;

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'TITLE')
  final String title;

  @JsonKey(name: r'HTML_CONTENT')
  final String? htmlContent;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTHTMLTBLBACKUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLBACKUpdateInput implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLBACKUpdateInput({
    this.reportId,
    this.userId,
    this.title,
    this.htmlContent,
    this.regDate,
    this.delYn,
  });

  factory WORKREPORTHTMLTBLBACKUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLBACKUpdateInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final StringFieldUpdateOperationsInput? reportId;

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'TITLE')
  final StringFieldUpdateOperationsInput? title;

  @JsonKey(name: r'HTML_CONTENT')
  final NullableStringFieldUpdateOperationsInput? htmlContent;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTHTMLTBLBACKUpdateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLBACKUncheckedUpdateInput
    implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLBACKUncheckedUpdateInput({
    this.reportId,
    this.userId,
    this.title,
    this.htmlContent,
    this.regDate,
    this.delYn,
  });

  factory WORKREPORTHTMLTBLBACKUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLBACKUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final StringFieldUpdateOperationsInput? reportId;

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'TITLE')
  final StringFieldUpdateOperationsInput? title;

  @JsonKey(name: r'HTML_CONTENT')
  final NullableStringFieldUpdateOperationsInput? htmlContent;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTHTMLTBLBACKUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLBACKCreateManyInput implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLBACKCreateManyInput({
    required this.reportId,
    required this.userId,
    required this.title,
    this.htmlContent,
    this.regDate,
    this.delYn,
  });

  factory WORKREPORTHTMLTBLBACKCreateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLBACKCreateManyInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final String reportId;

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'TITLE')
  final String title;

  @JsonKey(name: r'HTML_CONTENT')
  final String? htmlContent;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTHTMLTBLBACKCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLBACKUpdateManyMutationInput
    implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLBACKUpdateManyMutationInput({
    this.reportId,
    this.userId,
    this.title,
    this.htmlContent,
    this.regDate,
    this.delYn,
  });

  factory WORKREPORTHTMLTBLBACKUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLBACKUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final StringFieldUpdateOperationsInput? reportId;

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'TITLE')
  final StringFieldUpdateOperationsInput? title;

  @JsonKey(name: r'HTML_CONTENT')
  final NullableStringFieldUpdateOperationsInput? htmlContent;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTHTMLTBLBACKUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLBACKUncheckedUpdateManyInput
    implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLBACKUncheckedUpdateManyInput({
    this.reportId,
    this.userId,
    this.title,
    this.htmlContent,
    this.regDate,
    this.delYn,
  });

  factory WORKREPORTHTMLTBLBACKUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLBACKUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final StringFieldUpdateOperationsInput? reportId;

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'TITLE')
  final StringFieldUpdateOperationsInput? title;

  @JsonKey(name: r'HTML_CONTENT')
  final NullableStringFieldUpdateOperationsInput? htmlContent;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTHTMLTBLBACKUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTMASTERTBLCreateInput implements _i1.JsonSerializable {
  const WORKREPORTMASTERTBLCreateInput({
    required this.reportId,
    required this.title,
    required this.dept,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory WORKREPORTMASTERTBLCreateInput.fromJson(Map<String, dynamic> json) =>
      _$WORKREPORTMASTERTBLCreateInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final String reportId;

  @JsonKey(name: r'TITLE')
  final String title;

  @JsonKey(name: r'DEPT')
  final String dept;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() => _$WORKREPORTMASTERTBLCreateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTMASTERTBLUncheckedCreateInput implements _i1.JsonSerializable {
  const WORKREPORTMASTERTBLUncheckedCreateInput({
    required this.reportId,
    required this.title,
    required this.dept,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory WORKREPORTMASTERTBLUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTMASTERTBLUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final String reportId;

  @JsonKey(name: r'TITLE')
  final String title;

  @JsonKey(name: r'DEPT')
  final String dept;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTMASTERTBLUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTMASTERTBLUpdateInput implements _i1.JsonSerializable {
  const WORKREPORTMASTERTBLUpdateInput({
    this.reportId,
    this.title,
    this.dept,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory WORKREPORTMASTERTBLUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$WORKREPORTMASTERTBLUpdateInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final StringFieldUpdateOperationsInput? reportId;

  @JsonKey(name: r'TITLE')
  final StringFieldUpdateOperationsInput? title;

  @JsonKey(name: r'DEPT')
  final StringFieldUpdateOperationsInput? dept;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() => _$WORKREPORTMASTERTBLUpdateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTMASTERTBLUncheckedUpdateInput implements _i1.JsonSerializable {
  const WORKREPORTMASTERTBLUncheckedUpdateInput({
    this.reportId,
    this.title,
    this.dept,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory WORKREPORTMASTERTBLUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTMASTERTBLUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final StringFieldUpdateOperationsInput? reportId;

  @JsonKey(name: r'TITLE')
  final StringFieldUpdateOperationsInput? title;

  @JsonKey(name: r'DEPT')
  final StringFieldUpdateOperationsInput? dept;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTMASTERTBLUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTMASTERTBLCreateManyInput implements _i1.JsonSerializable {
  const WORKREPORTMASTERTBLCreateManyInput({
    required this.reportId,
    required this.title,
    required this.dept,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory WORKREPORTMASTERTBLCreateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTMASTERTBLCreateManyInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final String reportId;

  @JsonKey(name: r'TITLE')
  final String title;

  @JsonKey(name: r'DEPT')
  final String dept;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTMASTERTBLCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTMASTERTBLUpdateManyMutationInput
    implements _i1.JsonSerializable {
  const WORKREPORTMASTERTBLUpdateManyMutationInput({
    this.reportId,
    this.title,
    this.dept,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory WORKREPORTMASTERTBLUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTMASTERTBLUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final StringFieldUpdateOperationsInput? reportId;

  @JsonKey(name: r'TITLE')
  final StringFieldUpdateOperationsInput? title;

  @JsonKey(name: r'DEPT')
  final StringFieldUpdateOperationsInput? dept;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTMASTERTBLUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTMASTERTBLUncheckedUpdateManyInput
    implements _i1.JsonSerializable {
  const WORKREPORTMASTERTBLUncheckedUpdateManyInput({
    this.reportId,
    this.title,
    this.dept,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory WORKREPORTMASTERTBLUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTMASTERTBLUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final StringFieldUpdateOperationsInput? reportId;

  @JsonKey(name: r'TITLE')
  final StringFieldUpdateOperationsInput? title;

  @JsonKey(name: r'DEPT')
  final StringFieldUpdateOperationsInput? dept;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTMASTERTBLUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTMSTCreateInput implements _i1.JsonSerializable {
  const WORKREQUESTMSTCreateInput({
    required this.seq,
    required this.rqstrDpnm,
    required this.rqstrNm,
    required this.rqstrId,
    required this.rqstrDate,
    required this.hopeDate,
    required this.chrDprNm,
    required this.chrNm,
    required this.chrId,
    this.chrChk,
    required this.title,
    required this.cn,
    this.etc,
    this.doc,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory WORKREQUESTMSTCreateInput.fromJson(Map<String, dynamic> json) =>
      _$WORKREQUESTMSTCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'RQSTR_DPNM')
  final String rqstrDpnm;

  @JsonKey(name: r'RQSTR_NM')
  final String rqstrNm;

  @JsonKey(name: r'RQSTR_ID')
  final String rqstrId;

  @JsonKey(name: r'RQSTR_DATE')
  final String rqstrDate;

  @JsonKey(name: r'HOPE_DATE')
  final String hopeDate;

  @JsonKey(name: r'CHR_DPR_NM')
  final String chrDprNm;

  @JsonKey(name: r'CHR_NM')
  final String chrNm;

  @JsonKey(name: r'CHR_ID')
  final String chrId;

  @JsonKey(name: r'CHR_CHK')
  final String? chrChk;

  @JsonKey(name: r'TITLE')
  final String title;

  @JsonKey(name: r'CN')
  final String cn;

  @JsonKey(name: r'ETC')
  final String? etc;

  @JsonKey(name: r'DOC')
  final String? doc;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$WORKREQUESTMSTCreateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTMSTUncheckedCreateInput implements _i1.JsonSerializable {
  const WORKREQUESTMSTUncheckedCreateInput({
    required this.seq,
    required this.rqstrDpnm,
    required this.rqstrNm,
    required this.rqstrId,
    required this.rqstrDate,
    required this.hopeDate,
    required this.chrDprNm,
    required this.chrNm,
    required this.chrId,
    this.chrChk,
    required this.title,
    required this.cn,
    this.etc,
    this.doc,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory WORKREQUESTMSTUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREQUESTMSTUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'RQSTR_DPNM')
  final String rqstrDpnm;

  @JsonKey(name: r'RQSTR_NM')
  final String rqstrNm;

  @JsonKey(name: r'RQSTR_ID')
  final String rqstrId;

  @JsonKey(name: r'RQSTR_DATE')
  final String rqstrDate;

  @JsonKey(name: r'HOPE_DATE')
  final String hopeDate;

  @JsonKey(name: r'CHR_DPR_NM')
  final String chrDprNm;

  @JsonKey(name: r'CHR_NM')
  final String chrNm;

  @JsonKey(name: r'CHR_ID')
  final String chrId;

  @JsonKey(name: r'CHR_CHK')
  final String? chrChk;

  @JsonKey(name: r'TITLE')
  final String title;

  @JsonKey(name: r'CN')
  final String cn;

  @JsonKey(name: r'ETC')
  final String? etc;

  @JsonKey(name: r'DOC')
  final String? doc;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREQUESTMSTUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTMSTUpdateInput implements _i1.JsonSerializable {
  const WORKREQUESTMSTUpdateInput({
    this.seq,
    this.rqstrDpnm,
    this.rqstrNm,
    this.rqstrId,
    this.rqstrDate,
    this.hopeDate,
    this.chrDprNm,
    this.chrNm,
    this.chrId,
    this.chrChk,
    this.title,
    this.cn,
    this.etc,
    this.doc,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory WORKREQUESTMSTUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$WORKREQUESTMSTUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'RQSTR_DPNM')
  final StringFieldUpdateOperationsInput? rqstrDpnm;

  @JsonKey(name: r'RQSTR_NM')
  final StringFieldUpdateOperationsInput? rqstrNm;

  @JsonKey(name: r'RQSTR_ID')
  final StringFieldUpdateOperationsInput? rqstrId;

  @JsonKey(name: r'RQSTR_DATE')
  final StringFieldUpdateOperationsInput? rqstrDate;

  @JsonKey(name: r'HOPE_DATE')
  final StringFieldUpdateOperationsInput? hopeDate;

  @JsonKey(name: r'CHR_DPR_NM')
  final StringFieldUpdateOperationsInput? chrDprNm;

  @JsonKey(name: r'CHR_NM')
  final StringFieldUpdateOperationsInput? chrNm;

  @JsonKey(name: r'CHR_ID')
  final StringFieldUpdateOperationsInput? chrId;

  @JsonKey(name: r'CHR_CHK')
  final NullableStringFieldUpdateOperationsInput? chrChk;

  @JsonKey(name: r'TITLE')
  final StringFieldUpdateOperationsInput? title;

  @JsonKey(name: r'CN')
  final StringFieldUpdateOperationsInput? cn;

  @JsonKey(name: r'ETC')
  final NullableStringFieldUpdateOperationsInput? etc;

  @JsonKey(name: r'DOC')
  final NullableStringFieldUpdateOperationsInput? doc;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$WORKREQUESTMSTUpdateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTMSTUncheckedUpdateInput implements _i1.JsonSerializable {
  const WORKREQUESTMSTUncheckedUpdateInput({
    this.seq,
    this.rqstrDpnm,
    this.rqstrNm,
    this.rqstrId,
    this.rqstrDate,
    this.hopeDate,
    this.chrDprNm,
    this.chrNm,
    this.chrId,
    this.chrChk,
    this.title,
    this.cn,
    this.etc,
    this.doc,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory WORKREQUESTMSTUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREQUESTMSTUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'RQSTR_DPNM')
  final StringFieldUpdateOperationsInput? rqstrDpnm;

  @JsonKey(name: r'RQSTR_NM')
  final StringFieldUpdateOperationsInput? rqstrNm;

  @JsonKey(name: r'RQSTR_ID')
  final StringFieldUpdateOperationsInput? rqstrId;

  @JsonKey(name: r'RQSTR_DATE')
  final StringFieldUpdateOperationsInput? rqstrDate;

  @JsonKey(name: r'HOPE_DATE')
  final StringFieldUpdateOperationsInput? hopeDate;

  @JsonKey(name: r'CHR_DPR_NM')
  final StringFieldUpdateOperationsInput? chrDprNm;

  @JsonKey(name: r'CHR_NM')
  final StringFieldUpdateOperationsInput? chrNm;

  @JsonKey(name: r'CHR_ID')
  final StringFieldUpdateOperationsInput? chrId;

  @JsonKey(name: r'CHR_CHK')
  final NullableStringFieldUpdateOperationsInput? chrChk;

  @JsonKey(name: r'TITLE')
  final StringFieldUpdateOperationsInput? title;

  @JsonKey(name: r'CN')
  final StringFieldUpdateOperationsInput? cn;

  @JsonKey(name: r'ETC')
  final NullableStringFieldUpdateOperationsInput? etc;

  @JsonKey(name: r'DOC')
  final NullableStringFieldUpdateOperationsInput? doc;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREQUESTMSTUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTMSTCreateManyInput implements _i1.JsonSerializable {
  const WORKREQUESTMSTCreateManyInput({
    required this.seq,
    required this.rqstrDpnm,
    required this.rqstrNm,
    required this.rqstrId,
    required this.rqstrDate,
    required this.hopeDate,
    required this.chrDprNm,
    required this.chrNm,
    required this.chrId,
    this.chrChk,
    required this.title,
    required this.cn,
    this.etc,
    this.doc,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory WORKREQUESTMSTCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$WORKREQUESTMSTCreateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'RQSTR_DPNM')
  final String rqstrDpnm;

  @JsonKey(name: r'RQSTR_NM')
  final String rqstrNm;

  @JsonKey(name: r'RQSTR_ID')
  final String rqstrId;

  @JsonKey(name: r'RQSTR_DATE')
  final String rqstrDate;

  @JsonKey(name: r'HOPE_DATE')
  final String hopeDate;

  @JsonKey(name: r'CHR_DPR_NM')
  final String chrDprNm;

  @JsonKey(name: r'CHR_NM')
  final String chrNm;

  @JsonKey(name: r'CHR_ID')
  final String chrId;

  @JsonKey(name: r'CHR_CHK')
  final String? chrChk;

  @JsonKey(name: r'TITLE')
  final String title;

  @JsonKey(name: r'CN')
  final String cn;

  @JsonKey(name: r'ETC')
  final String? etc;

  @JsonKey(name: r'DOC')
  final String? doc;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$WORKREQUESTMSTCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTMSTUpdateManyMutationInput implements _i1.JsonSerializable {
  const WORKREQUESTMSTUpdateManyMutationInput({
    this.seq,
    this.rqstrDpnm,
    this.rqstrNm,
    this.rqstrId,
    this.rqstrDate,
    this.hopeDate,
    this.chrDprNm,
    this.chrNm,
    this.chrId,
    this.chrChk,
    this.title,
    this.cn,
    this.etc,
    this.doc,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory WORKREQUESTMSTUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREQUESTMSTUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'RQSTR_DPNM')
  final StringFieldUpdateOperationsInput? rqstrDpnm;

  @JsonKey(name: r'RQSTR_NM')
  final StringFieldUpdateOperationsInput? rqstrNm;

  @JsonKey(name: r'RQSTR_ID')
  final StringFieldUpdateOperationsInput? rqstrId;

  @JsonKey(name: r'RQSTR_DATE')
  final StringFieldUpdateOperationsInput? rqstrDate;

  @JsonKey(name: r'HOPE_DATE')
  final StringFieldUpdateOperationsInput? hopeDate;

  @JsonKey(name: r'CHR_DPR_NM')
  final StringFieldUpdateOperationsInput? chrDprNm;

  @JsonKey(name: r'CHR_NM')
  final StringFieldUpdateOperationsInput? chrNm;

  @JsonKey(name: r'CHR_ID')
  final StringFieldUpdateOperationsInput? chrId;

  @JsonKey(name: r'CHR_CHK')
  final NullableStringFieldUpdateOperationsInput? chrChk;

  @JsonKey(name: r'TITLE')
  final StringFieldUpdateOperationsInput? title;

  @JsonKey(name: r'CN')
  final StringFieldUpdateOperationsInput? cn;

  @JsonKey(name: r'ETC')
  final NullableStringFieldUpdateOperationsInput? etc;

  @JsonKey(name: r'DOC')
  final NullableStringFieldUpdateOperationsInput? doc;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREQUESTMSTUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTMSTUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const WORKREQUESTMSTUncheckedUpdateManyInput({
    this.seq,
    this.rqstrDpnm,
    this.rqstrNm,
    this.rqstrId,
    this.rqstrDate,
    this.hopeDate,
    this.chrDprNm,
    this.chrNm,
    this.chrId,
    this.chrChk,
    this.title,
    this.cn,
    this.etc,
    this.doc,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory WORKREQUESTMSTUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREQUESTMSTUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'RQSTR_DPNM')
  final StringFieldUpdateOperationsInput? rqstrDpnm;

  @JsonKey(name: r'RQSTR_NM')
  final StringFieldUpdateOperationsInput? rqstrNm;

  @JsonKey(name: r'RQSTR_ID')
  final StringFieldUpdateOperationsInput? rqstrId;

  @JsonKey(name: r'RQSTR_DATE')
  final StringFieldUpdateOperationsInput? rqstrDate;

  @JsonKey(name: r'HOPE_DATE')
  final StringFieldUpdateOperationsInput? hopeDate;

  @JsonKey(name: r'CHR_DPR_NM')
  final StringFieldUpdateOperationsInput? chrDprNm;

  @JsonKey(name: r'CHR_NM')
  final StringFieldUpdateOperationsInput? chrNm;

  @JsonKey(name: r'CHR_ID')
  final StringFieldUpdateOperationsInput? chrId;

  @JsonKey(name: r'CHR_CHK')
  final NullableStringFieldUpdateOperationsInput? chrChk;

  @JsonKey(name: r'TITLE')
  final StringFieldUpdateOperationsInput? title;

  @JsonKey(name: r'CN')
  final StringFieldUpdateOperationsInput? cn;

  @JsonKey(name: r'ETC')
  final NullableStringFieldUpdateOperationsInput? etc;

  @JsonKey(name: r'DOC')
  final NullableStringFieldUpdateOperationsInput? doc;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREQUESTMSTUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTREFCreateInput implements _i1.JsonSerializable {
  const WORKREQUESTREFCreateInput({
    required this.seq,
    required this.mseq,
    required this.refId,
    this.refNm,
    this.refDep,
    this.refGrade,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory WORKREQUESTREFCreateInput.fromJson(Map<String, dynamic> json) =>
      _$WORKREQUESTREFCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'MSEQ')
  final int mseq;

  @JsonKey(name: r'REF_ID')
  final String refId;

  @JsonKey(name: r'REF_NM')
  final String? refNm;

  @JsonKey(name: r'REF_DEP')
  final String? refDep;

  @JsonKey(name: r'REF_GRADE')
  final String? refGrade;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$WORKREQUESTREFCreateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTREFUncheckedCreateInput implements _i1.JsonSerializable {
  const WORKREQUESTREFUncheckedCreateInput({
    required this.seq,
    required this.mseq,
    required this.refId,
    this.refNm,
    this.refDep,
    this.refGrade,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory WORKREQUESTREFUncheckedCreateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREQUESTREFUncheckedCreateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'MSEQ')
  final int mseq;

  @JsonKey(name: r'REF_ID')
  final String refId;

  @JsonKey(name: r'REF_NM')
  final String? refNm;

  @JsonKey(name: r'REF_DEP')
  final String? refDep;

  @JsonKey(name: r'REF_GRADE')
  final String? refGrade;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREQUESTREFUncheckedCreateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTREFUpdateInput implements _i1.JsonSerializable {
  const WORKREQUESTREFUpdateInput({
    this.seq,
    this.mseq,
    this.refId,
    this.refNm,
    this.refDep,
    this.refGrade,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory WORKREQUESTREFUpdateInput.fromJson(Map<String, dynamic> json) =>
      _$WORKREQUESTREFUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'MSEQ')
  final IntFieldUpdateOperationsInput? mseq;

  @JsonKey(name: r'REF_ID')
  final StringFieldUpdateOperationsInput? refId;

  @JsonKey(name: r'REF_NM')
  final NullableStringFieldUpdateOperationsInput? refNm;

  @JsonKey(name: r'REF_DEP')
  final NullableStringFieldUpdateOperationsInput? refDep;

  @JsonKey(name: r'REF_GRADE')
  final NullableStringFieldUpdateOperationsInput? refGrade;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() => _$WORKREQUESTREFUpdateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTREFUncheckedUpdateInput implements _i1.JsonSerializable {
  const WORKREQUESTREFUncheckedUpdateInput({
    this.seq,
    this.mseq,
    this.refId,
    this.refNm,
    this.refDep,
    this.refGrade,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory WORKREQUESTREFUncheckedUpdateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREQUESTREFUncheckedUpdateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'MSEQ')
  final IntFieldUpdateOperationsInput? mseq;

  @JsonKey(name: r'REF_ID')
  final StringFieldUpdateOperationsInput? refId;

  @JsonKey(name: r'REF_NM')
  final NullableStringFieldUpdateOperationsInput? refNm;

  @JsonKey(name: r'REF_DEP')
  final NullableStringFieldUpdateOperationsInput? refDep;

  @JsonKey(name: r'REF_GRADE')
  final NullableStringFieldUpdateOperationsInput? refGrade;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREQUESTREFUncheckedUpdateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTREFCreateManyInput implements _i1.JsonSerializable {
  const WORKREQUESTREFCreateManyInput({
    required this.seq,
    required this.mseq,
    required this.refId,
    this.refNm,
    this.refDep,
    this.refGrade,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory WORKREQUESTREFCreateManyInput.fromJson(Map<String, dynamic> json) =>
      _$WORKREQUESTREFCreateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'MSEQ')
  final int mseq;

  @JsonKey(name: r'REF_ID')
  final String refId;

  @JsonKey(name: r'REF_NM')
  final String? refNm;

  @JsonKey(name: r'REF_DEP')
  final String? refDep;

  @JsonKey(name: r'REF_GRADE')
  final String? refGrade;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$WORKREQUESTREFCreateManyInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTREFUpdateManyMutationInput implements _i1.JsonSerializable {
  const WORKREQUESTREFUpdateManyMutationInput({
    this.seq,
    this.mseq,
    this.refId,
    this.refNm,
    this.refDep,
    this.refGrade,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory WORKREQUESTREFUpdateManyMutationInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREQUESTREFUpdateManyMutationInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'MSEQ')
  final IntFieldUpdateOperationsInput? mseq;

  @JsonKey(name: r'REF_ID')
  final StringFieldUpdateOperationsInput? refId;

  @JsonKey(name: r'REF_NM')
  final NullableStringFieldUpdateOperationsInput? refNm;

  @JsonKey(name: r'REF_DEP')
  final NullableStringFieldUpdateOperationsInput? refDep;

  @JsonKey(name: r'REF_GRADE')
  final NullableStringFieldUpdateOperationsInput? refGrade;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREQUESTREFUpdateManyMutationInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTREFUncheckedUpdateManyInput implements _i1.JsonSerializable {
  const WORKREQUESTREFUncheckedUpdateManyInput({
    this.seq,
    this.mseq,
    this.refId,
    this.refNm,
    this.refDep,
    this.refGrade,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory WORKREQUESTREFUncheckedUpdateManyInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREQUESTREFUncheckedUpdateManyInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final IntFieldUpdateOperationsInput? seq;

  @JsonKey(name: r'MSEQ')
  final IntFieldUpdateOperationsInput? mseq;

  @JsonKey(name: r'REF_ID')
  final StringFieldUpdateOperationsInput? refId;

  @JsonKey(name: r'REF_NM')
  final NullableStringFieldUpdateOperationsInput? refNm;

  @JsonKey(name: r'REF_DEP')
  final NullableStringFieldUpdateOperationsInput? refDep;

  @JsonKey(name: r'REF_GRADE')
  final NullableStringFieldUpdateOperationsInput? refGrade;

  @JsonKey(name: r'REG_ID')
  final StringFieldUpdateOperationsInput? regId;

  @JsonKey(name: r'REG_DATE')
  final StringFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'EDIT_ID')
  final NullableStringFieldUpdateOperationsInput? editId;

  @JsonKey(name: r'EDIT_DATE')
  final NullableStringFieldUpdateOperationsInput? editDate;

  @JsonKey(name: r'DEL_ID')
  final NullableStringFieldUpdateOperationsInput? delId;

  @JsonKey(name: r'DEL_DATE')
  final NullableStringFieldUpdateOperationsInput? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREQUESTREFUncheckedUpdateManyInputToJson(this);
}

@_i1.jsonSerializable
class StringFilter implements _i1.JsonSerializable {
  const StringFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
  });

  factory StringFilter.fromJson(Map<String, dynamic> json) =>
      _$StringFilterFromJson(json);

  final String? equals;

  @JsonKey(name: r'in')
  final Iterable<String>? $in;

  final Iterable<String>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  final NestedStringFilter? not;

  @override
  Map<String, dynamic> toJson() => _$StringFilterToJson(this);
}

@_i1.jsonSerializable
class StringNullableFilter implements _i1.JsonSerializable {
  const StringNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
  });

  factory StringNullableFilter.fromJson(Map<String, dynamic> json) =>
      _$StringNullableFilterFromJson(json);

  final String? equals;

  @JsonKey(name: r'in')
  final Iterable<String>? $in;

  final Iterable<String>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  final NestedStringNullableFilter? not;

  @override
  Map<String, dynamic> toJson() => _$StringNullableFilterToJson(this);
}

@_i1.jsonSerializable
class IntNullableFilter implements _i1.JsonSerializable {
  const IntNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  factory IntNullableFilter.fromJson(Map<String, dynamic> json) =>
      _$IntNullableFilterFromJson(json);

  final int? equals;

  @JsonKey(name: r'in')
  final Iterable<int>? $in;

  final Iterable<int>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final NestedIntNullableFilter? not;

  @override
  Map<String, dynamic> toJson() => _$IntNullableFilterToJson(this);
}

@_i1.jsonSerializable
class DateTimeFilter implements _i1.JsonSerializable {
  const DateTimeFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  factory DateTimeFilter.fromJson(Map<String, dynamic> json) =>
      _$DateTimeFilterFromJson(json);

  final DateTime? equals;

  @JsonKey(name: r'in')
  final Iterable<DateTime>? $in;

  final Iterable<DateTime>? notIn;

  final DateTime? lt;

  final DateTime? lte;

  final DateTime? gt;

  final DateTime? gte;

  final NestedDateTimeFilter? not;

  @override
  Map<String, dynamic> toJson() => _$DateTimeFilterToJson(this);
}

@_i1.jsonSerializable
class SortOrderInput implements _i1.JsonSerializable {
  const SortOrderInput({
    required this.sort,
    this.nulls,
  });

  factory SortOrderInput.fromJson(Map<String, dynamic> json) =>
      _$SortOrderInputFromJson(json);

  final SortOrder sort;

  final NullsOrder? nulls;

  @override
  Map<String, dynamic> toJson() => _$SortOrderInputToJson(this);
}

@_i1.jsonSerializable
class ALLCODETBLCODETYPEUNITTYPECompoundUniqueInput
    implements _i1.JsonSerializable {
  const ALLCODETBLCODETYPEUNITTYPECompoundUniqueInput({
    required this.codeType,
    required this.unitType,
  });

  factory ALLCODETBLCODETYPEUNITTYPECompoundUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$ALLCODETBLCODETYPEUNITTYPECompoundUniqueInputFromJson(json);

  @JsonKey(name: r'CODE_TYPE')
  final String codeType;

  @JsonKey(name: r'UNIT_TYPE')
  final String unitType;

  @override
  Map<String, dynamic> toJson() =>
      _$ALLCODETBLCODETYPEUNITTYPECompoundUniqueInputToJson(this);
}

@_i1.jsonSerializable
class ALLCODETBLCountOrderByAggregateInput implements _i1.JsonSerializable {
  const ALLCODETBLCountOrderByAggregateInput({
    this.codeType,
    this.codeName,
    this.unitType,
    this.unitName,
    this.sort,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory ALLCODETBLCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$ALLCODETBLCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'CODE_TYPE')
  final SortOrder? codeType;

  @JsonKey(name: r'CODE_NAME')
  final SortOrder? codeName;

  @JsonKey(name: r'UNIT_TYPE')
  final SortOrder? unitType;

  @JsonKey(name: r'UNIT_NAME')
  final SortOrder? unitName;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$ALLCODETBLCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class ALLCODETBLAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const ALLCODETBLAvgOrderByAggregateInput({this.sort});

  factory ALLCODETBLAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$ALLCODETBLAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @override
  Map<String, dynamic> toJson() =>
      _$ALLCODETBLAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class ALLCODETBLMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const ALLCODETBLMaxOrderByAggregateInput({
    this.codeType,
    this.codeName,
    this.unitType,
    this.unitName,
    this.sort,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory ALLCODETBLMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$ALLCODETBLMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'CODE_TYPE')
  final SortOrder? codeType;

  @JsonKey(name: r'CODE_NAME')
  final SortOrder? codeName;

  @JsonKey(name: r'UNIT_TYPE')
  final SortOrder? unitType;

  @JsonKey(name: r'UNIT_NAME')
  final SortOrder? unitName;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$ALLCODETBLMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class ALLCODETBLMinOrderByAggregateInput implements _i1.JsonSerializable {
  const ALLCODETBLMinOrderByAggregateInput({
    this.codeType,
    this.codeName,
    this.unitType,
    this.unitName,
    this.sort,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory ALLCODETBLMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$ALLCODETBLMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'CODE_TYPE')
  final SortOrder? codeType;

  @JsonKey(name: r'CODE_NAME')
  final SortOrder? codeName;

  @JsonKey(name: r'UNIT_TYPE')
  final SortOrder? unitType;

  @JsonKey(name: r'UNIT_NAME')
  final SortOrder? unitName;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$ALLCODETBLMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class ALLCODETBLSumOrderByAggregateInput implements _i1.JsonSerializable {
  const ALLCODETBLSumOrderByAggregateInput({this.sort});

  factory ALLCODETBLSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$ALLCODETBLSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @override
  Map<String, dynamic> toJson() =>
      _$ALLCODETBLSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class StringWithAggregatesFilter implements _i1.JsonSerializable {
  const StringWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  factory StringWithAggregatesFilter.fromJson(Map<String, dynamic> json) =>
      _$StringWithAggregatesFilterFromJson(json);

  final String? equals;

  @JsonKey(name: r'in')
  final Iterable<String>? $in;

  final Iterable<String>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  final NestedStringWithAggregatesFilter? not;

  @JsonKey(name: r'_count')
  final NestedIntFilter? $count;

  @JsonKey(name: r'_min')
  final NestedStringFilter? $min;

  @JsonKey(name: r'_max')
  final NestedStringFilter? $max;

  @override
  Map<String, dynamic> toJson() => _$StringWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class StringNullableWithAggregatesFilter implements _i1.JsonSerializable {
  const StringNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  factory StringNullableWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$StringNullableWithAggregatesFilterFromJson(json);

  final String? equals;

  @JsonKey(name: r'in')
  final Iterable<String>? $in;

  final Iterable<String>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  final NestedStringNullableWithAggregatesFilter? not;

  @JsonKey(name: r'_count')
  final NestedIntNullableFilter? $count;

  @JsonKey(name: r'_min')
  final NestedStringNullableFilter? $min;

  @JsonKey(name: r'_max')
  final NestedStringNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() =>
      _$StringNullableWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class IntNullableWithAggregatesFilter implements _i1.JsonSerializable {
  const IntNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory IntNullableWithAggregatesFilter.fromJson(Map<String, dynamic> json) =>
      _$IntNullableWithAggregatesFilterFromJson(json);

  final int? equals;

  @JsonKey(name: r'in')
  final Iterable<int>? $in;

  final Iterable<int>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final NestedIntNullableWithAggregatesFilter? not;

  @JsonKey(name: r'_count')
  final NestedIntNullableFilter? $count;

  @JsonKey(name: r'_avg')
  final NestedFloatNullableFilter? $avg;

  @JsonKey(name: r'_sum')
  final NestedIntNullableFilter? $sum;

  @JsonKey(name: r'_min')
  final NestedIntNullableFilter? $min;

  @JsonKey(name: r'_max')
  final NestedIntNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() =>
      _$IntNullableWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class DateTimeWithAggregatesFilter implements _i1.JsonSerializable {
  const DateTimeWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  factory DateTimeWithAggregatesFilter.fromJson(Map<String, dynamic> json) =>
      _$DateTimeWithAggregatesFilterFromJson(json);

  final DateTime? equals;

  @JsonKey(name: r'in')
  final Iterable<DateTime>? $in;

  final Iterable<DateTime>? notIn;

  final DateTime? lt;

  final DateTime? lte;

  final DateTime? gt;

  final DateTime? gte;

  final NestedDateTimeWithAggregatesFilter? not;

  @JsonKey(name: r'_count')
  final NestedIntFilter? $count;

  @JsonKey(name: r'_min')
  final NestedDateTimeFilter? $min;

  @JsonKey(name: r'_max')
  final NestedDateTimeFilter? $max;

  @override
  Map<String, dynamic> toJson() => _$DateTimeWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class DecimalFilter implements _i1.JsonSerializable {
  const DecimalFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  factory DecimalFilter.fromJson(Map<String, dynamic> json) =>
      _$DecimalFilterFromJson(json);

  final double? equals;

  @JsonKey(name: r'in')
  final Iterable<double>? $in;

  final Iterable<double>? notIn;

  final double? lt;

  final double? lte;

  final double? gt;

  final double? gte;

  final NestedDecimalFilter? not;

  @override
  Map<String, dynamic> toJson() => _$DecimalFilterToJson(this);
}

@_i1.jsonSerializable
class APPROVALATTACHFILETBLAPPROVALIDSEQCompoundUniqueInput
    implements _i1.JsonSerializable {
  const APPROVALATTACHFILETBLAPPROVALIDSEQCompoundUniqueInput({
    required this.approvalId,
    required this.seq,
  });

  factory APPROVALATTACHFILETBLAPPROVALIDSEQCompoundUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALATTACHFILETBLAPPROVALIDSEQCompoundUniqueInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final String approvalId;

  @JsonKey(name: r'SEQ')
  final double seq;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALATTACHFILETBLAPPROVALIDSEQCompoundUniqueInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALATTACHFILETBLCountOrderByAggregateInput
    implements _i1.JsonSerializable {
  const APPROVALATTACHFILETBLCountOrderByAggregateInput({
    this.approvalId,
    this.seq,
    this.oriFileNm,
    this.saveFileNm,
    this.fileSize,
    this.regDate,
  });

  factory APPROVALATTACHFILETBLCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALATTACHFILETBLCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final SortOrder? approvalId;

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ORI_FILE_NM')
  final SortOrder? oriFileNm;

  @JsonKey(name: r'SAVE_FILE_NM')
  final SortOrder? saveFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final SortOrder? fileSize;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALATTACHFILETBLCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALATTACHFILETBLAvgOrderByAggregateInput
    implements _i1.JsonSerializable {
  const APPROVALATTACHFILETBLAvgOrderByAggregateInput({
    this.seq,
    this.fileSize,
  });

  factory APPROVALATTACHFILETBLAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALATTACHFILETBLAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'FILE_SIZE')
  final SortOrder? fileSize;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALATTACHFILETBLAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALATTACHFILETBLMaxOrderByAggregateInput
    implements _i1.JsonSerializable {
  const APPROVALATTACHFILETBLMaxOrderByAggregateInput({
    this.approvalId,
    this.seq,
    this.oriFileNm,
    this.saveFileNm,
    this.fileSize,
    this.regDate,
  });

  factory APPROVALATTACHFILETBLMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALATTACHFILETBLMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final SortOrder? approvalId;

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ORI_FILE_NM')
  final SortOrder? oriFileNm;

  @JsonKey(name: r'SAVE_FILE_NM')
  final SortOrder? saveFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final SortOrder? fileSize;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALATTACHFILETBLMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALATTACHFILETBLMinOrderByAggregateInput
    implements _i1.JsonSerializable {
  const APPROVALATTACHFILETBLMinOrderByAggregateInput({
    this.approvalId,
    this.seq,
    this.oriFileNm,
    this.saveFileNm,
    this.fileSize,
    this.regDate,
  });

  factory APPROVALATTACHFILETBLMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALATTACHFILETBLMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final SortOrder? approvalId;

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ORI_FILE_NM')
  final SortOrder? oriFileNm;

  @JsonKey(name: r'SAVE_FILE_NM')
  final SortOrder? saveFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final SortOrder? fileSize;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALATTACHFILETBLMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALATTACHFILETBLSumOrderByAggregateInput
    implements _i1.JsonSerializable {
  const APPROVALATTACHFILETBLSumOrderByAggregateInput({
    this.seq,
    this.fileSize,
  });

  factory APPROVALATTACHFILETBLSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALATTACHFILETBLSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'FILE_SIZE')
  final SortOrder? fileSize;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALATTACHFILETBLSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class DecimalWithAggregatesFilter implements _i1.JsonSerializable {
  const DecimalWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory DecimalWithAggregatesFilter.fromJson(Map<String, dynamic> json) =>
      _$DecimalWithAggregatesFilterFromJson(json);

  final double? equals;

  @JsonKey(name: r'in')
  final Iterable<double>? $in;

  final Iterable<double>? notIn;

  final double? lt;

  final double? lte;

  final double? gt;

  final double? gte;

  final NestedDecimalWithAggregatesFilter? not;

  @JsonKey(name: r'_count')
  final NestedIntFilter? $count;

  @JsonKey(name: r'_avg')
  final NestedDecimalFilter? $avg;

  @JsonKey(name: r'_sum')
  final NestedDecimalFilter? $sum;

  @JsonKey(name: r'_min')
  final NestedDecimalFilter? $min;

  @JsonKey(name: r'_max')
  final NestedDecimalFilter? $max;

  @override
  Map<String, dynamic> toJson() => _$DecimalWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class BigIntFilter implements _i1.JsonSerializable {
  const BigIntFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  factory BigIntFilter.fromJson(Map<String, dynamic> json) =>
      _$BigIntFilterFromJson(json);

  final BigInt? equals;

  @JsonKey(name: r'in')
  final Iterable<BigInt>? $in;

  final Iterable<BigInt>? notIn;

  final BigInt? lt;

  final BigInt? lte;

  final BigInt? gt;

  final BigInt? gte;

  final NestedBigIntFilter? not;

  @override
  Map<String, dynamic> toJson() => _$BigIntFilterToJson(this);
}

@_i1.jsonSerializable
class DateTimeNullableFilter implements _i1.JsonSerializable {
  const DateTimeNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  factory DateTimeNullableFilter.fromJson(Map<String, dynamic> json) =>
      _$DateTimeNullableFilterFromJson(json);

  final DateTime? equals;

  @JsonKey(name: r'in')
  final Iterable<DateTime>? $in;

  final Iterable<DateTime>? notIn;

  final DateTime? lt;

  final DateTime? lte;

  final DateTime? gt;

  final DateTime? gte;

  final NestedDateTimeNullableFilter? not;

  @override
  Map<String, dynamic> toJson() => _$DateTimeNullableFilterToJson(this);
}

@_i1.jsonSerializable
class APPROVALDOCINFOTBLCountOrderByAggregateInput
    implements _i1.JsonSerializable {
  const APPROVALDOCINFOTBLCountOrderByAggregateInput({
    this.seq,
    this.docType,
    this.docNm,
    this.title,
    this.approvalLineType,
    this.approvalLineContent,
    this.approvalLineContentBak,
    this.content,
    this.writerId,
    this.userNm,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
  });

  factory APPROVALDOCINFOTBLCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALDOCINFOTBLCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'DOC_TYPE')
  final SortOrder? docType;

  @JsonKey(name: r'DOC_NM')
  final SortOrder? docNm;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'APPROVAL_LINE_TYPE')
  final SortOrder? approvalLineType;

  @JsonKey(name: r'APPROVAL_LINE_CONTENT')
  final SortOrder? approvalLineContent;

  @JsonKey(name: r'APPROVAL_LINE_CONTENT_BAK')
  final SortOrder? approvalLineContentBak;

  @JsonKey(name: r'CONTENT')
  final SortOrder? content;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'USER_NM')
  final SortOrder? userNm;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALDOCINFOTBLCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALDOCINFOTBLAvgOrderByAggregateInput
    implements _i1.JsonSerializable {
  const APPROVALDOCINFOTBLAvgOrderByAggregateInput({this.seq});

  factory APPROVALDOCINFOTBLAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALDOCINFOTBLAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALDOCINFOTBLAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALDOCINFOTBLMaxOrderByAggregateInput
    implements _i1.JsonSerializable {
  const APPROVALDOCINFOTBLMaxOrderByAggregateInput({
    this.seq,
    this.docType,
    this.docNm,
    this.title,
    this.approvalLineType,
    this.approvalLineContent,
    this.approvalLineContentBak,
    this.content,
    this.writerId,
    this.userNm,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
  });

  factory APPROVALDOCINFOTBLMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALDOCINFOTBLMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'DOC_TYPE')
  final SortOrder? docType;

  @JsonKey(name: r'DOC_NM')
  final SortOrder? docNm;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'APPROVAL_LINE_TYPE')
  final SortOrder? approvalLineType;

  @JsonKey(name: r'APPROVAL_LINE_CONTENT')
  final SortOrder? approvalLineContent;

  @JsonKey(name: r'APPROVAL_LINE_CONTENT_BAK')
  final SortOrder? approvalLineContentBak;

  @JsonKey(name: r'CONTENT')
  final SortOrder? content;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'USER_NM')
  final SortOrder? userNm;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALDOCINFOTBLMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALDOCINFOTBLMinOrderByAggregateInput
    implements _i1.JsonSerializable {
  const APPROVALDOCINFOTBLMinOrderByAggregateInput({
    this.seq,
    this.docType,
    this.docNm,
    this.title,
    this.approvalLineType,
    this.approvalLineContent,
    this.approvalLineContentBak,
    this.content,
    this.writerId,
    this.userNm,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
  });

  factory APPROVALDOCINFOTBLMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALDOCINFOTBLMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'DOC_TYPE')
  final SortOrder? docType;

  @JsonKey(name: r'DOC_NM')
  final SortOrder? docNm;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'APPROVAL_LINE_TYPE')
  final SortOrder? approvalLineType;

  @JsonKey(name: r'APPROVAL_LINE_CONTENT')
  final SortOrder? approvalLineContent;

  @JsonKey(name: r'APPROVAL_LINE_CONTENT_BAK')
  final SortOrder? approvalLineContentBak;

  @JsonKey(name: r'CONTENT')
  final SortOrder? content;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'USER_NM')
  final SortOrder? userNm;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALDOCINFOTBLMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALDOCINFOTBLSumOrderByAggregateInput
    implements _i1.JsonSerializable {
  const APPROVALDOCINFOTBLSumOrderByAggregateInput({this.seq});

  factory APPROVALDOCINFOTBLSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALDOCINFOTBLSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALDOCINFOTBLSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class BigIntWithAggregatesFilter implements _i1.JsonSerializable {
  const BigIntWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory BigIntWithAggregatesFilter.fromJson(Map<String, dynamic> json) =>
      _$BigIntWithAggregatesFilterFromJson(json);

  final BigInt? equals;

  @JsonKey(name: r'in')
  final Iterable<BigInt>? $in;

  final Iterable<BigInt>? notIn;

  final BigInt? lt;

  final BigInt? lte;

  final BigInt? gt;

  final BigInt? gte;

  final NestedBigIntWithAggregatesFilter? not;

  @JsonKey(name: r'_count')
  final NestedIntFilter? $count;

  @JsonKey(name: r'_avg')
  final NestedFloatFilter? $avg;

  @JsonKey(name: r'_sum')
  final NestedBigIntFilter? $sum;

  @JsonKey(name: r'_min')
  final NestedBigIntFilter? $min;

  @JsonKey(name: r'_max')
  final NestedBigIntFilter? $max;

  @override
  Map<String, dynamic> toJson() => _$BigIntWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class DateTimeNullableWithAggregatesFilter implements _i1.JsonSerializable {
  const DateTimeNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  factory DateTimeNullableWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$DateTimeNullableWithAggregatesFilterFromJson(json);

  final DateTime? equals;

  @JsonKey(name: r'in')
  final Iterable<DateTime>? $in;

  final Iterable<DateTime>? notIn;

  final DateTime? lt;

  final DateTime? lte;

  final DateTime? gt;

  final DateTime? gte;

  final NestedDateTimeNullableWithAggregatesFilter? not;

  @JsonKey(name: r'_count')
  final NestedIntNullableFilter? $count;

  @JsonKey(name: r'_min')
  final NestedDateTimeNullableFilter? $min;

  @JsonKey(name: r'_max')
  final NestedDateTimeNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() =>
      _$DateTimeNullableWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class IntFilter implements _i1.JsonSerializable {
  const IntFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  factory IntFilter.fromJson(Map<String, dynamic> json) =>
      _$IntFilterFromJson(json);

  final int? equals;

  @JsonKey(name: r'in')
  final Iterable<int>? $in;

  final Iterable<int>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final NestedIntFilter? not;

  @override
  Map<String, dynamic> toJson() => _$IntFilterToJson(this);
}

@_i1.jsonSerializable
class APPROVALHISTORYTBLCountOrderByAggregateInput
    implements _i1.JsonSerializable {
  const APPROVALHISTORYTBLCountOrderByAggregateInput({
    this.seq,
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.docType,
    this.keepPriod,
    this.keepDate,
    this.grade,
    this.status,
    this.content,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALHISTORYTBLCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALHISTORYTBLCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'APPROVAL_ID')
  final SortOrder? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'WRITER_NM')
  final SortOrder? writerNm;

  @JsonKey(name: r'DOC_TYPE')
  final SortOrder? docType;

  @JsonKey(name: r'KEEP_PRIOD')
  final SortOrder? keepPriod;

  @JsonKey(name: r'KEEP_DATE')
  final SortOrder? keepDate;

  @JsonKey(name: r'GRADE')
  final SortOrder? grade;

  @JsonKey(name: r'STATUS')
  final SortOrder? status;

  @JsonKey(name: r'CONTENT')
  final SortOrder? content;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALHISTORYTBLCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALHISTORYTBLAvgOrderByAggregateInput
    implements _i1.JsonSerializable {
  const APPROVALHISTORYTBLAvgOrderByAggregateInput({
    this.seq,
    this.keepPriod,
  });

  factory APPROVALHISTORYTBLAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALHISTORYTBLAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'KEEP_PRIOD')
  final SortOrder? keepPriod;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALHISTORYTBLAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALHISTORYTBLMaxOrderByAggregateInput
    implements _i1.JsonSerializable {
  const APPROVALHISTORYTBLMaxOrderByAggregateInput({
    this.seq,
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.docType,
    this.keepPriod,
    this.keepDate,
    this.grade,
    this.status,
    this.content,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALHISTORYTBLMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALHISTORYTBLMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'APPROVAL_ID')
  final SortOrder? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'WRITER_NM')
  final SortOrder? writerNm;

  @JsonKey(name: r'DOC_TYPE')
  final SortOrder? docType;

  @JsonKey(name: r'KEEP_PRIOD')
  final SortOrder? keepPriod;

  @JsonKey(name: r'KEEP_DATE')
  final SortOrder? keepDate;

  @JsonKey(name: r'GRADE')
  final SortOrder? grade;

  @JsonKey(name: r'STATUS')
  final SortOrder? status;

  @JsonKey(name: r'CONTENT')
  final SortOrder? content;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALHISTORYTBLMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALHISTORYTBLMinOrderByAggregateInput
    implements _i1.JsonSerializable {
  const APPROVALHISTORYTBLMinOrderByAggregateInput({
    this.seq,
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.docType,
    this.keepPriod,
    this.keepDate,
    this.grade,
    this.status,
    this.content,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALHISTORYTBLMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALHISTORYTBLMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'APPROVAL_ID')
  final SortOrder? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'WRITER_NM')
  final SortOrder? writerNm;

  @JsonKey(name: r'DOC_TYPE')
  final SortOrder? docType;

  @JsonKey(name: r'KEEP_PRIOD')
  final SortOrder? keepPriod;

  @JsonKey(name: r'KEEP_DATE')
  final SortOrder? keepDate;

  @JsonKey(name: r'GRADE')
  final SortOrder? grade;

  @JsonKey(name: r'STATUS')
  final SortOrder? status;

  @JsonKey(name: r'CONTENT')
  final SortOrder? content;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALHISTORYTBLMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALHISTORYTBLSumOrderByAggregateInput
    implements _i1.JsonSerializable {
  const APPROVALHISTORYTBLSumOrderByAggregateInput({
    this.seq,
    this.keepPriod,
  });

  factory APPROVALHISTORYTBLSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALHISTORYTBLSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'KEEP_PRIOD')
  final SortOrder? keepPriod;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALHISTORYTBLSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class IntWithAggregatesFilter implements _i1.JsonSerializable {
  const IntWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory IntWithAggregatesFilter.fromJson(Map<String, dynamic> json) =>
      _$IntWithAggregatesFilterFromJson(json);

  final int? equals;

  @JsonKey(name: r'in')
  final Iterable<int>? $in;

  final Iterable<int>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final NestedIntWithAggregatesFilter? not;

  @JsonKey(name: r'_count')
  final NestedIntFilter? $count;

  @JsonKey(name: r'_avg')
  final NestedFloatFilter? $avg;

  @JsonKey(name: r'_sum')
  final NestedIntFilter? $sum;

  @JsonKey(name: r'_min')
  final NestedIntFilter? $min;

  @JsonKey(name: r'_max')
  final NestedIntFilter? $max;

  @override
  Map<String, dynamic> toJson() => _$IntWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class DecimalNullableFilter implements _i1.JsonSerializable {
  const DecimalNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  factory DecimalNullableFilter.fromJson(Map<String, dynamic> json) =>
      _$DecimalNullableFilterFromJson(json);

  final double? equals;

  @JsonKey(name: r'in')
  final Iterable<double>? $in;

  final Iterable<double>? notIn;

  final double? lt;

  final double? lte;

  final double? gt;

  final double? gte;

  final NestedDecimalNullableFilter? not;

  @override
  Map<String, dynamic> toJson() => _$DecimalNullableFilterToJson(this);
}

@_i1.jsonSerializable
class APPROVALMASTERTBLCountOrderByAggregateInput
    implements _i1.JsonSerializable {
  const APPROVALMASTERTBLCountOrderByAggregateInput({
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.docType,
    this.keepPriod,
    this.keepDate,
    this.grade,
    this.status,
    this.title,
    this.header,
    this.content,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
    this.regDate,
    this.completeDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALMASTERTBLCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALMASTERTBLCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final SortOrder? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'WRITER_NM')
  final SortOrder? writerNm;

  @JsonKey(name: r'DOC_TYPE')
  final SortOrder? docType;

  @JsonKey(name: r'KEEP_PRIOD')
  final SortOrder? keepPriod;

  @JsonKey(name: r'KEEP_DATE')
  final SortOrder? keepDate;

  @JsonKey(name: r'GRADE')
  final SortOrder? grade;

  @JsonKey(name: r'STATUS')
  final SortOrder? status;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'HEADER')
  final SortOrder? header;

  @JsonKey(name: r'CONTENT')
  final SortOrder? content;

  @JsonKey(name: r'M1')
  final SortOrder? m1;

  @JsonKey(name: r'M2')
  final SortOrder? m2;

  @JsonKey(name: r'M3')
  final SortOrder? m3;

  @JsonKey(name: r'M4')
  final SortOrder? m4;

  @JsonKey(name: r'M5')
  final SortOrder? m5;

  @JsonKey(name: r'M6')
  final SortOrder? m6;

  @JsonKey(name: r'M7')
  final SortOrder? m7;

  @JsonKey(name: r'M8')
  final SortOrder? m8;

  @JsonKey(name: r'M9')
  final SortOrder? m9;

  @JsonKey(name: r'M10')
  final SortOrder? m10;

  @JsonKey(name: r'M11')
  final SortOrder? m11;

  @JsonKey(name: r'M12')
  final SortOrder? m12;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'COMPLETE_DATE')
  final SortOrder? completeDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALMASTERTBLCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALMASTERTBLAvgOrderByAggregateInput
    implements _i1.JsonSerializable {
  const APPROVALMASTERTBLAvgOrderByAggregateInput({
    this.keepPriod,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
  });

  factory APPROVALMASTERTBLAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALMASTERTBLAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'KEEP_PRIOD')
  final SortOrder? keepPriod;

  @JsonKey(name: r'M1')
  final SortOrder? m1;

  @JsonKey(name: r'M2')
  final SortOrder? m2;

  @JsonKey(name: r'M3')
  final SortOrder? m3;

  @JsonKey(name: r'M4')
  final SortOrder? m4;

  @JsonKey(name: r'M5')
  final SortOrder? m5;

  @JsonKey(name: r'M6')
  final SortOrder? m6;

  @JsonKey(name: r'M7')
  final SortOrder? m7;

  @JsonKey(name: r'M8')
  final SortOrder? m8;

  @JsonKey(name: r'M9')
  final SortOrder? m9;

  @JsonKey(name: r'M10')
  final SortOrder? m10;

  @JsonKey(name: r'M11')
  final SortOrder? m11;

  @JsonKey(name: r'M12')
  final SortOrder? m12;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALMASTERTBLAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALMASTERTBLMaxOrderByAggregateInput
    implements _i1.JsonSerializable {
  const APPROVALMASTERTBLMaxOrderByAggregateInput({
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.docType,
    this.keepPriod,
    this.keepDate,
    this.grade,
    this.status,
    this.title,
    this.header,
    this.content,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
    this.regDate,
    this.completeDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALMASTERTBLMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALMASTERTBLMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final SortOrder? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'WRITER_NM')
  final SortOrder? writerNm;

  @JsonKey(name: r'DOC_TYPE')
  final SortOrder? docType;

  @JsonKey(name: r'KEEP_PRIOD')
  final SortOrder? keepPriod;

  @JsonKey(name: r'KEEP_DATE')
  final SortOrder? keepDate;

  @JsonKey(name: r'GRADE')
  final SortOrder? grade;

  @JsonKey(name: r'STATUS')
  final SortOrder? status;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'HEADER')
  final SortOrder? header;

  @JsonKey(name: r'CONTENT')
  final SortOrder? content;

  @JsonKey(name: r'M1')
  final SortOrder? m1;

  @JsonKey(name: r'M2')
  final SortOrder? m2;

  @JsonKey(name: r'M3')
  final SortOrder? m3;

  @JsonKey(name: r'M4')
  final SortOrder? m4;

  @JsonKey(name: r'M5')
  final SortOrder? m5;

  @JsonKey(name: r'M6')
  final SortOrder? m6;

  @JsonKey(name: r'M7')
  final SortOrder? m7;

  @JsonKey(name: r'M8')
  final SortOrder? m8;

  @JsonKey(name: r'M9')
  final SortOrder? m9;

  @JsonKey(name: r'M10')
  final SortOrder? m10;

  @JsonKey(name: r'M11')
  final SortOrder? m11;

  @JsonKey(name: r'M12')
  final SortOrder? m12;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'COMPLETE_DATE')
  final SortOrder? completeDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALMASTERTBLMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALMASTERTBLMinOrderByAggregateInput
    implements _i1.JsonSerializable {
  const APPROVALMASTERTBLMinOrderByAggregateInput({
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.docType,
    this.keepPriod,
    this.keepDate,
    this.grade,
    this.status,
    this.title,
    this.header,
    this.content,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
    this.regDate,
    this.completeDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALMASTERTBLMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALMASTERTBLMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final SortOrder? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'WRITER_NM')
  final SortOrder? writerNm;

  @JsonKey(name: r'DOC_TYPE')
  final SortOrder? docType;

  @JsonKey(name: r'KEEP_PRIOD')
  final SortOrder? keepPriod;

  @JsonKey(name: r'KEEP_DATE')
  final SortOrder? keepDate;

  @JsonKey(name: r'GRADE')
  final SortOrder? grade;

  @JsonKey(name: r'STATUS')
  final SortOrder? status;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'HEADER')
  final SortOrder? header;

  @JsonKey(name: r'CONTENT')
  final SortOrder? content;

  @JsonKey(name: r'M1')
  final SortOrder? m1;

  @JsonKey(name: r'M2')
  final SortOrder? m2;

  @JsonKey(name: r'M3')
  final SortOrder? m3;

  @JsonKey(name: r'M4')
  final SortOrder? m4;

  @JsonKey(name: r'M5')
  final SortOrder? m5;

  @JsonKey(name: r'M6')
  final SortOrder? m6;

  @JsonKey(name: r'M7')
  final SortOrder? m7;

  @JsonKey(name: r'M8')
  final SortOrder? m8;

  @JsonKey(name: r'M9')
  final SortOrder? m9;

  @JsonKey(name: r'M10')
  final SortOrder? m10;

  @JsonKey(name: r'M11')
  final SortOrder? m11;

  @JsonKey(name: r'M12')
  final SortOrder? m12;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'COMPLETE_DATE')
  final SortOrder? completeDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALMASTERTBLMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALMASTERTBLSumOrderByAggregateInput
    implements _i1.JsonSerializable {
  const APPROVALMASTERTBLSumOrderByAggregateInput({
    this.keepPriod,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
  });

  factory APPROVALMASTERTBLSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALMASTERTBLSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'KEEP_PRIOD')
  final SortOrder? keepPriod;

  @JsonKey(name: r'M1')
  final SortOrder? m1;

  @JsonKey(name: r'M2')
  final SortOrder? m2;

  @JsonKey(name: r'M3')
  final SortOrder? m3;

  @JsonKey(name: r'M4')
  final SortOrder? m4;

  @JsonKey(name: r'M5')
  final SortOrder? m5;

  @JsonKey(name: r'M6')
  final SortOrder? m6;

  @JsonKey(name: r'M7')
  final SortOrder? m7;

  @JsonKey(name: r'M8')
  final SortOrder? m8;

  @JsonKey(name: r'M9')
  final SortOrder? m9;

  @JsonKey(name: r'M10')
  final SortOrder? m10;

  @JsonKey(name: r'M11')
  final SortOrder? m11;

  @JsonKey(name: r'M12')
  final SortOrder? m12;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALMASTERTBLSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class DecimalNullableWithAggregatesFilter implements _i1.JsonSerializable {
  const DecimalNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory DecimalNullableWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$DecimalNullableWithAggregatesFilterFromJson(json);

  final double? equals;

  @JsonKey(name: r'in')
  final Iterable<double>? $in;

  final Iterable<double>? notIn;

  final double? lt;

  final double? lte;

  final double? gt;

  final double? gte;

  final NestedDecimalNullableWithAggregatesFilter? not;

  @JsonKey(name: r'_count')
  final NestedIntNullableFilter? $count;

  @JsonKey(name: r'_avg')
  final NestedDecimalNullableFilter? $avg;

  @JsonKey(name: r'_sum')
  final NestedDecimalNullableFilter? $sum;

  @JsonKey(name: r'_min')
  final NestedDecimalNullableFilter? $min;

  @JsonKey(name: r'_max')
  final NestedDecimalNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() =>
      _$DecimalNullableWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class APPROVALMEMOTBLCountOrderByAggregateInput
    implements _i1.JsonSerializable {
  const APPROVALMEMOTBLCountOrderByAggregateInput({
    this.seq,
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.content,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALMEMOTBLCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALMEMOTBLCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'APPROVAL_ID')
  final SortOrder? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'WRITER_NM')
  final SortOrder? writerNm;

  @JsonKey(name: r'CONTENT')
  final SortOrder? content;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALMEMOTBLCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALMEMOTBLAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const APPROVALMEMOTBLAvgOrderByAggregateInput({this.seq});

  factory APPROVALMEMOTBLAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALMEMOTBLAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALMEMOTBLAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALMEMOTBLMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const APPROVALMEMOTBLMaxOrderByAggregateInput({
    this.seq,
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.content,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALMEMOTBLMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALMEMOTBLMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'APPROVAL_ID')
  final SortOrder? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'WRITER_NM')
  final SortOrder? writerNm;

  @JsonKey(name: r'CONTENT')
  final SortOrder? content;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALMEMOTBLMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALMEMOTBLMinOrderByAggregateInput implements _i1.JsonSerializable {
  const APPROVALMEMOTBLMinOrderByAggregateInput({
    this.seq,
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.content,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALMEMOTBLMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALMEMOTBLMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'APPROVAL_ID')
  final SortOrder? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'WRITER_NM')
  final SortOrder? writerNm;

  @JsonKey(name: r'CONTENT')
  final SortOrder? content;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALMEMOTBLMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALMEMOTBLSumOrderByAggregateInput implements _i1.JsonSerializable {
  const APPROVALMEMOTBLSumOrderByAggregateInput({this.seq});

  factory APPROVALMEMOTBLSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALMEMOTBLSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALMEMOTBLSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALTYPETBLCountOrderByAggregateInput
    implements _i1.JsonSerializable {
  const APPROVALTYPETBLCountOrderByAggregateInput({
    this.type,
    this.content,
    this.contentBak,
    this.useYn,
    this.delYn,
  });

  factory APPROVALTYPETBLCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALTYPETBLCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'TYPE')
  final SortOrder? type;

  @JsonKey(name: r'CONTENT')
  final SortOrder? content;

  @JsonKey(name: r'CONTENT_BAK')
  final SortOrder? contentBak;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALTYPETBLCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALTYPETBLMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const APPROVALTYPETBLMaxOrderByAggregateInput({
    this.type,
    this.content,
    this.contentBak,
    this.useYn,
    this.delYn,
  });

  factory APPROVALTYPETBLMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALTYPETBLMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'TYPE')
  final SortOrder? type;

  @JsonKey(name: r'CONTENT')
  final SortOrder? content;

  @JsonKey(name: r'CONTENT_BAK')
  final SortOrder? contentBak;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALTYPETBLMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALTYPETBLMinOrderByAggregateInput implements _i1.JsonSerializable {
  const APPROVALTYPETBLMinOrderByAggregateInput({
    this.type,
    this.content,
    this.contentBak,
    this.useYn,
    this.delYn,
  });

  factory APPROVALTYPETBLMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALTYPETBLMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'TYPE')
  final SortOrder? type;

  @JsonKey(name: r'CONTENT')
  final SortOrder? content;

  @JsonKey(name: r'CONTENT_BAK')
  final SortOrder? contentBak;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALTYPETBLMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALUSERTBLAPPROVALIDAPPROVALUSRIDAPPROVALUSRTYPECompoundUniqueInput
    implements _i1.JsonSerializable {
  const APPROVALUSERTBLAPPROVALIDAPPROVALUSRIDAPPROVALUSRTYPECompoundUniqueInput({
    required this.approvalId,
    required this.approvalUsrId,
    required this.approvalUsrType,
  });

  factory APPROVALUSERTBLAPPROVALIDAPPROVALUSRIDAPPROVALUSRTYPECompoundUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALUSERTBLAPPROVALIDAPPROVALUSRIDAPPROVALUSRTYPECompoundUniqueInputFromJson(
          json);

  @JsonKey(name: r'APPROVAL_ID')
  final String approvalId;

  @JsonKey(name: r'APPROVAL_USR_ID')
  final String approvalUsrId;

  @JsonKey(name: r'APPROVAL_USR_TYPE')
  final String approvalUsrType;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALUSERTBLAPPROVALIDAPPROVALUSRIDAPPROVALUSRTYPECompoundUniqueInputToJson(
          this);
}

@_i1.jsonSerializable
class APPROVALUSERTBLCountOrderByAggregateInput
    implements _i1.JsonSerializable {
  const APPROVALUSERTBLCountOrderByAggregateInput({
    this.approvalId,
    this.approvalUsrId,
    this.approvalUsrGradeCd,
    this.approvalUsrType,
    this.approvalUsrSort,
    this.approvalProcUserYn,
    this.approvalProcYn,
    this.approvalProcDate,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALUSERTBLCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALUSERTBLCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final SortOrder? approvalId;

  @JsonKey(name: r'APPROVAL_USR_ID')
  final SortOrder? approvalUsrId;

  @JsonKey(name: r'APPROVAL_USR_GRADE_CD')
  final SortOrder? approvalUsrGradeCd;

  @JsonKey(name: r'APPROVAL_USR_TYPE')
  final SortOrder? approvalUsrType;

  @JsonKey(name: r'APPROVAL_USR_SORT')
  final SortOrder? approvalUsrSort;

  @JsonKey(name: r'APPROVAL_PROC_USER_YN')
  final SortOrder? approvalProcUserYn;

  @JsonKey(name: r'APPROVAL_PROC_YN')
  final SortOrder? approvalProcYn;

  @JsonKey(name: r'APPROVAL_PROC_DATE')
  final SortOrder? approvalProcDate;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALUSERTBLCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALUSERTBLAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const APPROVALUSERTBLAvgOrderByAggregateInput({this.approvalUsrSort});

  factory APPROVALUSERTBLAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALUSERTBLAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'APPROVAL_USR_SORT')
  final SortOrder? approvalUsrSort;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALUSERTBLAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALUSERTBLMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const APPROVALUSERTBLMaxOrderByAggregateInput({
    this.approvalId,
    this.approvalUsrId,
    this.approvalUsrGradeCd,
    this.approvalUsrType,
    this.approvalUsrSort,
    this.approvalProcUserYn,
    this.approvalProcYn,
    this.approvalProcDate,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALUSERTBLMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALUSERTBLMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final SortOrder? approvalId;

  @JsonKey(name: r'APPROVAL_USR_ID')
  final SortOrder? approvalUsrId;

  @JsonKey(name: r'APPROVAL_USR_GRADE_CD')
  final SortOrder? approvalUsrGradeCd;

  @JsonKey(name: r'APPROVAL_USR_TYPE')
  final SortOrder? approvalUsrType;

  @JsonKey(name: r'APPROVAL_USR_SORT')
  final SortOrder? approvalUsrSort;

  @JsonKey(name: r'APPROVAL_PROC_USER_YN')
  final SortOrder? approvalProcUserYn;

  @JsonKey(name: r'APPROVAL_PROC_YN')
  final SortOrder? approvalProcYn;

  @JsonKey(name: r'APPROVAL_PROC_DATE')
  final SortOrder? approvalProcDate;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALUSERTBLMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALUSERTBLMinOrderByAggregateInput implements _i1.JsonSerializable {
  const APPROVALUSERTBLMinOrderByAggregateInput({
    this.approvalId,
    this.approvalUsrId,
    this.approvalUsrGradeCd,
    this.approvalUsrType,
    this.approvalUsrSort,
    this.approvalProcUserYn,
    this.approvalProcYn,
    this.approvalProcDate,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALUSERTBLMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALUSERTBLMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final SortOrder? approvalId;

  @JsonKey(name: r'APPROVAL_USR_ID')
  final SortOrder? approvalUsrId;

  @JsonKey(name: r'APPROVAL_USR_GRADE_CD')
  final SortOrder? approvalUsrGradeCd;

  @JsonKey(name: r'APPROVAL_USR_TYPE')
  final SortOrder? approvalUsrType;

  @JsonKey(name: r'APPROVAL_USR_SORT')
  final SortOrder? approvalUsrSort;

  @JsonKey(name: r'APPROVAL_PROC_USER_YN')
  final SortOrder? approvalProcUserYn;

  @JsonKey(name: r'APPROVAL_PROC_YN')
  final SortOrder? approvalProcYn;

  @JsonKey(name: r'APPROVAL_PROC_DATE')
  final SortOrder? approvalProcDate;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALUSERTBLMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class APPROVALUSERTBLSumOrderByAggregateInput implements _i1.JsonSerializable {
  const APPROVALUSERTBLSumOrderByAggregateInput({this.approvalUsrSort});

  factory APPROVALUSERTBLSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALUSERTBLSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'APPROVAL_USR_SORT')
  final SortOrder? approvalUsrSort;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALUSERTBLSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class BOOKASSETTBLCountOrderByAggregateInput implements _i1.JsonSerializable {
  const BOOKASSETTBLCountOrderByAggregateInput({
    this.seq,
    this.assetNo,
    this.bookNm,
    this.cnt,
    this.publisher,
    this.amount,
    this.buyDate,
    this.mngDept,
    this.rentYn,
    this.rentUser,
    this.remarks,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory BOOKASSETTBLCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$BOOKASSETTBLCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ASSET_NO')
  final SortOrder? assetNo;

  @JsonKey(name: r'BOOK_NM')
  final SortOrder? bookNm;

  @JsonKey(name: r'CNT')
  final SortOrder? cnt;

  @JsonKey(name: r'PUBLISHER')
  final SortOrder? publisher;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @JsonKey(name: r'BUY_DATE')
  final SortOrder? buyDate;

  @JsonKey(name: r'MNG_DEPT')
  final SortOrder? mngDept;

  @JsonKey(name: r'RENT_YN')
  final SortOrder? rentYn;

  @JsonKey(name: r'RENT_USER')
  final SortOrder? rentUser;

  @JsonKey(name: r'REMARKS')
  final SortOrder? remarks;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$BOOKASSETTBLCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class BOOKASSETTBLAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const BOOKASSETTBLAvgOrderByAggregateInput({
    this.seq,
    this.cnt,
    this.amount,
  });

  factory BOOKASSETTBLAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$BOOKASSETTBLAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'CNT')
  final SortOrder? cnt;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @override
  Map<String, dynamic> toJson() =>
      _$BOOKASSETTBLAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class BOOKASSETTBLMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const BOOKASSETTBLMaxOrderByAggregateInput({
    this.seq,
    this.assetNo,
    this.bookNm,
    this.cnt,
    this.publisher,
    this.amount,
    this.buyDate,
    this.mngDept,
    this.rentYn,
    this.rentUser,
    this.remarks,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory BOOKASSETTBLMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$BOOKASSETTBLMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ASSET_NO')
  final SortOrder? assetNo;

  @JsonKey(name: r'BOOK_NM')
  final SortOrder? bookNm;

  @JsonKey(name: r'CNT')
  final SortOrder? cnt;

  @JsonKey(name: r'PUBLISHER')
  final SortOrder? publisher;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @JsonKey(name: r'BUY_DATE')
  final SortOrder? buyDate;

  @JsonKey(name: r'MNG_DEPT')
  final SortOrder? mngDept;

  @JsonKey(name: r'RENT_YN')
  final SortOrder? rentYn;

  @JsonKey(name: r'RENT_USER')
  final SortOrder? rentUser;

  @JsonKey(name: r'REMARKS')
  final SortOrder? remarks;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$BOOKASSETTBLMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class BOOKASSETTBLMinOrderByAggregateInput implements _i1.JsonSerializable {
  const BOOKASSETTBLMinOrderByAggregateInput({
    this.seq,
    this.assetNo,
    this.bookNm,
    this.cnt,
    this.publisher,
    this.amount,
    this.buyDate,
    this.mngDept,
    this.rentYn,
    this.rentUser,
    this.remarks,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory BOOKASSETTBLMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$BOOKASSETTBLMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ASSET_NO')
  final SortOrder? assetNo;

  @JsonKey(name: r'BOOK_NM')
  final SortOrder? bookNm;

  @JsonKey(name: r'CNT')
  final SortOrder? cnt;

  @JsonKey(name: r'PUBLISHER')
  final SortOrder? publisher;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @JsonKey(name: r'BUY_DATE')
  final SortOrder? buyDate;

  @JsonKey(name: r'MNG_DEPT')
  final SortOrder? mngDept;

  @JsonKey(name: r'RENT_YN')
  final SortOrder? rentYn;

  @JsonKey(name: r'RENT_USER')
  final SortOrder? rentUser;

  @JsonKey(name: r'REMARKS')
  final SortOrder? remarks;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$BOOKASSETTBLMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class BOOKASSETTBLSumOrderByAggregateInput implements _i1.JsonSerializable {
  const BOOKASSETTBLSumOrderByAggregateInput({
    this.seq,
    this.cnt,
    this.amount,
  });

  factory BOOKASSETTBLSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$BOOKASSETTBLSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'CNT')
  final SortOrder? cnt;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @override
  Map<String, dynamic> toJson() =>
      _$BOOKASSETTBLSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETINSURTBLCountOrderByAggregateInput
    implements _i1.JsonSerializable {
  const CARASSETINSURTBLCountOrderByAggregateInput({
    this.seq,
    this.mseq,
    this.guarantee,
  });

  factory CARASSETINSURTBLCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARASSETINSURTBLCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'GUARANTEE')
  final SortOrder? guarantee;

  @override
  Map<String, dynamic> toJson() =>
      _$CARASSETINSURTBLCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETINSURTBLAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const CARASSETINSURTBLAvgOrderByAggregateInput({
    this.seq,
    this.mseq,
  });

  factory CARASSETINSURTBLAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARASSETINSURTBLAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @override
  Map<String, dynamic> toJson() =>
      _$CARASSETINSURTBLAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETINSURTBLMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const CARASSETINSURTBLMaxOrderByAggregateInput({
    this.seq,
    this.mseq,
    this.guarantee,
  });

  factory CARASSETINSURTBLMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARASSETINSURTBLMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'GUARANTEE')
  final SortOrder? guarantee;

  @override
  Map<String, dynamic> toJson() =>
      _$CARASSETINSURTBLMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETINSURTBLMinOrderByAggregateInput implements _i1.JsonSerializable {
  const CARASSETINSURTBLMinOrderByAggregateInput({
    this.seq,
    this.mseq,
    this.guarantee,
  });

  factory CARASSETINSURTBLMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARASSETINSURTBLMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'GUARANTEE')
  final SortOrder? guarantee;

  @override
  Map<String, dynamic> toJson() =>
      _$CARASSETINSURTBLMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETINSURTBLSumOrderByAggregateInput implements _i1.JsonSerializable {
  const CARASSETINSURTBLSumOrderByAggregateInput({
    this.seq,
    this.mseq,
  });

  factory CARASSETINSURTBLSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARASSETINSURTBLSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @override
  Map<String, dynamic> toJson() =>
      _$CARASSETINSURTBLSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETTBLCountOrderByAggregateInput implements _i1.JsonSerializable {
  const CARASSETTBLCountOrderByAggregateInput({
    this.seq,
    this.assetNo,
    this.modelNo,
    this.carNo,
    this.owner,
    this.ownerType,
    this.amount,
    this.buyDate,
    this.seller,
    this.remarks,
    this.mngrNm,
    this.fuel,
    this.manuDt,
    this.effic,
    this.insur,
    this.insurMngr,
    this.emgTel,
    this.storeNm,
    this.storeTel,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory CARASSETTBLCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARASSETTBLCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ASSET_NO')
  final SortOrder? assetNo;

  @JsonKey(name: r'MODEL_NO')
  final SortOrder? modelNo;

  @JsonKey(name: r'CAR_NO')
  final SortOrder? carNo;

  @JsonKey(name: r'OWNER')
  final SortOrder? owner;

  @JsonKey(name: r'OWNER_TYPE')
  final SortOrder? ownerType;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @JsonKey(name: r'BUY_DATE')
  final SortOrder? buyDate;

  @JsonKey(name: r'SELLER')
  final SortOrder? seller;

  @JsonKey(name: r'REMARKS')
  final SortOrder? remarks;

  @JsonKey(name: r'MNGR_NM')
  final SortOrder? mngrNm;

  @JsonKey(name: r'FUEL')
  final SortOrder? fuel;

  @JsonKey(name: r'MANU_DT')
  final SortOrder? manuDt;

  @JsonKey(name: r'EFFIC')
  final SortOrder? effic;

  @JsonKey(name: r'INSUR')
  final SortOrder? insur;

  @JsonKey(name: r'INSUR_MNGR')
  final SortOrder? insurMngr;

  @JsonKey(name: r'EMG_TEL')
  final SortOrder? emgTel;

  @JsonKey(name: r'STORE_NM')
  final SortOrder? storeNm;

  @JsonKey(name: r'STORE_TEL')
  final SortOrder? storeTel;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARASSETTBLCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETTBLAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const CARASSETTBLAvgOrderByAggregateInput({
    this.seq,
    this.amount,
  });

  factory CARASSETTBLAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARASSETTBLAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @override
  Map<String, dynamic> toJson() =>
      _$CARASSETTBLAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETTBLMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const CARASSETTBLMaxOrderByAggregateInput({
    this.seq,
    this.assetNo,
    this.modelNo,
    this.carNo,
    this.owner,
    this.ownerType,
    this.amount,
    this.buyDate,
    this.seller,
    this.remarks,
    this.mngrNm,
    this.fuel,
    this.manuDt,
    this.effic,
    this.insur,
    this.insurMngr,
    this.emgTel,
    this.storeNm,
    this.storeTel,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory CARASSETTBLMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARASSETTBLMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ASSET_NO')
  final SortOrder? assetNo;

  @JsonKey(name: r'MODEL_NO')
  final SortOrder? modelNo;

  @JsonKey(name: r'CAR_NO')
  final SortOrder? carNo;

  @JsonKey(name: r'OWNER')
  final SortOrder? owner;

  @JsonKey(name: r'OWNER_TYPE')
  final SortOrder? ownerType;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @JsonKey(name: r'BUY_DATE')
  final SortOrder? buyDate;

  @JsonKey(name: r'SELLER')
  final SortOrder? seller;

  @JsonKey(name: r'REMARKS')
  final SortOrder? remarks;

  @JsonKey(name: r'MNGR_NM')
  final SortOrder? mngrNm;

  @JsonKey(name: r'FUEL')
  final SortOrder? fuel;

  @JsonKey(name: r'MANU_DT')
  final SortOrder? manuDt;

  @JsonKey(name: r'EFFIC')
  final SortOrder? effic;

  @JsonKey(name: r'INSUR')
  final SortOrder? insur;

  @JsonKey(name: r'INSUR_MNGR')
  final SortOrder? insurMngr;

  @JsonKey(name: r'EMG_TEL')
  final SortOrder? emgTel;

  @JsonKey(name: r'STORE_NM')
  final SortOrder? storeNm;

  @JsonKey(name: r'STORE_TEL')
  final SortOrder? storeTel;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARASSETTBLMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETTBLMinOrderByAggregateInput implements _i1.JsonSerializable {
  const CARASSETTBLMinOrderByAggregateInput({
    this.seq,
    this.assetNo,
    this.modelNo,
    this.carNo,
    this.owner,
    this.ownerType,
    this.amount,
    this.buyDate,
    this.seller,
    this.remarks,
    this.mngrNm,
    this.fuel,
    this.manuDt,
    this.effic,
    this.insur,
    this.insurMngr,
    this.emgTel,
    this.storeNm,
    this.storeTel,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory CARASSETTBLMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARASSETTBLMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ASSET_NO')
  final SortOrder? assetNo;

  @JsonKey(name: r'MODEL_NO')
  final SortOrder? modelNo;

  @JsonKey(name: r'CAR_NO')
  final SortOrder? carNo;

  @JsonKey(name: r'OWNER')
  final SortOrder? owner;

  @JsonKey(name: r'OWNER_TYPE')
  final SortOrder? ownerType;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @JsonKey(name: r'BUY_DATE')
  final SortOrder? buyDate;

  @JsonKey(name: r'SELLER')
  final SortOrder? seller;

  @JsonKey(name: r'REMARKS')
  final SortOrder? remarks;

  @JsonKey(name: r'MNGR_NM')
  final SortOrder? mngrNm;

  @JsonKey(name: r'FUEL')
  final SortOrder? fuel;

  @JsonKey(name: r'MANU_DT')
  final SortOrder? manuDt;

  @JsonKey(name: r'EFFIC')
  final SortOrder? effic;

  @JsonKey(name: r'INSUR')
  final SortOrder? insur;

  @JsonKey(name: r'INSUR_MNGR')
  final SortOrder? insurMngr;

  @JsonKey(name: r'EMG_TEL')
  final SortOrder? emgTel;

  @JsonKey(name: r'STORE_NM')
  final SortOrder? storeNm;

  @JsonKey(name: r'STORE_TEL')
  final SortOrder? storeTel;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARASSETTBLMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARASSETTBLSumOrderByAggregateInput implements _i1.JsonSerializable {
  const CARASSETTBLSumOrderByAggregateInput({
    this.seq,
    this.amount,
  });

  factory CARASSETTBLSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARASSETTBLSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @override
  Map<String, dynamic> toJson() =>
      _$CARASSETTBLSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARCHARGETBLCountOrderByAggregateInput implements _i1.JsonSerializable {
  const CARCHARGETBLCountOrderByAggregateInput({
    this.seq,
    this.item,
    this.charge,
    this.writerId,
    this.memo,
    this.regDate,
  });

  factory CARCHARGETBLCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARCHARGETBLCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ITEM')
  final SortOrder? item;

  @JsonKey(name: r'CHARGE')
  final SortOrder? charge;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'MEMO')
  final SortOrder? memo;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARCHARGETBLCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARCHARGETBLAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const CARCHARGETBLAvgOrderByAggregateInput({
    this.seq,
    this.charge,
  });

  factory CARCHARGETBLAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARCHARGETBLAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'CHARGE')
  final SortOrder? charge;

  @override
  Map<String, dynamic> toJson() =>
      _$CARCHARGETBLAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARCHARGETBLMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const CARCHARGETBLMaxOrderByAggregateInput({
    this.seq,
    this.item,
    this.charge,
    this.writerId,
    this.memo,
    this.regDate,
  });

  factory CARCHARGETBLMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARCHARGETBLMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ITEM')
  final SortOrder? item;

  @JsonKey(name: r'CHARGE')
  final SortOrder? charge;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'MEMO')
  final SortOrder? memo;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARCHARGETBLMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARCHARGETBLMinOrderByAggregateInput implements _i1.JsonSerializable {
  const CARCHARGETBLMinOrderByAggregateInput({
    this.seq,
    this.item,
    this.charge,
    this.writerId,
    this.memo,
    this.regDate,
  });

  factory CARCHARGETBLMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARCHARGETBLMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ITEM')
  final SortOrder? item;

  @JsonKey(name: r'CHARGE')
  final SortOrder? charge;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'MEMO')
  final SortOrder? memo;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARCHARGETBLMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARCHARGETBLSumOrderByAggregateInput implements _i1.JsonSerializable {
  const CARCHARGETBLSumOrderByAggregateInput({
    this.seq,
    this.charge,
  });

  factory CARCHARGETBLSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARCHARGETBLSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'CHARGE')
  final SortOrder? charge;

  @override
  Map<String, dynamic> toJson() =>
      _$CARCHARGETBLSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARINFOTBLCountOrderByAggregateInput implements _i1.JsonSerializable {
  const CARINFOTBLCountOrderByAggregateInput({
    this.sort,
    this.carManageNo,
    this.model,
    this.userId,
    this.regDate,
    this.disusedYn,
  });

  factory CARINFOTBLCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARINFOTBLCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'CAR_MANAGE_NO')
  final SortOrder? carManageNo;

  @JsonKey(name: r'MODEL')
  final SortOrder? model;

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'DISUSED_YN')
  final SortOrder? disusedYn;

  @override
  Map<String, dynamic> toJson() =>
      _$CARINFOTBLCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARINFOTBLAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const CARINFOTBLAvgOrderByAggregateInput({this.sort});

  factory CARINFOTBLAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARINFOTBLAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @override
  Map<String, dynamic> toJson() =>
      _$CARINFOTBLAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARINFOTBLMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const CARINFOTBLMaxOrderByAggregateInput({
    this.sort,
    this.carManageNo,
    this.model,
    this.userId,
    this.regDate,
    this.disusedYn,
  });

  factory CARINFOTBLMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARINFOTBLMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'CAR_MANAGE_NO')
  final SortOrder? carManageNo;

  @JsonKey(name: r'MODEL')
  final SortOrder? model;

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'DISUSED_YN')
  final SortOrder? disusedYn;

  @override
  Map<String, dynamic> toJson() =>
      _$CARINFOTBLMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARINFOTBLMinOrderByAggregateInput implements _i1.JsonSerializable {
  const CARINFOTBLMinOrderByAggregateInput({
    this.sort,
    this.carManageNo,
    this.model,
    this.userId,
    this.regDate,
    this.disusedYn,
  });

  factory CARINFOTBLMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARINFOTBLMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'CAR_MANAGE_NO')
  final SortOrder? carManageNo;

  @JsonKey(name: r'MODEL')
  final SortOrder? model;

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'DISUSED_YN')
  final SortOrder? disusedYn;

  @override
  Map<String, dynamic> toJson() =>
      _$CARINFOTBLMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARINFOTBLSumOrderByAggregateInput implements _i1.JsonSerializable {
  const CARINFOTBLSumOrderByAggregateInput({this.sort});

  factory CARINFOTBLSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARINFOTBLSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @override
  Map<String, dynamic> toJson() =>
      _$CARINFOTBLSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARMILEAGETBLCountOrderByAggregateInput implements _i1.JsonSerializable {
  const CARMILEAGETBLCountOrderByAggregateInput({
    this.seq,
    this.carManageNo,
    this.forUse,
    this.stPoint,
    this.destination,
    this.mileage,
    this.totalMileage,
    this.recordDate,
    this.writerId,
    this.editorId,
    this.regDate,
    this.apprYn,
  });

  factory CARMILEAGETBLCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARMILEAGETBLCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'CAR_MANAGE_NO')
  final SortOrder? carManageNo;

  @JsonKey(name: r'FOR_USE')
  final SortOrder? forUse;

  @JsonKey(name: r'ST_POINT')
  final SortOrder? stPoint;

  @JsonKey(name: r'DESTINATION')
  final SortOrder? destination;

  @JsonKey(name: r'MILEAGE')
  final SortOrder? mileage;

  @JsonKey(name: r'TOTAL_MILEAGE')
  final SortOrder? totalMileage;

  @JsonKey(name: r'RECORD_DATE')
  final SortOrder? recordDate;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'EDITOR_ID')
  final SortOrder? editorId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'APPR_YN')
  final SortOrder? apprYn;

  @override
  Map<String, dynamic> toJson() =>
      _$CARMILEAGETBLCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARMILEAGETBLAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const CARMILEAGETBLAvgOrderByAggregateInput({
    this.seq,
    this.mileage,
    this.totalMileage,
  });

  factory CARMILEAGETBLAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARMILEAGETBLAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MILEAGE')
  final SortOrder? mileage;

  @JsonKey(name: r'TOTAL_MILEAGE')
  final SortOrder? totalMileage;

  @override
  Map<String, dynamic> toJson() =>
      _$CARMILEAGETBLAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARMILEAGETBLMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const CARMILEAGETBLMaxOrderByAggregateInput({
    this.seq,
    this.carManageNo,
    this.forUse,
    this.stPoint,
    this.destination,
    this.mileage,
    this.totalMileage,
    this.recordDate,
    this.writerId,
    this.editorId,
    this.regDate,
    this.apprYn,
  });

  factory CARMILEAGETBLMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARMILEAGETBLMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'CAR_MANAGE_NO')
  final SortOrder? carManageNo;

  @JsonKey(name: r'FOR_USE')
  final SortOrder? forUse;

  @JsonKey(name: r'ST_POINT')
  final SortOrder? stPoint;

  @JsonKey(name: r'DESTINATION')
  final SortOrder? destination;

  @JsonKey(name: r'MILEAGE')
  final SortOrder? mileage;

  @JsonKey(name: r'TOTAL_MILEAGE')
  final SortOrder? totalMileage;

  @JsonKey(name: r'RECORD_DATE')
  final SortOrder? recordDate;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'EDITOR_ID')
  final SortOrder? editorId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'APPR_YN')
  final SortOrder? apprYn;

  @override
  Map<String, dynamic> toJson() =>
      _$CARMILEAGETBLMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARMILEAGETBLMinOrderByAggregateInput implements _i1.JsonSerializable {
  const CARMILEAGETBLMinOrderByAggregateInput({
    this.seq,
    this.carManageNo,
    this.forUse,
    this.stPoint,
    this.destination,
    this.mileage,
    this.totalMileage,
    this.recordDate,
    this.writerId,
    this.editorId,
    this.regDate,
    this.apprYn,
  });

  factory CARMILEAGETBLMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARMILEAGETBLMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'CAR_MANAGE_NO')
  final SortOrder? carManageNo;

  @JsonKey(name: r'FOR_USE')
  final SortOrder? forUse;

  @JsonKey(name: r'ST_POINT')
  final SortOrder? stPoint;

  @JsonKey(name: r'DESTINATION')
  final SortOrder? destination;

  @JsonKey(name: r'MILEAGE')
  final SortOrder? mileage;

  @JsonKey(name: r'TOTAL_MILEAGE')
  final SortOrder? totalMileage;

  @JsonKey(name: r'RECORD_DATE')
  final SortOrder? recordDate;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'EDITOR_ID')
  final SortOrder? editorId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'APPR_YN')
  final SortOrder? apprYn;

  @override
  Map<String, dynamic> toJson() =>
      _$CARMILEAGETBLMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARMILEAGETBLSumOrderByAggregateInput implements _i1.JsonSerializable {
  const CARMILEAGETBLSumOrderByAggregateInput({
    this.seq,
    this.mileage,
    this.totalMileage,
  });

  factory CARMILEAGETBLSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARMILEAGETBLSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MILEAGE')
  final SortOrder? mileage;

  @JsonKey(name: r'TOTAL_MILEAGE')
  final SortOrder? totalMileage;

  @override
  Map<String, dynamic> toJson() =>
      _$CARMILEAGETBLSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARPARTREPLACETBLCountOrderByAggregateInput
    implements _i1.JsonSerializable {
  const CARPARTREPLACETBLCountOrderByAggregateInput({
    this.seq,
    this.partNm,
    this.replacePeriod,
    this.reTotalMileage,
    this.nowTotalMileage,
    this.remainMileage,
    this.replaceCount,
    this.partReDate,
    this.writerId,
    this.regDate,
  });

  factory CARPARTREPLACETBLCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARPARTREPLACETBLCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'PART_NM')
  final SortOrder? partNm;

  @JsonKey(name: r'REPLACE_PERIOD')
  final SortOrder? replacePeriod;

  @JsonKey(name: r'RE_TOTAL_MILEAGE')
  final SortOrder? reTotalMileage;

  @JsonKey(name: r'NOW_TOTAL_MILEAGE')
  final SortOrder? nowTotalMileage;

  @JsonKey(name: r'REMAIN_MILEAGE')
  final SortOrder? remainMileage;

  @JsonKey(name: r'REPLACE_COUNT')
  final SortOrder? replaceCount;

  @JsonKey(name: r'PART_RE_DATE')
  final SortOrder? partReDate;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARPARTREPLACETBLCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARPARTREPLACETBLAvgOrderByAggregateInput
    implements _i1.JsonSerializable {
  const CARPARTREPLACETBLAvgOrderByAggregateInput({
    this.seq,
    this.replacePeriod,
    this.reTotalMileage,
    this.nowTotalMileage,
    this.remainMileage,
    this.replaceCount,
  });

  factory CARPARTREPLACETBLAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARPARTREPLACETBLAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'REPLACE_PERIOD')
  final SortOrder? replacePeriod;

  @JsonKey(name: r'RE_TOTAL_MILEAGE')
  final SortOrder? reTotalMileage;

  @JsonKey(name: r'NOW_TOTAL_MILEAGE')
  final SortOrder? nowTotalMileage;

  @JsonKey(name: r'REMAIN_MILEAGE')
  final SortOrder? remainMileage;

  @JsonKey(name: r'REPLACE_COUNT')
  final SortOrder? replaceCount;

  @override
  Map<String, dynamic> toJson() =>
      _$CARPARTREPLACETBLAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARPARTREPLACETBLMaxOrderByAggregateInput
    implements _i1.JsonSerializable {
  const CARPARTREPLACETBLMaxOrderByAggregateInput({
    this.seq,
    this.partNm,
    this.replacePeriod,
    this.reTotalMileage,
    this.nowTotalMileage,
    this.remainMileage,
    this.replaceCount,
    this.partReDate,
    this.writerId,
    this.regDate,
  });

  factory CARPARTREPLACETBLMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARPARTREPLACETBLMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'PART_NM')
  final SortOrder? partNm;

  @JsonKey(name: r'REPLACE_PERIOD')
  final SortOrder? replacePeriod;

  @JsonKey(name: r'RE_TOTAL_MILEAGE')
  final SortOrder? reTotalMileage;

  @JsonKey(name: r'NOW_TOTAL_MILEAGE')
  final SortOrder? nowTotalMileage;

  @JsonKey(name: r'REMAIN_MILEAGE')
  final SortOrder? remainMileage;

  @JsonKey(name: r'REPLACE_COUNT')
  final SortOrder? replaceCount;

  @JsonKey(name: r'PART_RE_DATE')
  final SortOrder? partReDate;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARPARTREPLACETBLMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARPARTREPLACETBLMinOrderByAggregateInput
    implements _i1.JsonSerializable {
  const CARPARTREPLACETBLMinOrderByAggregateInput({
    this.seq,
    this.partNm,
    this.replacePeriod,
    this.reTotalMileage,
    this.nowTotalMileage,
    this.remainMileage,
    this.replaceCount,
    this.partReDate,
    this.writerId,
    this.regDate,
  });

  factory CARPARTREPLACETBLMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARPARTREPLACETBLMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'PART_NM')
  final SortOrder? partNm;

  @JsonKey(name: r'REPLACE_PERIOD')
  final SortOrder? replacePeriod;

  @JsonKey(name: r'RE_TOTAL_MILEAGE')
  final SortOrder? reTotalMileage;

  @JsonKey(name: r'NOW_TOTAL_MILEAGE')
  final SortOrder? nowTotalMileage;

  @JsonKey(name: r'REMAIN_MILEAGE')
  final SortOrder? remainMileage;

  @JsonKey(name: r'REPLACE_COUNT')
  final SortOrder? replaceCount;

  @JsonKey(name: r'PART_RE_DATE')
  final SortOrder? partReDate;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARPARTREPLACETBLMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARPARTREPLACETBLSumOrderByAggregateInput
    implements _i1.JsonSerializable {
  const CARPARTREPLACETBLSumOrderByAggregateInput({
    this.seq,
    this.replacePeriod,
    this.reTotalMileage,
    this.nowTotalMileage,
    this.remainMileage,
    this.replaceCount,
  });

  factory CARPARTREPLACETBLSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARPARTREPLACETBLSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'REPLACE_PERIOD')
  final SortOrder? replacePeriod;

  @JsonKey(name: r'RE_TOTAL_MILEAGE')
  final SortOrder? reTotalMileage;

  @JsonKey(name: r'NOW_TOTAL_MILEAGE')
  final SortOrder? nowTotalMileage;

  @JsonKey(name: r'REMAIN_MILEAGE')
  final SortOrder? remainMileage;

  @JsonKey(name: r'REPLACE_COUNT')
  final SortOrder? replaceCount;

  @override
  Map<String, dynamic> toJson() =>
      _$CARPARTREPLACETBLSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class BigIntNullableFilter implements _i1.JsonSerializable {
  const BigIntNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  factory BigIntNullableFilter.fromJson(Map<String, dynamic> json) =>
      _$BigIntNullableFilterFromJson(json);

  final BigInt? equals;

  @JsonKey(name: r'in')
  final Iterable<BigInt>? $in;

  final Iterable<BigInt>? notIn;

  final BigInt? lt;

  final BigInt? lte;

  final BigInt? gt;

  final BigInt? gte;

  final NestedBigIntNullableFilter? not;

  @override
  Map<String, dynamic> toJson() => _$BigIntNullableFilterToJson(this);
}

@_i1.jsonSerializable
class CARREPAIRLOGCountOrderByAggregateInput implements _i1.JsonSerializable {
  const CARREPAIRLOGCountOrderByAggregateInput({
    this.seq,
    this.mseq,
    this.assetNo,
    this.repairDe,
    this.repairAmount,
    this.repairStore,
    this.repairLog,
    this.repairOwner,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory CARREPAIRLOGCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARREPAIRLOGCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'ASSET_NO')
  final SortOrder? assetNo;

  @JsonKey(name: r'REPAIR_DE')
  final SortOrder? repairDe;

  @JsonKey(name: r'REPAIR_AMOUNT')
  final SortOrder? repairAmount;

  @JsonKey(name: r'REPAIR_STORE')
  final SortOrder? repairStore;

  @JsonKey(name: r'REPAIR_LOG')
  final SortOrder? repairLog;

  @JsonKey(name: r'REPAIR_OWNER')
  final SortOrder? repairOwner;

  @JsonKey(name: r'FILE_TP')
  final SortOrder? fileTp;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final SortOrder? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final SortOrder? streFileNm;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARREPAIRLOGCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARREPAIRLOGAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const CARREPAIRLOGAvgOrderByAggregateInput({
    this.seq,
    this.mseq,
  });

  factory CARREPAIRLOGAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARREPAIRLOGAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @override
  Map<String, dynamic> toJson() =>
      _$CARREPAIRLOGAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARREPAIRLOGMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const CARREPAIRLOGMaxOrderByAggregateInput({
    this.seq,
    this.mseq,
    this.assetNo,
    this.repairDe,
    this.repairAmount,
    this.repairStore,
    this.repairLog,
    this.repairOwner,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory CARREPAIRLOGMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARREPAIRLOGMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'ASSET_NO')
  final SortOrder? assetNo;

  @JsonKey(name: r'REPAIR_DE')
  final SortOrder? repairDe;

  @JsonKey(name: r'REPAIR_AMOUNT')
  final SortOrder? repairAmount;

  @JsonKey(name: r'REPAIR_STORE')
  final SortOrder? repairStore;

  @JsonKey(name: r'REPAIR_LOG')
  final SortOrder? repairLog;

  @JsonKey(name: r'REPAIR_OWNER')
  final SortOrder? repairOwner;

  @JsonKey(name: r'FILE_TP')
  final SortOrder? fileTp;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final SortOrder? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final SortOrder? streFileNm;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARREPAIRLOGMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARREPAIRLOGMinOrderByAggregateInput implements _i1.JsonSerializable {
  const CARREPAIRLOGMinOrderByAggregateInput({
    this.seq,
    this.mseq,
    this.assetNo,
    this.repairDe,
    this.repairAmount,
    this.repairStore,
    this.repairLog,
    this.repairOwner,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory CARREPAIRLOGMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARREPAIRLOGMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'ASSET_NO')
  final SortOrder? assetNo;

  @JsonKey(name: r'REPAIR_DE')
  final SortOrder? repairDe;

  @JsonKey(name: r'REPAIR_AMOUNT')
  final SortOrder? repairAmount;

  @JsonKey(name: r'REPAIR_STORE')
  final SortOrder? repairStore;

  @JsonKey(name: r'REPAIR_LOG')
  final SortOrder? repairLog;

  @JsonKey(name: r'REPAIR_OWNER')
  final SortOrder? repairOwner;

  @JsonKey(name: r'FILE_TP')
  final SortOrder? fileTp;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final SortOrder? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final SortOrder? streFileNm;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARREPAIRLOGMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARREPAIRLOGSumOrderByAggregateInput implements _i1.JsonSerializable {
  const CARREPAIRLOGSumOrderByAggregateInput({
    this.seq,
    this.mseq,
  });

  factory CARREPAIRLOGSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARREPAIRLOGSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @override
  Map<String, dynamic> toJson() =>
      _$CARREPAIRLOGSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class BigIntNullableWithAggregatesFilter implements _i1.JsonSerializable {
  const BigIntNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory BigIntNullableWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$BigIntNullableWithAggregatesFilterFromJson(json);

  final BigInt? equals;

  @JsonKey(name: r'in')
  final Iterable<BigInt>? $in;

  final Iterable<BigInt>? notIn;

  final BigInt? lt;

  final BigInt? lte;

  final BigInt? gt;

  final BigInt? gte;

  final NestedBigIntNullableWithAggregatesFilter? not;

  @JsonKey(name: r'_count')
  final NestedIntNullableFilter? $count;

  @JsonKey(name: r'_avg')
  final NestedFloatNullableFilter? $avg;

  @JsonKey(name: r'_sum')
  final NestedBigIntNullableFilter? $sum;

  @JsonKey(name: r'_min')
  final NestedBigIntNullableFilter? $min;

  @JsonKey(name: r'_max')
  final NestedBigIntNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() =>
      _$BigIntNullableWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class CARUSEMANAGETBLCountOrderByAggregateInput
    implements _i1.JsonSerializable {
  const CARUSEMANAGETBLCountOrderByAggregateInput({
    this.seq,
    this.carNo,
    this.carType,
    this.destination,
    this.purpose,
    this.users,
    this.useStartDate,
    this.useEndDate,
    this.useBeforeDistance,
    this.useAfterDistance,
    this.remarks,
    this.acceptYn,
    this.regUser,
    this.regDate,
    this.useStartHour,
    this.useEndHour,
    this.cardApply,
  });

  factory CARUSEMANAGETBLCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARUSEMANAGETBLCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'CAR_NO')
  final SortOrder? carNo;

  @JsonKey(name: r'CAR_TYPE')
  final SortOrder? carType;

  @JsonKey(name: r'DESTINATION')
  final SortOrder? destination;

  @JsonKey(name: r'PURPOSE')
  final SortOrder? purpose;

  @JsonKey(name: r'USERS')
  final SortOrder? users;

  @JsonKey(name: r'USE_START_DATE')
  final SortOrder? useStartDate;

  @JsonKey(name: r'USE_END_DATE')
  final SortOrder? useEndDate;

  @JsonKey(name: r'USE_BEFORE_DISTANCE')
  final SortOrder? useBeforeDistance;

  @JsonKey(name: r'USE_AFTER_DISTANCE')
  final SortOrder? useAfterDistance;

  @JsonKey(name: r'REMARKS')
  final SortOrder? remarks;

  @JsonKey(name: r'ACCEPT_YN')
  final SortOrder? acceptYn;

  @JsonKey(name: r'REG_USER')
  final SortOrder? regUser;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'USE_START_HOUR')
  final SortOrder? useStartHour;

  @JsonKey(name: r'USE_END_HOUR')
  final SortOrder? useEndHour;

  @JsonKey(name: r'CARD_APPLY')
  final SortOrder? cardApply;

  @override
  Map<String, dynamic> toJson() =>
      _$CARUSEMANAGETBLCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARUSEMANAGETBLAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const CARUSEMANAGETBLAvgOrderByAggregateInput({
    this.seq,
    this.useBeforeDistance,
    this.useAfterDistance,
  });

  factory CARUSEMANAGETBLAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARUSEMANAGETBLAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'USE_BEFORE_DISTANCE')
  final SortOrder? useBeforeDistance;

  @JsonKey(name: r'USE_AFTER_DISTANCE')
  final SortOrder? useAfterDistance;

  @override
  Map<String, dynamic> toJson() =>
      _$CARUSEMANAGETBLAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARUSEMANAGETBLMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const CARUSEMANAGETBLMaxOrderByAggregateInput({
    this.seq,
    this.carNo,
    this.carType,
    this.destination,
    this.purpose,
    this.users,
    this.useStartDate,
    this.useEndDate,
    this.useBeforeDistance,
    this.useAfterDistance,
    this.remarks,
    this.acceptYn,
    this.regUser,
    this.regDate,
    this.useStartHour,
    this.useEndHour,
    this.cardApply,
  });

  factory CARUSEMANAGETBLMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARUSEMANAGETBLMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'CAR_NO')
  final SortOrder? carNo;

  @JsonKey(name: r'CAR_TYPE')
  final SortOrder? carType;

  @JsonKey(name: r'DESTINATION')
  final SortOrder? destination;

  @JsonKey(name: r'PURPOSE')
  final SortOrder? purpose;

  @JsonKey(name: r'USERS')
  final SortOrder? users;

  @JsonKey(name: r'USE_START_DATE')
  final SortOrder? useStartDate;

  @JsonKey(name: r'USE_END_DATE')
  final SortOrder? useEndDate;

  @JsonKey(name: r'USE_BEFORE_DISTANCE')
  final SortOrder? useBeforeDistance;

  @JsonKey(name: r'USE_AFTER_DISTANCE')
  final SortOrder? useAfterDistance;

  @JsonKey(name: r'REMARKS')
  final SortOrder? remarks;

  @JsonKey(name: r'ACCEPT_YN')
  final SortOrder? acceptYn;

  @JsonKey(name: r'REG_USER')
  final SortOrder? regUser;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'USE_START_HOUR')
  final SortOrder? useStartHour;

  @JsonKey(name: r'USE_END_HOUR')
  final SortOrder? useEndHour;

  @JsonKey(name: r'CARD_APPLY')
  final SortOrder? cardApply;

  @override
  Map<String, dynamic> toJson() =>
      _$CARUSEMANAGETBLMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARUSEMANAGETBLMinOrderByAggregateInput implements _i1.JsonSerializable {
  const CARUSEMANAGETBLMinOrderByAggregateInput({
    this.seq,
    this.carNo,
    this.carType,
    this.destination,
    this.purpose,
    this.users,
    this.useStartDate,
    this.useEndDate,
    this.useBeforeDistance,
    this.useAfterDistance,
    this.remarks,
    this.acceptYn,
    this.regUser,
    this.regDate,
    this.useStartHour,
    this.useEndHour,
    this.cardApply,
  });

  factory CARUSEMANAGETBLMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARUSEMANAGETBLMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'CAR_NO')
  final SortOrder? carNo;

  @JsonKey(name: r'CAR_TYPE')
  final SortOrder? carType;

  @JsonKey(name: r'DESTINATION')
  final SortOrder? destination;

  @JsonKey(name: r'PURPOSE')
  final SortOrder? purpose;

  @JsonKey(name: r'USERS')
  final SortOrder? users;

  @JsonKey(name: r'USE_START_DATE')
  final SortOrder? useStartDate;

  @JsonKey(name: r'USE_END_DATE')
  final SortOrder? useEndDate;

  @JsonKey(name: r'USE_BEFORE_DISTANCE')
  final SortOrder? useBeforeDistance;

  @JsonKey(name: r'USE_AFTER_DISTANCE')
  final SortOrder? useAfterDistance;

  @JsonKey(name: r'REMARKS')
  final SortOrder? remarks;

  @JsonKey(name: r'ACCEPT_YN')
  final SortOrder? acceptYn;

  @JsonKey(name: r'REG_USER')
  final SortOrder? regUser;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'USE_START_HOUR')
  final SortOrder? useStartHour;

  @JsonKey(name: r'USE_END_HOUR')
  final SortOrder? useEndHour;

  @JsonKey(name: r'CARD_APPLY')
  final SortOrder? cardApply;

  @override
  Map<String, dynamic> toJson() =>
      _$CARUSEMANAGETBLMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class CARUSEMANAGETBLSumOrderByAggregateInput implements _i1.JsonSerializable {
  const CARUSEMANAGETBLSumOrderByAggregateInput({
    this.seq,
    this.useBeforeDistance,
    this.useAfterDistance,
  });

  factory CARUSEMANAGETBLSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$CARUSEMANAGETBLSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'USE_BEFORE_DISTANCE')
  final SortOrder? useBeforeDistance;

  @JsonKey(name: r'USE_AFTER_DISTANCE')
  final SortOrder? useAfterDistance;

  @override
  Map<String, dynamic> toJson() =>
      _$CARUSEMANAGETBLSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class HOLIDAYTBLUSERIDSTDYEARCompoundUniqueInput
    implements _i1.JsonSerializable {
  const HOLIDAYTBLUSERIDSTDYEARCompoundUniqueInput({
    required this.userId,
    required this.stdYear,
  });

  factory HOLIDAYTBLUSERIDSTDYEARCompoundUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$HOLIDAYTBLUSERIDSTDYEARCompoundUniqueInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'STD_YEAR')
  final String stdYear;

  @override
  Map<String, dynamic> toJson() =>
      _$HOLIDAYTBLUSERIDSTDYEARCompoundUniqueInputToJson(this);
}

@_i1.jsonSerializable
class HOLIDAYTBLCountOrderByAggregateInput implements _i1.JsonSerializable {
  const HOLIDAYTBLCountOrderByAggregateInput({
    this.userId,
    this.stdYear,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory HOLIDAYTBLCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$HOLIDAYTBLCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'STD_YEAR')
  final SortOrder? stdYear;

  @JsonKey(name: r'M1')
  final SortOrder? m1;

  @JsonKey(name: r'M2')
  final SortOrder? m2;

  @JsonKey(name: r'M3')
  final SortOrder? m3;

  @JsonKey(name: r'M4')
  final SortOrder? m4;

  @JsonKey(name: r'M5')
  final SortOrder? m5;

  @JsonKey(name: r'M6')
  final SortOrder? m6;

  @JsonKey(name: r'M7')
  final SortOrder? m7;

  @JsonKey(name: r'M8')
  final SortOrder? m8;

  @JsonKey(name: r'M9')
  final SortOrder? m9;

  @JsonKey(name: r'M10')
  final SortOrder? m10;

  @JsonKey(name: r'M11')
  final SortOrder? m11;

  @JsonKey(name: r'M12')
  final SortOrder? m12;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$HOLIDAYTBLCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class HOLIDAYTBLAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const HOLIDAYTBLAvgOrderByAggregateInput({
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
  });

  factory HOLIDAYTBLAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$HOLIDAYTBLAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'M1')
  final SortOrder? m1;

  @JsonKey(name: r'M2')
  final SortOrder? m2;

  @JsonKey(name: r'M3')
  final SortOrder? m3;

  @JsonKey(name: r'M4')
  final SortOrder? m4;

  @JsonKey(name: r'M5')
  final SortOrder? m5;

  @JsonKey(name: r'M6')
  final SortOrder? m6;

  @JsonKey(name: r'M7')
  final SortOrder? m7;

  @JsonKey(name: r'M8')
  final SortOrder? m8;

  @JsonKey(name: r'M9')
  final SortOrder? m9;

  @JsonKey(name: r'M10')
  final SortOrder? m10;

  @JsonKey(name: r'M11')
  final SortOrder? m11;

  @JsonKey(name: r'M12')
  final SortOrder? m12;

  @override
  Map<String, dynamic> toJson() =>
      _$HOLIDAYTBLAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class HOLIDAYTBLMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const HOLIDAYTBLMaxOrderByAggregateInput({
    this.userId,
    this.stdYear,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory HOLIDAYTBLMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$HOLIDAYTBLMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'STD_YEAR')
  final SortOrder? stdYear;

  @JsonKey(name: r'M1')
  final SortOrder? m1;

  @JsonKey(name: r'M2')
  final SortOrder? m2;

  @JsonKey(name: r'M3')
  final SortOrder? m3;

  @JsonKey(name: r'M4')
  final SortOrder? m4;

  @JsonKey(name: r'M5')
  final SortOrder? m5;

  @JsonKey(name: r'M6')
  final SortOrder? m6;

  @JsonKey(name: r'M7')
  final SortOrder? m7;

  @JsonKey(name: r'M8')
  final SortOrder? m8;

  @JsonKey(name: r'M9')
  final SortOrder? m9;

  @JsonKey(name: r'M10')
  final SortOrder? m10;

  @JsonKey(name: r'M11')
  final SortOrder? m11;

  @JsonKey(name: r'M12')
  final SortOrder? m12;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$HOLIDAYTBLMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class HOLIDAYTBLMinOrderByAggregateInput implements _i1.JsonSerializable {
  const HOLIDAYTBLMinOrderByAggregateInput({
    this.userId,
    this.stdYear,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory HOLIDAYTBLMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$HOLIDAYTBLMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'STD_YEAR')
  final SortOrder? stdYear;

  @JsonKey(name: r'M1')
  final SortOrder? m1;

  @JsonKey(name: r'M2')
  final SortOrder? m2;

  @JsonKey(name: r'M3')
  final SortOrder? m3;

  @JsonKey(name: r'M4')
  final SortOrder? m4;

  @JsonKey(name: r'M5')
  final SortOrder? m5;

  @JsonKey(name: r'M6')
  final SortOrder? m6;

  @JsonKey(name: r'M7')
  final SortOrder? m7;

  @JsonKey(name: r'M8')
  final SortOrder? m8;

  @JsonKey(name: r'M9')
  final SortOrder? m9;

  @JsonKey(name: r'M10')
  final SortOrder? m10;

  @JsonKey(name: r'M11')
  final SortOrder? m11;

  @JsonKey(name: r'M12')
  final SortOrder? m12;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$HOLIDAYTBLMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class HOLIDAYTBLSumOrderByAggregateInput implements _i1.JsonSerializable {
  const HOLIDAYTBLSumOrderByAggregateInput({
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
  });

  factory HOLIDAYTBLSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$HOLIDAYTBLSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'M1')
  final SortOrder? m1;

  @JsonKey(name: r'M2')
  final SortOrder? m2;

  @JsonKey(name: r'M3')
  final SortOrder? m3;

  @JsonKey(name: r'M4')
  final SortOrder? m4;

  @JsonKey(name: r'M5')
  final SortOrder? m5;

  @JsonKey(name: r'M6')
  final SortOrder? m6;

  @JsonKey(name: r'M7')
  final SortOrder? m7;

  @JsonKey(name: r'M8')
  final SortOrder? m8;

  @JsonKey(name: r'M9')
  final SortOrder? m9;

  @JsonKey(name: r'M10')
  final SortOrder? m10;

  @JsonKey(name: r'M11')
  final SortOrder? m11;

  @JsonKey(name: r'M12')
  final SortOrder? m12;

  @override
  Map<String, dynamic> toJson() =>
      _$HOLIDAYTBLSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class MENUTBLListRelationFilter implements _i1.JsonSerializable {
  const MENUTBLListRelationFilter({
    this.every,
    this.some,
    this.none,
  });

  factory MENUTBLListRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$MENUTBLListRelationFilterFromJson(json);

  final MENUTBLWhereInput? every;

  final MENUTBLWhereInput? some;

  final MENUTBLWhereInput? none;

  @override
  Map<String, dynamic> toJson() => _$MENUTBLListRelationFilterToJson(this);
}

@_i1.jsonSerializable
class MENUTBLOrderByRelationAggregateInput implements _i1.JsonSerializable {
  const MENUTBLOrderByRelationAggregateInput({this.$count});

  factory MENUTBLOrderByRelationAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$MENUTBLOrderByRelationAggregateInputFromJson(json);

  @JsonKey(name: r'_count')
  final SortOrder? $count;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUTBLOrderByRelationAggregateInputToJson(this);
}

@_i1.jsonSerializable
class MEMBERTBLCountOrderByAggregateInput implements _i1.JsonSerializable {
  const MEMBERTBLCountOrderByAggregateInput({
    this.userId,
    this.passwd,
    this.userNm,
    this.dept,
    this.grade,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
    this.lastLoginDate,
    this.memo,
  });

  factory MEMBERTBLCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$MEMBERTBLCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'PASSWD')
  final SortOrder? passwd;

  @JsonKey(name: r'USER_NM')
  final SortOrder? userNm;

  @JsonKey(name: r'DEPT')
  final SortOrder? dept;

  @JsonKey(name: r'GRADE')
  final SortOrder? grade;

  @JsonKey(name: r'JOIN_DATE')
  final SortOrder? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final SortOrder? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final SortOrder? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final SortOrder? pwdWrongCnt;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'LAST_LOGIN_DATE')
  final SortOrder? lastLoginDate;

  @JsonKey(name: r'MEMO')
  final SortOrder? memo;

  @override
  Map<String, dynamic> toJson() =>
      _$MEMBERTBLCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class MEMBERTBLAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const MEMBERTBLAvgOrderByAggregateInput({this.pwdWrongCnt});

  factory MEMBERTBLAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$MEMBERTBLAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'PWD_WRONG_CNT')
  final SortOrder? pwdWrongCnt;

  @override
  Map<String, dynamic> toJson() =>
      _$MEMBERTBLAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class MEMBERTBLMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const MEMBERTBLMaxOrderByAggregateInput({
    this.userId,
    this.passwd,
    this.userNm,
    this.dept,
    this.grade,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
    this.lastLoginDate,
    this.memo,
  });

  factory MEMBERTBLMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$MEMBERTBLMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'PASSWD')
  final SortOrder? passwd;

  @JsonKey(name: r'USER_NM')
  final SortOrder? userNm;

  @JsonKey(name: r'DEPT')
  final SortOrder? dept;

  @JsonKey(name: r'GRADE')
  final SortOrder? grade;

  @JsonKey(name: r'JOIN_DATE')
  final SortOrder? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final SortOrder? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final SortOrder? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final SortOrder? pwdWrongCnt;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'LAST_LOGIN_DATE')
  final SortOrder? lastLoginDate;

  @JsonKey(name: r'MEMO')
  final SortOrder? memo;

  @override
  Map<String, dynamic> toJson() =>
      _$MEMBERTBLMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class MEMBERTBLMinOrderByAggregateInput implements _i1.JsonSerializable {
  const MEMBERTBLMinOrderByAggregateInput({
    this.userId,
    this.passwd,
    this.userNm,
    this.dept,
    this.grade,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
    this.lastLoginDate,
    this.memo,
  });

  factory MEMBERTBLMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$MEMBERTBLMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'PASSWD')
  final SortOrder? passwd;

  @JsonKey(name: r'USER_NM')
  final SortOrder? userNm;

  @JsonKey(name: r'DEPT')
  final SortOrder? dept;

  @JsonKey(name: r'GRADE')
  final SortOrder? grade;

  @JsonKey(name: r'JOIN_DATE')
  final SortOrder? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final SortOrder? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final SortOrder? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final SortOrder? pwdWrongCnt;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'LAST_LOGIN_DATE')
  final SortOrder? lastLoginDate;

  @JsonKey(name: r'MEMO')
  final SortOrder? memo;

  @override
  Map<String, dynamic> toJson() =>
      _$MEMBERTBLMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class MEMBERTBLSumOrderByAggregateInput implements _i1.JsonSerializable {
  const MEMBERTBLSumOrderByAggregateInput({this.pwdWrongCnt});

  factory MEMBERTBLSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$MEMBERTBLSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'PWD_WRONG_CNT')
  final SortOrder? pwdWrongCnt;

  @override
  Map<String, dynamic> toJson() =>
      _$MEMBERTBLSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class MENUAUTHTBLUSERIDMENUIDCompoundUniqueInput
    implements _i1.JsonSerializable {
  const MENUAUTHTBLUSERIDMENUIDCompoundUniqueInput({
    required this.userId,
    required this.menuId,
  });

  factory MENUAUTHTBLUSERIDMENUIDCompoundUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$MENUAUTHTBLUSERIDMENUIDCompoundUniqueInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'MENU_ID')
  final String menuId;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUAUTHTBLUSERIDMENUIDCompoundUniqueInputToJson(this);
}

@_i1.jsonSerializable
class MENUAUTHTBLCountOrderByAggregateInput implements _i1.JsonSerializable {
  const MENUAUTHTBLCountOrderByAggregateInput({
    this.userId,
    this.menuId,
    this.readYn,
    this.writeYn,
    this.regId,
    this.updId,
    this.regDate,
    this.updDate,
  });

  factory MENUAUTHTBLCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$MENUAUTHTBLCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'MENU_ID')
  final SortOrder? menuId;

  @JsonKey(name: r'READ_YN')
  final SortOrder? readYn;

  @JsonKey(name: r'WRITE_YN')
  final SortOrder? writeYn;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'UPD_ID')
  final SortOrder? updId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUAUTHTBLCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class MENUAUTHTBLMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const MENUAUTHTBLMaxOrderByAggregateInput({
    this.userId,
    this.menuId,
    this.readYn,
    this.writeYn,
    this.regId,
    this.updId,
    this.regDate,
    this.updDate,
  });

  factory MENUAUTHTBLMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$MENUAUTHTBLMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'MENU_ID')
  final SortOrder? menuId;

  @JsonKey(name: r'READ_YN')
  final SortOrder? readYn;

  @JsonKey(name: r'WRITE_YN')
  final SortOrder? writeYn;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'UPD_ID')
  final SortOrder? updId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUAUTHTBLMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class MENUAUTHTBLMinOrderByAggregateInput implements _i1.JsonSerializable {
  const MENUAUTHTBLMinOrderByAggregateInput({
    this.userId,
    this.menuId,
    this.readYn,
    this.writeYn,
    this.regId,
    this.updId,
    this.regDate,
    this.updDate,
  });

  factory MENUAUTHTBLMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$MENUAUTHTBLMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'MENU_ID')
  final SortOrder? menuId;

  @JsonKey(name: r'READ_YN')
  final SortOrder? readYn;

  @JsonKey(name: r'WRITE_YN')
  final SortOrder? writeYn;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'UPD_ID')
  final SortOrder? updId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUAUTHTBLMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class MEMBERTBLRelationFilter implements _i1.JsonSerializable {
  const MEMBERTBLRelationFilter({
    this.$is,
    this.isNot,
  });

  factory MEMBERTBLRelationFilter.fromJson(Map<String, dynamic> json) =>
      _$MEMBERTBLRelationFilterFromJson(json);

  @JsonKey(name: r'is')
  final MEMBERTBLWhereInput? $is;

  final MEMBERTBLWhereInput? isNot;

  @override
  Map<String, dynamic> toJson() => _$MEMBERTBLRelationFilterToJson(this);
}

@_i1.jsonSerializable
class MENUTBLCountOrderByAggregateInput implements _i1.JsonSerializable {
  const MENUTBLCountOrderByAggregateInput({
    this.menuId,
    this.menuNm,
    this.depth,
    this.sort,
    this.ownerId,
    this.url,
    this.writerId,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
    this.dispYn,
    this.menuIcon,
  });

  factory MENUTBLCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$MENUTBLCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'MENU_ID')
  final SortOrder? menuId;

  @JsonKey(name: r'MENU_NM')
  final SortOrder? menuNm;

  @JsonKey(name: r'DEPTH')
  final SortOrder? depth;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'OWNER_ID')
  final SortOrder? ownerId;

  @JsonKey(name: r'URL')
  final SortOrder? url;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'DISP_YN')
  final SortOrder? dispYn;

  @JsonKey(name: r'MENU_ICON')
  final SortOrder? menuIcon;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUTBLCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class MENUTBLAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const MENUTBLAvgOrderByAggregateInput({
    this.depth,
    this.sort,
  });

  factory MENUTBLAvgOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$MENUTBLAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'DEPTH')
  final SortOrder? depth;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUTBLAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class MENUTBLMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const MENUTBLMaxOrderByAggregateInput({
    this.menuId,
    this.menuNm,
    this.depth,
    this.sort,
    this.ownerId,
    this.url,
    this.writerId,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
    this.dispYn,
    this.menuIcon,
  });

  factory MENUTBLMaxOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$MENUTBLMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'MENU_ID')
  final SortOrder? menuId;

  @JsonKey(name: r'MENU_NM')
  final SortOrder? menuNm;

  @JsonKey(name: r'DEPTH')
  final SortOrder? depth;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'OWNER_ID')
  final SortOrder? ownerId;

  @JsonKey(name: r'URL')
  final SortOrder? url;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'DISP_YN')
  final SortOrder? dispYn;

  @JsonKey(name: r'MENU_ICON')
  final SortOrder? menuIcon;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUTBLMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class MENUTBLMinOrderByAggregateInput implements _i1.JsonSerializable {
  const MENUTBLMinOrderByAggregateInput({
    this.menuId,
    this.menuNm,
    this.depth,
    this.sort,
    this.ownerId,
    this.url,
    this.writerId,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
    this.dispYn,
    this.menuIcon,
  });

  factory MENUTBLMinOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$MENUTBLMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'MENU_ID')
  final SortOrder? menuId;

  @JsonKey(name: r'MENU_NM')
  final SortOrder? menuNm;

  @JsonKey(name: r'DEPTH')
  final SortOrder? depth;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'OWNER_ID')
  final SortOrder? ownerId;

  @JsonKey(name: r'URL')
  final SortOrder? url;

  @JsonKey(name: r'WRITER_ID')
  final SortOrder? writerId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'DISP_YN')
  final SortOrder? dispYn;

  @JsonKey(name: r'MENU_ICON')
  final SortOrder? menuIcon;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUTBLMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class MENUTBLSumOrderByAggregateInput implements _i1.JsonSerializable {
  const MENUTBLSumOrderByAggregateInput({
    this.depth,
    this.sort,
  });

  factory MENUTBLSumOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$MENUTBLSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'DEPTH')
  final SortOrder? depth;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUTBLSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class OFFICEASSETTBLCountOrderByAggregateInput implements _i1.JsonSerializable {
  const OFFICEASSETTBLCountOrderByAggregateInput({
    this.seq,
    this.assetNo,
    this.assetType,
    this.seller,
    this.buyDate,
    this.modelNo,
    this.serialNo,
    this.amount,
    this.keepYear,
    this.mngDept,
    this.assetAccount,
    this.remarks,
    this.carryOut,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory OFFICEASSETTBLCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$OFFICEASSETTBLCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ASSET_NO')
  final SortOrder? assetNo;

  @JsonKey(name: r'ASSET_TYPE')
  final SortOrder? assetType;

  @JsonKey(name: r'SELLER')
  final SortOrder? seller;

  @JsonKey(name: r'BUY_DATE')
  final SortOrder? buyDate;

  @JsonKey(name: r'MODEL_NO')
  final SortOrder? modelNo;

  @JsonKey(name: r'SERIAL_NO')
  final SortOrder? serialNo;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @JsonKey(name: r'KEEP_YEAR')
  final SortOrder? keepYear;

  @JsonKey(name: r'MNG_DEPT')
  final SortOrder? mngDept;

  @JsonKey(name: r'ASSET_ACCOUNT')
  final SortOrder? assetAccount;

  @JsonKey(name: r'REMARKS')
  final SortOrder? remarks;

  @JsonKey(name: r'CARRY_OUT')
  final SortOrder? carryOut;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$OFFICEASSETTBLCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class OFFICEASSETTBLAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const OFFICEASSETTBLAvgOrderByAggregateInput({
    this.seq,
    this.amount,
    this.keepYear,
  });

  factory OFFICEASSETTBLAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$OFFICEASSETTBLAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @JsonKey(name: r'KEEP_YEAR')
  final SortOrder? keepYear;

  @override
  Map<String, dynamic> toJson() =>
      _$OFFICEASSETTBLAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class OFFICEASSETTBLMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const OFFICEASSETTBLMaxOrderByAggregateInput({
    this.seq,
    this.assetNo,
    this.assetType,
    this.seller,
    this.buyDate,
    this.modelNo,
    this.serialNo,
    this.amount,
    this.keepYear,
    this.mngDept,
    this.assetAccount,
    this.remarks,
    this.carryOut,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory OFFICEASSETTBLMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$OFFICEASSETTBLMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ASSET_NO')
  final SortOrder? assetNo;

  @JsonKey(name: r'ASSET_TYPE')
  final SortOrder? assetType;

  @JsonKey(name: r'SELLER')
  final SortOrder? seller;

  @JsonKey(name: r'BUY_DATE')
  final SortOrder? buyDate;

  @JsonKey(name: r'MODEL_NO')
  final SortOrder? modelNo;

  @JsonKey(name: r'SERIAL_NO')
  final SortOrder? serialNo;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @JsonKey(name: r'KEEP_YEAR')
  final SortOrder? keepYear;

  @JsonKey(name: r'MNG_DEPT')
  final SortOrder? mngDept;

  @JsonKey(name: r'ASSET_ACCOUNT')
  final SortOrder? assetAccount;

  @JsonKey(name: r'REMARKS')
  final SortOrder? remarks;

  @JsonKey(name: r'CARRY_OUT')
  final SortOrder? carryOut;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$OFFICEASSETTBLMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class OFFICEASSETTBLMinOrderByAggregateInput implements _i1.JsonSerializable {
  const OFFICEASSETTBLMinOrderByAggregateInput({
    this.seq,
    this.assetNo,
    this.assetType,
    this.seller,
    this.buyDate,
    this.modelNo,
    this.serialNo,
    this.amount,
    this.keepYear,
    this.mngDept,
    this.assetAccount,
    this.remarks,
    this.carryOut,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory OFFICEASSETTBLMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$OFFICEASSETTBLMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ASSET_NO')
  final SortOrder? assetNo;

  @JsonKey(name: r'ASSET_TYPE')
  final SortOrder? assetType;

  @JsonKey(name: r'SELLER')
  final SortOrder? seller;

  @JsonKey(name: r'BUY_DATE')
  final SortOrder? buyDate;

  @JsonKey(name: r'MODEL_NO')
  final SortOrder? modelNo;

  @JsonKey(name: r'SERIAL_NO')
  final SortOrder? serialNo;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @JsonKey(name: r'KEEP_YEAR')
  final SortOrder? keepYear;

  @JsonKey(name: r'MNG_DEPT')
  final SortOrder? mngDept;

  @JsonKey(name: r'ASSET_ACCOUNT')
  final SortOrder? assetAccount;

  @JsonKey(name: r'REMARKS')
  final SortOrder? remarks;

  @JsonKey(name: r'CARRY_OUT')
  final SortOrder? carryOut;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$OFFICEASSETTBLMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class OFFICEASSETTBLSumOrderByAggregateInput implements _i1.JsonSerializable {
  const OFFICEASSETTBLSumOrderByAggregateInput({
    this.seq,
    this.amount,
    this.keepYear,
  });

  factory OFFICEASSETTBLSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$OFFICEASSETTBLSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @JsonKey(name: r'KEEP_YEAR')
  final SortOrder? keepYear;

  @override
  Map<String, dynamic> toJson() =>
      _$OFFICEASSETTBLSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class SERVERASSETTBLCountOrderByAggregateInput implements _i1.JsonSerializable {
  const SERVERASSETTBLCountOrderByAggregateInput({
    this.seq,
    this.assetNo,
    this.assetType,
    this.maker,
    this.cnt,
    this.amount,
    this.buyDate,
    this.seller,
    this.modelNo,
    this.serialNo,
    this.hostname,
    this.builtLoc,
    this.useDesc,
    this.osInfo,
    this.cpuInfo,
    this.ramInfo,
    this.hddInfo,
    this.ssdInfo,
    this.odd,
    this.remarks,
    this.carryOut,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory SERVERASSETTBLCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$SERVERASSETTBLCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ASSET_NO')
  final SortOrder? assetNo;

  @JsonKey(name: r'ASSET_TYPE')
  final SortOrder? assetType;

  @JsonKey(name: r'MAKER')
  final SortOrder? maker;

  @JsonKey(name: r'CNT')
  final SortOrder? cnt;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @JsonKey(name: r'BUY_DATE')
  final SortOrder? buyDate;

  @JsonKey(name: r'SELLER')
  final SortOrder? seller;

  @JsonKey(name: r'MODEL_NO')
  final SortOrder? modelNo;

  @JsonKey(name: r'SERIAL_NO')
  final SortOrder? serialNo;

  @JsonKey(name: r'HOSTNAME')
  final SortOrder? hostname;

  @JsonKey(name: r'BUILT_LOC')
  final SortOrder? builtLoc;

  @JsonKey(name: r'USE_DESC')
  final SortOrder? useDesc;

  @JsonKey(name: r'OS_INFO')
  final SortOrder? osInfo;

  @JsonKey(name: r'CPU_INFO')
  final SortOrder? cpuInfo;

  @JsonKey(name: r'RAM_INFO')
  final SortOrder? ramInfo;

  @JsonKey(name: r'HDD_INFO')
  final SortOrder? hddInfo;

  @JsonKey(name: r'SSD_INFO')
  final SortOrder? ssdInfo;

  @JsonKey(name: r'ODD')
  final SortOrder? odd;

  @JsonKey(name: r'REMARKS')
  final SortOrder? remarks;

  @JsonKey(name: r'CARRY_OUT')
  final SortOrder? carryOut;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$SERVERASSETTBLCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class SERVERASSETTBLAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const SERVERASSETTBLAvgOrderByAggregateInput({
    this.seq,
    this.cnt,
    this.amount,
  });

  factory SERVERASSETTBLAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$SERVERASSETTBLAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'CNT')
  final SortOrder? cnt;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @override
  Map<String, dynamic> toJson() =>
      _$SERVERASSETTBLAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class SERVERASSETTBLMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const SERVERASSETTBLMaxOrderByAggregateInput({
    this.seq,
    this.assetNo,
    this.assetType,
    this.maker,
    this.cnt,
    this.amount,
    this.buyDate,
    this.seller,
    this.modelNo,
    this.serialNo,
    this.hostname,
    this.builtLoc,
    this.useDesc,
    this.osInfo,
    this.cpuInfo,
    this.ramInfo,
    this.hddInfo,
    this.ssdInfo,
    this.odd,
    this.remarks,
    this.carryOut,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory SERVERASSETTBLMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$SERVERASSETTBLMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ASSET_NO')
  final SortOrder? assetNo;

  @JsonKey(name: r'ASSET_TYPE')
  final SortOrder? assetType;

  @JsonKey(name: r'MAKER')
  final SortOrder? maker;

  @JsonKey(name: r'CNT')
  final SortOrder? cnt;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @JsonKey(name: r'BUY_DATE')
  final SortOrder? buyDate;

  @JsonKey(name: r'SELLER')
  final SortOrder? seller;

  @JsonKey(name: r'MODEL_NO')
  final SortOrder? modelNo;

  @JsonKey(name: r'SERIAL_NO')
  final SortOrder? serialNo;

  @JsonKey(name: r'HOSTNAME')
  final SortOrder? hostname;

  @JsonKey(name: r'BUILT_LOC')
  final SortOrder? builtLoc;

  @JsonKey(name: r'USE_DESC')
  final SortOrder? useDesc;

  @JsonKey(name: r'OS_INFO')
  final SortOrder? osInfo;

  @JsonKey(name: r'CPU_INFO')
  final SortOrder? cpuInfo;

  @JsonKey(name: r'RAM_INFO')
  final SortOrder? ramInfo;

  @JsonKey(name: r'HDD_INFO')
  final SortOrder? hddInfo;

  @JsonKey(name: r'SSD_INFO')
  final SortOrder? ssdInfo;

  @JsonKey(name: r'ODD')
  final SortOrder? odd;

  @JsonKey(name: r'REMARKS')
  final SortOrder? remarks;

  @JsonKey(name: r'CARRY_OUT')
  final SortOrder? carryOut;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$SERVERASSETTBLMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class SERVERASSETTBLMinOrderByAggregateInput implements _i1.JsonSerializable {
  const SERVERASSETTBLMinOrderByAggregateInput({
    this.seq,
    this.assetNo,
    this.assetType,
    this.maker,
    this.cnt,
    this.amount,
    this.buyDate,
    this.seller,
    this.modelNo,
    this.serialNo,
    this.hostname,
    this.builtLoc,
    this.useDesc,
    this.osInfo,
    this.cpuInfo,
    this.ramInfo,
    this.hddInfo,
    this.ssdInfo,
    this.odd,
    this.remarks,
    this.carryOut,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory SERVERASSETTBLMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$SERVERASSETTBLMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ASSET_NO')
  final SortOrder? assetNo;

  @JsonKey(name: r'ASSET_TYPE')
  final SortOrder? assetType;

  @JsonKey(name: r'MAKER')
  final SortOrder? maker;

  @JsonKey(name: r'CNT')
  final SortOrder? cnt;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @JsonKey(name: r'BUY_DATE')
  final SortOrder? buyDate;

  @JsonKey(name: r'SELLER')
  final SortOrder? seller;

  @JsonKey(name: r'MODEL_NO')
  final SortOrder? modelNo;

  @JsonKey(name: r'SERIAL_NO')
  final SortOrder? serialNo;

  @JsonKey(name: r'HOSTNAME')
  final SortOrder? hostname;

  @JsonKey(name: r'BUILT_LOC')
  final SortOrder? builtLoc;

  @JsonKey(name: r'USE_DESC')
  final SortOrder? useDesc;

  @JsonKey(name: r'OS_INFO')
  final SortOrder? osInfo;

  @JsonKey(name: r'CPU_INFO')
  final SortOrder? cpuInfo;

  @JsonKey(name: r'RAM_INFO')
  final SortOrder? ramInfo;

  @JsonKey(name: r'HDD_INFO')
  final SortOrder? hddInfo;

  @JsonKey(name: r'SSD_INFO')
  final SortOrder? ssdInfo;

  @JsonKey(name: r'ODD')
  final SortOrder? odd;

  @JsonKey(name: r'REMARKS')
  final SortOrder? remarks;

  @JsonKey(name: r'CARRY_OUT')
  final SortOrder? carryOut;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$SERVERASSETTBLMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class SERVERASSETTBLSumOrderByAggregateInput implements _i1.JsonSerializable {
  const SERVERASSETTBLSumOrderByAggregateInput({
    this.seq,
    this.cnt,
    this.amount,
  });

  factory SERVERASSETTBLSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$SERVERASSETTBLSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'CNT')
  final SortOrder? cnt;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @override
  Map<String, dynamic> toJson() =>
      _$SERVERASSETTBLSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class SOFTWAREASSETTBLCountOrderByAggregateInput
    implements _i1.JsonSerializable {
  const SOFTWAREASSETTBLCountOrderByAggregateInput({
    this.seq,
    this.assetNo,
    this.softwareNm,
    this.versionNm,
    this.cnt,
    this.amount,
    this.buyDate,
    this.serialNo,
    this.licenseNo,
    this.userNm,
    this.remarks,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory SOFTWAREASSETTBLCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$SOFTWAREASSETTBLCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ASSET_NO')
  final SortOrder? assetNo;

  @JsonKey(name: r'SOFTWARE_NM')
  final SortOrder? softwareNm;

  @JsonKey(name: r'VERSION_NM')
  final SortOrder? versionNm;

  @JsonKey(name: r'CNT')
  final SortOrder? cnt;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @JsonKey(name: r'BUY_DATE')
  final SortOrder? buyDate;

  @JsonKey(name: r'SERIAL_NO')
  final SortOrder? serialNo;

  @JsonKey(name: r'LICENSE_NO')
  final SortOrder? licenseNo;

  @JsonKey(name: r'USER_NM')
  final SortOrder? userNm;

  @JsonKey(name: r'REMARKS')
  final SortOrder? remarks;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$SOFTWAREASSETTBLCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class SOFTWAREASSETTBLAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const SOFTWAREASSETTBLAvgOrderByAggregateInput({
    this.seq,
    this.cnt,
    this.amount,
  });

  factory SOFTWAREASSETTBLAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$SOFTWAREASSETTBLAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'CNT')
  final SortOrder? cnt;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @override
  Map<String, dynamic> toJson() =>
      _$SOFTWAREASSETTBLAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class SOFTWAREASSETTBLMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const SOFTWAREASSETTBLMaxOrderByAggregateInput({
    this.seq,
    this.assetNo,
    this.softwareNm,
    this.versionNm,
    this.cnt,
    this.amount,
    this.buyDate,
    this.serialNo,
    this.licenseNo,
    this.userNm,
    this.remarks,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory SOFTWAREASSETTBLMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$SOFTWAREASSETTBLMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ASSET_NO')
  final SortOrder? assetNo;

  @JsonKey(name: r'SOFTWARE_NM')
  final SortOrder? softwareNm;

  @JsonKey(name: r'VERSION_NM')
  final SortOrder? versionNm;

  @JsonKey(name: r'CNT')
  final SortOrder? cnt;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @JsonKey(name: r'BUY_DATE')
  final SortOrder? buyDate;

  @JsonKey(name: r'SERIAL_NO')
  final SortOrder? serialNo;

  @JsonKey(name: r'LICENSE_NO')
  final SortOrder? licenseNo;

  @JsonKey(name: r'USER_NM')
  final SortOrder? userNm;

  @JsonKey(name: r'REMARKS')
  final SortOrder? remarks;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$SOFTWAREASSETTBLMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class SOFTWAREASSETTBLMinOrderByAggregateInput implements _i1.JsonSerializable {
  const SOFTWAREASSETTBLMinOrderByAggregateInput({
    this.seq,
    this.assetNo,
    this.softwareNm,
    this.versionNm,
    this.cnt,
    this.amount,
    this.buyDate,
    this.serialNo,
    this.licenseNo,
    this.userNm,
    this.remarks,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory SOFTWAREASSETTBLMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$SOFTWAREASSETTBLMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'ASSET_NO')
  final SortOrder? assetNo;

  @JsonKey(name: r'SOFTWARE_NM')
  final SortOrder? softwareNm;

  @JsonKey(name: r'VERSION_NM')
  final SortOrder? versionNm;

  @JsonKey(name: r'CNT')
  final SortOrder? cnt;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @JsonKey(name: r'BUY_DATE')
  final SortOrder? buyDate;

  @JsonKey(name: r'SERIAL_NO')
  final SortOrder? serialNo;

  @JsonKey(name: r'LICENSE_NO')
  final SortOrder? licenseNo;

  @JsonKey(name: r'USER_NM')
  final SortOrder? userNm;

  @JsonKey(name: r'REMARKS')
  final SortOrder? remarks;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$SOFTWAREASSETTBLMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class SOFTWAREASSETTBLSumOrderByAggregateInput implements _i1.JsonSerializable {
  const SOFTWAREASSETTBLSumOrderByAggregateInput({
    this.seq,
    this.cnt,
    this.amount,
  });

  factory SOFTWAREASSETTBLSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$SOFTWAREASSETTBLSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'CNT')
  final SortOrder? cnt;

  @JsonKey(name: r'AMOUNT')
  final SortOrder? amount;

  @override
  Map<String, dynamic> toJson() =>
      _$SOFTWAREASSETTBLSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STADMINMENUCountOrderByAggregateInput implements _i1.JsonSerializable {
  const STADMINMENUCountOrderByAggregateInput({
    this.menuCd,
    this.menuNm,
    this.menuPath,
    this.menuSrt,
    this.menuDeps,
    this.menuIcon,
    this.menuTp,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STADMINMENUCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STADMINMENUCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'MENU_CD')
  final SortOrder? menuCd;

  @JsonKey(name: r'MENU_NM')
  final SortOrder? menuNm;

  @JsonKey(name: r'MENU_PATH')
  final SortOrder? menuPath;

  @JsonKey(name: r'MENU_SRT')
  final SortOrder? menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final SortOrder? menuDeps;

  @JsonKey(name: r'MENU_ICON')
  final SortOrder? menuIcon;

  @JsonKey(name: r'MENU_TP')
  final SortOrder? menuTp;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STADMINMENUCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STADMINMENUAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const STADMINMENUAvgOrderByAggregateInput({
    this.menuSrt,
    this.menuDeps,
  });

  factory STADMINMENUAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STADMINMENUAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'MENU_SRT')
  final SortOrder? menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final SortOrder? menuDeps;

  @override
  Map<String, dynamic> toJson() =>
      _$STADMINMENUAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STADMINMENUMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const STADMINMENUMaxOrderByAggregateInput({
    this.menuCd,
    this.menuNm,
    this.menuPath,
    this.menuSrt,
    this.menuDeps,
    this.menuIcon,
    this.menuTp,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STADMINMENUMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STADMINMENUMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'MENU_CD')
  final SortOrder? menuCd;

  @JsonKey(name: r'MENU_NM')
  final SortOrder? menuNm;

  @JsonKey(name: r'MENU_PATH')
  final SortOrder? menuPath;

  @JsonKey(name: r'MENU_SRT')
  final SortOrder? menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final SortOrder? menuDeps;

  @JsonKey(name: r'MENU_ICON')
  final SortOrder? menuIcon;

  @JsonKey(name: r'MENU_TP')
  final SortOrder? menuTp;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STADMINMENUMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STADMINMENUMinOrderByAggregateInput implements _i1.JsonSerializable {
  const STADMINMENUMinOrderByAggregateInput({
    this.menuCd,
    this.menuNm,
    this.menuPath,
    this.menuSrt,
    this.menuDeps,
    this.menuIcon,
    this.menuTp,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STADMINMENUMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STADMINMENUMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'MENU_CD')
  final SortOrder? menuCd;

  @JsonKey(name: r'MENU_NM')
  final SortOrder? menuNm;

  @JsonKey(name: r'MENU_PATH')
  final SortOrder? menuPath;

  @JsonKey(name: r'MENU_SRT')
  final SortOrder? menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final SortOrder? menuDeps;

  @JsonKey(name: r'MENU_ICON')
  final SortOrder? menuIcon;

  @JsonKey(name: r'MENU_TP')
  final SortOrder? menuTp;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STADMINMENUMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STADMINMENUSumOrderByAggregateInput implements _i1.JsonSerializable {
  const STADMINMENUSumOrderByAggregateInput({
    this.menuSrt,
    this.menuDeps,
  });

  factory STADMINMENUSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STADMINMENUSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'MENU_SRT')
  final SortOrder? menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final SortOrder? menuDeps;

  @override
  Map<String, dynamic> toJson() =>
      _$STADMINMENUSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STALARMCountOrderByAggregateInput implements _i1.JsonSerializable {
  const STALARMCountOrderByAggregateInput({
    this.seq,
    this.msgCd,
    this.msgCnts,
    this.sendDate,
    this.sendDiv,
    this.sendDeptCd,
    this.sendId,
    this.recvId,
    this.popYn,
    this.editId,
    this.editDate,
  });

  factory STALARMCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STALARMCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSG_CD')
  final SortOrder? msgCd;

  @JsonKey(name: r'MSG_CNTS')
  final SortOrder? msgCnts;

  @JsonKey(name: r'SEND_DATE')
  final SortOrder? sendDate;

  @JsonKey(name: r'SEND_DIV')
  final SortOrder? sendDiv;

  @JsonKey(name: r'SEND_DEPT_CD')
  final SortOrder? sendDeptCd;

  @JsonKey(name: r'SEND_ID')
  final SortOrder? sendId;

  @JsonKey(name: r'RECV_ID')
  final SortOrder? recvId;

  @JsonKey(name: r'POP_YN')
  final SortOrder? popYn;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STALARMCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STALARMAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const STALARMAvgOrderByAggregateInput({this.seq});

  factory STALARMAvgOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$STALARMAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @override
  Map<String, dynamic> toJson() =>
      _$STALARMAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STALARMMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const STALARMMaxOrderByAggregateInput({
    this.seq,
    this.msgCd,
    this.msgCnts,
    this.sendDate,
    this.sendDiv,
    this.sendDeptCd,
    this.sendId,
    this.recvId,
    this.popYn,
    this.editId,
    this.editDate,
  });

  factory STALARMMaxOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$STALARMMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSG_CD')
  final SortOrder? msgCd;

  @JsonKey(name: r'MSG_CNTS')
  final SortOrder? msgCnts;

  @JsonKey(name: r'SEND_DATE')
  final SortOrder? sendDate;

  @JsonKey(name: r'SEND_DIV')
  final SortOrder? sendDiv;

  @JsonKey(name: r'SEND_DEPT_CD')
  final SortOrder? sendDeptCd;

  @JsonKey(name: r'SEND_ID')
  final SortOrder? sendId;

  @JsonKey(name: r'RECV_ID')
  final SortOrder? recvId;

  @JsonKey(name: r'POP_YN')
  final SortOrder? popYn;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STALARMMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STALARMMinOrderByAggregateInput implements _i1.JsonSerializable {
  const STALARMMinOrderByAggregateInput({
    this.seq,
    this.msgCd,
    this.msgCnts,
    this.sendDate,
    this.sendDiv,
    this.sendDeptCd,
    this.sendId,
    this.recvId,
    this.popYn,
    this.editId,
    this.editDate,
  });

  factory STALARMMinOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$STALARMMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSG_CD')
  final SortOrder? msgCd;

  @JsonKey(name: r'MSG_CNTS')
  final SortOrder? msgCnts;

  @JsonKey(name: r'SEND_DATE')
  final SortOrder? sendDate;

  @JsonKey(name: r'SEND_DIV')
  final SortOrder? sendDiv;

  @JsonKey(name: r'SEND_DEPT_CD')
  final SortOrder? sendDeptCd;

  @JsonKey(name: r'SEND_ID')
  final SortOrder? sendId;

  @JsonKey(name: r'RECV_ID')
  final SortOrder? recvId;

  @JsonKey(name: r'POP_YN')
  final SortOrder? popYn;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STALARMMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STALARMSumOrderByAggregateInput implements _i1.JsonSerializable {
  const STALARMSumOrderByAggregateInput({this.seq});

  factory STALARMSumOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$STALARMSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @override
  Map<String, dynamic> toJson() =>
      _$STALARMSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STAUDITLOGCountOrderByAggregateInput implements _i1.JsonSerializable {
  const STAUDITLOGCountOrderByAggregateInput({
    this.seq,
    this.logCode,
    this.logCnts,
    this.errCode,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STAUDITLOGCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STAUDITLOGCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'LOG_CODE')
  final SortOrder? logCode;

  @JsonKey(name: r'LOG_CNTS')
  final SortOrder? logCnts;

  @JsonKey(name: r'ERR_CODE')
  final SortOrder? errCode;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STAUDITLOGCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STAUDITLOGAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const STAUDITLOGAvgOrderByAggregateInput({this.seq});

  factory STAUDITLOGAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STAUDITLOGAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @override
  Map<String, dynamic> toJson() =>
      _$STAUDITLOGAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STAUDITLOGMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const STAUDITLOGMaxOrderByAggregateInput({
    this.seq,
    this.logCode,
    this.logCnts,
    this.errCode,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STAUDITLOGMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STAUDITLOGMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'LOG_CODE')
  final SortOrder? logCode;

  @JsonKey(name: r'LOG_CNTS')
  final SortOrder? logCnts;

  @JsonKey(name: r'ERR_CODE')
  final SortOrder? errCode;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STAUDITLOGMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STAUDITLOGMinOrderByAggregateInput implements _i1.JsonSerializable {
  const STAUDITLOGMinOrderByAggregateInput({
    this.seq,
    this.logCode,
    this.logCnts,
    this.errCode,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STAUDITLOGMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STAUDITLOGMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'LOG_CODE')
  final SortOrder? logCode;

  @JsonKey(name: r'LOG_CNTS')
  final SortOrder? logCnts;

  @JsonKey(name: r'ERR_CODE')
  final SortOrder? errCode;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STAUDITLOGMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STAUDITLOGSumOrderByAggregateInput implements _i1.JsonSerializable {
  const STAUDITLOGSumOrderByAggregateInput({this.seq});

  factory STAUDITLOGSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STAUDITLOGSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @override
  Map<String, dynamic> toJson() =>
      _$STAUDITLOGSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STBANNERCountOrderByAggregateInput implements _i1.JsonSerializable {
  const STBANNERCountOrderByAggregateInput({
    this.bannerCd,
    this.lkUrl,
    this.lkTarget,
    this.flpth,
    this.fileNm,
    this.useYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBANNERCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBANNERCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'BANNER_CD')
  final SortOrder? bannerCd;

  @JsonKey(name: r'LK_URL')
  final SortOrder? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final SortOrder? lkTarget;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'FILE_NM')
  final SortOrder? fileNm;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBANNERCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STBANNERMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const STBANNERMaxOrderByAggregateInput({
    this.bannerCd,
    this.lkUrl,
    this.lkTarget,
    this.flpth,
    this.fileNm,
    this.useYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBANNERMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBANNERMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'BANNER_CD')
  final SortOrder? bannerCd;

  @JsonKey(name: r'LK_URL')
  final SortOrder? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final SortOrder? lkTarget;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'FILE_NM')
  final SortOrder? fileNm;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBANNERMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STBANNERMinOrderByAggregateInput implements _i1.JsonSerializable {
  const STBANNERMinOrderByAggregateInput({
    this.bannerCd,
    this.lkUrl,
    this.lkTarget,
    this.flpth,
    this.fileNm,
    this.useYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBANNERMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBANNERMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'BANNER_CD')
  final SortOrder? bannerCd;

  @JsonKey(name: r'LK_URL')
  final SortOrder? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final SortOrder? lkTarget;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'FILE_NM')
  final SortOrder? fileNm;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBANNERMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNBOARDCDCOLCDCompoundUniqueInput
    implements _i1.JsonSerializable {
  const STBOARDCOLUMNBOARDCDCOLCDCompoundUniqueInput({
    required this.boardCd,
    required this.colCd,
  });

  factory STBOARDCOLUMNBOARDCDCOLCDCompoundUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOLUMNBOARDCDCOLCDCompoundUniqueInputFromJson(json);

  @JsonKey(name: r'BOARD_CD')
  final String boardCd;

  @JsonKey(name: r'COL_CD')
  final String colCd;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOLUMNBOARDCDCOLCDCompoundUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNCountOrderByAggregateInput implements _i1.JsonSerializable {
  const STBOARDCOLUMNCountOrderByAggregateInput({
    this.boardCd,
    this.sort,
    this.colCd,
    this.colNm,
    this.regId,
    this.regDate,
  });

  factory STBOARDCOLUMNCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOLUMNCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'BOARD_CD')
  final SortOrder? boardCd;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'COL_CD')
  final SortOrder? colCd;

  @JsonKey(name: r'COL_NM')
  final SortOrder? colNm;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOLUMNCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const STBOARDCOLUMNAvgOrderByAggregateInput({this.sort});

  factory STBOARDCOLUMNAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOLUMNAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOLUMNAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const STBOARDCOLUMNMaxOrderByAggregateInput({
    this.boardCd,
    this.sort,
    this.colCd,
    this.colNm,
    this.regId,
    this.regDate,
  });

  factory STBOARDCOLUMNMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOLUMNMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'BOARD_CD')
  final SortOrder? boardCd;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'COL_CD')
  final SortOrder? colCd;

  @JsonKey(name: r'COL_NM')
  final SortOrder? colNm;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOLUMNMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNMinOrderByAggregateInput implements _i1.JsonSerializable {
  const STBOARDCOLUMNMinOrderByAggregateInput({
    this.boardCd,
    this.sort,
    this.colCd,
    this.colNm,
    this.regId,
    this.regDate,
  });

  factory STBOARDCOLUMNMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOLUMNMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'BOARD_CD')
  final SortOrder? boardCd;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'COL_CD')
  final SortOrder? colCd;

  @JsonKey(name: r'COL_NM')
  final SortOrder? colNm;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOLUMNMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNSumOrderByAggregateInput implements _i1.JsonSerializable {
  const STBOARDCOLUMNSumOrderByAggregateInput({this.sort});

  factory STBOARDCOLUMNSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOLUMNSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOLUMNSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNDFTBOARDTYCOLCDDELYNCompoundUniqueInput
    implements _i1.JsonSerializable {
  const STBOARDCOLUMNDFTBOARDTYCOLCDDELYNCompoundUniqueInput({
    required this.boardTy,
    required this.colCd,
    required this.delYn,
  });

  factory STBOARDCOLUMNDFTBOARDTYCOLCDDELYNCompoundUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOLUMNDFTBOARDTYCOLCDDELYNCompoundUniqueInputFromJson(json);

  @JsonKey(name: r'BOARD_TY')
  final String boardTy;

  @JsonKey(name: r'COL_CD')
  final String colCd;

  @JsonKey(name: r'DEL_YN')
  final String delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOLUMNDFTBOARDTYCOLCDDELYNCompoundUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNDFTCountOrderByAggregateInput
    implements _i1.JsonSerializable {
  const STBOARDCOLUMNDFTCountOrderByAggregateInput({
    this.boardTy,
    this.sort,
    this.colCd,
    this.colNm,
    this.editId,
    this.editDate,
    this.delYn,
  });

  factory STBOARDCOLUMNDFTCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOLUMNDFTCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'BOARD_TY')
  final SortOrder? boardTy;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'COL_CD')
  final SortOrder? colCd;

  @JsonKey(name: r'COL_NM')
  final SortOrder? colNm;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOLUMNDFTCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNDFTAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const STBOARDCOLUMNDFTAvgOrderByAggregateInput({this.sort});

  factory STBOARDCOLUMNDFTAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOLUMNDFTAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOLUMNDFTAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNDFTMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const STBOARDCOLUMNDFTMaxOrderByAggregateInput({
    this.boardTy,
    this.sort,
    this.colCd,
    this.colNm,
    this.editId,
    this.editDate,
    this.delYn,
  });

  factory STBOARDCOLUMNDFTMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOLUMNDFTMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'BOARD_TY')
  final SortOrder? boardTy;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'COL_CD')
  final SortOrder? colCd;

  @JsonKey(name: r'COL_NM')
  final SortOrder? colNm;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOLUMNDFTMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNDFTMinOrderByAggregateInput implements _i1.JsonSerializable {
  const STBOARDCOLUMNDFTMinOrderByAggregateInput({
    this.boardTy,
    this.sort,
    this.colCd,
    this.colNm,
    this.editId,
    this.editDate,
    this.delYn,
  });

  factory STBOARDCOLUMNDFTMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOLUMNDFTMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'BOARD_TY')
  final SortOrder? boardTy;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'COL_CD')
  final SortOrder? colCd;

  @JsonKey(name: r'COL_NM')
  final SortOrder? colNm;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOLUMNDFTMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNDFTSumOrderByAggregateInput implements _i1.JsonSerializable {
  const STBOARDCOLUMNDFTSumOrderByAggregateInput({this.sort});

  factory STBOARDCOLUMNDFTSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOLUMNDFTSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOLUMNDFTSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOMMENTSEQMSEQBOARDCDCompoundUniqueInput
    implements _i1.JsonSerializable {
  const STBOARDCOMMENTSEQMSEQBOARDCDCompoundUniqueInput({
    required this.seq,
    required this.mseq,
    required this.boardCd,
  });

  factory STBOARDCOMMENTSEQMSEQBOARDCDCompoundUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOMMENTSEQMSEQBOARDCDCompoundUniqueInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'MSEQ')
  final int mseq;

  @JsonKey(name: r'BOARD_CD')
  final String boardCd;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOMMENTSEQMSEQBOARDCDCompoundUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOMMENTCountOrderByAggregateInput implements _i1.JsonSerializable {
  const STBOARDCOMMENTCountOrderByAggregateInput({
    this.seq,
    this.mseq,
    this.boardCd,
    this.cnts,
    this.upperSeq,
    this.replyYn,
    this.regAdminYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDCOMMENTCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOMMENTCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'BOARD_CD')
  final SortOrder? boardCd;

  @JsonKey(name: r'CNTS')
  final SortOrder? cnts;

  @JsonKey(name: r'UPPER_SEQ')
  final SortOrder? upperSeq;

  @JsonKey(name: r'REPLY_YN')
  final SortOrder? replyYn;

  @JsonKey(name: r'REG_ADMIN_YN')
  final SortOrder? regAdminYn;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOMMENTCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOMMENTAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const STBOARDCOMMENTAvgOrderByAggregateInput({
    this.seq,
    this.mseq,
    this.upperSeq,
  });

  factory STBOARDCOMMENTAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOMMENTAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'UPPER_SEQ')
  final SortOrder? upperSeq;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOMMENTAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOMMENTMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const STBOARDCOMMENTMaxOrderByAggregateInput({
    this.seq,
    this.mseq,
    this.boardCd,
    this.cnts,
    this.upperSeq,
    this.replyYn,
    this.regAdminYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDCOMMENTMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOMMENTMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'BOARD_CD')
  final SortOrder? boardCd;

  @JsonKey(name: r'CNTS')
  final SortOrder? cnts;

  @JsonKey(name: r'UPPER_SEQ')
  final SortOrder? upperSeq;

  @JsonKey(name: r'REPLY_YN')
  final SortOrder? replyYn;

  @JsonKey(name: r'REG_ADMIN_YN')
  final SortOrder? regAdminYn;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOMMENTMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOMMENTMinOrderByAggregateInput implements _i1.JsonSerializable {
  const STBOARDCOMMENTMinOrderByAggregateInput({
    this.seq,
    this.mseq,
    this.boardCd,
    this.cnts,
    this.upperSeq,
    this.replyYn,
    this.regAdminYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDCOMMENTMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOMMENTMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'BOARD_CD')
  final SortOrder? boardCd;

  @JsonKey(name: r'CNTS')
  final SortOrder? cnts;

  @JsonKey(name: r'UPPER_SEQ')
  final SortOrder? upperSeq;

  @JsonKey(name: r'REPLY_YN')
  final SortOrder? replyYn;

  @JsonKey(name: r'REG_ADMIN_YN')
  final SortOrder? regAdminYn;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOMMENTMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOMMENTSumOrderByAggregateInput implements _i1.JsonSerializable {
  const STBOARDCOMMENTSumOrderByAggregateInput({
    this.seq,
    this.mseq,
    this.upperSeq,
  });

  factory STBOARDCOMMENTSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOMMENTSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'UPPER_SEQ')
  final SortOrder? upperSeq;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOMMENTSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDFILESEQMSEQBOARDCDCompoundUniqueInput
    implements _i1.JsonSerializable {
  const STBOARDFILESEQMSEQBOARDCDCompoundUniqueInput({
    required this.seq,
    required this.mseq,
    required this.boardCd,
  });

  factory STBOARDFILESEQMSEQBOARDCDCompoundUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDFILESEQMSEQBOARDCDCompoundUniqueInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'MSEQ')
  final int mseq;

  @JsonKey(name: r'BOARD_CD')
  final String boardCd;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDFILESEQMSEQBOARDCDCompoundUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDFILECountOrderByAggregateInput implements _i1.JsonSerializable {
  const STBOARDFILECountOrderByAggregateInput({
    this.seq,
    this.mseq,
    this.boardCd,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileSize,
    this.repreYn,
    this.dwldCo,
  });

  factory STBOARDFILECountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDFILECountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'BOARD_CD')
  final SortOrder? boardCd;

  @JsonKey(name: r'FILE_TP')
  final SortOrder? fileTp;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final SortOrder? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final SortOrder? streFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final SortOrder? fileSize;

  @JsonKey(name: r'REPRE_YN')
  final SortOrder? repreYn;

  @JsonKey(name: r'DWLD_CO')
  final SortOrder? dwldCo;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDFILECountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDFILEAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const STBOARDFILEAvgOrderByAggregateInput({
    this.seq,
    this.mseq,
    this.fileSize,
    this.dwldCo,
  });

  factory STBOARDFILEAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDFILEAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'FILE_SIZE')
  final SortOrder? fileSize;

  @JsonKey(name: r'DWLD_CO')
  final SortOrder? dwldCo;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDFILEAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDFILEMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const STBOARDFILEMaxOrderByAggregateInput({
    this.seq,
    this.mseq,
    this.boardCd,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileSize,
    this.repreYn,
    this.dwldCo,
  });

  factory STBOARDFILEMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDFILEMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'BOARD_CD')
  final SortOrder? boardCd;

  @JsonKey(name: r'FILE_TP')
  final SortOrder? fileTp;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final SortOrder? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final SortOrder? streFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final SortOrder? fileSize;

  @JsonKey(name: r'REPRE_YN')
  final SortOrder? repreYn;

  @JsonKey(name: r'DWLD_CO')
  final SortOrder? dwldCo;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDFILEMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDFILEMinOrderByAggregateInput implements _i1.JsonSerializable {
  const STBOARDFILEMinOrderByAggregateInput({
    this.seq,
    this.mseq,
    this.boardCd,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileSize,
    this.repreYn,
    this.dwldCo,
  });

  factory STBOARDFILEMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDFILEMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'BOARD_CD')
  final SortOrder? boardCd;

  @JsonKey(name: r'FILE_TP')
  final SortOrder? fileTp;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final SortOrder? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final SortOrder? streFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final SortOrder? fileSize;

  @JsonKey(name: r'REPRE_YN')
  final SortOrder? repreYn;

  @JsonKey(name: r'DWLD_CO')
  final SortOrder? dwldCo;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDFILEMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDFILESumOrderByAggregateInput implements _i1.JsonSerializable {
  const STBOARDFILESumOrderByAggregateInput({
    this.seq,
    this.mseq,
    this.fileSize,
    this.dwldCo,
  });

  factory STBOARDFILESumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDFILESumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'FILE_SIZE')
  final SortOrder? fileSize;

  @JsonKey(name: r'DWLD_CO')
  final SortOrder? dwldCo;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDFILESumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDMSTSEQBOARDCDCompoundUniqueInput implements _i1.JsonSerializable {
  const STBOARDMSTSEQBOARDCDCompoundUniqueInput({
    required this.seq,
    required this.boardCd,
  });

  factory STBOARDMSTSEQBOARDCDCompoundUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDMSTSEQBOARDCDCompoundUniqueInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'BOARD_CD')
  final String boardCd;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDMSTSEQBOARDCDCompoundUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDMSTCountOrderByAggregateInput implements _i1.JsonSerializable {
  const STBOARDMSTCountOrderByAggregateInput({
    this.seq,
    this.boardCd,
    this.clsCd,
    this.ttl,
    this.cnts,
    this.fileYn,
    this.imageYn,
    this.noticeYn,
    this.lkUrl,
    this.lkTarget,
    this.readCnt,
    this.regAdminYn,
    this.replyYn,
    this.upperSeq,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDMSTCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDMSTCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'BOARD_CD')
  final SortOrder? boardCd;

  @JsonKey(name: r'CLS_CD')
  final SortOrder? clsCd;

  @JsonKey(name: r'TTL')
  final SortOrder? ttl;

  @JsonKey(name: r'CNTS')
  final SortOrder? cnts;

  @JsonKey(name: r'FILE_YN')
  final SortOrder? fileYn;

  @JsonKey(name: r'IMAGE_YN')
  final SortOrder? imageYn;

  @JsonKey(name: r'NOTICE_YN')
  final SortOrder? noticeYn;

  @JsonKey(name: r'LK_URL')
  final SortOrder? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final SortOrder? lkTarget;

  @JsonKey(name: r'READ_CNT')
  final SortOrder? readCnt;

  @JsonKey(name: r'REG_ADMIN_YN')
  final SortOrder? regAdminYn;

  @JsonKey(name: r'REPLY_YN')
  final SortOrder? replyYn;

  @JsonKey(name: r'UPPER_SEQ')
  final SortOrder? upperSeq;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDMSTCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDMSTAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const STBOARDMSTAvgOrderByAggregateInput({
    this.seq,
    this.readCnt,
    this.upperSeq,
  });

  factory STBOARDMSTAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDMSTAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'READ_CNT')
  final SortOrder? readCnt;

  @JsonKey(name: r'UPPER_SEQ')
  final SortOrder? upperSeq;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDMSTAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDMSTMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const STBOARDMSTMaxOrderByAggregateInput({
    this.seq,
    this.boardCd,
    this.clsCd,
    this.ttl,
    this.cnts,
    this.fileYn,
    this.imageYn,
    this.noticeYn,
    this.lkUrl,
    this.lkTarget,
    this.readCnt,
    this.regAdminYn,
    this.replyYn,
    this.upperSeq,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDMSTMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDMSTMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'BOARD_CD')
  final SortOrder? boardCd;

  @JsonKey(name: r'CLS_CD')
  final SortOrder? clsCd;

  @JsonKey(name: r'TTL')
  final SortOrder? ttl;

  @JsonKey(name: r'CNTS')
  final SortOrder? cnts;

  @JsonKey(name: r'FILE_YN')
  final SortOrder? fileYn;

  @JsonKey(name: r'IMAGE_YN')
  final SortOrder? imageYn;

  @JsonKey(name: r'NOTICE_YN')
  final SortOrder? noticeYn;

  @JsonKey(name: r'LK_URL')
  final SortOrder? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final SortOrder? lkTarget;

  @JsonKey(name: r'READ_CNT')
  final SortOrder? readCnt;

  @JsonKey(name: r'REG_ADMIN_YN')
  final SortOrder? regAdminYn;

  @JsonKey(name: r'REPLY_YN')
  final SortOrder? replyYn;

  @JsonKey(name: r'UPPER_SEQ')
  final SortOrder? upperSeq;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDMSTMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDMSTMinOrderByAggregateInput implements _i1.JsonSerializable {
  const STBOARDMSTMinOrderByAggregateInput({
    this.seq,
    this.boardCd,
    this.clsCd,
    this.ttl,
    this.cnts,
    this.fileYn,
    this.imageYn,
    this.noticeYn,
    this.lkUrl,
    this.lkTarget,
    this.readCnt,
    this.regAdminYn,
    this.replyYn,
    this.upperSeq,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDMSTMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDMSTMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'BOARD_CD')
  final SortOrder? boardCd;

  @JsonKey(name: r'CLS_CD')
  final SortOrder? clsCd;

  @JsonKey(name: r'TTL')
  final SortOrder? ttl;

  @JsonKey(name: r'CNTS')
  final SortOrder? cnts;

  @JsonKey(name: r'FILE_YN')
  final SortOrder? fileYn;

  @JsonKey(name: r'IMAGE_YN')
  final SortOrder? imageYn;

  @JsonKey(name: r'NOTICE_YN')
  final SortOrder? noticeYn;

  @JsonKey(name: r'LK_URL')
  final SortOrder? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final SortOrder? lkTarget;

  @JsonKey(name: r'READ_CNT')
  final SortOrder? readCnt;

  @JsonKey(name: r'REG_ADMIN_YN')
  final SortOrder? regAdminYn;

  @JsonKey(name: r'REPLY_YN')
  final SortOrder? replyYn;

  @JsonKey(name: r'UPPER_SEQ')
  final SortOrder? upperSeq;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDMSTMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDMSTSumOrderByAggregateInput implements _i1.JsonSerializable {
  const STBOARDMSTSumOrderByAggregateInput({
    this.seq,
    this.readCnt,
    this.upperSeq,
  });

  factory STBOARDMSTSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDMSTSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'READ_CNT')
  final SortOrder? readCnt;

  @JsonKey(name: r'UPPER_SEQ')
  final SortOrder? upperSeq;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDMSTSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDSTNGCountOrderByAggregateInput implements _i1.JsonSerializable {
  const STBOARDSTNGCountOrderByAggregateInput({
    this.boardCd,
    this.boardNm,
    this.boardTy,
    this.editorYn,
    this.rlsYn,
    this.cclSeq,
    this.listCnt,
    this.writeYn,
    this.commentYn,
    this.replyYn,
    this.attachYn,
    this.attachSize,
    this.attachCnt,
    this.attachExt,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDSTNGCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDSTNGCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'BOARD_CD')
  final SortOrder? boardCd;

  @JsonKey(name: r'BOARD_NM')
  final SortOrder? boardNm;

  @JsonKey(name: r'BOARD_TY')
  final SortOrder? boardTy;

  @JsonKey(name: r'EDITOR_YN')
  final SortOrder? editorYn;

  @JsonKey(name: r'RLS_YN')
  final SortOrder? rlsYn;

  @JsonKey(name: r'CCL_SEQ')
  final SortOrder? cclSeq;

  @JsonKey(name: r'LIST_CNT')
  final SortOrder? listCnt;

  @JsonKey(name: r'WRITE_YN')
  final SortOrder? writeYn;

  @JsonKey(name: r'COMMENT_YN')
  final SortOrder? commentYn;

  @JsonKey(name: r'REPLY_YN')
  final SortOrder? replyYn;

  @JsonKey(name: r'ATTACH_YN')
  final SortOrder? attachYn;

  @JsonKey(name: r'ATTACH_SIZE')
  final SortOrder? attachSize;

  @JsonKey(name: r'ATTACH_CNT')
  final SortOrder? attachCnt;

  @JsonKey(name: r'ATTACH_EXT')
  final SortOrder? attachExt;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDSTNGCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDSTNGAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const STBOARDSTNGAvgOrderByAggregateInput({
    this.cclSeq,
    this.listCnt,
  });

  factory STBOARDSTNGAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDSTNGAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'CCL_SEQ')
  final SortOrder? cclSeq;

  @JsonKey(name: r'LIST_CNT')
  final SortOrder? listCnt;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDSTNGAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDSTNGMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const STBOARDSTNGMaxOrderByAggregateInput({
    this.boardCd,
    this.boardNm,
    this.boardTy,
    this.editorYn,
    this.rlsYn,
    this.cclSeq,
    this.listCnt,
    this.writeYn,
    this.commentYn,
    this.replyYn,
    this.attachYn,
    this.attachSize,
    this.attachCnt,
    this.attachExt,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDSTNGMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDSTNGMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'BOARD_CD')
  final SortOrder? boardCd;

  @JsonKey(name: r'BOARD_NM')
  final SortOrder? boardNm;

  @JsonKey(name: r'BOARD_TY')
  final SortOrder? boardTy;

  @JsonKey(name: r'EDITOR_YN')
  final SortOrder? editorYn;

  @JsonKey(name: r'RLS_YN')
  final SortOrder? rlsYn;

  @JsonKey(name: r'CCL_SEQ')
  final SortOrder? cclSeq;

  @JsonKey(name: r'LIST_CNT')
  final SortOrder? listCnt;

  @JsonKey(name: r'WRITE_YN')
  final SortOrder? writeYn;

  @JsonKey(name: r'COMMENT_YN')
  final SortOrder? commentYn;

  @JsonKey(name: r'REPLY_YN')
  final SortOrder? replyYn;

  @JsonKey(name: r'ATTACH_YN')
  final SortOrder? attachYn;

  @JsonKey(name: r'ATTACH_SIZE')
  final SortOrder? attachSize;

  @JsonKey(name: r'ATTACH_CNT')
  final SortOrder? attachCnt;

  @JsonKey(name: r'ATTACH_EXT')
  final SortOrder? attachExt;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDSTNGMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDSTNGMinOrderByAggregateInput implements _i1.JsonSerializable {
  const STBOARDSTNGMinOrderByAggregateInput({
    this.boardCd,
    this.boardNm,
    this.boardTy,
    this.editorYn,
    this.rlsYn,
    this.cclSeq,
    this.listCnt,
    this.writeYn,
    this.commentYn,
    this.replyYn,
    this.attachYn,
    this.attachSize,
    this.attachCnt,
    this.attachExt,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDSTNGMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDSTNGMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'BOARD_CD')
  final SortOrder? boardCd;

  @JsonKey(name: r'BOARD_NM')
  final SortOrder? boardNm;

  @JsonKey(name: r'BOARD_TY')
  final SortOrder? boardTy;

  @JsonKey(name: r'EDITOR_YN')
  final SortOrder? editorYn;

  @JsonKey(name: r'RLS_YN')
  final SortOrder? rlsYn;

  @JsonKey(name: r'CCL_SEQ')
  final SortOrder? cclSeq;

  @JsonKey(name: r'LIST_CNT')
  final SortOrder? listCnt;

  @JsonKey(name: r'WRITE_YN')
  final SortOrder? writeYn;

  @JsonKey(name: r'COMMENT_YN')
  final SortOrder? commentYn;

  @JsonKey(name: r'REPLY_YN')
  final SortOrder? replyYn;

  @JsonKey(name: r'ATTACH_YN')
  final SortOrder? attachYn;

  @JsonKey(name: r'ATTACH_SIZE')
  final SortOrder? attachSize;

  @JsonKey(name: r'ATTACH_CNT')
  final SortOrder? attachCnt;

  @JsonKey(name: r'ATTACH_EXT')
  final SortOrder? attachExt;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDSTNGMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STBOARDSTNGSumOrderByAggregateInput implements _i1.JsonSerializable {
  const STBOARDSTNGSumOrderByAggregateInput({
    this.cclSeq,
    this.listCnt,
  });

  factory STBOARDSTNGSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDSTNGSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'CCL_SEQ')
  final SortOrder? cclSeq;

  @JsonKey(name: r'LIST_CNT')
  final SortOrder? listCnt;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDSTNGSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STCCLCountOrderByAggregateInput implements _i1.JsonSerializable {
  const STCCLCountOrderByAggregateInput({
    this.seq,
    this.cclType,
    this.cclNm,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileExtsn,
    this.fileSize,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCCLCountOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$STCCLCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'CCL_TYPE')
  final SortOrder? cclType;

  @JsonKey(name: r'CCL_NM')
  final SortOrder? cclNm;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final SortOrder? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final SortOrder? streFileNm;

  @JsonKey(name: r'FILE_EXTSN')
  final SortOrder? fileExtsn;

  @JsonKey(name: r'FILE_SIZE')
  final SortOrder? fileSize;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STCCLCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STCCLAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const STCCLAvgOrderByAggregateInput({
    this.seq,
    this.fileSize,
  });

  factory STCCLAvgOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$STCCLAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'FILE_SIZE')
  final SortOrder? fileSize;

  @override
  Map<String, dynamic> toJson() => _$STCCLAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STCCLMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const STCCLMaxOrderByAggregateInput({
    this.seq,
    this.cclType,
    this.cclNm,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileExtsn,
    this.fileSize,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCCLMaxOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$STCCLMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'CCL_TYPE')
  final SortOrder? cclType;

  @JsonKey(name: r'CCL_NM')
  final SortOrder? cclNm;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final SortOrder? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final SortOrder? streFileNm;

  @JsonKey(name: r'FILE_EXTSN')
  final SortOrder? fileExtsn;

  @JsonKey(name: r'FILE_SIZE')
  final SortOrder? fileSize;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() => _$STCCLMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STCCLMinOrderByAggregateInput implements _i1.JsonSerializable {
  const STCCLMinOrderByAggregateInput({
    this.seq,
    this.cclType,
    this.cclNm,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileExtsn,
    this.fileSize,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCCLMinOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$STCCLMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'CCL_TYPE')
  final SortOrder? cclType;

  @JsonKey(name: r'CCL_NM')
  final SortOrder? cclNm;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final SortOrder? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final SortOrder? streFileNm;

  @JsonKey(name: r'FILE_EXTSN')
  final SortOrder? fileExtsn;

  @JsonKey(name: r'FILE_SIZE')
  final SortOrder? fileSize;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() => _$STCCLMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STCCLSumOrderByAggregateInput implements _i1.JsonSerializable {
  const STCCLSumOrderByAggregateInput({
    this.seq,
    this.fileSize,
  });

  factory STCCLSumOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$STCCLSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'FILE_SIZE')
  final SortOrder? fileSize;

  @override
  Map<String, dynamic> toJson() => _$STCCLSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STCODEMSTCDGRPCDKEYCompoundUniqueInput implements _i1.JsonSerializable {
  const STCODEMSTCDGRPCDKEYCompoundUniqueInput({
    required this.cdGrp,
    required this.cdKey,
  });

  factory STCODEMSTCDGRPCDKEYCompoundUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCODEMSTCDGRPCDKEYCompoundUniqueInputFromJson(json);

  @JsonKey(name: r'CD_GRP')
  final String cdGrp;

  @JsonKey(name: r'CD_KEY')
  final String cdKey;

  @override
  Map<String, dynamic> toJson() =>
      _$STCODEMSTCDGRPCDKEYCompoundUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STCODEMSTCountOrderByAggregateInput implements _i1.JsonSerializable {
  const STCODEMSTCountOrderByAggregateInput({
    this.cdGrp,
    this.cdKey,
    this.cdVal,
    this.cdDesc,
    this.cdSrt,
    this.depth,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCODEMSTCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCODEMSTCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'CD_GRP')
  final SortOrder? cdGrp;

  @JsonKey(name: r'CD_KEY')
  final SortOrder? cdKey;

  @JsonKey(name: r'CD_VAL')
  final SortOrder? cdVal;

  @JsonKey(name: r'CD_DESC')
  final SortOrder? cdDesc;

  @JsonKey(name: r'CD_SRT')
  final SortOrder? cdSrt;

  @JsonKey(name: r'DEPTH')
  final SortOrder? depth;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STCODEMSTCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STCODEMSTAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const STCODEMSTAvgOrderByAggregateInput({
    this.cdSrt,
    this.depth,
  });

  factory STCODEMSTAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCODEMSTAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'CD_SRT')
  final SortOrder? cdSrt;

  @JsonKey(name: r'DEPTH')
  final SortOrder? depth;

  @override
  Map<String, dynamic> toJson() =>
      _$STCODEMSTAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STCODEMSTMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const STCODEMSTMaxOrderByAggregateInput({
    this.cdGrp,
    this.cdKey,
    this.cdVal,
    this.cdDesc,
    this.cdSrt,
    this.depth,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCODEMSTMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCODEMSTMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'CD_GRP')
  final SortOrder? cdGrp;

  @JsonKey(name: r'CD_KEY')
  final SortOrder? cdKey;

  @JsonKey(name: r'CD_VAL')
  final SortOrder? cdVal;

  @JsonKey(name: r'CD_DESC')
  final SortOrder? cdDesc;

  @JsonKey(name: r'CD_SRT')
  final SortOrder? cdSrt;

  @JsonKey(name: r'DEPTH')
  final SortOrder? depth;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STCODEMSTMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STCODEMSTMinOrderByAggregateInput implements _i1.JsonSerializable {
  const STCODEMSTMinOrderByAggregateInput({
    this.cdGrp,
    this.cdKey,
    this.cdVal,
    this.cdDesc,
    this.cdSrt,
    this.depth,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCODEMSTMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCODEMSTMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'CD_GRP')
  final SortOrder? cdGrp;

  @JsonKey(name: r'CD_KEY')
  final SortOrder? cdKey;

  @JsonKey(name: r'CD_VAL')
  final SortOrder? cdVal;

  @JsonKey(name: r'CD_DESC')
  final SortOrder? cdDesc;

  @JsonKey(name: r'CD_SRT')
  final SortOrder? cdSrt;

  @JsonKey(name: r'DEPTH')
  final SortOrder? depth;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STCODEMSTMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STCODEMSTSumOrderByAggregateInput implements _i1.JsonSerializable {
  const STCODEMSTSumOrderByAggregateInput({
    this.cdSrt,
    this.depth,
  });

  factory STCODEMSTSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCODEMSTSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'CD_SRT')
  final SortOrder? cdSrt;

  @JsonKey(name: r'DEPTH')
  final SortOrder? depth;

  @override
  Map<String, dynamic> toJson() =>
      _$STCODEMSTSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STCONNECTLOGCountOrderByAggregateInput implements _i1.JsonSerializable {
  const STCONNECTLOGCountOrderByAggregateInput({
    this.seq,
    this.userId,
    this.connType,
    this.osType,
    this.browserType,
    this.conneIp,
    this.regDate,
  });

  factory STCONNECTLOGCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONNECTLOGCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'CONN_TYPE')
  final SortOrder? connType;

  @JsonKey(name: r'OS_TYPE')
  final SortOrder? osType;

  @JsonKey(name: r'BROWSER_TYPE')
  final SortOrder? browserType;

  @JsonKey(name: r'CONNE_IP')
  final SortOrder? conneIp;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONNECTLOGCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STCONNECTLOGAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const STCONNECTLOGAvgOrderByAggregateInput({this.seq});

  factory STCONNECTLOGAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONNECTLOGAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONNECTLOGAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STCONNECTLOGMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const STCONNECTLOGMaxOrderByAggregateInput({
    this.seq,
    this.userId,
    this.connType,
    this.osType,
    this.browserType,
    this.conneIp,
    this.regDate,
  });

  factory STCONNECTLOGMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONNECTLOGMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'CONN_TYPE')
  final SortOrder? connType;

  @JsonKey(name: r'OS_TYPE')
  final SortOrder? osType;

  @JsonKey(name: r'BROWSER_TYPE')
  final SortOrder? browserType;

  @JsonKey(name: r'CONNE_IP')
  final SortOrder? conneIp;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONNECTLOGMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STCONNECTLOGMinOrderByAggregateInput implements _i1.JsonSerializable {
  const STCONNECTLOGMinOrderByAggregateInput({
    this.seq,
    this.userId,
    this.connType,
    this.osType,
    this.browserType,
    this.conneIp,
    this.regDate,
  });

  factory STCONNECTLOGMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONNECTLOGMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'CONN_TYPE')
  final SortOrder? connType;

  @JsonKey(name: r'OS_TYPE')
  final SortOrder? osType;

  @JsonKey(name: r'BROWSER_TYPE')
  final SortOrder? browserType;

  @JsonKey(name: r'CONNE_IP')
  final SortOrder? conneIp;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONNECTLOGMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STCONNECTLOGSumOrderByAggregateInput implements _i1.JsonSerializable {
  const STCONNECTLOGSumOrderByAggregateInput({this.seq});

  factory STCONNECTLOGSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONNECTLOGSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONNECTLOGSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSFILECountOrderByAggregateInput implements _i1.JsonSerializable {
  const STCONTENTSFILECountOrderByAggregateInput({
    this.seq,
    this.mseq,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileSize,
  });

  factory STCONTENTSFILECountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONTENTSFILECountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'FILE_TP')
  final SortOrder? fileTp;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final SortOrder? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final SortOrder? streFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final SortOrder? fileSize;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONTENTSFILECountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSFILEAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const STCONTENTSFILEAvgOrderByAggregateInput({
    this.seq,
    this.fileSize,
  });

  factory STCONTENTSFILEAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONTENTSFILEAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'FILE_SIZE')
  final SortOrder? fileSize;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONTENTSFILEAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSFILEMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const STCONTENTSFILEMaxOrderByAggregateInput({
    this.seq,
    this.mseq,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileSize,
  });

  factory STCONTENTSFILEMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONTENTSFILEMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'FILE_TP')
  final SortOrder? fileTp;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final SortOrder? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final SortOrder? streFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final SortOrder? fileSize;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONTENTSFILEMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSFILEMinOrderByAggregateInput implements _i1.JsonSerializable {
  const STCONTENTSFILEMinOrderByAggregateInput({
    this.seq,
    this.mseq,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileSize,
  });

  factory STCONTENTSFILEMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONTENTSFILEMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'FILE_TP')
  final SortOrder? fileTp;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final SortOrder? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final SortOrder? streFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final SortOrder? fileSize;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONTENTSFILEMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSFILESumOrderByAggregateInput implements _i1.JsonSerializable {
  const STCONTENTSFILESumOrderByAggregateInput({
    this.seq,
    this.fileSize,
  });

  factory STCONTENTSFILESumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONTENTSFILESumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'FILE_SIZE')
  final SortOrder? fileSize;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONTENTSFILESumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSMSTCountOrderByAggregateInput implements _i1.JsonSerializable {
  const STCONTENTSMSTCountOrderByAggregateInput({
    this.seq,
    this.cntsNm,
    this.pubDate,
    this.pubState,
    this.cn,
    this.srchYn,
    this.fileYn,
    this.imageYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCONTENTSMSTCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONTENTSMSTCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'CNTS_NM')
  final SortOrder? cntsNm;

  @JsonKey(name: r'PUB_DATE')
  final SortOrder? pubDate;

  @JsonKey(name: r'PUB_STATE')
  final SortOrder? pubState;

  @JsonKey(name: r'CN')
  final SortOrder? cn;

  @JsonKey(name: r'SRCH_YN')
  final SortOrder? srchYn;

  @JsonKey(name: r'FILE_YN')
  final SortOrder? fileYn;

  @JsonKey(name: r'IMAGE_YN')
  final SortOrder? imageYn;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONTENTSMSTCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSMSTAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const STCONTENTSMSTAvgOrderByAggregateInput({this.seq});

  factory STCONTENTSMSTAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONTENTSMSTAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONTENTSMSTAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSMSTMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const STCONTENTSMSTMaxOrderByAggregateInput({
    this.seq,
    this.cntsNm,
    this.pubDate,
    this.pubState,
    this.cn,
    this.srchYn,
    this.fileYn,
    this.imageYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCONTENTSMSTMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONTENTSMSTMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'CNTS_NM')
  final SortOrder? cntsNm;

  @JsonKey(name: r'PUB_DATE')
  final SortOrder? pubDate;

  @JsonKey(name: r'PUB_STATE')
  final SortOrder? pubState;

  @JsonKey(name: r'CN')
  final SortOrder? cn;

  @JsonKey(name: r'SRCH_YN')
  final SortOrder? srchYn;

  @JsonKey(name: r'FILE_YN')
  final SortOrder? fileYn;

  @JsonKey(name: r'IMAGE_YN')
  final SortOrder? imageYn;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONTENTSMSTMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSMSTMinOrderByAggregateInput implements _i1.JsonSerializable {
  const STCONTENTSMSTMinOrderByAggregateInput({
    this.seq,
    this.cntsNm,
    this.pubDate,
    this.pubState,
    this.cn,
    this.srchYn,
    this.fileYn,
    this.imageYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCONTENTSMSTMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONTENTSMSTMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'CNTS_NM')
  final SortOrder? cntsNm;

  @JsonKey(name: r'PUB_DATE')
  final SortOrder? pubDate;

  @JsonKey(name: r'PUB_STATE')
  final SortOrder? pubState;

  @JsonKey(name: r'CN')
  final SortOrder? cn;

  @JsonKey(name: r'SRCH_YN')
  final SortOrder? srchYn;

  @JsonKey(name: r'FILE_YN')
  final SortOrder? fileYn;

  @JsonKey(name: r'IMAGE_YN')
  final SortOrder? imageYn;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONTENTSMSTMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSMSTSumOrderByAggregateInput implements _i1.JsonSerializable {
  const STCONTENTSMSTSumOrderByAggregateInput({this.seq});

  factory STCONTENTSMSTSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STCONTENTSMSTSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONTENTSMSTSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STDEPTCountOrderByAggregateInput implements _i1.JsonSerializable {
  const STDEPTCountOrderByAggregateInput({
    this.deptCd,
    this.deptNm,
    this.upperDeptCd,
    this.upperDeptNm,
    this.sort,
    this.mainYn,
    this.deptDesc,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STDEPTCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STDEPTCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'DEPT_CD')
  final SortOrder? deptCd;

  @JsonKey(name: r'DEPT_NM')
  final SortOrder? deptNm;

  @JsonKey(name: r'UPPER_DEPT_CD')
  final SortOrder? upperDeptCd;

  @JsonKey(name: r'UPPER_DEPT_NM')
  final SortOrder? upperDeptNm;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'MAIN_YN')
  final SortOrder? mainYn;

  @JsonKey(name: r'DEPT_DESC')
  final SortOrder? deptDesc;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STDEPTCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STDEPTAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const STDEPTAvgOrderByAggregateInput({this.sort});

  factory STDEPTAvgOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$STDEPTAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @override
  Map<String, dynamic> toJson() => _$STDEPTAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STDEPTMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const STDEPTMaxOrderByAggregateInput({
    this.deptCd,
    this.deptNm,
    this.upperDeptCd,
    this.upperDeptNm,
    this.sort,
    this.mainYn,
    this.deptDesc,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STDEPTMaxOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$STDEPTMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'DEPT_CD')
  final SortOrder? deptCd;

  @JsonKey(name: r'DEPT_NM')
  final SortOrder? deptNm;

  @JsonKey(name: r'UPPER_DEPT_CD')
  final SortOrder? upperDeptCd;

  @JsonKey(name: r'UPPER_DEPT_NM')
  final SortOrder? upperDeptNm;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'MAIN_YN')
  final SortOrder? mainYn;

  @JsonKey(name: r'DEPT_DESC')
  final SortOrder? deptDesc;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() => _$STDEPTMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STDEPTMinOrderByAggregateInput implements _i1.JsonSerializable {
  const STDEPTMinOrderByAggregateInput({
    this.deptCd,
    this.deptNm,
    this.upperDeptCd,
    this.upperDeptNm,
    this.sort,
    this.mainYn,
    this.deptDesc,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STDEPTMinOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$STDEPTMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'DEPT_CD')
  final SortOrder? deptCd;

  @JsonKey(name: r'DEPT_NM')
  final SortOrder? deptNm;

  @JsonKey(name: r'UPPER_DEPT_CD')
  final SortOrder? upperDeptCd;

  @JsonKey(name: r'UPPER_DEPT_NM')
  final SortOrder? upperDeptNm;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'MAIN_YN')
  final SortOrder? mainYn;

  @JsonKey(name: r'DEPT_DESC')
  final SortOrder? deptDesc;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() => _$STDEPTMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STDEPTSumOrderByAggregateInput implements _i1.JsonSerializable {
  const STDEPTSumOrderByAggregateInput({this.sort});

  factory STDEPTSumOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$STDEPTSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @override
  Map<String, dynamic> toJson() => _$STDEPTSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STDEPTEMPCountOrderByAggregateInput implements _i1.JsonSerializable {
  const STDEPTEMPCountOrderByAggregateInput({
    this.empNo,
    this.empNm,
    this.deptCd,
    this.deptNm,
    this.fctnCd,
    this.fctnNm,
    this.ofcpCd,
    this.ofcpNm,
    this.emailAddr,
    this.offmTelno,
    this.htelTelno,
    this.deptYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STDEPTEMPCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STDEPTEMPCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'EMP_NO')
  final SortOrder? empNo;

  @JsonKey(name: r'EMP_NM')
  final SortOrder? empNm;

  @JsonKey(name: r'DEPT_CD')
  final SortOrder? deptCd;

  @JsonKey(name: r'DEPT_NM')
  final SortOrder? deptNm;

  @JsonKey(name: r'FCTN_CD')
  final SortOrder? fctnCd;

  @JsonKey(name: r'FCTN_NM')
  final SortOrder? fctnNm;

  @JsonKey(name: r'OFCP_CD')
  final SortOrder? ofcpCd;

  @JsonKey(name: r'OFCP_NM')
  final SortOrder? ofcpNm;

  @JsonKey(name: r'EMAIL_ADDR')
  final SortOrder? emailAddr;

  @JsonKey(name: r'OFFM_TELNO')
  final SortOrder? offmTelno;

  @JsonKey(name: r'HTEL_TELNO')
  final SortOrder? htelTelno;

  @JsonKey(name: r'DEPT_YN')
  final SortOrder? deptYn;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STDEPTEMPCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STDEPTEMPMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const STDEPTEMPMaxOrderByAggregateInput({
    this.empNo,
    this.empNm,
    this.deptCd,
    this.deptNm,
    this.fctnCd,
    this.fctnNm,
    this.ofcpCd,
    this.ofcpNm,
    this.emailAddr,
    this.offmTelno,
    this.htelTelno,
    this.deptYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STDEPTEMPMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STDEPTEMPMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'EMP_NO')
  final SortOrder? empNo;

  @JsonKey(name: r'EMP_NM')
  final SortOrder? empNm;

  @JsonKey(name: r'DEPT_CD')
  final SortOrder? deptCd;

  @JsonKey(name: r'DEPT_NM')
  final SortOrder? deptNm;

  @JsonKey(name: r'FCTN_CD')
  final SortOrder? fctnCd;

  @JsonKey(name: r'FCTN_NM')
  final SortOrder? fctnNm;

  @JsonKey(name: r'OFCP_CD')
  final SortOrder? ofcpCd;

  @JsonKey(name: r'OFCP_NM')
  final SortOrder? ofcpNm;

  @JsonKey(name: r'EMAIL_ADDR')
  final SortOrder? emailAddr;

  @JsonKey(name: r'OFFM_TELNO')
  final SortOrder? offmTelno;

  @JsonKey(name: r'HTEL_TELNO')
  final SortOrder? htelTelno;

  @JsonKey(name: r'DEPT_YN')
  final SortOrder? deptYn;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STDEPTEMPMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STDEPTEMPMinOrderByAggregateInput implements _i1.JsonSerializable {
  const STDEPTEMPMinOrderByAggregateInput({
    this.empNo,
    this.empNm,
    this.deptCd,
    this.deptNm,
    this.fctnCd,
    this.fctnNm,
    this.ofcpCd,
    this.ofcpNm,
    this.emailAddr,
    this.offmTelno,
    this.htelTelno,
    this.deptYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STDEPTEMPMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STDEPTEMPMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'EMP_NO')
  final SortOrder? empNo;

  @JsonKey(name: r'EMP_NM')
  final SortOrder? empNm;

  @JsonKey(name: r'DEPT_CD')
  final SortOrder? deptCd;

  @JsonKey(name: r'DEPT_NM')
  final SortOrder? deptNm;

  @JsonKey(name: r'FCTN_CD')
  final SortOrder? fctnCd;

  @JsonKey(name: r'FCTN_NM')
  final SortOrder? fctnNm;

  @JsonKey(name: r'OFCP_CD')
  final SortOrder? ofcpCd;

  @JsonKey(name: r'OFCP_NM')
  final SortOrder? ofcpNm;

  @JsonKey(name: r'EMAIL_ADDR')
  final SortOrder? emailAddr;

  @JsonKey(name: r'OFFM_TELNO')
  final SortOrder? offmTelno;

  @JsonKey(name: r'HTEL_TELNO')
  final SortOrder? htelTelno;

  @JsonKey(name: r'DEPT_YN')
  final SortOrder? deptYn;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STDEPTEMPMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STMENUCountOrderByAggregateInput implements _i1.JsonSerializable {
  const STMENUCountOrderByAggregateInput({
    this.menuCd,
    this.menuNm,
    this.menuPath,
    this.menuMapping,
    this.menuSrt,
    this.menuDeps,
    this.menuIcon,
    this.menuTp,
    this.mainExpsrYn,
    this.subExpsrYn,
    this.upendClas,
    this.upendCn,
    this.cclType,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMENUCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMENUCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'MENU_CD')
  final SortOrder? menuCd;

  @JsonKey(name: r'MENU_NM')
  final SortOrder? menuNm;

  @JsonKey(name: r'MENU_PATH')
  final SortOrder? menuPath;

  @JsonKey(name: r'MENU_MAPPING')
  final SortOrder? menuMapping;

  @JsonKey(name: r'MENU_SRT')
  final SortOrder? menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final SortOrder? menuDeps;

  @JsonKey(name: r'MENU_ICON')
  final SortOrder? menuIcon;

  @JsonKey(name: r'MENU_TP')
  final SortOrder? menuTp;

  @JsonKey(name: r'MAIN_EXPSR_YN')
  final SortOrder? mainExpsrYn;

  @JsonKey(name: r'SUB_EXPSR_YN')
  final SortOrder? subExpsrYn;

  @JsonKey(name: r'UPEND_CLAS')
  final SortOrder? upendClas;

  @JsonKey(name: r'UPEND_CN')
  final SortOrder? upendCn;

  @JsonKey(name: r'CCL_TYPE')
  final SortOrder? cclType;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STMENUCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STMENUAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const STMENUAvgOrderByAggregateInput({
    this.menuSrt,
    this.menuDeps,
  });

  factory STMENUAvgOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$STMENUAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'MENU_SRT')
  final SortOrder? menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final SortOrder? menuDeps;

  @override
  Map<String, dynamic> toJson() => _$STMENUAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STMENUMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const STMENUMaxOrderByAggregateInput({
    this.menuCd,
    this.menuNm,
    this.menuPath,
    this.menuMapping,
    this.menuSrt,
    this.menuDeps,
    this.menuIcon,
    this.menuTp,
    this.mainExpsrYn,
    this.subExpsrYn,
    this.upendClas,
    this.upendCn,
    this.cclType,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMENUMaxOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$STMENUMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'MENU_CD')
  final SortOrder? menuCd;

  @JsonKey(name: r'MENU_NM')
  final SortOrder? menuNm;

  @JsonKey(name: r'MENU_PATH')
  final SortOrder? menuPath;

  @JsonKey(name: r'MENU_MAPPING')
  final SortOrder? menuMapping;

  @JsonKey(name: r'MENU_SRT')
  final SortOrder? menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final SortOrder? menuDeps;

  @JsonKey(name: r'MENU_ICON')
  final SortOrder? menuIcon;

  @JsonKey(name: r'MENU_TP')
  final SortOrder? menuTp;

  @JsonKey(name: r'MAIN_EXPSR_YN')
  final SortOrder? mainExpsrYn;

  @JsonKey(name: r'SUB_EXPSR_YN')
  final SortOrder? subExpsrYn;

  @JsonKey(name: r'UPEND_CLAS')
  final SortOrder? upendClas;

  @JsonKey(name: r'UPEND_CN')
  final SortOrder? upendCn;

  @JsonKey(name: r'CCL_TYPE')
  final SortOrder? cclType;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() => _$STMENUMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STMENUMinOrderByAggregateInput implements _i1.JsonSerializable {
  const STMENUMinOrderByAggregateInput({
    this.menuCd,
    this.menuNm,
    this.menuPath,
    this.menuMapping,
    this.menuSrt,
    this.menuDeps,
    this.menuIcon,
    this.menuTp,
    this.mainExpsrYn,
    this.subExpsrYn,
    this.upendClas,
    this.upendCn,
    this.cclType,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMENUMinOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$STMENUMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'MENU_CD')
  final SortOrder? menuCd;

  @JsonKey(name: r'MENU_NM')
  final SortOrder? menuNm;

  @JsonKey(name: r'MENU_PATH')
  final SortOrder? menuPath;

  @JsonKey(name: r'MENU_MAPPING')
  final SortOrder? menuMapping;

  @JsonKey(name: r'MENU_SRT')
  final SortOrder? menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final SortOrder? menuDeps;

  @JsonKey(name: r'MENU_ICON')
  final SortOrder? menuIcon;

  @JsonKey(name: r'MENU_TP')
  final SortOrder? menuTp;

  @JsonKey(name: r'MAIN_EXPSR_YN')
  final SortOrder? mainExpsrYn;

  @JsonKey(name: r'SUB_EXPSR_YN')
  final SortOrder? subExpsrYn;

  @JsonKey(name: r'UPEND_CLAS')
  final SortOrder? upendClas;

  @JsonKey(name: r'UPEND_CN')
  final SortOrder? upendCn;

  @JsonKey(name: r'CCL_TYPE')
  final SortOrder? cclType;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() => _$STMENUMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STMENUSumOrderByAggregateInput implements _i1.JsonSerializable {
  const STMENUSumOrderByAggregateInput({
    this.menuSrt,
    this.menuDeps,
  });

  factory STMENUSumOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$STMENUSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'MENU_SRT')
  final SortOrder? menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final SortOrder? menuDeps;

  @override
  Map<String, dynamic> toJson() => _$STMENUSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STMESSAGETMPLATMSGDIVCDMSGCDCompoundUniqueInput
    implements _i1.JsonSerializable {
  const STMESSAGETMPLATMSGDIVCDMSGCDCompoundUniqueInput({
    required this.msgDivCd,
    required this.msgCd,
  });

  factory STMESSAGETMPLATMSGDIVCDMSGCDCompoundUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMESSAGETMPLATMSGDIVCDMSGCDCompoundUniqueInputFromJson(json);

  @JsonKey(name: r'MSG_DIV_CD')
  final String msgDivCd;

  @JsonKey(name: r'MSG_CD')
  final String msgCd;

  @override
  Map<String, dynamic> toJson() =>
      _$STMESSAGETMPLATMSGDIVCDMSGCDCompoundUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STMESSAGETMPLATCountOrderByAggregateInput
    implements _i1.JsonSerializable {
  const STMESSAGETMPLATCountOrderByAggregateInput({
    this.msgDivCd,
    this.msgCd,
    this.msgNm,
    this.msgTmplat,
    this.useYn,
    this.editId,
    this.editDate,
  });

  factory STMESSAGETMPLATCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMESSAGETMPLATCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'MSG_DIV_CD')
  final SortOrder? msgDivCd;

  @JsonKey(name: r'MSG_CD')
  final SortOrder? msgCd;

  @JsonKey(name: r'MSG_NM')
  final SortOrder? msgNm;

  @JsonKey(name: r'MSG_TMPLAT')
  final SortOrder? msgTmplat;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STMESSAGETMPLATCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STMESSAGETMPLATMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const STMESSAGETMPLATMaxOrderByAggregateInput({
    this.msgDivCd,
    this.msgCd,
    this.msgNm,
    this.msgTmplat,
    this.useYn,
    this.editId,
    this.editDate,
  });

  factory STMESSAGETMPLATMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMESSAGETMPLATMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'MSG_DIV_CD')
  final SortOrder? msgDivCd;

  @JsonKey(name: r'MSG_CD')
  final SortOrder? msgCd;

  @JsonKey(name: r'MSG_NM')
  final SortOrder? msgNm;

  @JsonKey(name: r'MSG_TMPLAT')
  final SortOrder? msgTmplat;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STMESSAGETMPLATMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STMESSAGETMPLATMinOrderByAggregateInput implements _i1.JsonSerializable {
  const STMESSAGETMPLATMinOrderByAggregateInput({
    this.msgDivCd,
    this.msgCd,
    this.msgNm,
    this.msgTmplat,
    this.useYn,
    this.editId,
    this.editDate,
  });

  factory STMESSAGETMPLATMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMESSAGETMPLATMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'MSG_DIV_CD')
  final SortOrder? msgDivCd;

  @JsonKey(name: r'MSG_CD')
  final SortOrder? msgCd;

  @JsonKey(name: r'MSG_NM')
  final SortOrder? msgNm;

  @JsonKey(name: r'MSG_TMPLAT')
  final SortOrder? msgTmplat;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STMESSAGETMPLATMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STMIMETYPECountOrderByAggregateInput implements _i1.JsonSerializable {
  const STMIMETYPECountOrderByAggregateInput({
    this.seq,
    this.extnNm,
    this.fileMt,
  });

  factory STMIMETYPECountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMIMETYPECountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'EXTN_NM')
  final SortOrder? extnNm;

  @JsonKey(name: r'FILE_MT')
  final SortOrder? fileMt;

  @override
  Map<String, dynamic> toJson() =>
      _$STMIMETYPECountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STMIMETYPEAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const STMIMETYPEAvgOrderByAggregateInput({this.seq});

  factory STMIMETYPEAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMIMETYPEAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @override
  Map<String, dynamic> toJson() =>
      _$STMIMETYPEAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STMIMETYPEMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const STMIMETYPEMaxOrderByAggregateInput({
    this.seq,
    this.extnNm,
    this.fileMt,
  });

  factory STMIMETYPEMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMIMETYPEMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'EXTN_NM')
  final SortOrder? extnNm;

  @JsonKey(name: r'FILE_MT')
  final SortOrder? fileMt;

  @override
  Map<String, dynamic> toJson() =>
      _$STMIMETYPEMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STMIMETYPEMinOrderByAggregateInput implements _i1.JsonSerializable {
  const STMIMETYPEMinOrderByAggregateInput({
    this.seq,
    this.extnNm,
    this.fileMt,
  });

  factory STMIMETYPEMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMIMETYPEMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'EXTN_NM')
  final SortOrder? extnNm;

  @JsonKey(name: r'FILE_MT')
  final SortOrder? fileMt;

  @override
  Map<String, dynamic> toJson() =>
      _$STMIMETYPEMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STMIMETYPESumOrderByAggregateInput implements _i1.JsonSerializable {
  const STMIMETYPESumOrderByAggregateInput({this.seq});

  factory STMIMETYPESumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMIMETYPESumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @override
  Map<String, dynamic> toJson() =>
      _$STMIMETYPESumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRGRPCountOrderByAggregateInput implements _i1.JsonSerializable {
  const STMNGRGRPCountOrderByAggregateInput({
    this.grpCd,
    this.grpNm,
    this.grpDesc,
    this.sort,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMNGRGRPCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMNGRGRPCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'GRP_CD')
  final SortOrder? grpCd;

  @JsonKey(name: r'GRP_NM')
  final SortOrder? grpNm;

  @JsonKey(name: r'GRP_DESC')
  final SortOrder? grpDesc;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STMNGRGRPCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRGRPAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const STMNGRGRPAvgOrderByAggregateInput({this.sort});

  factory STMNGRGRPAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMNGRGRPAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @override
  Map<String, dynamic> toJson() =>
      _$STMNGRGRPAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRGRPMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const STMNGRGRPMaxOrderByAggregateInput({
    this.grpCd,
    this.grpNm,
    this.grpDesc,
    this.sort,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMNGRGRPMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMNGRGRPMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'GRP_CD')
  final SortOrder? grpCd;

  @JsonKey(name: r'GRP_NM')
  final SortOrder? grpNm;

  @JsonKey(name: r'GRP_DESC')
  final SortOrder? grpDesc;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STMNGRGRPMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRGRPMinOrderByAggregateInput implements _i1.JsonSerializable {
  const STMNGRGRPMinOrderByAggregateInput({
    this.grpCd,
    this.grpNm,
    this.grpDesc,
    this.sort,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMNGRGRPMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMNGRGRPMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'GRP_CD')
  final SortOrder? grpCd;

  @JsonKey(name: r'GRP_NM')
  final SortOrder? grpNm;

  @JsonKey(name: r'GRP_DESC')
  final SortOrder? grpDesc;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STMNGRGRPMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRGRPSumOrderByAggregateInput implements _i1.JsonSerializable {
  const STMNGRGRPSumOrderByAggregateInput({this.sort});

  factory STMNGRGRPSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMNGRGRPSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @override
  Map<String, dynamic> toJson() =>
      _$STMNGRGRPSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRMSTCountOrderByAggregateInput implements _i1.JsonSerializable {
  const STMNGRMSTCountOrderByAggregateInput({
    this.mngrId,
    this.mngrNm,
    this.mngrPw,
    this.grpCd,
    this.grade,
    this.permCd,
    this.acsYn,
    this.clph,
    this.empNo,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.pwdWrongDate,
    this.lstLoginDate,
    this.flpth,
    this.fileNm,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMNGRMSTCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMNGRMSTCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'MNGR_ID')
  final SortOrder? mngrId;

  @JsonKey(name: r'MNGR_NM')
  final SortOrder? mngrNm;

  @JsonKey(name: r'MNGR_PW')
  final SortOrder? mngrPw;

  @JsonKey(name: r'GRP_CD')
  final SortOrder? grpCd;

  @JsonKey(name: r'GRADE')
  final SortOrder? grade;

  @JsonKey(name: r'PERM_CD')
  final SortOrder? permCd;

  @JsonKey(name: r'ACS_YN')
  final SortOrder? acsYn;

  @JsonKey(name: r'CLPH')
  final SortOrder? clph;

  @JsonKey(name: r'EMP_NO')
  final SortOrder? empNo;

  @JsonKey(name: r'JOIN_DATE')
  final SortOrder? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final SortOrder? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final SortOrder? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final SortOrder? pwdWrongCnt;

  @JsonKey(name: r'PWD_WRONG_DATE')
  final SortOrder? pwdWrongDate;

  @JsonKey(name: r'LST_LOGIN_DATE')
  final SortOrder? lstLoginDate;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'FILE_NM')
  final SortOrder? fileNm;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STMNGRMSTCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRMSTAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const STMNGRMSTAvgOrderByAggregateInput({this.pwdWrongCnt});

  factory STMNGRMSTAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMNGRMSTAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'PWD_WRONG_CNT')
  final SortOrder? pwdWrongCnt;

  @override
  Map<String, dynamic> toJson() =>
      _$STMNGRMSTAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRMSTMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const STMNGRMSTMaxOrderByAggregateInput({
    this.mngrId,
    this.mngrNm,
    this.mngrPw,
    this.grpCd,
    this.grade,
    this.permCd,
    this.acsYn,
    this.clph,
    this.empNo,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.pwdWrongDate,
    this.lstLoginDate,
    this.flpth,
    this.fileNm,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMNGRMSTMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMNGRMSTMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'MNGR_ID')
  final SortOrder? mngrId;

  @JsonKey(name: r'MNGR_NM')
  final SortOrder? mngrNm;

  @JsonKey(name: r'MNGR_PW')
  final SortOrder? mngrPw;

  @JsonKey(name: r'GRP_CD')
  final SortOrder? grpCd;

  @JsonKey(name: r'GRADE')
  final SortOrder? grade;

  @JsonKey(name: r'PERM_CD')
  final SortOrder? permCd;

  @JsonKey(name: r'ACS_YN')
  final SortOrder? acsYn;

  @JsonKey(name: r'CLPH')
  final SortOrder? clph;

  @JsonKey(name: r'EMP_NO')
  final SortOrder? empNo;

  @JsonKey(name: r'JOIN_DATE')
  final SortOrder? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final SortOrder? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final SortOrder? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final SortOrder? pwdWrongCnt;

  @JsonKey(name: r'PWD_WRONG_DATE')
  final SortOrder? pwdWrongDate;

  @JsonKey(name: r'LST_LOGIN_DATE')
  final SortOrder? lstLoginDate;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'FILE_NM')
  final SortOrder? fileNm;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STMNGRMSTMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRMSTMinOrderByAggregateInput implements _i1.JsonSerializable {
  const STMNGRMSTMinOrderByAggregateInput({
    this.mngrId,
    this.mngrNm,
    this.mngrPw,
    this.grpCd,
    this.grade,
    this.permCd,
    this.acsYn,
    this.clph,
    this.empNo,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.pwdWrongDate,
    this.lstLoginDate,
    this.flpth,
    this.fileNm,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMNGRMSTMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMNGRMSTMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'MNGR_ID')
  final SortOrder? mngrId;

  @JsonKey(name: r'MNGR_NM')
  final SortOrder? mngrNm;

  @JsonKey(name: r'MNGR_PW')
  final SortOrder? mngrPw;

  @JsonKey(name: r'GRP_CD')
  final SortOrder? grpCd;

  @JsonKey(name: r'GRADE')
  final SortOrder? grade;

  @JsonKey(name: r'PERM_CD')
  final SortOrder? permCd;

  @JsonKey(name: r'ACS_YN')
  final SortOrder? acsYn;

  @JsonKey(name: r'CLPH')
  final SortOrder? clph;

  @JsonKey(name: r'EMP_NO')
  final SortOrder? empNo;

  @JsonKey(name: r'JOIN_DATE')
  final SortOrder? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final SortOrder? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final SortOrder? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final SortOrder? pwdWrongCnt;

  @JsonKey(name: r'PWD_WRONG_DATE')
  final SortOrder? pwdWrongDate;

  @JsonKey(name: r'LST_LOGIN_DATE')
  final SortOrder? lstLoginDate;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'FILE_NM')
  final SortOrder? fileNm;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STMNGRMSTMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STMNGRMSTSumOrderByAggregateInput implements _i1.JsonSerializable {
  const STMNGRMSTSumOrderByAggregateInput({this.pwdWrongCnt});

  factory STMNGRMSTSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMNGRMSTSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'PWD_WRONG_CNT')
  final SortOrder? pwdWrongCnt;

  @override
  Map<String, dynamic> toJson() =>
      _$STMNGRMSTSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STMYSTNGUSERIDSTNGCDUSERDIVCompoundUniqueInput
    implements _i1.JsonSerializable {
  const STMYSTNGUSERIDSTNGCDUSERDIVCompoundUniqueInput({
    required this.userId,
    required this.stngCd,
    required this.userDiv,
  });

  factory STMYSTNGUSERIDSTNGCDUSERDIVCompoundUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMYSTNGUSERIDSTNGCDUSERDIVCompoundUniqueInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'STNG_CD')
  final String stngCd;

  @JsonKey(name: r'USER_DIV')
  final String userDiv;

  @override
  Map<String, dynamic> toJson() =>
      _$STMYSTNGUSERIDSTNGCDUSERDIVCompoundUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STMYSTNGCountOrderByAggregateInput implements _i1.JsonSerializable {
  const STMYSTNGCountOrderByAggregateInput({
    this.userId,
    this.stngCd,
    this.userDiv,
    this.stngData,
  });

  factory STMYSTNGCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMYSTNGCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'STNG_CD')
  final SortOrder? stngCd;

  @JsonKey(name: r'USER_DIV')
  final SortOrder? userDiv;

  @JsonKey(name: r'STNG_DATA')
  final SortOrder? stngData;

  @override
  Map<String, dynamic> toJson() =>
      _$STMYSTNGCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STMYSTNGMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const STMYSTNGMaxOrderByAggregateInput({
    this.userId,
    this.stngCd,
    this.userDiv,
    this.stngData,
  });

  factory STMYSTNGMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMYSTNGMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'STNG_CD')
  final SortOrder? stngCd;

  @JsonKey(name: r'USER_DIV')
  final SortOrder? userDiv;

  @JsonKey(name: r'STNG_DATA')
  final SortOrder? stngData;

  @override
  Map<String, dynamic> toJson() =>
      _$STMYSTNGMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STMYSTNGMinOrderByAggregateInput implements _i1.JsonSerializable {
  const STMYSTNGMinOrderByAggregateInput({
    this.userId,
    this.stngCd,
    this.userDiv,
    this.stngData,
  });

  factory STMYSTNGMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STMYSTNGMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'STNG_CD')
  final SortOrder? stngCd;

  @JsonKey(name: r'USER_DIV')
  final SortOrder? userDiv;

  @JsonKey(name: r'STNG_DATA')
  final SortOrder? stngData;

  @override
  Map<String, dynamic> toJson() =>
      _$STMYSTNGMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STPERMDTLPERMCDMENUCDCompoundUniqueInput implements _i1.JsonSerializable {
  const STPERMDTLPERMCDMENUCDCompoundUniqueInput({
    required this.permCd,
    required this.menuCd,
  });

  factory STPERMDTLPERMCDMENUCDCompoundUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$STPERMDTLPERMCDMENUCDCompoundUniqueInputFromJson(json);

  @JsonKey(name: r'PERM_CD')
  final String permCd;

  @JsonKey(name: r'MENU_CD')
  final String menuCd;

  @override
  Map<String, dynamic> toJson() =>
      _$STPERMDTLPERMCDMENUCDCompoundUniqueInputToJson(this);
}

@_i1.jsonSerializable
class STPERMDTLCountOrderByAggregateInput implements _i1.JsonSerializable {
  const STPERMDTLCountOrderByAggregateInput({
    this.permCd,
    this.menuCd,
    this.readYn,
    this.regYn,
    this.mdfcnYn,
    this.delYn,
    this.manageYn,
    this.regId,
    this.regDate,
  });

  factory STPERMDTLCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STPERMDTLCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'PERM_CD')
  final SortOrder? permCd;

  @JsonKey(name: r'MENU_CD')
  final SortOrder? menuCd;

  @JsonKey(name: r'READ_YN')
  final SortOrder? readYn;

  @JsonKey(name: r'REG_YN')
  final SortOrder? regYn;

  @JsonKey(name: r'MDFCN_YN')
  final SortOrder? mdfcnYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'MANAGE_YN')
  final SortOrder? manageYn;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STPERMDTLCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STPERMDTLMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const STPERMDTLMaxOrderByAggregateInput({
    this.permCd,
    this.menuCd,
    this.readYn,
    this.regYn,
    this.mdfcnYn,
    this.delYn,
    this.manageYn,
    this.regId,
    this.regDate,
  });

  factory STPERMDTLMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STPERMDTLMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'PERM_CD')
  final SortOrder? permCd;

  @JsonKey(name: r'MENU_CD')
  final SortOrder? menuCd;

  @JsonKey(name: r'READ_YN')
  final SortOrder? readYn;

  @JsonKey(name: r'REG_YN')
  final SortOrder? regYn;

  @JsonKey(name: r'MDFCN_YN')
  final SortOrder? mdfcnYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'MANAGE_YN')
  final SortOrder? manageYn;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STPERMDTLMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STPERMDTLMinOrderByAggregateInput implements _i1.JsonSerializable {
  const STPERMDTLMinOrderByAggregateInput({
    this.permCd,
    this.menuCd,
    this.readYn,
    this.regYn,
    this.mdfcnYn,
    this.delYn,
    this.manageYn,
    this.regId,
    this.regDate,
  });

  factory STPERMDTLMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STPERMDTLMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'PERM_CD')
  final SortOrder? permCd;

  @JsonKey(name: r'MENU_CD')
  final SortOrder? menuCd;

  @JsonKey(name: r'READ_YN')
  final SortOrder? readYn;

  @JsonKey(name: r'REG_YN')
  final SortOrder? regYn;

  @JsonKey(name: r'MDFCN_YN')
  final SortOrder? mdfcnYn;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @JsonKey(name: r'MANAGE_YN')
  final SortOrder? manageYn;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STPERMDTLMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STPERMMSTCountOrderByAggregateInput implements _i1.JsonSerializable {
  const STPERMMSTCountOrderByAggregateInput({
    this.permCd,
    this.permNm,
    this.sort,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STPERMMSTCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STPERMMSTCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'PERM_CD')
  final SortOrder? permCd;

  @JsonKey(name: r'PERM_NM')
  final SortOrder? permNm;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STPERMMSTCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STPERMMSTMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const STPERMMSTMaxOrderByAggregateInput({
    this.permCd,
    this.permNm,
    this.sort,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STPERMMSTMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STPERMMSTMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'PERM_CD')
  final SortOrder? permCd;

  @JsonKey(name: r'PERM_NM')
  final SortOrder? permNm;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STPERMMSTMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STPERMMSTMinOrderByAggregateInput implements _i1.JsonSerializable {
  const STPERMMSTMinOrderByAggregateInput({
    this.permCd,
    this.permNm,
    this.sort,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STPERMMSTMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STPERMMSTMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'PERM_CD')
  final SortOrder? permCd;

  @JsonKey(name: r'PERM_NM')
  final SortOrder? permNm;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STPERMMSTMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STPOPUPCountOrderByAggregateInput implements _i1.JsonSerializable {
  const STPOPUPCountOrderByAggregateInput({
    this.popCd,
    this.popNm,
    this.popTy,
    this.imgText,
    this.lkUrl,
    this.lkTarget,
    this.bgngDate,
    this.endDate,
    this.spwgPred,
    this.flpth,
    this.fileNm,
    this.useYn,
    this.beforeCd,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STPOPUPCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STPOPUPCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'POP_CD')
  final SortOrder? popCd;

  @JsonKey(name: r'POP_NM')
  final SortOrder? popNm;

  @JsonKey(name: r'POP_TY')
  final SortOrder? popTy;

  @JsonKey(name: r'IMG_TEXT')
  final SortOrder? imgText;

  @JsonKey(name: r'LK_URL')
  final SortOrder? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final SortOrder? lkTarget;

  @JsonKey(name: r'BGNG_DATE')
  final SortOrder? bgngDate;

  @JsonKey(name: r'END_DATE')
  final SortOrder? endDate;

  @JsonKey(name: r'SPWG_PRED')
  final SortOrder? spwgPred;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'FILE_NM')
  final SortOrder? fileNm;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'BEFORE_CD')
  final SortOrder? beforeCd;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STPOPUPCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STPOPUPMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const STPOPUPMaxOrderByAggregateInput({
    this.popCd,
    this.popNm,
    this.popTy,
    this.imgText,
    this.lkUrl,
    this.lkTarget,
    this.bgngDate,
    this.endDate,
    this.spwgPred,
    this.flpth,
    this.fileNm,
    this.useYn,
    this.beforeCd,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STPOPUPMaxOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$STPOPUPMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'POP_CD')
  final SortOrder? popCd;

  @JsonKey(name: r'POP_NM')
  final SortOrder? popNm;

  @JsonKey(name: r'POP_TY')
  final SortOrder? popTy;

  @JsonKey(name: r'IMG_TEXT')
  final SortOrder? imgText;

  @JsonKey(name: r'LK_URL')
  final SortOrder? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final SortOrder? lkTarget;

  @JsonKey(name: r'BGNG_DATE')
  final SortOrder? bgngDate;

  @JsonKey(name: r'END_DATE')
  final SortOrder? endDate;

  @JsonKey(name: r'SPWG_PRED')
  final SortOrder? spwgPred;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'FILE_NM')
  final SortOrder? fileNm;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'BEFORE_CD')
  final SortOrder? beforeCd;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STPOPUPMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STPOPUPMinOrderByAggregateInput implements _i1.JsonSerializable {
  const STPOPUPMinOrderByAggregateInput({
    this.popCd,
    this.popNm,
    this.popTy,
    this.imgText,
    this.lkUrl,
    this.lkTarget,
    this.bgngDate,
    this.endDate,
    this.spwgPred,
    this.flpth,
    this.fileNm,
    this.useYn,
    this.beforeCd,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STPOPUPMinOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$STPOPUPMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'POP_CD')
  final SortOrder? popCd;

  @JsonKey(name: r'POP_NM')
  final SortOrder? popNm;

  @JsonKey(name: r'POP_TY')
  final SortOrder? popTy;

  @JsonKey(name: r'IMG_TEXT')
  final SortOrder? imgText;

  @JsonKey(name: r'LK_URL')
  final SortOrder? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final SortOrder? lkTarget;

  @JsonKey(name: r'BGNG_DATE')
  final SortOrder? bgngDate;

  @JsonKey(name: r'END_DATE')
  final SortOrder? endDate;

  @JsonKey(name: r'SPWG_PRED')
  final SortOrder? spwgPred;

  @JsonKey(name: r'FLPTH')
  final SortOrder? flpth;

  @JsonKey(name: r'FILE_NM')
  final SortOrder? fileNm;

  @JsonKey(name: r'USE_YN')
  final SortOrder? useYn;

  @JsonKey(name: r'BEFORE_CD')
  final SortOrder? beforeCd;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STPOPUPMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STSTNGCountOrderByAggregateInput implements _i1.JsonSerializable {
  const STSTNGCountOrderByAggregateInput({
    this.stngCd,
    this.stngData,
    this.title,
    this.descCn,
    this.sort,
    this.editId,
    this.editDate,
  });

  factory STSTNGCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STSTNGCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'STNG_CD')
  final SortOrder? stngCd;

  @JsonKey(name: r'STNG_DATA')
  final SortOrder? stngData;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'DESC_CN')
  final SortOrder? descCn;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STSTNGCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STSTNGAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const STSTNGAvgOrderByAggregateInput({this.sort});

  factory STSTNGAvgOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$STSTNGAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @override
  Map<String, dynamic> toJson() => _$STSTNGAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STSTNGMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const STSTNGMaxOrderByAggregateInput({
    this.stngCd,
    this.stngData,
    this.title,
    this.descCn,
    this.sort,
    this.editId,
    this.editDate,
  });

  factory STSTNGMaxOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$STSTNGMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'STNG_CD')
  final SortOrder? stngCd;

  @JsonKey(name: r'STNG_DATA')
  final SortOrder? stngData;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'DESC_CN')
  final SortOrder? descCn;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @override
  Map<String, dynamic> toJson() => _$STSTNGMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STSTNGMinOrderByAggregateInput implements _i1.JsonSerializable {
  const STSTNGMinOrderByAggregateInput({
    this.stngCd,
    this.stngData,
    this.title,
    this.descCn,
    this.sort,
    this.editId,
    this.editDate,
  });

  factory STSTNGMinOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$STSTNGMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'STNG_CD')
  final SortOrder? stngCd;

  @JsonKey(name: r'STNG_DATA')
  final SortOrder? stngData;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'DESC_CN')
  final SortOrder? descCn;

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @override
  Map<String, dynamic> toJson() => _$STSTNGMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STSTNGSumOrderByAggregateInput implements _i1.JsonSerializable {
  const STSTNGSumOrderByAggregateInput({this.sort});

  factory STSTNGSumOrderByAggregateInput.fromJson(Map<String, dynamic> json) =>
      _$STSTNGSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SORT')
  final SortOrder? sort;

  @override
  Map<String, dynamic> toJson() => _$STSTNGSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STUSERMSTCountOrderByAggregateInput implements _i1.JsonSerializable {
  const STUSERMSTCountOrderByAggregateInput({
    this.userId,
    this.userNm,
    this.userPw,
    this.userDiv,
    this.status,
    this.prevLoginYn,
    this.withdrawnYn,
    this.clph,
    this.email,
    this.lstLoginDate,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STUSERMSTCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STUSERMSTCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'USER_NM')
  final SortOrder? userNm;

  @JsonKey(name: r'USER_PW')
  final SortOrder? userPw;

  @JsonKey(name: r'USER_DIV')
  final SortOrder? userDiv;

  @JsonKey(name: r'STATUS')
  final SortOrder? status;

  @JsonKey(name: r'PREV_LOGIN_YN')
  final SortOrder? prevLoginYn;

  @JsonKey(name: r'WITHDRAWN_YN')
  final SortOrder? withdrawnYn;

  @JsonKey(name: r'CLPH')
  final SortOrder? clph;

  @JsonKey(name: r'EMAIL')
  final SortOrder? email;

  @JsonKey(name: r'LST_LOGIN_DATE')
  final SortOrder? lstLoginDate;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STUSERMSTCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STUSERMSTMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const STUSERMSTMaxOrderByAggregateInput({
    this.userId,
    this.userNm,
    this.userPw,
    this.userDiv,
    this.status,
    this.prevLoginYn,
    this.withdrawnYn,
    this.clph,
    this.email,
    this.lstLoginDate,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STUSERMSTMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STUSERMSTMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'USER_NM')
  final SortOrder? userNm;

  @JsonKey(name: r'USER_PW')
  final SortOrder? userPw;

  @JsonKey(name: r'USER_DIV')
  final SortOrder? userDiv;

  @JsonKey(name: r'STATUS')
  final SortOrder? status;

  @JsonKey(name: r'PREV_LOGIN_YN')
  final SortOrder? prevLoginYn;

  @JsonKey(name: r'WITHDRAWN_YN')
  final SortOrder? withdrawnYn;

  @JsonKey(name: r'CLPH')
  final SortOrder? clph;

  @JsonKey(name: r'EMAIL')
  final SortOrder? email;

  @JsonKey(name: r'LST_LOGIN_DATE')
  final SortOrder? lstLoginDate;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STUSERMSTMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class STUSERMSTMinOrderByAggregateInput implements _i1.JsonSerializable {
  const STUSERMSTMinOrderByAggregateInput({
    this.userId,
    this.userNm,
    this.userPw,
    this.userDiv,
    this.status,
    this.prevLoginYn,
    this.withdrawnYn,
    this.clph,
    this.email,
    this.lstLoginDate,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STUSERMSTMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$STUSERMSTMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'USER_NM')
  final SortOrder? userNm;

  @JsonKey(name: r'USER_PW')
  final SortOrder? userPw;

  @JsonKey(name: r'USER_DIV')
  final SortOrder? userDiv;

  @JsonKey(name: r'STATUS')
  final SortOrder? status;

  @JsonKey(name: r'PREV_LOGIN_YN')
  final SortOrder? prevLoginYn;

  @JsonKey(name: r'WITHDRAWN_YN')
  final SortOrder? withdrawnYn;

  @JsonKey(name: r'CLPH')
  final SortOrder? clph;

  @JsonKey(name: r'EMAIL')
  final SortOrder? email;

  @JsonKey(name: r'LST_LOGIN_DATE')
  final SortOrder? lstLoginDate;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STUSERMSTMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTDETAILTBLSEQREPORTIDCompoundUniqueInput
    implements _i1.JsonSerializable {
  const WORKREPORTDETAILTBLSEQREPORTIDCompoundUniqueInput({
    required this.seq,
    required this.reportId,
  });

  factory WORKREPORTDETAILTBLSEQREPORTIDCompoundUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTDETAILTBLSEQREPORTIDCompoundUniqueInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt seq;

  @JsonKey(name: r'REPORT_ID')
  final String reportId;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTDETAILTBLSEQREPORTIDCompoundUniqueInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTDETAILTBLCountOrderByAggregateInput
    implements _i1.JsonSerializable {
  const WORKREPORTDETAILTBLCountOrderByAggregateInput({
    this.reportId,
    this.seq,
    this.projectNm,
    this.projectSubNm,
    this.detailContent,
    this.worker,
    this.grade,
    this.processRate,
    this.workDate,
    this.processType,
    this.subjectYn,
    this.regUser,
    this.regDate,
    this.completeDate,
  });

  factory WORKREPORTDETAILTBLCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTDETAILTBLCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final SortOrder? reportId;

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'PROJECT_NM')
  final SortOrder? projectNm;

  @JsonKey(name: r'PROJECT_SUB_NM')
  final SortOrder? projectSubNm;

  @JsonKey(name: r'DETAIL_CONTENT')
  final SortOrder? detailContent;

  @JsonKey(name: r'WORKER')
  final SortOrder? worker;

  @JsonKey(name: r'GRADE')
  final SortOrder? grade;

  @JsonKey(name: r'PROCESS_RATE')
  final SortOrder? processRate;

  @JsonKey(name: r'WORK_DATE')
  final SortOrder? workDate;

  @JsonKey(name: r'PROCESS_TYPE')
  final SortOrder? processType;

  @JsonKey(name: r'SUBJECT_YN')
  final SortOrder? subjectYn;

  @JsonKey(name: r'REG_USER')
  final SortOrder? regUser;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'COMPLETE_DATE')
  final SortOrder? completeDate;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTDETAILTBLCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTDETAILTBLAvgOrderByAggregateInput
    implements _i1.JsonSerializable {
  const WORKREPORTDETAILTBLAvgOrderByAggregateInput({this.seq});

  factory WORKREPORTDETAILTBLAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTDETAILTBLAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTDETAILTBLAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTDETAILTBLMaxOrderByAggregateInput
    implements _i1.JsonSerializable {
  const WORKREPORTDETAILTBLMaxOrderByAggregateInput({
    this.reportId,
    this.seq,
    this.projectNm,
    this.projectSubNm,
    this.detailContent,
    this.worker,
    this.grade,
    this.processRate,
    this.workDate,
    this.processType,
    this.subjectYn,
    this.regUser,
    this.regDate,
    this.completeDate,
  });

  factory WORKREPORTDETAILTBLMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTDETAILTBLMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final SortOrder? reportId;

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'PROJECT_NM')
  final SortOrder? projectNm;

  @JsonKey(name: r'PROJECT_SUB_NM')
  final SortOrder? projectSubNm;

  @JsonKey(name: r'DETAIL_CONTENT')
  final SortOrder? detailContent;

  @JsonKey(name: r'WORKER')
  final SortOrder? worker;

  @JsonKey(name: r'GRADE')
  final SortOrder? grade;

  @JsonKey(name: r'PROCESS_RATE')
  final SortOrder? processRate;

  @JsonKey(name: r'WORK_DATE')
  final SortOrder? workDate;

  @JsonKey(name: r'PROCESS_TYPE')
  final SortOrder? processType;

  @JsonKey(name: r'SUBJECT_YN')
  final SortOrder? subjectYn;

  @JsonKey(name: r'REG_USER')
  final SortOrder? regUser;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'COMPLETE_DATE')
  final SortOrder? completeDate;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTDETAILTBLMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTDETAILTBLMinOrderByAggregateInput
    implements _i1.JsonSerializable {
  const WORKREPORTDETAILTBLMinOrderByAggregateInput({
    this.reportId,
    this.seq,
    this.projectNm,
    this.projectSubNm,
    this.detailContent,
    this.worker,
    this.grade,
    this.processRate,
    this.workDate,
    this.processType,
    this.subjectYn,
    this.regUser,
    this.regDate,
    this.completeDate,
  });

  factory WORKREPORTDETAILTBLMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTDETAILTBLMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final SortOrder? reportId;

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'PROJECT_NM')
  final SortOrder? projectNm;

  @JsonKey(name: r'PROJECT_SUB_NM')
  final SortOrder? projectSubNm;

  @JsonKey(name: r'DETAIL_CONTENT')
  final SortOrder? detailContent;

  @JsonKey(name: r'WORKER')
  final SortOrder? worker;

  @JsonKey(name: r'GRADE')
  final SortOrder? grade;

  @JsonKey(name: r'PROCESS_RATE')
  final SortOrder? processRate;

  @JsonKey(name: r'WORK_DATE')
  final SortOrder? workDate;

  @JsonKey(name: r'PROCESS_TYPE')
  final SortOrder? processType;

  @JsonKey(name: r'SUBJECT_YN')
  final SortOrder? subjectYn;

  @JsonKey(name: r'REG_USER')
  final SortOrder? regUser;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'COMPLETE_DATE')
  final SortOrder? completeDate;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTDETAILTBLMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTDETAILTBLSumOrderByAggregateInput
    implements _i1.JsonSerializable {
  const WORKREPORTDETAILTBLSumOrderByAggregateInput({this.seq});

  factory WORKREPORTDETAILTBLSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTDETAILTBLSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTDETAILTBLSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLREPORTIDUSERIDCompoundUniqueInput
    implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLREPORTIDUSERIDCompoundUniqueInput({
    required this.reportId,
    required this.userId,
  });

  factory WORKREPORTHTMLTBLREPORTIDUSERIDCompoundUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLREPORTIDUSERIDCompoundUniqueInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final String reportId;

  @JsonKey(name: r'USER_ID')
  final String userId;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTHTMLTBLREPORTIDUSERIDCompoundUniqueInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLCountOrderByAggregateInput
    implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLCountOrderByAggregateInput({
    this.reportId,
    this.userId,
    this.title,
    this.htmlContent,
    this.regDate,
    this.delYn,
  });

  factory WORKREPORTHTMLTBLCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final SortOrder? reportId;

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'HTML_CONTENT')
  final SortOrder? htmlContent;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTHTMLTBLCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLMaxOrderByAggregateInput
    implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLMaxOrderByAggregateInput({
    this.reportId,
    this.userId,
    this.title,
    this.htmlContent,
    this.regDate,
    this.delYn,
  });

  factory WORKREPORTHTMLTBLMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final SortOrder? reportId;

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'HTML_CONTENT')
  final SortOrder? htmlContent;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTHTMLTBLMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLMinOrderByAggregateInput
    implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLMinOrderByAggregateInput({
    this.reportId,
    this.userId,
    this.title,
    this.htmlContent,
    this.regDate,
    this.delYn,
  });

  factory WORKREPORTHTMLTBLMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final SortOrder? reportId;

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'HTML_CONTENT')
  final SortOrder? htmlContent;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTHTMLTBLMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLBACKREPORTIDUSERIDCompoundUniqueInput
    implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLBACKREPORTIDUSERIDCompoundUniqueInput({
    required this.reportId,
    required this.userId,
  });

  factory WORKREPORTHTMLTBLBACKREPORTIDUSERIDCompoundUniqueInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLBACKREPORTIDUSERIDCompoundUniqueInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final String reportId;

  @JsonKey(name: r'USER_ID')
  final String userId;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTHTMLTBLBACKREPORTIDUSERIDCompoundUniqueInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLBACKCountOrderByAggregateInput
    implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLBACKCountOrderByAggregateInput({
    this.reportId,
    this.userId,
    this.title,
    this.htmlContent,
    this.regDate,
    this.delYn,
  });

  factory WORKREPORTHTMLTBLBACKCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLBACKCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final SortOrder? reportId;

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'HTML_CONTENT')
  final SortOrder? htmlContent;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTHTMLTBLBACKCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLBACKMaxOrderByAggregateInput
    implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLBACKMaxOrderByAggregateInput({
    this.reportId,
    this.userId,
    this.title,
    this.htmlContent,
    this.regDate,
    this.delYn,
  });

  factory WORKREPORTHTMLTBLBACKMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLBACKMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final SortOrder? reportId;

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'HTML_CONTENT')
  final SortOrder? htmlContent;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTHTMLTBLBACKMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLBACKMinOrderByAggregateInput
    implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLBACKMinOrderByAggregateInput({
    this.reportId,
    this.userId,
    this.title,
    this.htmlContent,
    this.regDate,
    this.delYn,
  });

  factory WORKREPORTHTMLTBLBACKMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLBACKMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final SortOrder? reportId;

  @JsonKey(name: r'USER_ID')
  final SortOrder? userId;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'HTML_CONTENT')
  final SortOrder? htmlContent;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTHTMLTBLBACKMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTMASTERTBLCountOrderByAggregateInput
    implements _i1.JsonSerializable {
  const WORKREPORTMASTERTBLCountOrderByAggregateInput({
    this.reportId,
    this.title,
    this.dept,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory WORKREPORTMASTERTBLCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTMASTERTBLCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final SortOrder? reportId;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'DEPT')
  final SortOrder? dept;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTMASTERTBLCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTMASTERTBLMaxOrderByAggregateInput
    implements _i1.JsonSerializable {
  const WORKREPORTMASTERTBLMaxOrderByAggregateInput({
    this.reportId,
    this.title,
    this.dept,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory WORKREPORTMASTERTBLMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTMASTERTBLMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final SortOrder? reportId;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'DEPT')
  final SortOrder? dept;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTMASTERTBLMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTMASTERTBLMinOrderByAggregateInput
    implements _i1.JsonSerializable {
  const WORKREPORTMASTERTBLMinOrderByAggregateInput({
    this.reportId,
    this.title,
    this.dept,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory WORKREPORTMASTERTBLMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTMASTERTBLMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final SortOrder? reportId;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'DEPT')
  final SortOrder? dept;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'UPD_DATE')
  final SortOrder? updDate;

  @JsonKey(name: r'DEL_YN')
  final SortOrder? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTMASTERTBLMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTMSTCountOrderByAggregateInput implements _i1.JsonSerializable {
  const WORKREQUESTMSTCountOrderByAggregateInput({
    this.seq,
    this.rqstrDpnm,
    this.rqstrNm,
    this.rqstrId,
    this.rqstrDate,
    this.hopeDate,
    this.chrDprNm,
    this.chrNm,
    this.chrId,
    this.chrChk,
    this.title,
    this.cn,
    this.etc,
    this.doc,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory WORKREQUESTMSTCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREQUESTMSTCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'RQSTR_DPNM')
  final SortOrder? rqstrDpnm;

  @JsonKey(name: r'RQSTR_NM')
  final SortOrder? rqstrNm;

  @JsonKey(name: r'RQSTR_ID')
  final SortOrder? rqstrId;

  @JsonKey(name: r'RQSTR_DATE')
  final SortOrder? rqstrDate;

  @JsonKey(name: r'HOPE_DATE')
  final SortOrder? hopeDate;

  @JsonKey(name: r'CHR_DPR_NM')
  final SortOrder? chrDprNm;

  @JsonKey(name: r'CHR_NM')
  final SortOrder? chrNm;

  @JsonKey(name: r'CHR_ID')
  final SortOrder? chrId;

  @JsonKey(name: r'CHR_CHK')
  final SortOrder? chrChk;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'CN')
  final SortOrder? cn;

  @JsonKey(name: r'ETC')
  final SortOrder? etc;

  @JsonKey(name: r'DOC')
  final SortOrder? doc;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREQUESTMSTCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTMSTAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const WORKREQUESTMSTAvgOrderByAggregateInput({this.seq});

  factory WORKREQUESTMSTAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREQUESTMSTAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREQUESTMSTAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTMSTMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const WORKREQUESTMSTMaxOrderByAggregateInput({
    this.seq,
    this.rqstrDpnm,
    this.rqstrNm,
    this.rqstrId,
    this.rqstrDate,
    this.hopeDate,
    this.chrDprNm,
    this.chrNm,
    this.chrId,
    this.chrChk,
    this.title,
    this.cn,
    this.etc,
    this.doc,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory WORKREQUESTMSTMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREQUESTMSTMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'RQSTR_DPNM')
  final SortOrder? rqstrDpnm;

  @JsonKey(name: r'RQSTR_NM')
  final SortOrder? rqstrNm;

  @JsonKey(name: r'RQSTR_ID')
  final SortOrder? rqstrId;

  @JsonKey(name: r'RQSTR_DATE')
  final SortOrder? rqstrDate;

  @JsonKey(name: r'HOPE_DATE')
  final SortOrder? hopeDate;

  @JsonKey(name: r'CHR_DPR_NM')
  final SortOrder? chrDprNm;

  @JsonKey(name: r'CHR_NM')
  final SortOrder? chrNm;

  @JsonKey(name: r'CHR_ID')
  final SortOrder? chrId;

  @JsonKey(name: r'CHR_CHK')
  final SortOrder? chrChk;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'CN')
  final SortOrder? cn;

  @JsonKey(name: r'ETC')
  final SortOrder? etc;

  @JsonKey(name: r'DOC')
  final SortOrder? doc;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREQUESTMSTMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTMSTMinOrderByAggregateInput implements _i1.JsonSerializable {
  const WORKREQUESTMSTMinOrderByAggregateInput({
    this.seq,
    this.rqstrDpnm,
    this.rqstrNm,
    this.rqstrId,
    this.rqstrDate,
    this.hopeDate,
    this.chrDprNm,
    this.chrNm,
    this.chrId,
    this.chrChk,
    this.title,
    this.cn,
    this.etc,
    this.doc,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory WORKREQUESTMSTMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREQUESTMSTMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'RQSTR_DPNM')
  final SortOrder? rqstrDpnm;

  @JsonKey(name: r'RQSTR_NM')
  final SortOrder? rqstrNm;

  @JsonKey(name: r'RQSTR_ID')
  final SortOrder? rqstrId;

  @JsonKey(name: r'RQSTR_DATE')
  final SortOrder? rqstrDate;

  @JsonKey(name: r'HOPE_DATE')
  final SortOrder? hopeDate;

  @JsonKey(name: r'CHR_DPR_NM')
  final SortOrder? chrDprNm;

  @JsonKey(name: r'CHR_NM')
  final SortOrder? chrNm;

  @JsonKey(name: r'CHR_ID')
  final SortOrder? chrId;

  @JsonKey(name: r'CHR_CHK')
  final SortOrder? chrChk;

  @JsonKey(name: r'TITLE')
  final SortOrder? title;

  @JsonKey(name: r'CN')
  final SortOrder? cn;

  @JsonKey(name: r'ETC')
  final SortOrder? etc;

  @JsonKey(name: r'DOC')
  final SortOrder? doc;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREQUESTMSTMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTMSTSumOrderByAggregateInput implements _i1.JsonSerializable {
  const WORKREQUESTMSTSumOrderByAggregateInput({this.seq});

  factory WORKREQUESTMSTSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREQUESTMSTSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREQUESTMSTSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTREFCountOrderByAggregateInput implements _i1.JsonSerializable {
  const WORKREQUESTREFCountOrderByAggregateInput({
    this.seq,
    this.mseq,
    this.refId,
    this.refNm,
    this.refDep,
    this.refGrade,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory WORKREQUESTREFCountOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREQUESTREFCountOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'REF_ID')
  final SortOrder? refId;

  @JsonKey(name: r'REF_NM')
  final SortOrder? refNm;

  @JsonKey(name: r'REF_DEP')
  final SortOrder? refDep;

  @JsonKey(name: r'REF_GRADE')
  final SortOrder? refGrade;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREQUESTREFCountOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTREFAvgOrderByAggregateInput implements _i1.JsonSerializable {
  const WORKREQUESTREFAvgOrderByAggregateInput({
    this.seq,
    this.mseq,
  });

  factory WORKREQUESTREFAvgOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREQUESTREFAvgOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREQUESTREFAvgOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTREFMaxOrderByAggregateInput implements _i1.JsonSerializable {
  const WORKREQUESTREFMaxOrderByAggregateInput({
    this.seq,
    this.mseq,
    this.refId,
    this.refNm,
    this.refDep,
    this.refGrade,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory WORKREQUESTREFMaxOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREQUESTREFMaxOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'REF_ID')
  final SortOrder? refId;

  @JsonKey(name: r'REF_NM')
  final SortOrder? refNm;

  @JsonKey(name: r'REF_DEP')
  final SortOrder? refDep;

  @JsonKey(name: r'REF_GRADE')
  final SortOrder? refGrade;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREQUESTREFMaxOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTREFMinOrderByAggregateInput implements _i1.JsonSerializable {
  const WORKREQUESTREFMinOrderByAggregateInput({
    this.seq,
    this.mseq,
    this.refId,
    this.refNm,
    this.refDep,
    this.refGrade,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory WORKREQUESTREFMinOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREQUESTREFMinOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @JsonKey(name: r'REF_ID')
  final SortOrder? refId;

  @JsonKey(name: r'REF_NM')
  final SortOrder? refNm;

  @JsonKey(name: r'REF_DEP')
  final SortOrder? refDep;

  @JsonKey(name: r'REF_GRADE')
  final SortOrder? refGrade;

  @JsonKey(name: r'REG_ID')
  final SortOrder? regId;

  @JsonKey(name: r'REG_DATE')
  final SortOrder? regDate;

  @JsonKey(name: r'EDIT_ID')
  final SortOrder? editId;

  @JsonKey(name: r'EDIT_DATE')
  final SortOrder? editDate;

  @JsonKey(name: r'DEL_ID')
  final SortOrder? delId;

  @JsonKey(name: r'DEL_DATE')
  final SortOrder? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREQUESTREFMinOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTREFSumOrderByAggregateInput implements _i1.JsonSerializable {
  const WORKREQUESTREFSumOrderByAggregateInput({
    this.seq,
    this.mseq,
  });

  factory WORKREQUESTREFSumOrderByAggregateInput.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREQUESTREFSumOrderByAggregateInputFromJson(json);

  @JsonKey(name: r'SEQ')
  final SortOrder? seq;

  @JsonKey(name: r'MSEQ')
  final SortOrder? mseq;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREQUESTREFSumOrderByAggregateInputToJson(this);
}

@_i1.jsonSerializable
class StringFieldUpdateOperationsInput implements _i1.JsonSerializable {
  const StringFieldUpdateOperationsInput({this.set});

  factory StringFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$StringFieldUpdateOperationsInputFromJson(json);

  final String? set;

  @override
  Map<String, dynamic> toJson() =>
      _$StringFieldUpdateOperationsInputToJson(this);
}

@_i1.jsonSerializable
class NullableStringFieldUpdateOperationsInput implements _i1.JsonSerializable {
  const NullableStringFieldUpdateOperationsInput({this.set});

  factory NullableStringFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$NullableStringFieldUpdateOperationsInputFromJson(json);

  final String? set;

  @override
  Map<String, dynamic> toJson() =>
      _$NullableStringFieldUpdateOperationsInputToJson(this);
}

@_i1.jsonSerializable
class NullableIntFieldUpdateOperationsInput implements _i1.JsonSerializable {
  const NullableIntFieldUpdateOperationsInput({
    this.set,
    this.increment,
    this.decrement,
    this.multiply,
    this.divide,
  });

  factory NullableIntFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$NullableIntFieldUpdateOperationsInputFromJson(json);

  final int? set;

  final int? increment;

  final int? decrement;

  final int? multiply;

  final int? divide;

  @override
  Map<String, dynamic> toJson() =>
      _$NullableIntFieldUpdateOperationsInputToJson(this);
}

@_i1.jsonSerializable
class DateTimeFieldUpdateOperationsInput implements _i1.JsonSerializable {
  const DateTimeFieldUpdateOperationsInput({this.set});

  factory DateTimeFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$DateTimeFieldUpdateOperationsInputFromJson(json);

  final DateTime? set;

  @override
  Map<String, dynamic> toJson() =>
      _$DateTimeFieldUpdateOperationsInputToJson(this);
}

@_i1.jsonSerializable
class DecimalFieldUpdateOperationsInput implements _i1.JsonSerializable {
  const DecimalFieldUpdateOperationsInput({
    this.set,
    this.increment,
    this.decrement,
    this.multiply,
    this.divide,
  });

  factory DecimalFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$DecimalFieldUpdateOperationsInputFromJson(json);

  final double? set;

  final double? increment;

  final double? decrement;

  final double? multiply;

  final double? divide;

  @override
  Map<String, dynamic> toJson() =>
      _$DecimalFieldUpdateOperationsInputToJson(this);
}

@_i1.jsonSerializable
class BigIntFieldUpdateOperationsInput implements _i1.JsonSerializable {
  const BigIntFieldUpdateOperationsInput({
    this.set,
    this.increment,
    this.decrement,
    this.multiply,
    this.divide,
  });

  factory BigIntFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$BigIntFieldUpdateOperationsInputFromJson(json);

  final BigInt? set;

  final BigInt? increment;

  final BigInt? decrement;

  final BigInt? multiply;

  final BigInt? divide;

  @override
  Map<String, dynamic> toJson() =>
      _$BigIntFieldUpdateOperationsInputToJson(this);
}

@_i1.jsonSerializable
class NullableDateTimeFieldUpdateOperationsInput
    implements _i1.JsonSerializable {
  const NullableDateTimeFieldUpdateOperationsInput({this.set});

  factory NullableDateTimeFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$NullableDateTimeFieldUpdateOperationsInputFromJson(json);

  final DateTime? set;

  @override
  Map<String, dynamic> toJson() =>
      _$NullableDateTimeFieldUpdateOperationsInputToJson(this);
}

@_i1.jsonSerializable
class IntFieldUpdateOperationsInput implements _i1.JsonSerializable {
  const IntFieldUpdateOperationsInput({
    this.set,
    this.increment,
    this.decrement,
    this.multiply,
    this.divide,
  });

  factory IntFieldUpdateOperationsInput.fromJson(Map<String, dynamic> json) =>
      _$IntFieldUpdateOperationsInputFromJson(json);

  final int? set;

  final int? increment;

  final int? decrement;

  final int? multiply;

  final int? divide;

  @override
  Map<String, dynamic> toJson() => _$IntFieldUpdateOperationsInputToJson(this);
}

@_i1.jsonSerializable
class NullableDecimalFieldUpdateOperationsInput
    implements _i1.JsonSerializable {
  const NullableDecimalFieldUpdateOperationsInput({
    this.set,
    this.increment,
    this.decrement,
    this.multiply,
    this.divide,
  });

  factory NullableDecimalFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$NullableDecimalFieldUpdateOperationsInputFromJson(json);

  final double? set;

  final double? increment;

  final double? decrement;

  final double? multiply;

  final double? divide;

  @override
  Map<String, dynamic> toJson() =>
      _$NullableDecimalFieldUpdateOperationsInputToJson(this);
}

@_i1.jsonSerializable
class NullableBigIntFieldUpdateOperationsInput implements _i1.JsonSerializable {
  const NullableBigIntFieldUpdateOperationsInput({
    this.set,
    this.increment,
    this.decrement,
    this.multiply,
    this.divide,
  });

  factory NullableBigIntFieldUpdateOperationsInput.fromJson(
          Map<String, dynamic> json) =>
      _$NullableBigIntFieldUpdateOperationsInputFromJson(json);

  final BigInt? set;

  final BigInt? increment;

  final BigInt? decrement;

  final BigInt? multiply;

  final BigInt? divide;

  @override
  Map<String, dynamic> toJson() =>
      _$NullableBigIntFieldUpdateOperationsInputToJson(this);
}

@_i1.jsonSerializable
class MENUTBLCreateNestedManyWithoutMEMBERTBLInput
    implements _i1.JsonSerializable {
  const MENUTBLCreateNestedManyWithoutMEMBERTBLInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory MENUTBLCreateNestedManyWithoutMEMBERTBLInput.fromJson(
          Map<String, dynamic> json) =>
      _$MENUTBLCreateNestedManyWithoutMEMBERTBLInputFromJson(json);

  final Iterable<MENUTBLCreateWithoutMEMBERTBLInput>? create;

  final Iterable<MENUTBLCreateOrConnectWithoutMEMBERTBLInput>? connectOrCreate;

  final MENUTBLCreateManyMEMBERTBLInputEnvelope? createMany;

  final Iterable<MENUTBLWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUTBLCreateNestedManyWithoutMEMBERTBLInputToJson(this);
}

@_i1.jsonSerializable
class MENUTBLUncheckedCreateNestedManyWithoutMEMBERTBLInput
    implements _i1.JsonSerializable {
  const MENUTBLUncheckedCreateNestedManyWithoutMEMBERTBLInput({
    this.create,
    this.connectOrCreate,
    this.createMany,
    this.connect,
  });

  factory MENUTBLUncheckedCreateNestedManyWithoutMEMBERTBLInput.fromJson(
          Map<String, dynamic> json) =>
      _$MENUTBLUncheckedCreateNestedManyWithoutMEMBERTBLInputFromJson(json);

  final Iterable<MENUTBLCreateWithoutMEMBERTBLInput>? create;

  final Iterable<MENUTBLCreateOrConnectWithoutMEMBERTBLInput>? connectOrCreate;

  final MENUTBLCreateManyMEMBERTBLInputEnvelope? createMany;

  final Iterable<MENUTBLWhereUniqueInput>? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUTBLUncheckedCreateNestedManyWithoutMEMBERTBLInputToJson(this);
}

@_i1.jsonSerializable
class MENUTBLUpdateManyWithoutMEMBERTBLNestedInput
    implements _i1.JsonSerializable {
  const MENUTBLUpdateManyWithoutMEMBERTBLNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory MENUTBLUpdateManyWithoutMEMBERTBLNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$MENUTBLUpdateManyWithoutMEMBERTBLNestedInputFromJson(json);

  final Iterable<MENUTBLCreateWithoutMEMBERTBLInput>? create;

  final Iterable<MENUTBLCreateOrConnectWithoutMEMBERTBLInput>? connectOrCreate;

  final Iterable<MENUTBLUpsertWithWhereUniqueWithoutMEMBERTBLInput>? upsert;

  final MENUTBLCreateManyMEMBERTBLInputEnvelope? createMany;

  final Iterable<MENUTBLWhereUniqueInput>? set;

  final Iterable<MENUTBLWhereUniqueInput>? disconnect;

  final Iterable<MENUTBLWhereUniqueInput>? delete;

  final Iterable<MENUTBLWhereUniqueInput>? connect;

  final Iterable<MENUTBLUpdateWithWhereUniqueWithoutMEMBERTBLInput>? update;

  final Iterable<MENUTBLUpdateManyWithWhereWithoutMEMBERTBLInput>? updateMany;

  final Iterable<MENUTBLScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUTBLUpdateManyWithoutMEMBERTBLNestedInputToJson(this);
}

@_i1.jsonSerializable
class MENUTBLUncheckedUpdateManyWithoutMEMBERTBLNestedInput
    implements _i1.JsonSerializable {
  const MENUTBLUncheckedUpdateManyWithoutMEMBERTBLNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.createMany,
    this.set,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
    this.updateMany,
    this.deleteMany,
  });

  factory MENUTBLUncheckedUpdateManyWithoutMEMBERTBLNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$MENUTBLUncheckedUpdateManyWithoutMEMBERTBLNestedInputFromJson(json);

  final Iterable<MENUTBLCreateWithoutMEMBERTBLInput>? create;

  final Iterable<MENUTBLCreateOrConnectWithoutMEMBERTBLInput>? connectOrCreate;

  final Iterable<MENUTBLUpsertWithWhereUniqueWithoutMEMBERTBLInput>? upsert;

  final MENUTBLCreateManyMEMBERTBLInputEnvelope? createMany;

  final Iterable<MENUTBLWhereUniqueInput>? set;

  final Iterable<MENUTBLWhereUniqueInput>? disconnect;

  final Iterable<MENUTBLWhereUniqueInput>? delete;

  final Iterable<MENUTBLWhereUniqueInput>? connect;

  final Iterable<MENUTBLUpdateWithWhereUniqueWithoutMEMBERTBLInput>? update;

  final Iterable<MENUTBLUpdateManyWithWhereWithoutMEMBERTBLInput>? updateMany;

  final Iterable<MENUTBLScalarWhereInput>? deleteMany;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUTBLUncheckedUpdateManyWithoutMEMBERTBLNestedInputToJson(this);
}

@_i1.jsonSerializable
class MEMBERTBLCreateNestedOneWithoutMENUTBLInput
    implements _i1.JsonSerializable {
  const MEMBERTBLCreateNestedOneWithoutMENUTBLInput({
    this.create,
    this.connectOrCreate,
    this.connect,
  });

  factory MEMBERTBLCreateNestedOneWithoutMENUTBLInput.fromJson(
          Map<String, dynamic> json) =>
      _$MEMBERTBLCreateNestedOneWithoutMENUTBLInputFromJson(json);

  final MEMBERTBLCreateWithoutMENUTBLInput? create;

  final MEMBERTBLCreateOrConnectWithoutMENUTBLInput? connectOrCreate;

  final MEMBERTBLWhereUniqueInput? connect;

  @override
  Map<String, dynamic> toJson() =>
      _$MEMBERTBLCreateNestedOneWithoutMENUTBLInputToJson(this);
}

@_i1.jsonSerializable
class MEMBERTBLUpdateOneWithoutMENUTBLNestedInput
    implements _i1.JsonSerializable {
  const MEMBERTBLUpdateOneWithoutMENUTBLNestedInput({
    this.create,
    this.connectOrCreate,
    this.upsert,
    this.disconnect,
    this.delete,
    this.connect,
    this.update,
  });

  factory MEMBERTBLUpdateOneWithoutMENUTBLNestedInput.fromJson(
          Map<String, dynamic> json) =>
      _$MEMBERTBLUpdateOneWithoutMENUTBLNestedInputFromJson(json);

  final MEMBERTBLCreateWithoutMENUTBLInput? create;

  final MEMBERTBLCreateOrConnectWithoutMENUTBLInput? connectOrCreate;

  final MEMBERTBLUpsertWithoutMENUTBLInput? upsert;

  final bool? disconnect;

  final bool? delete;

  final MEMBERTBLWhereUniqueInput? connect;

  final MEMBERTBLUpdateWithoutMENUTBLInput? update;

  @override
  Map<String, dynamic> toJson() =>
      _$MEMBERTBLUpdateOneWithoutMENUTBLNestedInputToJson(this);
}

@_i1.jsonSerializable
class NestedStringFilter implements _i1.JsonSerializable {
  const NestedStringFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
  });

  factory NestedStringFilter.fromJson(Map<String, dynamic> json) =>
      _$NestedStringFilterFromJson(json);

  final String? equals;

  @JsonKey(name: r'in')
  final Iterable<String>? $in;

  final Iterable<String>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  final NestedStringFilter? not;

  @override
  Map<String, dynamic> toJson() => _$NestedStringFilterToJson(this);
}

@_i1.jsonSerializable
class NestedStringNullableFilter implements _i1.JsonSerializable {
  const NestedStringNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
  });

  factory NestedStringNullableFilter.fromJson(Map<String, dynamic> json) =>
      _$NestedStringNullableFilterFromJson(json);

  final String? equals;

  @JsonKey(name: r'in')
  final Iterable<String>? $in;

  final Iterable<String>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  final NestedStringNullableFilter? not;

  @override
  Map<String, dynamic> toJson() => _$NestedStringNullableFilterToJson(this);
}

@_i1.jsonSerializable
class NestedIntNullableFilter implements _i1.JsonSerializable {
  const NestedIntNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  factory NestedIntNullableFilter.fromJson(Map<String, dynamic> json) =>
      _$NestedIntNullableFilterFromJson(json);

  final int? equals;

  @JsonKey(name: r'in')
  final Iterable<int>? $in;

  final Iterable<int>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final NestedIntNullableFilter? not;

  @override
  Map<String, dynamic> toJson() => _$NestedIntNullableFilterToJson(this);
}

@_i1.jsonSerializable
class NestedDateTimeFilter implements _i1.JsonSerializable {
  const NestedDateTimeFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  factory NestedDateTimeFilter.fromJson(Map<String, dynamic> json) =>
      _$NestedDateTimeFilterFromJson(json);

  final DateTime? equals;

  @JsonKey(name: r'in')
  final Iterable<DateTime>? $in;

  final Iterable<DateTime>? notIn;

  final DateTime? lt;

  final DateTime? lte;

  final DateTime? gt;

  final DateTime? gte;

  final NestedDateTimeFilter? not;

  @override
  Map<String, dynamic> toJson() => _$NestedDateTimeFilterToJson(this);
}

@_i1.jsonSerializable
class NestedStringWithAggregatesFilter implements _i1.JsonSerializable {
  const NestedStringWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  factory NestedStringWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$NestedStringWithAggregatesFilterFromJson(json);

  final String? equals;

  @JsonKey(name: r'in')
  final Iterable<String>? $in;

  final Iterable<String>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  final NestedStringWithAggregatesFilter? not;

  @JsonKey(name: r'_count')
  final NestedIntFilter? $count;

  @JsonKey(name: r'_min')
  final NestedStringFilter? $min;

  @JsonKey(name: r'_max')
  final NestedStringFilter? $max;

  @override
  Map<String, dynamic> toJson() =>
      _$NestedStringWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class NestedIntFilter implements _i1.JsonSerializable {
  const NestedIntFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  factory NestedIntFilter.fromJson(Map<String, dynamic> json) =>
      _$NestedIntFilterFromJson(json);

  final int? equals;

  @JsonKey(name: r'in')
  final Iterable<int>? $in;

  final Iterable<int>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final NestedIntFilter? not;

  @override
  Map<String, dynamic> toJson() => _$NestedIntFilterToJson(this);
}

@_i1.jsonSerializable
class NestedStringNullableWithAggregatesFilter implements _i1.JsonSerializable {
  const NestedStringNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  factory NestedStringNullableWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$NestedStringNullableWithAggregatesFilterFromJson(json);

  final String? equals;

  @JsonKey(name: r'in')
  final Iterable<String>? $in;

  final Iterable<String>? notIn;

  final String? lt;

  final String? lte;

  final String? gt;

  final String? gte;

  final String? contains;

  final String? startsWith;

  final String? endsWith;

  final NestedStringNullableWithAggregatesFilter? not;

  @JsonKey(name: r'_count')
  final NestedIntNullableFilter? $count;

  @JsonKey(name: r'_min')
  final NestedStringNullableFilter? $min;

  @JsonKey(name: r'_max')
  final NestedStringNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() =>
      _$NestedStringNullableWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class NestedIntNullableWithAggregatesFilter implements _i1.JsonSerializable {
  const NestedIntNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory NestedIntNullableWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$NestedIntNullableWithAggregatesFilterFromJson(json);

  final int? equals;

  @JsonKey(name: r'in')
  final Iterable<int>? $in;

  final Iterable<int>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final NestedIntNullableWithAggregatesFilter? not;

  @JsonKey(name: r'_count')
  final NestedIntNullableFilter? $count;

  @JsonKey(name: r'_avg')
  final NestedFloatNullableFilter? $avg;

  @JsonKey(name: r'_sum')
  final NestedIntNullableFilter? $sum;

  @JsonKey(name: r'_min')
  final NestedIntNullableFilter? $min;

  @JsonKey(name: r'_max')
  final NestedIntNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() =>
      _$NestedIntNullableWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class NestedFloatNullableFilter implements _i1.JsonSerializable {
  const NestedFloatNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  factory NestedFloatNullableFilter.fromJson(Map<String, dynamic> json) =>
      _$NestedFloatNullableFilterFromJson(json);

  final double? equals;

  @JsonKey(name: r'in')
  final Iterable<double>? $in;

  final Iterable<double>? notIn;

  final double? lt;

  final double? lte;

  final double? gt;

  final double? gte;

  final NestedFloatNullableFilter? not;

  @override
  Map<String, dynamic> toJson() => _$NestedFloatNullableFilterToJson(this);
}

@_i1.jsonSerializable
class NestedDateTimeWithAggregatesFilter implements _i1.JsonSerializable {
  const NestedDateTimeWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  factory NestedDateTimeWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$NestedDateTimeWithAggregatesFilterFromJson(json);

  final DateTime? equals;

  @JsonKey(name: r'in')
  final Iterable<DateTime>? $in;

  final Iterable<DateTime>? notIn;

  final DateTime? lt;

  final DateTime? lte;

  final DateTime? gt;

  final DateTime? gte;

  final NestedDateTimeWithAggregatesFilter? not;

  @JsonKey(name: r'_count')
  final NestedIntFilter? $count;

  @JsonKey(name: r'_min')
  final NestedDateTimeFilter? $min;

  @JsonKey(name: r'_max')
  final NestedDateTimeFilter? $max;

  @override
  Map<String, dynamic> toJson() =>
      _$NestedDateTimeWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class NestedDecimalFilter implements _i1.JsonSerializable {
  const NestedDecimalFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  factory NestedDecimalFilter.fromJson(Map<String, dynamic> json) =>
      _$NestedDecimalFilterFromJson(json);

  final double? equals;

  @JsonKey(name: r'in')
  final Iterable<double>? $in;

  final Iterable<double>? notIn;

  final double? lt;

  final double? lte;

  final double? gt;

  final double? gte;

  final NestedDecimalFilter? not;

  @override
  Map<String, dynamic> toJson() => _$NestedDecimalFilterToJson(this);
}

@_i1.jsonSerializable
class NestedDecimalWithAggregatesFilter implements _i1.JsonSerializable {
  const NestedDecimalWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory NestedDecimalWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$NestedDecimalWithAggregatesFilterFromJson(json);

  final double? equals;

  @JsonKey(name: r'in')
  final Iterable<double>? $in;

  final Iterable<double>? notIn;

  final double? lt;

  final double? lte;

  final double? gt;

  final double? gte;

  final NestedDecimalWithAggregatesFilter? not;

  @JsonKey(name: r'_count')
  final NestedIntFilter? $count;

  @JsonKey(name: r'_avg')
  final NestedDecimalFilter? $avg;

  @JsonKey(name: r'_sum')
  final NestedDecimalFilter? $sum;

  @JsonKey(name: r'_min')
  final NestedDecimalFilter? $min;

  @JsonKey(name: r'_max')
  final NestedDecimalFilter? $max;

  @override
  Map<String, dynamic> toJson() =>
      _$NestedDecimalWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class NestedBigIntFilter implements _i1.JsonSerializable {
  const NestedBigIntFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  factory NestedBigIntFilter.fromJson(Map<String, dynamic> json) =>
      _$NestedBigIntFilterFromJson(json);

  final BigInt? equals;

  @JsonKey(name: r'in')
  final Iterable<BigInt>? $in;

  final Iterable<BigInt>? notIn;

  final BigInt? lt;

  final BigInt? lte;

  final BigInt? gt;

  final BigInt? gte;

  final NestedBigIntFilter? not;

  @override
  Map<String, dynamic> toJson() => _$NestedBigIntFilterToJson(this);
}

@_i1.jsonSerializable
class NestedDateTimeNullableFilter implements _i1.JsonSerializable {
  const NestedDateTimeNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  factory NestedDateTimeNullableFilter.fromJson(Map<String, dynamic> json) =>
      _$NestedDateTimeNullableFilterFromJson(json);

  final DateTime? equals;

  @JsonKey(name: r'in')
  final Iterable<DateTime>? $in;

  final Iterable<DateTime>? notIn;

  final DateTime? lt;

  final DateTime? lte;

  final DateTime? gt;

  final DateTime? gte;

  final NestedDateTimeNullableFilter? not;

  @override
  Map<String, dynamic> toJson() => _$NestedDateTimeNullableFilterToJson(this);
}

@_i1.jsonSerializable
class NestedBigIntWithAggregatesFilter implements _i1.JsonSerializable {
  const NestedBigIntWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory NestedBigIntWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$NestedBigIntWithAggregatesFilterFromJson(json);

  final BigInt? equals;

  @JsonKey(name: r'in')
  final Iterable<BigInt>? $in;

  final Iterable<BigInt>? notIn;

  final BigInt? lt;

  final BigInt? lte;

  final BigInt? gt;

  final BigInt? gte;

  final NestedBigIntWithAggregatesFilter? not;

  @JsonKey(name: r'_count')
  final NestedIntFilter? $count;

  @JsonKey(name: r'_avg')
  final NestedFloatFilter? $avg;

  @JsonKey(name: r'_sum')
  final NestedBigIntFilter? $sum;

  @JsonKey(name: r'_min')
  final NestedBigIntFilter? $min;

  @JsonKey(name: r'_max')
  final NestedBigIntFilter? $max;

  @override
  Map<String, dynamic> toJson() =>
      _$NestedBigIntWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class NestedFloatFilter implements _i1.JsonSerializable {
  const NestedFloatFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  factory NestedFloatFilter.fromJson(Map<String, dynamic> json) =>
      _$NestedFloatFilterFromJson(json);

  final double? equals;

  @JsonKey(name: r'in')
  final Iterable<double>? $in;

  final Iterable<double>? notIn;

  final double? lt;

  final double? lte;

  final double? gt;

  final double? gte;

  final NestedFloatFilter? not;

  @override
  Map<String, dynamic> toJson() => _$NestedFloatFilterToJson(this);
}

@_i1.jsonSerializable
class NestedDateTimeNullableWithAggregatesFilter
    implements _i1.JsonSerializable {
  const NestedDateTimeNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  factory NestedDateTimeNullableWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$NestedDateTimeNullableWithAggregatesFilterFromJson(json);

  final DateTime? equals;

  @JsonKey(name: r'in')
  final Iterable<DateTime>? $in;

  final Iterable<DateTime>? notIn;

  final DateTime? lt;

  final DateTime? lte;

  final DateTime? gt;

  final DateTime? gte;

  final NestedDateTimeNullableWithAggregatesFilter? not;

  @JsonKey(name: r'_count')
  final NestedIntNullableFilter? $count;

  @JsonKey(name: r'_min')
  final NestedDateTimeNullableFilter? $min;

  @JsonKey(name: r'_max')
  final NestedDateTimeNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() =>
      _$NestedDateTimeNullableWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class NestedIntWithAggregatesFilter implements _i1.JsonSerializable {
  const NestedIntWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory NestedIntWithAggregatesFilter.fromJson(Map<String, dynamic> json) =>
      _$NestedIntWithAggregatesFilterFromJson(json);

  final int? equals;

  @JsonKey(name: r'in')
  final Iterable<int>? $in;

  final Iterable<int>? notIn;

  final int? lt;

  final int? lte;

  final int? gt;

  final int? gte;

  final NestedIntWithAggregatesFilter? not;

  @JsonKey(name: r'_count')
  final NestedIntFilter? $count;

  @JsonKey(name: r'_avg')
  final NestedFloatFilter? $avg;

  @JsonKey(name: r'_sum')
  final NestedIntFilter? $sum;

  @JsonKey(name: r'_min')
  final NestedIntFilter? $min;

  @JsonKey(name: r'_max')
  final NestedIntFilter? $max;

  @override
  Map<String, dynamic> toJson() => _$NestedIntWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class NestedDecimalNullableFilter implements _i1.JsonSerializable {
  const NestedDecimalNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  factory NestedDecimalNullableFilter.fromJson(Map<String, dynamic> json) =>
      _$NestedDecimalNullableFilterFromJson(json);

  final double? equals;

  @JsonKey(name: r'in')
  final Iterable<double>? $in;

  final Iterable<double>? notIn;

  final double? lt;

  final double? lte;

  final double? gt;

  final double? gte;

  final NestedDecimalNullableFilter? not;

  @override
  Map<String, dynamic> toJson() => _$NestedDecimalNullableFilterToJson(this);
}

@_i1.jsonSerializable
class NestedDecimalNullableWithAggregatesFilter
    implements _i1.JsonSerializable {
  const NestedDecimalNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory NestedDecimalNullableWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$NestedDecimalNullableWithAggregatesFilterFromJson(json);

  final double? equals;

  @JsonKey(name: r'in')
  final Iterable<double>? $in;

  final Iterable<double>? notIn;

  final double? lt;

  final double? lte;

  final double? gt;

  final double? gte;

  final NestedDecimalNullableWithAggregatesFilter? not;

  @JsonKey(name: r'_count')
  final NestedIntNullableFilter? $count;

  @JsonKey(name: r'_avg')
  final NestedDecimalNullableFilter? $avg;

  @JsonKey(name: r'_sum')
  final NestedDecimalNullableFilter? $sum;

  @JsonKey(name: r'_min')
  final NestedDecimalNullableFilter? $min;

  @JsonKey(name: r'_max')
  final NestedDecimalNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() =>
      _$NestedDecimalNullableWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class NestedBigIntNullableFilter implements _i1.JsonSerializable {
  const NestedBigIntNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  factory NestedBigIntNullableFilter.fromJson(Map<String, dynamic> json) =>
      _$NestedBigIntNullableFilterFromJson(json);

  final BigInt? equals;

  @JsonKey(name: r'in')
  final Iterable<BigInt>? $in;

  final Iterable<BigInt>? notIn;

  final BigInt? lt;

  final BigInt? lte;

  final BigInt? gt;

  final BigInt? gte;

  final NestedBigIntNullableFilter? not;

  @override
  Map<String, dynamic> toJson() => _$NestedBigIntNullableFilterToJson(this);
}

@_i1.jsonSerializable
class NestedBigIntNullableWithAggregatesFilter implements _i1.JsonSerializable {
  const NestedBigIntNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory NestedBigIntNullableWithAggregatesFilter.fromJson(
          Map<String, dynamic> json) =>
      _$NestedBigIntNullableWithAggregatesFilterFromJson(json);

  final BigInt? equals;

  @JsonKey(name: r'in')
  final Iterable<BigInt>? $in;

  final Iterable<BigInt>? notIn;

  final BigInt? lt;

  final BigInt? lte;

  final BigInt? gt;

  final BigInt? gte;

  final NestedBigIntNullableWithAggregatesFilter? not;

  @JsonKey(name: r'_count')
  final NestedIntNullableFilter? $count;

  @JsonKey(name: r'_avg')
  final NestedFloatNullableFilter? $avg;

  @JsonKey(name: r'_sum')
  final NestedBigIntNullableFilter? $sum;

  @JsonKey(name: r'_min')
  final NestedBigIntNullableFilter? $min;

  @JsonKey(name: r'_max')
  final NestedBigIntNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() =>
      _$NestedBigIntNullableWithAggregatesFilterToJson(this);
}

@_i1.jsonSerializable
class MENUTBLCreateWithoutMEMBERTBLInput implements _i1.JsonSerializable {
  const MENUTBLCreateWithoutMEMBERTBLInput({
    required this.menuId,
    required this.menuNm,
    required this.depth,
    required this.sort,
    this.ownerId,
    this.url,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
    this.dispYn,
    this.menuIcon,
  });

  factory MENUTBLCreateWithoutMEMBERTBLInput.fromJson(
          Map<String, dynamic> json) =>
      _$MENUTBLCreateWithoutMEMBERTBLInputFromJson(json);

  @JsonKey(name: r'MENU_ID')
  final String menuId;

  @JsonKey(name: r'MENU_NM')
  final String menuNm;

  @JsonKey(name: r'DEPTH')
  final int depth;

  @JsonKey(name: r'SORT')
  final int sort;

  @JsonKey(name: r'OWNER_ID')
  final String? ownerId;

  @JsonKey(name: r'URL')
  final String? url;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'DISP_YN')
  final String? dispYn;

  @JsonKey(name: r'MENU_ICON')
  final String? menuIcon;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUTBLCreateWithoutMEMBERTBLInputToJson(this);
}

@_i1.jsonSerializable
class MENUTBLUncheckedCreateWithoutMEMBERTBLInput
    implements _i1.JsonSerializable {
  const MENUTBLUncheckedCreateWithoutMEMBERTBLInput({
    required this.menuId,
    required this.menuNm,
    required this.depth,
    required this.sort,
    this.ownerId,
    this.url,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
    this.dispYn,
    this.menuIcon,
  });

  factory MENUTBLUncheckedCreateWithoutMEMBERTBLInput.fromJson(
          Map<String, dynamic> json) =>
      _$MENUTBLUncheckedCreateWithoutMEMBERTBLInputFromJson(json);

  @JsonKey(name: r'MENU_ID')
  final String menuId;

  @JsonKey(name: r'MENU_NM')
  final String menuNm;

  @JsonKey(name: r'DEPTH')
  final int depth;

  @JsonKey(name: r'SORT')
  final int sort;

  @JsonKey(name: r'OWNER_ID')
  final String? ownerId;

  @JsonKey(name: r'URL')
  final String? url;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'DISP_YN')
  final String? dispYn;

  @JsonKey(name: r'MENU_ICON')
  final String? menuIcon;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUTBLUncheckedCreateWithoutMEMBERTBLInputToJson(this);
}

@_i1.jsonSerializable
class MENUTBLCreateOrConnectWithoutMEMBERTBLInput
    implements _i1.JsonSerializable {
  const MENUTBLCreateOrConnectWithoutMEMBERTBLInput({
    required this.where,
    required this.create,
  });

  factory MENUTBLCreateOrConnectWithoutMEMBERTBLInput.fromJson(
          Map<String, dynamic> json) =>
      _$MENUTBLCreateOrConnectWithoutMEMBERTBLInputFromJson(json);

  final MENUTBLWhereUniqueInput where;

  final MENUTBLCreateWithoutMEMBERTBLInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUTBLCreateOrConnectWithoutMEMBERTBLInputToJson(this);
}

@_i1.jsonSerializable
class MENUTBLCreateManyMEMBERTBLInputEnvelope implements _i1.JsonSerializable {
  const MENUTBLCreateManyMEMBERTBLInputEnvelope({
    required this.data,
    this.skipDuplicates,
  });

  factory MENUTBLCreateManyMEMBERTBLInputEnvelope.fromJson(
          Map<String, dynamic> json) =>
      _$MENUTBLCreateManyMEMBERTBLInputEnvelopeFromJson(json);

  final Iterable<MENUTBLCreateManyMEMBERTBLInput> data;

  final bool? skipDuplicates;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUTBLCreateManyMEMBERTBLInputEnvelopeToJson(this);
}

@_i1.jsonSerializable
class MENUTBLUpsertWithWhereUniqueWithoutMEMBERTBLInput
    implements _i1.JsonSerializable {
  const MENUTBLUpsertWithWhereUniqueWithoutMEMBERTBLInput({
    required this.where,
    required this.update,
    required this.create,
  });

  factory MENUTBLUpsertWithWhereUniqueWithoutMEMBERTBLInput.fromJson(
          Map<String, dynamic> json) =>
      _$MENUTBLUpsertWithWhereUniqueWithoutMEMBERTBLInputFromJson(json);

  final MENUTBLWhereUniqueInput where;

  final MENUTBLUpdateWithoutMEMBERTBLInput update;

  final MENUTBLCreateWithoutMEMBERTBLInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUTBLUpsertWithWhereUniqueWithoutMEMBERTBLInputToJson(this);
}

@_i1.jsonSerializable
class MENUTBLUpdateWithWhereUniqueWithoutMEMBERTBLInput
    implements _i1.JsonSerializable {
  const MENUTBLUpdateWithWhereUniqueWithoutMEMBERTBLInput({
    required this.where,
    required this.data,
  });

  factory MENUTBLUpdateWithWhereUniqueWithoutMEMBERTBLInput.fromJson(
          Map<String, dynamic> json) =>
      _$MENUTBLUpdateWithWhereUniqueWithoutMEMBERTBLInputFromJson(json);

  final MENUTBLWhereUniqueInput where;

  final MENUTBLUpdateWithoutMEMBERTBLInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUTBLUpdateWithWhereUniqueWithoutMEMBERTBLInputToJson(this);
}

@_i1.jsonSerializable
class MENUTBLUpdateManyWithWhereWithoutMEMBERTBLInput
    implements _i1.JsonSerializable {
  const MENUTBLUpdateManyWithWhereWithoutMEMBERTBLInput({
    required this.where,
    required this.data,
  });

  factory MENUTBLUpdateManyWithWhereWithoutMEMBERTBLInput.fromJson(
          Map<String, dynamic> json) =>
      _$MENUTBLUpdateManyWithWhereWithoutMEMBERTBLInputFromJson(json);

  final MENUTBLScalarWhereInput where;

  final MENUTBLUpdateManyMutationInput data;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUTBLUpdateManyWithWhereWithoutMEMBERTBLInputToJson(this);
}

@_i1.jsonSerializable
class MENUTBLScalarWhereInput implements _i1.JsonSerializable {
  const MENUTBLScalarWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.menuId,
    this.menuNm,
    this.depth,
    this.sort,
    this.ownerId,
    this.url,
    this.writerId,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
    this.dispYn,
    this.menuIcon,
  });

  factory MENUTBLScalarWhereInput.fromJson(Map<String, dynamic> json) =>
      _$MENUTBLScalarWhereInputFromJson(json);

  final Iterable<MENUTBLScalarWhereInput>? AND;

  final Iterable<MENUTBLScalarWhereInput>? OR;

  final Iterable<MENUTBLScalarWhereInput>? NOT;

  @JsonKey(name: r'MENU_ID')
  final StringFilter? menuId;

  @JsonKey(name: r'MENU_NM')
  final StringFilter? menuNm;

  @JsonKey(name: r'DEPTH')
  final IntFilter? depth;

  @JsonKey(name: r'SORT')
  final IntFilter? sort;

  @JsonKey(name: r'OWNER_ID')
  final StringNullableFilter? ownerId;

  @JsonKey(name: r'URL')
  final StringNullableFilter? url;

  @JsonKey(name: r'WRITER_ID')
  final StringNullableFilter? writerId;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFilter? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTimeNullableFilter? updDate;

  @JsonKey(name: r'USE_YN')
  final StringNullableFilter? useYn;

  @JsonKey(name: r'DEL_YN')
  final StringNullableFilter? delYn;

  @JsonKey(name: r'DISP_YN')
  final StringNullableFilter? dispYn;

  @JsonKey(name: r'MENU_ICON')
  final StringNullableFilter? menuIcon;

  @override
  Map<String, dynamic> toJson() => _$MENUTBLScalarWhereInputToJson(this);
}

@_i1.jsonSerializable
class MEMBERTBLCreateWithoutMENUTBLInput implements _i1.JsonSerializable {
  const MEMBERTBLCreateWithoutMENUTBLInput({
    required this.userId,
    required this.passwd,
    required this.userNm,
    this.dept,
    this.grade,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
    this.lastLoginDate,
    this.memo,
  });

  factory MEMBERTBLCreateWithoutMENUTBLInput.fromJson(
          Map<String, dynamic> json) =>
      _$MEMBERTBLCreateWithoutMENUTBLInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'PASSWD')
  final String passwd;

  @JsonKey(name: r'USER_NM')
  final String userNm;

  @JsonKey(name: r'DEPT')
  final String? dept;

  @JsonKey(name: r'GRADE')
  final String? grade;

  @JsonKey(name: r'JOIN_DATE')
  final DateTime? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final DateTime? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final DateTime? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final int? pwdWrongCnt;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'LAST_LOGIN_DATE')
  final DateTime? lastLoginDate;

  @JsonKey(name: r'MEMO')
  final String? memo;

  @override
  Map<String, dynamic> toJson() =>
      _$MEMBERTBLCreateWithoutMENUTBLInputToJson(this);
}

@_i1.jsonSerializable
class MEMBERTBLUncheckedCreateWithoutMENUTBLInput
    implements _i1.JsonSerializable {
  const MEMBERTBLUncheckedCreateWithoutMENUTBLInput({
    required this.userId,
    required this.passwd,
    required this.userNm,
    this.dept,
    this.grade,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
    this.lastLoginDate,
    this.memo,
  });

  factory MEMBERTBLUncheckedCreateWithoutMENUTBLInput.fromJson(
          Map<String, dynamic> json) =>
      _$MEMBERTBLUncheckedCreateWithoutMENUTBLInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'PASSWD')
  final String passwd;

  @JsonKey(name: r'USER_NM')
  final String userNm;

  @JsonKey(name: r'DEPT')
  final String? dept;

  @JsonKey(name: r'GRADE')
  final String? grade;

  @JsonKey(name: r'JOIN_DATE')
  final DateTime? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final DateTime? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final DateTime? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final int? pwdWrongCnt;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'LAST_LOGIN_DATE')
  final DateTime? lastLoginDate;

  @JsonKey(name: r'MEMO')
  final String? memo;

  @override
  Map<String, dynamic> toJson() =>
      _$MEMBERTBLUncheckedCreateWithoutMENUTBLInputToJson(this);
}

@_i1.jsonSerializable
class MEMBERTBLCreateOrConnectWithoutMENUTBLInput
    implements _i1.JsonSerializable {
  const MEMBERTBLCreateOrConnectWithoutMENUTBLInput({
    required this.where,
    required this.create,
  });

  factory MEMBERTBLCreateOrConnectWithoutMENUTBLInput.fromJson(
          Map<String, dynamic> json) =>
      _$MEMBERTBLCreateOrConnectWithoutMENUTBLInputFromJson(json);

  final MEMBERTBLWhereUniqueInput where;

  final MEMBERTBLCreateWithoutMENUTBLInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$MEMBERTBLCreateOrConnectWithoutMENUTBLInputToJson(this);
}

@_i1.jsonSerializable
class MEMBERTBLUpsertWithoutMENUTBLInput implements _i1.JsonSerializable {
  const MEMBERTBLUpsertWithoutMENUTBLInput({
    required this.update,
    required this.create,
  });

  factory MEMBERTBLUpsertWithoutMENUTBLInput.fromJson(
          Map<String, dynamic> json) =>
      _$MEMBERTBLUpsertWithoutMENUTBLInputFromJson(json);

  final MEMBERTBLUpdateWithoutMENUTBLInput update;

  final MEMBERTBLCreateWithoutMENUTBLInput create;

  @override
  Map<String, dynamic> toJson() =>
      _$MEMBERTBLUpsertWithoutMENUTBLInputToJson(this);
}

@_i1.jsonSerializable
class MEMBERTBLUpdateWithoutMENUTBLInput implements _i1.JsonSerializable {
  const MEMBERTBLUpdateWithoutMENUTBLInput({
    this.userId,
    this.passwd,
    this.userNm,
    this.dept,
    this.grade,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
    this.lastLoginDate,
    this.memo,
  });

  factory MEMBERTBLUpdateWithoutMENUTBLInput.fromJson(
          Map<String, dynamic> json) =>
      _$MEMBERTBLUpdateWithoutMENUTBLInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'PASSWD')
  final StringFieldUpdateOperationsInput? passwd;

  @JsonKey(name: r'USER_NM')
  final StringFieldUpdateOperationsInput? userNm;

  @JsonKey(name: r'DEPT')
  final NullableStringFieldUpdateOperationsInput? dept;

  @JsonKey(name: r'GRADE')
  final NullableStringFieldUpdateOperationsInput? grade;

  @JsonKey(name: r'JOIN_DATE')
  final DateTimeFieldUpdateOperationsInput? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final DateTimeFieldUpdateOperationsInput? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final DateTimeFieldUpdateOperationsInput? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final NullableIntFieldUpdateOperationsInput? pwdWrongCnt;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'LAST_LOGIN_DATE')
  final DateTimeFieldUpdateOperationsInput? lastLoginDate;

  @JsonKey(name: r'MEMO')
  final NullableStringFieldUpdateOperationsInput? memo;

  @override
  Map<String, dynamic> toJson() =>
      _$MEMBERTBLUpdateWithoutMENUTBLInputToJson(this);
}

@_i1.jsonSerializable
class MEMBERTBLUncheckedUpdateWithoutMENUTBLInput
    implements _i1.JsonSerializable {
  const MEMBERTBLUncheckedUpdateWithoutMENUTBLInput({
    this.userId,
    this.passwd,
    this.userNm,
    this.dept,
    this.grade,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
    this.lastLoginDate,
    this.memo,
  });

  factory MEMBERTBLUncheckedUpdateWithoutMENUTBLInput.fromJson(
          Map<String, dynamic> json) =>
      _$MEMBERTBLUncheckedUpdateWithoutMENUTBLInputFromJson(json);

  @JsonKey(name: r'USER_ID')
  final StringFieldUpdateOperationsInput? userId;

  @JsonKey(name: r'PASSWD')
  final StringFieldUpdateOperationsInput? passwd;

  @JsonKey(name: r'USER_NM')
  final StringFieldUpdateOperationsInput? userNm;

  @JsonKey(name: r'DEPT')
  final NullableStringFieldUpdateOperationsInput? dept;

  @JsonKey(name: r'GRADE')
  final NullableStringFieldUpdateOperationsInput? grade;

  @JsonKey(name: r'JOIN_DATE')
  final DateTimeFieldUpdateOperationsInput? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final DateTimeFieldUpdateOperationsInput? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final DateTimeFieldUpdateOperationsInput? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final NullableIntFieldUpdateOperationsInput? pwdWrongCnt;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'LAST_LOGIN_DATE')
  final DateTimeFieldUpdateOperationsInput? lastLoginDate;

  @JsonKey(name: r'MEMO')
  final NullableStringFieldUpdateOperationsInput? memo;

  @override
  Map<String, dynamic> toJson() =>
      _$MEMBERTBLUncheckedUpdateWithoutMENUTBLInputToJson(this);
}

@_i1.jsonSerializable
class MENUTBLCreateManyMEMBERTBLInput implements _i1.JsonSerializable {
  const MENUTBLCreateManyMEMBERTBLInput({
    required this.menuId,
    required this.menuNm,
    required this.depth,
    required this.sort,
    this.ownerId,
    this.url,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
    this.dispYn,
    this.menuIcon,
  });

  factory MENUTBLCreateManyMEMBERTBLInput.fromJson(Map<String, dynamic> json) =>
      _$MENUTBLCreateManyMEMBERTBLInputFromJson(json);

  @JsonKey(name: r'MENU_ID')
  final String menuId;

  @JsonKey(name: r'MENU_NM')
  final String menuNm;

  @JsonKey(name: r'DEPTH')
  final int depth;

  @JsonKey(name: r'SORT')
  final int sort;

  @JsonKey(name: r'OWNER_ID')
  final String? ownerId;

  @JsonKey(name: r'URL')
  final String? url;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'DISP_YN')
  final String? dispYn;

  @JsonKey(name: r'MENU_ICON')
  final String? menuIcon;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUTBLCreateManyMEMBERTBLInputToJson(this);
}

@_i1.jsonSerializable
class MENUTBLUpdateWithoutMEMBERTBLInput implements _i1.JsonSerializable {
  const MENUTBLUpdateWithoutMEMBERTBLInput({
    this.menuId,
    this.menuNm,
    this.depth,
    this.sort,
    this.ownerId,
    this.url,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
    this.dispYn,
    this.menuIcon,
  });

  factory MENUTBLUpdateWithoutMEMBERTBLInput.fromJson(
          Map<String, dynamic> json) =>
      _$MENUTBLUpdateWithoutMEMBERTBLInputFromJson(json);

  @JsonKey(name: r'MENU_ID')
  final StringFieldUpdateOperationsInput? menuId;

  @JsonKey(name: r'MENU_NM')
  final StringFieldUpdateOperationsInput? menuNm;

  @JsonKey(name: r'DEPTH')
  final IntFieldUpdateOperationsInput? depth;

  @JsonKey(name: r'SORT')
  final IntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'OWNER_ID')
  final NullableStringFieldUpdateOperationsInput? ownerId;

  @JsonKey(name: r'URL')
  final NullableStringFieldUpdateOperationsInput? url;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'DISP_YN')
  final NullableStringFieldUpdateOperationsInput? dispYn;

  @JsonKey(name: r'MENU_ICON')
  final NullableStringFieldUpdateOperationsInput? menuIcon;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUTBLUpdateWithoutMEMBERTBLInputToJson(this);
}

@_i1.jsonSerializable
class MENUTBLUncheckedUpdateWithoutMEMBERTBLInput
    implements _i1.JsonSerializable {
  const MENUTBLUncheckedUpdateWithoutMEMBERTBLInput({
    this.menuId,
    this.menuNm,
    this.depth,
    this.sort,
    this.ownerId,
    this.url,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
    this.dispYn,
    this.menuIcon,
  });

  factory MENUTBLUncheckedUpdateWithoutMEMBERTBLInput.fromJson(
          Map<String, dynamic> json) =>
      _$MENUTBLUncheckedUpdateWithoutMEMBERTBLInputFromJson(json);

  @JsonKey(name: r'MENU_ID')
  final StringFieldUpdateOperationsInput? menuId;

  @JsonKey(name: r'MENU_NM')
  final StringFieldUpdateOperationsInput? menuNm;

  @JsonKey(name: r'DEPTH')
  final IntFieldUpdateOperationsInput? depth;

  @JsonKey(name: r'SORT')
  final IntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'OWNER_ID')
  final NullableStringFieldUpdateOperationsInput? ownerId;

  @JsonKey(name: r'URL')
  final NullableStringFieldUpdateOperationsInput? url;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'DISP_YN')
  final NullableStringFieldUpdateOperationsInput? dispYn;

  @JsonKey(name: r'MENU_ICON')
  final NullableStringFieldUpdateOperationsInput? menuIcon;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUTBLUncheckedUpdateWithoutMEMBERTBLInputToJson(this);
}

@_i1.jsonSerializable
class MENUTBLUncheckedUpdateManyWithoutMENUTBLInput
    implements _i1.JsonSerializable {
  const MENUTBLUncheckedUpdateManyWithoutMENUTBLInput({
    this.menuId,
    this.menuNm,
    this.depth,
    this.sort,
    this.ownerId,
    this.url,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
    this.dispYn,
    this.menuIcon,
  });

  factory MENUTBLUncheckedUpdateManyWithoutMENUTBLInput.fromJson(
          Map<String, dynamic> json) =>
      _$MENUTBLUncheckedUpdateManyWithoutMENUTBLInputFromJson(json);

  @JsonKey(name: r'MENU_ID')
  final StringFieldUpdateOperationsInput? menuId;

  @JsonKey(name: r'MENU_NM')
  final StringFieldUpdateOperationsInput? menuNm;

  @JsonKey(name: r'DEPTH')
  final IntFieldUpdateOperationsInput? depth;

  @JsonKey(name: r'SORT')
  final IntFieldUpdateOperationsInput? sort;

  @JsonKey(name: r'OWNER_ID')
  final NullableStringFieldUpdateOperationsInput? ownerId;

  @JsonKey(name: r'URL')
  final NullableStringFieldUpdateOperationsInput? url;

  @JsonKey(name: r'REG_DATE')
  final DateTimeFieldUpdateOperationsInput? regDate;

  @JsonKey(name: r'UPD_DATE')
  final NullableDateTimeFieldUpdateOperationsInput? updDate;

  @JsonKey(name: r'USE_YN')
  final NullableStringFieldUpdateOperationsInput? useYn;

  @JsonKey(name: r'DEL_YN')
  final NullableStringFieldUpdateOperationsInput? delYn;

  @JsonKey(name: r'DISP_YN')
  final NullableStringFieldUpdateOperationsInput? dispYn;

  @JsonKey(name: r'MENU_ICON')
  final NullableStringFieldUpdateOperationsInput? menuIcon;

  @override
  Map<String, dynamic> toJson() =>
      _$MENUTBLUncheckedUpdateManyWithoutMENUTBLInputToJson(this);
}

@_i1.jsonSerializable
class AllCodeTbl implements _i1.JsonSerializable {
  const AllCodeTbl({
    required this.codeType,
    this.codeName,
    required this.unitType,
    this.unitName,
    this.sort,
    this.useYn,
    this.delYn,
    required this.regDate,
    required this.updDate,
  });

  factory AllCodeTbl.fromJson(Map<String, dynamic> json) =>
      _$AllCodeTblFromJson(json);

  @JsonKey(name: r'CODE_TYPE')
  final String codeType;

  @JsonKey(name: r'CODE_NAME')
  final String? codeName;

  @JsonKey(name: r'UNIT_TYPE')
  final String unitType;

  @JsonKey(name: r'UNIT_NAME')
  final String? unitName;

  @JsonKey(name: r'SORT')
  final int? sort;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime updDate;

  @override
  Map<String, dynamic> toJson() => _$AllCodeTblToJson(this);
}

@_i1.jsonSerializable
class ApprovalAttachfileTbl implements _i1.JsonSerializable {
  const ApprovalAttachfileTbl({
    required this.approvalId,
    required this.seq,
    this.oriFileNm,
    this.saveFileNm,
    this.fileSize,
    required this.regDate,
  });

  factory ApprovalAttachfileTbl.fromJson(Map<String, dynamic> json) =>
      _$ApprovalAttachfileTblFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final String approvalId;

  @JsonKey(name: r'SEQ')
  final double seq;

  @JsonKey(name: r'ORI_FILE_NM')
  final String? oriFileNm;

  @JsonKey(name: r'SAVE_FILE_NM')
  final String? saveFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final int? fileSize;

  @JsonKey(name: r'REG_DATE')
  final DateTime regDate;

  @override
  Map<String, dynamic> toJson() => _$ApprovalAttachfileTblToJson(this);
}

@_i1.jsonSerializable
class ApprovalDocInfoTbl implements _i1.JsonSerializable {
  const ApprovalDocInfoTbl({
    required this.seq,
    this.docType,
    this.docNm,
    required this.title,
    this.approvalLineType,
    this.approvalLineContent,
    this.approvalLineContentBak,
    this.content,
    this.writerId,
    this.userNm,
    required this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
  });

  factory ApprovalDocInfoTbl.fromJson(Map<String, dynamic> json) =>
      _$ApprovalDocInfoTblFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt seq;

  @JsonKey(name: r'DOC_TYPE')
  final String? docType;

  @JsonKey(name: r'DOC_NM')
  final String? docNm;

  @JsonKey(name: r'TITLE')
  final String title;

  @JsonKey(name: r'APPROVAL_LINE_TYPE')
  final String? approvalLineType;

  @JsonKey(name: r'APPROVAL_LINE_CONTENT')
  final String? approvalLineContent;

  @JsonKey(name: r'APPROVAL_LINE_CONTENT_BAK')
  final String? approvalLineContentBak;

  @JsonKey(name: r'CONTENT')
  final String? content;

  @JsonKey(name: r'WRITER_ID')
  final String? writerId;

  @JsonKey(name: r'USER_NM')
  final String? userNm;

  @JsonKey(name: r'REG_DATE')
  final DateTime regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() => _$ApprovalDocInfoTblToJson(this);
}

@_i1.jsonSerializable
class ApprovalHistoryTbl implements _i1.JsonSerializable {
  const ApprovalHistoryTbl({
    required this.seq,
    required this.approvalId,
    required this.writerId,
    required this.writerNm,
    required this.docType,
    required this.keepPriod,
    required this.keepDate,
    required this.grade,
    this.status,
    this.content,
    required this.regDate,
    this.updDate,
    this.delYn,
  });

  factory ApprovalHistoryTbl.fromJson(Map<String, dynamic> json) =>
      _$ApprovalHistoryTblFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt seq;

  @JsonKey(name: r'APPROVAL_ID')
  final String approvalId;

  @JsonKey(name: r'WRITER_ID')
  final String writerId;

  @JsonKey(name: r'WRITER_NM')
  final String writerNm;

  @JsonKey(name: r'DOC_TYPE')
  final String docType;

  @JsonKey(name: r'KEEP_PRIOD')
  final int keepPriod;

  @JsonKey(name: r'KEEP_DATE')
  final DateTime keepDate;

  @JsonKey(name: r'GRADE')
  final String grade;

  @JsonKey(name: r'STATUS')
  final String? status;

  @JsonKey(name: r'CONTENT')
  final String? content;

  @JsonKey(name: r'REG_DATE')
  final DateTime regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() => _$ApprovalHistoryTblToJson(this);
}

@_i1.jsonSerializable
class ApprovalMasterTbl implements _i1.JsonSerializable {
  const ApprovalMasterTbl({
    required this.approvalId,
    required this.writerId,
    required this.writerNm,
    required this.docType,
    required this.keepPriod,
    required this.keepDate,
    required this.grade,
    this.status,
    this.title,
    this.header,
    this.content,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
    required this.regDate,
    required this.completeDate,
    this.updDate,
    this.delYn,
  });

  factory ApprovalMasterTbl.fromJson(Map<String, dynamic> json) =>
      _$ApprovalMasterTblFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final String approvalId;

  @JsonKey(name: r'WRITER_ID')
  final String writerId;

  @JsonKey(name: r'WRITER_NM')
  final String writerNm;

  @JsonKey(name: r'DOC_TYPE')
  final String docType;

  @JsonKey(name: r'KEEP_PRIOD')
  final int keepPriod;

  @JsonKey(name: r'KEEP_DATE')
  final DateTime keepDate;

  @JsonKey(name: r'GRADE')
  final String grade;

  @JsonKey(name: r'STATUS')
  final String? status;

  @JsonKey(name: r'TITLE')
  final String? title;

  @JsonKey(name: r'HEADER')
  final String? header;

  @JsonKey(name: r'CONTENT')
  final String? content;

  @JsonKey(name: r'M1')
  final double? m1;

  @JsonKey(name: r'M2')
  final double? m2;

  @JsonKey(name: r'M3')
  final double? m3;

  @JsonKey(name: r'M4')
  final double? m4;

  @JsonKey(name: r'M5')
  final double? m5;

  @JsonKey(name: r'M6')
  final double? m6;

  @JsonKey(name: r'M7')
  final double? m7;

  @JsonKey(name: r'M8')
  final double? m8;

  @JsonKey(name: r'M9')
  final double? m9;

  @JsonKey(name: r'M10')
  final double? m10;

  @JsonKey(name: r'M11')
  final double? m11;

  @JsonKey(name: r'M12')
  final double? m12;

  @JsonKey(name: r'REG_DATE')
  final DateTime regDate;

  @JsonKey(name: r'COMPLETE_DATE')
  final DateTime completeDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() => _$ApprovalMasterTblToJson(this);
}

@_i1.jsonSerializable
class ApprovalMemoTbl implements _i1.JsonSerializable {
  const ApprovalMemoTbl({
    required this.seq,
    required this.approvalId,
    required this.writerId,
    required this.writerNm,
    this.content,
    required this.regDate,
    this.updDate,
    this.delYn,
  });

  factory ApprovalMemoTbl.fromJson(Map<String, dynamic> json) =>
      _$ApprovalMemoTblFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt seq;

  @JsonKey(name: r'APPROVAL_ID')
  final String approvalId;

  @JsonKey(name: r'WRITER_ID')
  final String writerId;

  @JsonKey(name: r'WRITER_NM')
  final String writerNm;

  @JsonKey(name: r'CONTENT')
  final String? content;

  @JsonKey(name: r'REG_DATE')
  final DateTime regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() => _$ApprovalMemoTblToJson(this);
}

@_i1.jsonSerializable
class ApprovalTypeTbl implements _i1.JsonSerializable {
  const ApprovalTypeTbl({
    required this.type,
    this.content,
    this.contentBak,
    this.useYn,
    this.delYn,
  });

  factory ApprovalTypeTbl.fromJson(Map<String, dynamic> json) =>
      _$ApprovalTypeTblFromJson(json);

  @JsonKey(name: r'TYPE')
  final String type;

  @JsonKey(name: r'CONTENT')
  final String? content;

  @JsonKey(name: r'CONTENT_BAK')
  final String? contentBak;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() => _$ApprovalTypeTblToJson(this);
}

@_i1.jsonSerializable
class ApprovalUserTbl implements _i1.JsonSerializable {
  const ApprovalUserTbl({
    required this.approvalId,
    required this.approvalUsrId,
    this.approvalUsrGradeCd,
    required this.approvalUsrType,
    required this.approvalUsrSort,
    this.approvalProcUserYn,
    required this.approvalProcYn,
    required this.approvalProcDate,
    required this.regDate,
    this.updDate,
    this.delYn,
  });

  factory ApprovalUserTbl.fromJson(Map<String, dynamic> json) =>
      _$ApprovalUserTblFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final String approvalId;

  @JsonKey(name: r'APPROVAL_USR_ID')
  final String approvalUsrId;

  @JsonKey(name: r'APPROVAL_USR_GRADE_CD')
  final String? approvalUsrGradeCd;

  @JsonKey(name: r'APPROVAL_USR_TYPE')
  final String approvalUsrType;

  @JsonKey(name: r'APPROVAL_USR_SORT')
  final int approvalUsrSort;

  @JsonKey(name: r'APPROVAL_PROC_USER_YN')
  final String? approvalProcUserYn;

  @JsonKey(name: r'APPROVAL_PROC_YN')
  final String approvalProcYn;

  @JsonKey(name: r'APPROVAL_PROC_DATE')
  final DateTime approvalProcDate;

  @JsonKey(name: r'REG_DATE')
  final DateTime regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() => _$ApprovalUserTblToJson(this);
}

@_i1.jsonSerializable
class BookAssetTbl implements _i1.JsonSerializable {
  const BookAssetTbl({
    required this.seq,
    required this.assetNo,
    this.bookNm,
    this.cnt,
    this.publisher,
    this.amount,
    this.buyDate,
    this.mngDept,
    this.rentYn,
    this.rentUser,
    this.remarks,
    required this.useYn,
    required this.delYn,
    required this.regDate,
    this.updDate,
  });

  factory BookAssetTbl.fromJson(Map<String, dynamic> json) =>
      _$BookAssetTblFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt seq;

  @JsonKey(name: r'ASSET_NO')
  final String assetNo;

  @JsonKey(name: r'BOOK_NM')
  final String? bookNm;

  @JsonKey(name: r'CNT')
  final int? cnt;

  @JsonKey(name: r'PUBLISHER')
  final String? publisher;

  @JsonKey(name: r'AMOUNT')
  final int? amount;

  @JsonKey(name: r'BUY_DATE')
  final String? buyDate;

  @JsonKey(name: r'MNG_DEPT')
  final String? mngDept;

  @JsonKey(name: r'RENT_YN')
  final String? rentYn;

  @JsonKey(name: r'RENT_USER')
  final String? rentUser;

  @JsonKey(name: r'REMARKS')
  final String? remarks;

  @JsonKey(name: r'USE_YN')
  final String useYn;

  @JsonKey(name: r'DEL_YN')
  final String delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() => _$BookAssetTblToJson(this);
}

@_i1.jsonSerializable
class CarAssetInsurTbl implements _i1.JsonSerializable {
  const CarAssetInsurTbl({
    required this.seq,
    required this.mseq,
    required this.guarantee,
  });

  factory CarAssetInsurTbl.fromJson(Map<String, dynamic> json) =>
      _$CarAssetInsurTblFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt seq;

  @JsonKey(name: r'MSEQ')
  final BigInt mseq;

  @JsonKey(name: r'GUARANTEE')
  final String guarantee;

  @override
  Map<String, dynamic> toJson() => _$CarAssetInsurTblToJson(this);
}

@_i1.jsonSerializable
class CarAssetTbl implements _i1.JsonSerializable {
  const CarAssetTbl({
    required this.seq,
    required this.assetNo,
    this.modelNo,
    this.carNo,
    this.owner,
    this.ownerType,
    this.amount,
    this.buyDate,
    this.seller,
    this.remarks,
    this.mngrNm,
    this.fuel,
    this.manuDt,
    this.effic,
    this.insur,
    this.insurMngr,
    this.emgTel,
    this.storeNm,
    this.storeTel,
    required this.useYn,
    required this.delYn,
    required this.regDate,
    this.updDate,
  });

  factory CarAssetTbl.fromJson(Map<String, dynamic> json) =>
      _$CarAssetTblFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt seq;

  @JsonKey(name: r'ASSET_NO')
  final String assetNo;

  @JsonKey(name: r'MODEL_NO')
  final String? modelNo;

  @JsonKey(name: r'CAR_NO')
  final String? carNo;

  @JsonKey(name: r'OWNER')
  final String? owner;

  @JsonKey(name: r'OWNER_TYPE')
  final String? ownerType;

  @JsonKey(name: r'AMOUNT')
  final int? amount;

  @JsonKey(name: r'BUY_DATE')
  final String? buyDate;

  @JsonKey(name: r'SELLER')
  final String? seller;

  @JsonKey(name: r'REMARKS')
  final String? remarks;

  @JsonKey(name: r'MNGR_NM')
  final String? mngrNm;

  @JsonKey(name: r'FUEL')
  final String? fuel;

  @JsonKey(name: r'MANU_DT')
  final String? manuDt;

  @JsonKey(name: r'EFFIC')
  final String? effic;

  @JsonKey(name: r'INSUR')
  final String? insur;

  @JsonKey(name: r'INSUR_MNGR')
  final String? insurMngr;

  @JsonKey(name: r'EMG_TEL')
  final String? emgTel;

  @JsonKey(name: r'STORE_NM')
  final String? storeNm;

  @JsonKey(name: r'STORE_TEL')
  final String? storeTel;

  @JsonKey(name: r'USE_YN')
  final String useYn;

  @JsonKey(name: r'DEL_YN')
  final String delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() => _$CarAssetTblToJson(this);
}

@_i1.jsonSerializable
class CarChargeTbl implements _i1.JsonSerializable {
  const CarChargeTbl({
    required this.seq,
    required this.item,
    required this.charge,
    required this.writerId,
    required this.memo,
    required this.regDate,
  });

  factory CarChargeTbl.fromJson(Map<String, dynamic> json) =>
      _$CarChargeTblFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt seq;

  @JsonKey(name: r'ITEM')
  final String item;

  @JsonKey(name: r'CHARGE')
  final BigInt charge;

  @JsonKey(name: r'WRITER_ID')
  final String writerId;

  @JsonKey(name: r'MEMO')
  final String memo;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @override
  Map<String, dynamic> toJson() => _$CarChargeTblToJson(this);
}

@_i1.jsonSerializable
class CarInfoTbl implements _i1.JsonSerializable {
  const CarInfoTbl({
    required this.sort,
    required this.carManageNo,
    required this.model,
    required this.userId,
    required this.regDate,
    required this.disusedYn,
  });

  factory CarInfoTbl.fromJson(Map<String, dynamic> json) =>
      _$CarInfoTblFromJson(json);

  @JsonKey(name: r'SORT')
  final BigInt sort;

  @JsonKey(name: r'CAR_MANAGE_NO')
  final String carManageNo;

  @JsonKey(name: r'MODEL')
  final String model;

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'DISUSED_YN')
  final String disusedYn;

  @override
  Map<String, dynamic> toJson() => _$CarInfoTblToJson(this);
}

@_i1.jsonSerializable
class CarMileageTbl implements _i1.JsonSerializable {
  const CarMileageTbl({
    required this.seq,
    required this.carManageNo,
    required this.forUse,
    required this.stPoint,
    required this.destination,
    required this.mileage,
    required this.totalMileage,
    required this.recordDate,
    required this.writerId,
    required this.editorId,
    required this.regDate,
    required this.apprYn,
  });

  factory CarMileageTbl.fromJson(Map<String, dynamic> json) =>
      _$CarMileageTblFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt seq;

  @JsonKey(name: r'CAR_MANAGE_NO')
  final String carManageNo;

  @JsonKey(name: r'FOR_USE')
  final String forUse;

  @JsonKey(name: r'ST_POINT')
  final String stPoint;

  @JsonKey(name: r'DESTINATION')
  final String destination;

  @JsonKey(name: r'MILEAGE')
  final BigInt mileage;

  @JsonKey(name: r'TOTAL_MILEAGE')
  final BigInt totalMileage;

  @JsonKey(name: r'RECORD_DATE')
  final String recordDate;

  @JsonKey(name: r'WRITER_ID')
  final String writerId;

  @JsonKey(name: r'EDITOR_ID')
  final String editorId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'APPR_YN')
  final String apprYn;

  @override
  Map<String, dynamic> toJson() => _$CarMileageTblToJson(this);
}

@_i1.jsonSerializable
class CarPartReplaceTbl implements _i1.JsonSerializable {
  const CarPartReplaceTbl({
    required this.seq,
    required this.partNm,
    required this.replacePeriod,
    required this.reTotalMileage,
    required this.nowTotalMileage,
    required this.remainMileage,
    required this.replaceCount,
    required this.partReDate,
    required this.writerId,
    required this.regDate,
  });

  factory CarPartReplaceTbl.fromJson(Map<String, dynamic> json) =>
      _$CarPartReplaceTblFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt seq;

  @JsonKey(name: r'PART_NM')
  final String partNm;

  @JsonKey(name: r'REPLACE_PERIOD')
  final BigInt replacePeriod;

  @JsonKey(name: r'RE_TOTAL_MILEAGE')
  final BigInt reTotalMileage;

  @JsonKey(name: r'NOW_TOTAL_MILEAGE')
  final BigInt nowTotalMileage;

  @JsonKey(name: r'REMAIN_MILEAGE')
  final BigInt remainMileage;

  @JsonKey(name: r'REPLACE_COUNT')
  final BigInt replaceCount;

  @JsonKey(name: r'PART_RE_DATE')
  final String partReDate;

  @JsonKey(name: r'WRITER_ID')
  final String writerId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @override
  Map<String, dynamic> toJson() => _$CarPartReplaceTblToJson(this);
}

@_i1.jsonSerializable
class CarRepairLog implements _i1.JsonSerializable {
  const CarRepairLog({
    required this.seq,
    this.mseq,
    this.assetNo,
    this.repairDe,
    this.repairAmount,
    this.repairStore,
    this.repairLog,
    this.repairOwner,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory CarRepairLog.fromJson(Map<String, dynamic> json) =>
      _$CarRepairLogFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt seq;

  @JsonKey(name: r'MSEQ')
  final BigInt? mseq;

  @JsonKey(name: r'ASSET_NO')
  final String? assetNo;

  @JsonKey(name: r'REPAIR_DE')
  final String? repairDe;

  @JsonKey(name: r'REPAIR_AMOUNT')
  final String? repairAmount;

  @JsonKey(name: r'REPAIR_STORE')
  final String? repairStore;

  @JsonKey(name: r'REPAIR_LOG')
  final String? repairLog;

  @JsonKey(name: r'REPAIR_OWNER')
  final String? repairOwner;

  @JsonKey(name: r'FILE_TP')
  final String? fileTp;

  @JsonKey(name: r'FLPTH')
  final String? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final String? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final String? streFileNm;

  @JsonKey(name: r'REG_ID')
  final String? regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$CarRepairLogToJson(this);
}

@_i1.jsonSerializable
class CarUseManageTbl implements _i1.JsonSerializable {
  const CarUseManageTbl({
    required this.seq,
    required this.carNo,
    required this.carType,
    required this.destination,
    this.purpose,
    required this.users,
    required this.useStartDate,
    required this.useEndDate,
    this.useBeforeDistance,
    this.useAfterDistance,
    this.remarks,
    this.acceptYn,
    this.regUser,
    required this.regDate,
    this.useStartHour,
    this.useEndHour,
    required this.cardApply,
  });

  factory CarUseManageTbl.fromJson(Map<String, dynamic> json) =>
      _$CarUseManageTblFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt seq;

  @JsonKey(name: r'CAR_NO')
  final String carNo;

  @JsonKey(name: r'CAR_TYPE')
  final String carType;

  @JsonKey(name: r'DESTINATION')
  final String destination;

  @JsonKey(name: r'PURPOSE')
  final String? purpose;

  @JsonKey(name: r'USERS')
  final String users;

  @JsonKey(name: r'USE_START_DATE')
  final DateTime useStartDate;

  @JsonKey(name: r'USE_END_DATE')
  final DateTime useEndDate;

  @JsonKey(name: r'USE_BEFORE_DISTANCE')
  final double? useBeforeDistance;

  @JsonKey(name: r'USE_AFTER_DISTANCE')
  final double? useAfterDistance;

  @JsonKey(name: r'REMARKS')
  final String? remarks;

  @JsonKey(name: r'ACCEPT_YN')
  final String? acceptYn;

  @JsonKey(name: r'REG_USER')
  final String? regUser;

  @JsonKey(name: r'REG_DATE')
  final DateTime regDate;

  @JsonKey(name: r'USE_START_HOUR')
  final String? useStartHour;

  @JsonKey(name: r'USE_END_HOUR')
  final String? useEndHour;

  @JsonKey(name: r'CARD_APPLY')
  final String cardApply;

  @override
  Map<String, dynamic> toJson() => _$CarUseManageTblToJson(this);
}

@_i1.jsonSerializable
class HolidayTbl implements _i1.JsonSerializable {
  const HolidayTbl({
    required this.userId,
    required this.stdYear,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
    required this.useYn,
    required this.delYn,
    required this.regDate,
    this.updDate,
  });

  factory HolidayTbl.fromJson(Map<String, dynamic> json) =>
      _$HolidayTblFromJson(json);

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'STD_YEAR')
  final String stdYear;

  @JsonKey(name: r'M1')
  final double? m1;

  @JsonKey(name: r'M2')
  final double? m2;

  @JsonKey(name: r'M3')
  final double? m3;

  @JsonKey(name: r'M4')
  final double? m4;

  @JsonKey(name: r'M5')
  final double? m5;

  @JsonKey(name: r'M6')
  final double? m6;

  @JsonKey(name: r'M7')
  final double? m7;

  @JsonKey(name: r'M8')
  final double? m8;

  @JsonKey(name: r'M9')
  final double? m9;

  @JsonKey(name: r'M10')
  final double? m10;

  @JsonKey(name: r'M11')
  final double? m11;

  @JsonKey(name: r'M12')
  final double? m12;

  @JsonKey(name: r'USE_YN')
  final String useYn;

  @JsonKey(name: r'DEL_YN')
  final String delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() => _$HolidayTblToJson(this);
}

@_i1.jsonSerializable
class MemberTbl implements _i1.JsonSerializable {
  const MemberTbl({
    required this.userId,
    required this.passwd,
    required this.userNm,
    this.dept,
    this.grade,
    required this.joinDate,
    required this.retireDate,
    required this.pwdChgDate,
    this.pwdWrongCnt,
    this.useYn,
    this.delYn,
    required this.regDate,
    this.updDate,
    required this.lastLoginDate,
    this.memo,
  });

  factory MemberTbl.fromJson(Map<String, dynamic> json) =>
      _$MemberTblFromJson(json);

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'PASSWD')
  final String passwd;

  @JsonKey(name: r'USER_NM')
  final String userNm;

  @JsonKey(name: r'DEPT')
  final String? dept;

  @JsonKey(name: r'GRADE')
  final String? grade;

  @JsonKey(name: r'JOIN_DATE')
  final DateTime joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final DateTime retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final DateTime pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final int? pwdWrongCnt;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'LAST_LOGIN_DATE')
  final DateTime lastLoginDate;

  @JsonKey(name: r'MEMO')
  final String? memo;

  @override
  Map<String, dynamic> toJson() => _$MemberTblToJson(this);
}

@_i1.jsonSerializable
class MenuAuthTbl implements _i1.JsonSerializable {
  const MenuAuthTbl({
    required this.userId,
    required this.menuId,
    this.readYn,
    this.writeYn,
    this.regId,
    this.updId,
    required this.regDate,
    this.updDate,
  });

  factory MenuAuthTbl.fromJson(Map<String, dynamic> json) =>
      _$MenuAuthTblFromJson(json);

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'MENU_ID')
  final String menuId;

  @JsonKey(name: r'READ_YN')
  final String? readYn;

  @JsonKey(name: r'WRITE_YN')
  final String? writeYn;

  @JsonKey(name: r'REG_ID')
  final String? regId;

  @JsonKey(name: r'UPD_ID')
  final String? updId;

  @JsonKey(name: r'REG_DATE')
  final DateTime regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() => _$MenuAuthTblToJson(this);
}

@_i1.jsonSerializable
class MenuTbl implements _i1.JsonSerializable {
  const MenuTbl({
    required this.menuId,
    required this.menuNm,
    required this.depth,
    required this.sort,
    this.ownerId,
    this.url,
    this.writerId,
    required this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
    this.dispYn,
    this.menuIcon,
  });

  factory MenuTbl.fromJson(Map<String, dynamic> json) =>
      _$MenuTblFromJson(json);

  @JsonKey(name: r'MENU_ID')
  final String menuId;

  @JsonKey(name: r'MENU_NM')
  final String menuNm;

  @JsonKey(name: r'DEPTH')
  final int depth;

  @JsonKey(name: r'SORT')
  final int sort;

  @JsonKey(name: r'OWNER_ID')
  final String? ownerId;

  @JsonKey(name: r'URL')
  final String? url;

  @JsonKey(name: r'WRITER_ID')
  final String? writerId;

  @JsonKey(name: r'REG_DATE')
  final DateTime regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'DISP_YN')
  final String? dispYn;

  @JsonKey(name: r'MENU_ICON')
  final String? menuIcon;

  @override
  Map<String, dynamic> toJson() => _$MenuTblToJson(this);
}

@_i1.jsonSerializable
class OfficeAssetTbl implements _i1.JsonSerializable {
  const OfficeAssetTbl({
    required this.seq,
    required this.assetNo,
    required this.assetType,
    this.seller,
    this.buyDate,
    this.modelNo,
    this.serialNo,
    this.amount,
    this.keepYear,
    this.mngDept,
    this.assetAccount,
    this.remarks,
    this.carryOut,
    required this.useYn,
    required this.delYn,
    required this.regDate,
    this.updDate,
  });

  factory OfficeAssetTbl.fromJson(Map<String, dynamic> json) =>
      _$OfficeAssetTblFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt seq;

  @JsonKey(name: r'ASSET_NO')
  final String assetNo;

  @JsonKey(name: r'ASSET_TYPE')
  final String assetType;

  @JsonKey(name: r'SELLER')
  final String? seller;

  @JsonKey(name: r'BUY_DATE')
  final String? buyDate;

  @JsonKey(name: r'MODEL_NO')
  final String? modelNo;

  @JsonKey(name: r'SERIAL_NO')
  final String? serialNo;

  @JsonKey(name: r'AMOUNT')
  final int? amount;

  @JsonKey(name: r'KEEP_YEAR')
  final double? keepYear;

  @JsonKey(name: r'MNG_DEPT')
  final String? mngDept;

  @JsonKey(name: r'ASSET_ACCOUNT')
  final String? assetAccount;

  @JsonKey(name: r'REMARKS')
  final String? remarks;

  @JsonKey(name: r'CARRY_OUT')
  final String? carryOut;

  @JsonKey(name: r'USE_YN')
  final String useYn;

  @JsonKey(name: r'DEL_YN')
  final String delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() => _$OfficeAssetTblToJson(this);
}

@_i1.jsonSerializable
class ServerAssetTbl implements _i1.JsonSerializable {
  const ServerAssetTbl({
    required this.seq,
    required this.assetNo,
    required this.assetType,
    this.maker,
    this.cnt,
    this.amount,
    this.buyDate,
    this.seller,
    this.modelNo,
    this.serialNo,
    this.hostname,
    this.builtLoc,
    this.useDesc,
    this.osInfo,
    this.cpuInfo,
    this.ramInfo,
    this.hddInfo,
    this.ssdInfo,
    this.odd,
    this.remarks,
    this.carryOut,
    required this.useYn,
    required this.delYn,
    required this.regDate,
    this.updDate,
  });

  factory ServerAssetTbl.fromJson(Map<String, dynamic> json) =>
      _$ServerAssetTblFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt seq;

  @JsonKey(name: r'ASSET_NO')
  final String assetNo;

  @JsonKey(name: r'ASSET_TYPE')
  final String assetType;

  @JsonKey(name: r'MAKER')
  final String? maker;

  @JsonKey(name: r'CNT')
  final double? cnt;

  @JsonKey(name: r'AMOUNT')
  final int? amount;

  @JsonKey(name: r'BUY_DATE')
  final String? buyDate;

  @JsonKey(name: r'SELLER')
  final String? seller;

  @JsonKey(name: r'MODEL_NO')
  final String? modelNo;

  @JsonKey(name: r'SERIAL_NO')
  final String? serialNo;

  @JsonKey(name: r'HOSTNAME')
  final String? hostname;

  @JsonKey(name: r'BUILT_LOC')
  final String? builtLoc;

  @JsonKey(name: r'USE_DESC')
  final String? useDesc;

  @JsonKey(name: r'OS_INFO')
  final String? osInfo;

  @JsonKey(name: r'CPU_INFO')
  final String? cpuInfo;

  @JsonKey(name: r'RAM_INFO')
  final String? ramInfo;

  @JsonKey(name: r'HDD_INFO')
  final String? hddInfo;

  @JsonKey(name: r'SSD_INFO')
  final String? ssdInfo;

  @JsonKey(name: r'ODD')
  final String? odd;

  @JsonKey(name: r'REMARKS')
  final String? remarks;

  @JsonKey(name: r'CARRY_OUT')
  final String? carryOut;

  @JsonKey(name: r'USE_YN')
  final String useYn;

  @JsonKey(name: r'DEL_YN')
  final String delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() => _$ServerAssetTblToJson(this);
}

@_i1.jsonSerializable
class SoftwareAssetTbl implements _i1.JsonSerializable {
  const SoftwareAssetTbl({
    required this.seq,
    required this.assetNo,
    required this.softwareNm,
    this.versionNm,
    this.cnt,
    this.amount,
    this.buyDate,
    this.serialNo,
    this.licenseNo,
    this.userNm,
    this.remarks,
    required this.useYn,
    required this.delYn,
    required this.regDate,
    this.updDate,
  });

  factory SoftwareAssetTbl.fromJson(Map<String, dynamic> json) =>
      _$SoftwareAssetTblFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt seq;

  @JsonKey(name: r'ASSET_NO')
  final String assetNo;

  @JsonKey(name: r'SOFTWARE_NM')
  final String softwareNm;

  @JsonKey(name: r'VERSION_NM')
  final String? versionNm;

  @JsonKey(name: r'CNT')
  final double? cnt;

  @JsonKey(name: r'AMOUNT')
  final int? amount;

  @JsonKey(name: r'BUY_DATE')
  final String? buyDate;

  @JsonKey(name: r'SERIAL_NO')
  final String? serialNo;

  @JsonKey(name: r'LICENSE_NO')
  final String? licenseNo;

  @JsonKey(name: r'USER_NM')
  final String? userNm;

  @JsonKey(name: r'REMARKS')
  final String? remarks;

  @JsonKey(name: r'USE_YN')
  final String useYn;

  @JsonKey(name: r'DEL_YN')
  final String delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() => _$SoftwareAssetTblToJson(this);
}

@_i1.jsonSerializable
class StAdminMenu implements _i1.JsonSerializable {
  const StAdminMenu({
    required this.menuCd,
    required this.menuNm,
    this.menuPath,
    required this.menuSrt,
    required this.menuDeps,
    this.menuIcon,
    required this.menuTp,
    required this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory StAdminMenu.fromJson(Map<String, dynamic> json) =>
      _$StAdminMenuFromJson(json);

  @JsonKey(name: r'MENU_CD')
  final String menuCd;

  @JsonKey(name: r'MENU_NM')
  final String menuNm;

  @JsonKey(name: r'MENU_PATH')
  final String? menuPath;

  @JsonKey(name: r'MENU_SRT')
  final int menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final int menuDeps;

  @JsonKey(name: r'MENU_ICON')
  final String? menuIcon;

  @JsonKey(name: r'MENU_TP')
  final String menuTp;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$StAdminMenuToJson(this);
}

@_i1.jsonSerializable
class StAlarm implements _i1.JsonSerializable {
  const StAlarm({
    required this.seq,
    this.msgCd,
    this.msgCnts,
    this.sendDate,
    this.sendDiv,
    this.sendDeptCd,
    this.sendId,
    this.recvId,
    this.popYn,
    this.editId,
    this.editDate,
  });

  factory StAlarm.fromJson(Map<String, dynamic> json) =>
      _$StAlarmFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'MSG_CD')
  final String? msgCd;

  @JsonKey(name: r'MSG_CNTS')
  final String? msgCnts;

  @JsonKey(name: r'SEND_DATE')
  final String? sendDate;

  @JsonKey(name: r'SEND_DIV')
  final String? sendDiv;

  @JsonKey(name: r'SEND_DEPT_CD')
  final String? sendDeptCd;

  @JsonKey(name: r'SEND_ID')
  final String? sendId;

  @JsonKey(name: r'RECV_ID')
  final String? recvId;

  @JsonKey(name: r'POP_YN')
  final String? popYn;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @override
  Map<String, dynamic> toJson() => _$StAlarmToJson(this);
}

@_i1.jsonSerializable
class StAuditLog implements _i1.JsonSerializable {
  const StAuditLog({
    required this.seq,
    required this.logCode,
    required this.logCnts,
    this.errCode,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory StAuditLog.fromJson(Map<String, dynamic> json) =>
      _$StAuditLogFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'LOG_CODE')
  final String logCode;

  @JsonKey(name: r'LOG_CNTS')
  final String logCnts;

  @JsonKey(name: r'ERR_CODE')
  final String? errCode;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$StAuditLogToJson(this);
}

@_i1.jsonSerializable
class StBanner implements _i1.JsonSerializable {
  const StBanner({
    required this.bannerCd,
    this.lkUrl,
    this.lkTarget,
    this.flpth,
    this.fileNm,
    this.useYn,
    required this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory StBanner.fromJson(Map<String, dynamic> json) =>
      _$StBannerFromJson(json);

  @JsonKey(name: r'BANNER_CD')
  final String bannerCd;

  @JsonKey(name: r'LK_URL')
  final String? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final String? lkTarget;

  @JsonKey(name: r'FLPTH')
  final String? flpth;

  @JsonKey(name: r'FILE_NM')
  final String? fileNm;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$StBannerToJson(this);
}

@_i1.jsonSerializable
class StBoardColumn implements _i1.JsonSerializable {
  const StBoardColumn({
    required this.boardCd,
    required this.sort,
    required this.colCd,
    required this.colNm,
    required this.regId,
    required this.regDate,
  });

  factory StBoardColumn.fromJson(Map<String, dynamic> json) =>
      _$StBoardColumnFromJson(json);

  @JsonKey(name: r'BOARD_CD')
  final String boardCd;

  @JsonKey(name: r'SORT')
  final int sort;

  @JsonKey(name: r'COL_CD')
  final String colCd;

  @JsonKey(name: r'COL_NM')
  final String colNm;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @override
  Map<String, dynamic> toJson() => _$StBoardColumnToJson(this);
}

@_i1.jsonSerializable
class StBoardColumnDft implements _i1.JsonSerializable {
  const StBoardColumnDft({
    required this.boardTy,
    required this.sort,
    required this.colCd,
    required this.colNm,
    this.editId,
    this.editDate,
    required this.delYn,
  });

  factory StBoardColumnDft.fromJson(Map<String, dynamic> json) =>
      _$StBoardColumnDftFromJson(json);

  @JsonKey(name: r'BOARD_TY')
  final String boardTy;

  @JsonKey(name: r'SORT')
  final int sort;

  @JsonKey(name: r'COL_CD')
  final String colCd;

  @JsonKey(name: r'COL_NM')
  final String colNm;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_YN')
  final String delYn;

  @override
  Map<String, dynamic> toJson() => _$StBoardColumnDftToJson(this);
}

@_i1.jsonSerializable
class StBoardComment implements _i1.JsonSerializable {
  const StBoardComment({
    required this.seq,
    required this.mseq,
    required this.boardCd,
    this.cnts,
    this.upperSeq,
    this.replyYn,
    this.regAdminYn,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory StBoardComment.fromJson(Map<String, dynamic> json) =>
      _$StBoardCommentFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'MSEQ')
  final int mseq;

  @JsonKey(name: r'BOARD_CD')
  final String boardCd;

  @JsonKey(name: r'CNTS')
  final String? cnts;

  @JsonKey(name: r'UPPER_SEQ')
  final int? upperSeq;

  @JsonKey(name: r'REPLY_YN')
  final String? replyYn;

  @JsonKey(name: r'REG_ADMIN_YN')
  final String? regAdminYn;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$StBoardCommentToJson(this);
}

@_i1.jsonSerializable
class StBoardFile implements _i1.JsonSerializable {
  const StBoardFile({
    required this.seq,
    required this.mseq,
    required this.boardCd,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileSize,
    this.repreYn,
    this.dwldCo,
  });

  factory StBoardFile.fromJson(Map<String, dynamic> json) =>
      _$StBoardFileFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'MSEQ')
  final int mseq;

  @JsonKey(name: r'BOARD_CD')
  final String boardCd;

  @JsonKey(name: r'FILE_TP')
  final String? fileTp;

  @JsonKey(name: r'FLPTH')
  final String? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final String? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final String? streFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final int? fileSize;

  @JsonKey(name: r'REPRE_YN')
  final String? repreYn;

  @JsonKey(name: r'DWLD_CO')
  final int? dwldCo;

  @override
  Map<String, dynamic> toJson() => _$StBoardFileToJson(this);
}

@_i1.jsonSerializable
class StBoardMst implements _i1.JsonSerializable {
  const StBoardMst({
    required this.seq,
    required this.boardCd,
    this.clsCd,
    required this.ttl,
    required this.cnts,
    this.fileYn,
    this.imageYn,
    this.noticeYn,
    this.lkUrl,
    this.lkTarget,
    this.readCnt,
    this.regAdminYn,
    this.replyYn,
    this.upperSeq,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory StBoardMst.fromJson(Map<String, dynamic> json) =>
      _$StBoardMstFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'BOARD_CD')
  final String boardCd;

  @JsonKey(name: r'CLS_CD')
  final String? clsCd;

  @JsonKey(name: r'TTL')
  final String ttl;

  @JsonKey(name: r'CNTS')
  final String cnts;

  @JsonKey(name: r'FILE_YN')
  final String? fileYn;

  @JsonKey(name: r'IMAGE_YN')
  final String? imageYn;

  @JsonKey(name: r'NOTICE_YN')
  final String? noticeYn;

  @JsonKey(name: r'LK_URL')
  final String? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final String? lkTarget;

  @JsonKey(name: r'READ_CNT')
  final int? readCnt;

  @JsonKey(name: r'REG_ADMIN_YN')
  final String? regAdminYn;

  @JsonKey(name: r'REPLY_YN')
  final String? replyYn;

  @JsonKey(name: r'UPPER_SEQ')
  final int? upperSeq;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$StBoardMstToJson(this);
}

@_i1.jsonSerializable
class StBoardStng implements _i1.JsonSerializable {
  const StBoardStng({
    required this.boardCd,
    required this.boardNm,
    required this.boardTy,
    required this.editorYn,
    required this.rlsYn,
    this.cclSeq,
    this.listCnt,
    this.writeYn,
    this.commentYn,
    this.replyYn,
    this.attachYn,
    this.attachSize,
    this.attachCnt,
    this.attachExt,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory StBoardStng.fromJson(Map<String, dynamic> json) =>
      _$StBoardStngFromJson(json);

  @JsonKey(name: r'BOARD_CD')
  final String boardCd;

  @JsonKey(name: r'BOARD_NM')
  final String boardNm;

  @JsonKey(name: r'BOARD_TY')
  final String boardTy;

  @JsonKey(name: r'EDITOR_YN')
  final String editorYn;

  @JsonKey(name: r'RLS_YN')
  final String rlsYn;

  @JsonKey(name: r'CCL_SEQ')
  final int? cclSeq;

  @JsonKey(name: r'LIST_CNT')
  final int? listCnt;

  @JsonKey(name: r'WRITE_YN')
  final String? writeYn;

  @JsonKey(name: r'COMMENT_YN')
  final String? commentYn;

  @JsonKey(name: r'REPLY_YN')
  final String? replyYn;

  @JsonKey(name: r'ATTACH_YN')
  final String? attachYn;

  @JsonKey(name: r'ATTACH_SIZE')
  final String? attachSize;

  @JsonKey(name: r'ATTACH_CNT')
  final String? attachCnt;

  @JsonKey(name: r'ATTACH_EXT')
  final String? attachExt;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$StBoardStngToJson(this);
}

@_i1.jsonSerializable
class StCcl implements _i1.JsonSerializable {
  const StCcl({
    required this.seq,
    required this.cclType,
    required this.cclNm,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileExtsn,
    this.fileSize,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory StCcl.fromJson(Map<String, dynamic> json) => _$StCclFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'CCL_TYPE')
  final String cclType;

  @JsonKey(name: r'CCL_NM')
  final String cclNm;

  @JsonKey(name: r'FLPTH')
  final String? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final String? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final String? streFileNm;

  @JsonKey(name: r'FILE_EXTSN')
  final String? fileExtsn;

  @JsonKey(name: r'FILE_SIZE')
  final int? fileSize;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$StCclToJson(this);
}

@_i1.jsonSerializable
class StCodeMst implements _i1.JsonSerializable {
  const StCodeMst({
    required this.cdGrp,
    required this.cdKey,
    required this.cdVal,
    this.cdDesc,
    required this.cdSrt,
    this.depth,
    required this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory StCodeMst.fromJson(Map<String, dynamic> json) =>
      _$StCodeMstFromJson(json);

  @JsonKey(name: r'CD_GRP')
  final String cdGrp;

  @JsonKey(name: r'CD_KEY')
  final String cdKey;

  @JsonKey(name: r'CD_VAL')
  final String cdVal;

  @JsonKey(name: r'CD_DESC')
  final String? cdDesc;

  @JsonKey(name: r'CD_SRT')
  final int cdSrt;

  @JsonKey(name: r'DEPTH')
  final int? depth;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$StCodeMstToJson(this);
}

@_i1.jsonSerializable
class StConnectLog implements _i1.JsonSerializable {
  const StConnectLog({
    required this.seq,
    required this.userId,
    this.connType,
    this.osType,
    this.browserType,
    this.conneIp,
    this.regDate,
  });

  factory StConnectLog.fromJson(Map<String, dynamic> json) =>
      _$StConnectLogFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'CONN_TYPE')
  final String? connType;

  @JsonKey(name: r'OS_TYPE')
  final String? osType;

  @JsonKey(name: r'BROWSER_TYPE')
  final String? browserType;

  @JsonKey(name: r'CONNE_IP')
  final String? conneIp;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @override
  Map<String, dynamic> toJson() => _$StConnectLogToJson(this);
}

@_i1.jsonSerializable
class StContentsFile implements _i1.JsonSerializable {
  const StContentsFile({
    required this.seq,
    required this.mseq,
    this.fileTp,
    required this.flpth,
    required this.orginalFileNm,
    required this.streFileNm,
    required this.fileSize,
  });

  factory StContentsFile.fromJson(Map<String, dynamic> json) =>
      _$StContentsFileFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'MSEQ')
  final String mseq;

  @JsonKey(name: r'FILE_TP')
  final String? fileTp;

  @JsonKey(name: r'FLPTH')
  final String flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final String orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final String streFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final int fileSize;

  @override
  Map<String, dynamic> toJson() => _$StContentsFileToJson(this);
}

@_i1.jsonSerializable
class StContentsMst implements _i1.JsonSerializable {
  const StContentsMst({
    required this.seq,
    required this.cntsNm,
    this.pubDate,
    this.pubState,
    this.cn,
    this.srchYn,
    this.fileYn,
    this.imageYn,
    required this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory StContentsMst.fromJson(Map<String, dynamic> json) =>
      _$StContentsMstFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'CNTS_NM')
  final String cntsNm;

  @JsonKey(name: r'PUB_DATE')
  final String? pubDate;

  @JsonKey(name: r'PUB_STATE')
  final String? pubState;

  @JsonKey(name: r'CN')
  final String? cn;

  @JsonKey(name: r'SRCH_YN')
  final String? srchYn;

  @JsonKey(name: r'FILE_YN')
  final String? fileYn;

  @JsonKey(name: r'IMAGE_YN')
  final String? imageYn;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$StContentsMstToJson(this);
}

@_i1.jsonSerializable
class StDept implements _i1.JsonSerializable {
  const StDept({
    required this.deptCd,
    required this.deptNm,
    this.upperDeptCd,
    this.upperDeptNm,
    this.sort,
    this.mainYn,
    this.deptDesc,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory StDept.fromJson(Map<String, dynamic> json) => _$StDeptFromJson(json);

  @JsonKey(name: r'DEPT_CD')
  final String deptCd;

  @JsonKey(name: r'DEPT_NM')
  final String deptNm;

  @JsonKey(name: r'UPPER_DEPT_CD')
  final String? upperDeptCd;

  @JsonKey(name: r'UPPER_DEPT_NM')
  final String? upperDeptNm;

  @JsonKey(name: r'SORT')
  final int? sort;

  @JsonKey(name: r'MAIN_YN')
  final String? mainYn;

  @JsonKey(name: r'DEPT_DESC')
  final String? deptDesc;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$StDeptToJson(this);
}

@_i1.jsonSerializable
class StDeptEmp implements _i1.JsonSerializable {
  const StDeptEmp({
    required this.empNo,
    required this.empNm,
    this.deptCd,
    this.deptNm,
    this.fctnCd,
    this.fctnNm,
    this.ofcpCd,
    this.ofcpNm,
    this.emailAddr,
    this.offmTelno,
    this.htelTelno,
    this.deptYn,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory StDeptEmp.fromJson(Map<String, dynamic> json) =>
      _$StDeptEmpFromJson(json);

  @JsonKey(name: r'EMP_NO')
  final String empNo;

  @JsonKey(name: r'EMP_NM')
  final String empNm;

  @JsonKey(name: r'DEPT_CD')
  final String? deptCd;

  @JsonKey(name: r'DEPT_NM')
  final String? deptNm;

  @JsonKey(name: r'FCTN_CD')
  final String? fctnCd;

  @JsonKey(name: r'FCTN_NM')
  final String? fctnNm;

  @JsonKey(name: r'OFCP_CD')
  final String? ofcpCd;

  @JsonKey(name: r'OFCP_NM')
  final String? ofcpNm;

  @JsonKey(name: r'EMAIL_ADDR')
  final String? emailAddr;

  @JsonKey(name: r'OFFM_TELNO')
  final String? offmTelno;

  @JsonKey(name: r'HTEL_TELNO')
  final String? htelTelno;

  @JsonKey(name: r'DEPT_YN')
  final String? deptYn;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$StDeptEmpToJson(this);
}

@_i1.jsonSerializable
class StMenu implements _i1.JsonSerializable {
  const StMenu({
    required this.menuCd,
    required this.menuNm,
    this.menuPath,
    this.menuMapping,
    required this.menuSrt,
    required this.menuDeps,
    this.menuIcon,
    required this.menuTp,
    this.mainExpsrYn,
    this.subExpsrYn,
    this.upendClas,
    this.upendCn,
    this.cclType,
    required this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory StMenu.fromJson(Map<String, dynamic> json) => _$StMenuFromJson(json);

  @JsonKey(name: r'MENU_CD')
  final String menuCd;

  @JsonKey(name: r'MENU_NM')
  final String menuNm;

  @JsonKey(name: r'MENU_PATH')
  final String? menuPath;

  @JsonKey(name: r'MENU_MAPPING')
  final String? menuMapping;

  @JsonKey(name: r'MENU_SRT')
  final int menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final int menuDeps;

  @JsonKey(name: r'MENU_ICON')
  final String? menuIcon;

  @JsonKey(name: r'MENU_TP')
  final String menuTp;

  @JsonKey(name: r'MAIN_EXPSR_YN')
  final String? mainExpsrYn;

  @JsonKey(name: r'SUB_EXPSR_YN')
  final String? subExpsrYn;

  @JsonKey(name: r'UPEND_CLAS')
  final String? upendClas;

  @JsonKey(name: r'UPEND_CN')
  final String? upendCn;

  @JsonKey(name: r'CCL_TYPE')
  final String? cclType;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$StMenuToJson(this);
}

@_i1.jsonSerializable
class StMessageTmplat implements _i1.JsonSerializable {
  const StMessageTmplat({
    required this.msgDivCd,
    required this.msgCd,
    this.msgNm,
    this.msgTmplat,
    this.useYn,
    this.editId,
    this.editDate,
  });

  factory StMessageTmplat.fromJson(Map<String, dynamic> json) =>
      _$StMessageTmplatFromJson(json);

  @JsonKey(name: r'MSG_DIV_CD')
  final String msgDivCd;

  @JsonKey(name: r'MSG_CD')
  final String msgCd;

  @JsonKey(name: r'MSG_NM')
  final String? msgNm;

  @JsonKey(name: r'MSG_TMPLAT')
  final String? msgTmplat;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @override
  Map<String, dynamic> toJson() => _$StMessageTmplatToJson(this);
}

@_i1.jsonSerializable
class StMimeType implements _i1.JsonSerializable {
  const StMimeType({
    required this.seq,
    required this.extnNm,
    required this.fileMt,
  });

  factory StMimeType.fromJson(Map<String, dynamic> json) =>
      _$StMimeTypeFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'EXTN_NM')
  final String extnNm;

  @JsonKey(name: r'FILE_MT')
  final String fileMt;

  @override
  Map<String, dynamic> toJson() => _$StMimeTypeToJson(this);
}

@_i1.jsonSerializable
class StMngrGrp implements _i1.JsonSerializable {
  const StMngrGrp({
    required this.grpCd,
    this.grpNm,
    this.grpDesc,
    this.sort,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory StMngrGrp.fromJson(Map<String, dynamic> json) =>
      _$StMngrGrpFromJson(json);

  @JsonKey(name: r'GRP_CD')
  final String grpCd;

  @JsonKey(name: r'GRP_NM')
  final String? grpNm;

  @JsonKey(name: r'GRP_DESC')
  final String? grpDesc;

  @JsonKey(name: r'SORT')
  final int? sort;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$StMngrGrpToJson(this);
}

@_i1.jsonSerializable
class StMngrMst implements _i1.JsonSerializable {
  const StMngrMst({
    required this.mngrId,
    required this.mngrNm,
    this.mngrPw,
    this.grpCd,
    this.grade,
    required this.permCd,
    this.acsYn,
    this.clph,
    this.empNo,
    required this.joinDate,
    required this.retireDate,
    required this.pwdChgDate,
    this.pwdWrongCnt,
    this.pwdWrongDate,
    this.lstLoginDate,
    this.flpth,
    this.fileNm,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory StMngrMst.fromJson(Map<String, dynamic> json) =>
      _$StMngrMstFromJson(json);

  @JsonKey(name: r'MNGR_ID')
  final String mngrId;

  @JsonKey(name: r'MNGR_NM')
  final String mngrNm;

  @JsonKey(name: r'MNGR_PW')
  final String? mngrPw;

  @JsonKey(name: r'GRP_CD')
  final String? grpCd;

  @JsonKey(name: r'GRADE')
  final String? grade;

  @JsonKey(name: r'PERM_CD')
  final String permCd;

  @JsonKey(name: r'ACS_YN')
  final String? acsYn;

  @JsonKey(name: r'CLPH')
  final String? clph;

  @JsonKey(name: r'EMP_NO')
  final String? empNo;

  @JsonKey(name: r'JOIN_DATE')
  final String joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final DateTime retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final DateTime pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final int? pwdWrongCnt;

  @JsonKey(name: r'PWD_WRONG_DATE')
  final String? pwdWrongDate;

  @JsonKey(name: r'LST_LOGIN_DATE')
  final String? lstLoginDate;

  @JsonKey(name: r'FLPTH')
  final String? flpth;

  @JsonKey(name: r'FILE_NM')
  final String? fileNm;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$StMngrMstToJson(this);
}

@_i1.jsonSerializable
class StMyStng implements _i1.JsonSerializable {
  const StMyStng({
    required this.userId,
    required this.stngCd,
    required this.userDiv,
    this.stngData,
  });

  factory StMyStng.fromJson(Map<String, dynamic> json) =>
      _$StMyStngFromJson(json);

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'STNG_CD')
  final String stngCd;

  @JsonKey(name: r'USER_DIV')
  final String userDiv;

  @JsonKey(name: r'STNG_DATA')
  final String? stngData;

  @override
  Map<String, dynamic> toJson() => _$StMyStngToJson(this);
}

@_i1.jsonSerializable
class StPermDtl implements _i1.JsonSerializable {
  const StPermDtl({
    required this.permCd,
    required this.menuCd,
    this.readYn,
    this.regYn,
    this.mdfcnYn,
    this.delYn,
    this.manageYn,
    required this.regId,
    required this.regDate,
  });

  factory StPermDtl.fromJson(Map<String, dynamic> json) =>
      _$StPermDtlFromJson(json);

  @JsonKey(name: r'PERM_CD')
  final String permCd;

  @JsonKey(name: r'MENU_CD')
  final String menuCd;

  @JsonKey(name: r'READ_YN')
  final String? readYn;

  @JsonKey(name: r'REG_YN')
  final String? regYn;

  @JsonKey(name: r'MDFCN_YN')
  final String? mdfcnYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'MANAGE_YN')
  final String? manageYn;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @override
  Map<String, dynamic> toJson() => _$StPermDtlToJson(this);
}

@_i1.jsonSerializable
class StPermMst implements _i1.JsonSerializable {
  const StPermMst({
    required this.permCd,
    required this.permNm,
    this.sort,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory StPermMst.fromJson(Map<String, dynamic> json) =>
      _$StPermMstFromJson(json);

  @JsonKey(name: r'PERM_CD')
  final String permCd;

  @JsonKey(name: r'PERM_NM')
  final String permNm;

  @JsonKey(name: r'SORT')
  final String? sort;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$StPermMstToJson(this);
}

@_i1.jsonSerializable
class StPopup implements _i1.JsonSerializable {
  const StPopup({
    required this.popCd,
    required this.popNm,
    required this.popTy,
    this.imgText,
    this.lkUrl,
    this.lkTarget,
    required this.bgngDate,
    required this.endDate,
    this.spwgPred,
    this.flpth,
    this.fileNm,
    this.useYn,
    this.beforeCd,
    required this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory StPopup.fromJson(Map<String, dynamic> json) =>
      _$StPopupFromJson(json);

  @JsonKey(name: r'POP_CD')
  final String popCd;

  @JsonKey(name: r'POP_NM')
  final String popNm;

  @JsonKey(name: r'POP_TY')
  final String popTy;

  @JsonKey(name: r'IMG_TEXT')
  final String? imgText;

  @JsonKey(name: r'LK_URL')
  final String? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final String? lkTarget;

  @JsonKey(name: r'BGNG_DATE')
  final String bgngDate;

  @JsonKey(name: r'END_DATE')
  final String endDate;

  @JsonKey(name: r'SPWG_PRED')
  final String? spwgPred;

  @JsonKey(name: r'FLPTH')
  final String? flpth;

  @JsonKey(name: r'FILE_NM')
  final String? fileNm;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'BEFORE_CD')
  final String? beforeCd;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$StPopupToJson(this);
}

@_i1.jsonSerializable
class StStng implements _i1.JsonSerializable {
  const StStng({
    required this.stngCd,
    this.stngData,
    this.title,
    this.descCn,
    this.sort,
    this.editId,
    this.editDate,
  });

  factory StStng.fromJson(Map<String, dynamic> json) => _$StStngFromJson(json);

  @JsonKey(name: r'STNG_CD')
  final String stngCd;

  @JsonKey(name: r'STNG_DATA')
  final String? stngData;

  @JsonKey(name: r'TITLE')
  final String? title;

  @JsonKey(name: r'DESC_CN')
  final String? descCn;

  @JsonKey(name: r'SORT')
  final int? sort;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @override
  Map<String, dynamic> toJson() => _$StStngToJson(this);
}

@_i1.jsonSerializable
class StUserMst implements _i1.JsonSerializable {
  const StUserMst({
    required this.userId,
    this.userNm,
    required this.userPw,
    this.userDiv,
    this.status,
    this.prevLoginYn,
    this.withdrawnYn,
    this.clph,
    this.email,
    this.lstLoginDate,
    required this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory StUserMst.fromJson(Map<String, dynamic> json) =>
      _$StUserMstFromJson(json);

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'USER_NM')
  final String? userNm;

  @JsonKey(name: r'USER_PW')
  final String userPw;

  @JsonKey(name: r'USER_DIV')
  final String? userDiv;

  @JsonKey(name: r'STATUS')
  final String? status;

  @JsonKey(name: r'PREV_LOGIN_YN')
  final String? prevLoginYn;

  @JsonKey(name: r'WITHDRAWN_YN')
  final String? withdrawnYn;

  @JsonKey(name: r'CLPH')
  final String? clph;

  @JsonKey(name: r'EMAIL')
  final String? email;

  @JsonKey(name: r'LST_LOGIN_DATE')
  final String? lstLoginDate;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$StUserMstToJson(this);
}

@_i1.jsonSerializable
class WorkReportDetailTbl implements _i1.JsonSerializable {
  const WorkReportDetailTbl({
    required this.reportId,
    required this.seq,
    required this.projectNm,
    required this.projectSubNm,
    this.detailContent,
    this.worker,
    this.grade,
    this.processRate,
    this.workDate,
    this.processType,
    required this.subjectYn,
    required this.regUser,
    required this.regDate,
    this.completeDate,
  });

  factory WorkReportDetailTbl.fromJson(Map<String, dynamic> json) =>
      _$WorkReportDetailTblFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final String reportId;

  @JsonKey(name: r'SEQ')
  final BigInt seq;

  @JsonKey(name: r'PROJECT_NM')
  final String projectNm;

  @JsonKey(name: r'PROJECT_SUB_NM')
  final String projectSubNm;

  @JsonKey(name: r'DETAIL_CONTENT')
  final String? detailContent;

  @JsonKey(name: r'WORKER')
  final String? worker;

  @JsonKey(name: r'GRADE')
  final String? grade;

  @JsonKey(name: r'PROCESS_RATE')
  final String? processRate;

  @JsonKey(name: r'WORK_DATE')
  final String? workDate;

  @JsonKey(name: r'PROCESS_TYPE')
  final String? processType;

  @JsonKey(name: r'SUBJECT_YN')
  final String subjectYn;

  @JsonKey(name: r'REG_USER')
  final String regUser;

  @JsonKey(name: r'REG_DATE')
  final DateTime regDate;

  @JsonKey(name: r'COMPLETE_DATE')
  final String? completeDate;

  @override
  Map<String, dynamic> toJson() => _$WorkReportDetailTblToJson(this);
}

@_i1.jsonSerializable
class WorkReportHtmlTbl implements _i1.JsonSerializable {
  const WorkReportHtmlTbl({
    required this.reportId,
    required this.userId,
    required this.title,
    this.htmlContent,
    required this.regDate,
    this.delYn,
  });

  factory WorkReportHtmlTbl.fromJson(Map<String, dynamic> json) =>
      _$WorkReportHtmlTblFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final String reportId;

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'TITLE')
  final String title;

  @JsonKey(name: r'HTML_CONTENT')
  final String? htmlContent;

  @JsonKey(name: r'REG_DATE')
  final DateTime regDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() => _$WorkReportHtmlTblToJson(this);
}

@_i1.jsonSerializable
class WorkReportHtmlTblBack implements _i1.JsonSerializable {
  const WorkReportHtmlTblBack({
    required this.reportId,
    required this.userId,
    required this.title,
    this.htmlContent,
    required this.regDate,
    this.delYn,
  });

  factory WorkReportHtmlTblBack.fromJson(Map<String, dynamic> json) =>
      _$WorkReportHtmlTblBackFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final String reportId;

  @JsonKey(name: r'USER_ID')
  final String userId;

  @JsonKey(name: r'TITLE')
  final String title;

  @JsonKey(name: r'HTML_CONTENT')
  final String? htmlContent;

  @JsonKey(name: r'REG_DATE')
  final DateTime regDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() => _$WorkReportHtmlTblBackToJson(this);
}

@_i1.jsonSerializable
class WorkReportMasterTbl implements _i1.JsonSerializable {
  const WorkReportMasterTbl({
    required this.reportId,
    required this.title,
    required this.dept,
    required this.regDate,
    this.updDate,
    this.delYn,
  });

  factory WorkReportMasterTbl.fromJson(Map<String, dynamic> json) =>
      _$WorkReportMasterTblFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final String reportId;

  @JsonKey(name: r'TITLE')
  final String title;

  @JsonKey(name: r'DEPT')
  final String dept;

  @JsonKey(name: r'REG_DATE')
  final DateTime regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() => _$WorkReportMasterTblToJson(this);
}

@_i1.jsonSerializable
class WorkRequestMst implements _i1.JsonSerializable {
  const WorkRequestMst({
    required this.seq,
    required this.rqstrDpnm,
    required this.rqstrNm,
    required this.rqstrId,
    required this.rqstrDate,
    required this.hopeDate,
    required this.chrDprNm,
    required this.chrNm,
    required this.chrId,
    this.chrChk,
    required this.title,
    required this.cn,
    this.etc,
    this.doc,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory WorkRequestMst.fromJson(Map<String, dynamic> json) =>
      _$WorkRequestMstFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'RQSTR_DPNM')
  final String rqstrDpnm;

  @JsonKey(name: r'RQSTR_NM')
  final String rqstrNm;

  @JsonKey(name: r'RQSTR_ID')
  final String rqstrId;

  @JsonKey(name: r'RQSTR_DATE')
  final String rqstrDate;

  @JsonKey(name: r'HOPE_DATE')
  final String hopeDate;

  @JsonKey(name: r'CHR_DPR_NM')
  final String chrDprNm;

  @JsonKey(name: r'CHR_NM')
  final String chrNm;

  @JsonKey(name: r'CHR_ID')
  final String chrId;

  @JsonKey(name: r'CHR_CHK')
  final String? chrChk;

  @JsonKey(name: r'TITLE')
  final String title;

  @JsonKey(name: r'CN')
  final String cn;

  @JsonKey(name: r'ETC')
  final String? etc;

  @JsonKey(name: r'DOC')
  final String? doc;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$WorkRequestMstToJson(this);
}

@_i1.jsonSerializable
class WorkRequestRef implements _i1.JsonSerializable {
  const WorkRequestRef({
    required this.seq,
    required this.mseq,
    required this.refId,
    this.refNm,
    this.refDep,
    this.refGrade,
    required this.regId,
    required this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory WorkRequestRef.fromJson(Map<String, dynamic> json) =>
      _$WorkRequestRefFromJson(json);

  @JsonKey(name: r'SEQ')
  final int seq;

  @JsonKey(name: r'MSEQ')
  final int mseq;

  @JsonKey(name: r'REF_ID')
  final String refId;

  @JsonKey(name: r'REF_NM')
  final String? refNm;

  @JsonKey(name: r'REF_DEP')
  final String? refDep;

  @JsonKey(name: r'REF_GRADE')
  final String? refGrade;

  @JsonKey(name: r'REG_ID')
  final String regId;

  @JsonKey(name: r'REG_DATE')
  final String regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$WorkRequestRefToJson(this);
}

class ALLCODETBLFluent<T> extends _i1.PrismaFluent<T> {
  const ALLCODETBLFluent(
    super.original,
    super.$query,
  );
}

class APPROVALATTACHFILETBLFluent<T> extends _i1.PrismaFluent<T> {
  const APPROVALATTACHFILETBLFluent(
    super.original,
    super.$query,
  );
}

class APPROVALDOCINFOTBLFluent<T> extends _i1.PrismaFluent<T> {
  const APPROVALDOCINFOTBLFluent(
    super.original,
    super.$query,
  );
}

class APPROVALHISTORYTBLFluent<T> extends _i1.PrismaFluent<T> {
  const APPROVALHISTORYTBLFluent(
    super.original,
    super.$query,
  );
}

class APPROVALMASTERTBLFluent<T> extends _i1.PrismaFluent<T> {
  const APPROVALMASTERTBLFluent(
    super.original,
    super.$query,
  );
}

class APPROVALMEMOTBLFluent<T> extends _i1.PrismaFluent<T> {
  const APPROVALMEMOTBLFluent(
    super.original,
    super.$query,
  );
}

class APPROVALTYPETBLFluent<T> extends _i1.PrismaFluent<T> {
  const APPROVALTYPETBLFluent(
    super.original,
    super.$query,
  );
}

class APPROVALUSERTBLFluent<T> extends _i1.PrismaFluent<T> {
  const APPROVALUSERTBLFluent(
    super.original,
    super.$query,
  );
}

class BOOKASSETTBLFluent<T> extends _i1.PrismaFluent<T> {
  const BOOKASSETTBLFluent(
    super.original,
    super.$query,
  );
}

class CARASSETINSURTBLFluent<T> extends _i1.PrismaFluent<T> {
  const CARASSETINSURTBLFluent(
    super.original,
    super.$query,
  );
}

class CARASSETTBLFluent<T> extends _i1.PrismaFluent<T> {
  const CARASSETTBLFluent(
    super.original,
    super.$query,
  );
}

class CARCHARGETBLFluent<T> extends _i1.PrismaFluent<T> {
  const CARCHARGETBLFluent(
    super.original,
    super.$query,
  );
}

class CARINFOTBLFluent<T> extends _i1.PrismaFluent<T> {
  const CARINFOTBLFluent(
    super.original,
    super.$query,
  );
}

class CARMILEAGETBLFluent<T> extends _i1.PrismaFluent<T> {
  const CARMILEAGETBLFluent(
    super.original,
    super.$query,
  );
}

class CARPARTREPLACETBLFluent<T> extends _i1.PrismaFluent<T> {
  const CARPARTREPLACETBLFluent(
    super.original,
    super.$query,
  );
}

class CARREPAIRLOGFluent<T> extends _i1.PrismaFluent<T> {
  const CARREPAIRLOGFluent(
    super.original,
    super.$query,
  );
}

class CARUSEMANAGETBLFluent<T> extends _i1.PrismaFluent<T> {
  const CARUSEMANAGETBLFluent(
    super.original,
    super.$query,
  );
}

class HOLIDAYTBLFluent<T> extends _i1.PrismaFluent<T> {
  const HOLIDAYTBLFluent(
    super.original,
    super.$query,
  );
}

class MEMBERTBLFluent<T> extends _i1.PrismaFluent<T> {
  const MEMBERTBLFluent(
    super.original,
    super.$query,
  );

  Future<Iterable<MenuTbl>?> menuTbl({
    MENUTBLWhereInput? where,
    Iterable<MENUTBLOrderByWithRelationInput>? orderBy,
    MENUTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<MENUTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'MENU_TBL',
    );
    final fields = MENUTBLScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> menuTbl) =>
        menuTbl.map((Map menuTbl) => MenuTbl.fromJson(menuTbl.cast()));
    return query(fields)
        .then((json) => json is Iterable ? compiler(json.cast()) : null);
  }

  MEMBERTBLCountOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return MEMBERTBLCountOutputType(query);
  }
}

class MENUAUTHTBLFluent<T> extends _i1.PrismaFluent<T> {
  const MENUAUTHTBLFluent(
    super.original,
    super.$query,
  );
}

class MENUTBLFluent<T> extends _i1.PrismaFluent<T> {
  const MENUTBLFluent(
    super.original,
    super.$query,
  );

  MEMBERTBLFluent<MemberTbl?> memberTbl() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MEMBER_TBL',
          fields: fields,
        )
      ]),
      key: r'MEMBER_TBL',
    );
    final future = query(MEMBERTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? MemberTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return MEMBERTBLFluent<MemberTbl?>(
      future,
      query,
    );
  }
}

class OFFICEASSETTBLFluent<T> extends _i1.PrismaFluent<T> {
  const OFFICEASSETTBLFluent(
    super.original,
    super.$query,
  );
}

class SERVERASSETTBLFluent<T> extends _i1.PrismaFluent<T> {
  const SERVERASSETTBLFluent(
    super.original,
    super.$query,
  );
}

class SOFTWAREASSETTBLFluent<T> extends _i1.PrismaFluent<T> {
  const SOFTWAREASSETTBLFluent(
    super.original,
    super.$query,
  );
}

class STADMINMENUFluent<T> extends _i1.PrismaFluent<T> {
  const STADMINMENUFluent(
    super.original,
    super.$query,
  );
}

class STALARMFluent<T> extends _i1.PrismaFluent<T> {
  const STALARMFluent(
    super.original,
    super.$query,
  );
}

class STAUDITLOGFluent<T> extends _i1.PrismaFluent<T> {
  const STAUDITLOGFluent(
    super.original,
    super.$query,
  );
}

class STBANNERFluent<T> extends _i1.PrismaFluent<T> {
  const STBANNERFluent(
    super.original,
    super.$query,
  );
}

class STBOARDCOLUMNFluent<T> extends _i1.PrismaFluent<T> {
  const STBOARDCOLUMNFluent(
    super.original,
    super.$query,
  );
}

class STBOARDCOLUMNDFTFluent<T> extends _i1.PrismaFluent<T> {
  const STBOARDCOLUMNDFTFluent(
    super.original,
    super.$query,
  );
}

class STBOARDCOMMENTFluent<T> extends _i1.PrismaFluent<T> {
  const STBOARDCOMMENTFluent(
    super.original,
    super.$query,
  );
}

class STBOARDFILEFluent<T> extends _i1.PrismaFluent<T> {
  const STBOARDFILEFluent(
    super.original,
    super.$query,
  );
}

class STBOARDMSTFluent<T> extends _i1.PrismaFluent<T> {
  const STBOARDMSTFluent(
    super.original,
    super.$query,
  );
}

class STBOARDSTNGFluent<T> extends _i1.PrismaFluent<T> {
  const STBOARDSTNGFluent(
    super.original,
    super.$query,
  );
}

class STCCLFluent<T> extends _i1.PrismaFluent<T> {
  const STCCLFluent(
    super.original,
    super.$query,
  );
}

class STCODEMSTFluent<T> extends _i1.PrismaFluent<T> {
  const STCODEMSTFluent(
    super.original,
    super.$query,
  );
}

class STCONNECTLOGFluent<T> extends _i1.PrismaFluent<T> {
  const STCONNECTLOGFluent(
    super.original,
    super.$query,
  );
}

class STCONTENTSFILEFluent<T> extends _i1.PrismaFluent<T> {
  const STCONTENTSFILEFluent(
    super.original,
    super.$query,
  );
}

class STCONTENTSMSTFluent<T> extends _i1.PrismaFluent<T> {
  const STCONTENTSMSTFluent(
    super.original,
    super.$query,
  );
}

class STDEPTFluent<T> extends _i1.PrismaFluent<T> {
  const STDEPTFluent(
    super.original,
    super.$query,
  );
}

class STDEPTEMPFluent<T> extends _i1.PrismaFluent<T> {
  const STDEPTEMPFluent(
    super.original,
    super.$query,
  );
}

class STMENUFluent<T> extends _i1.PrismaFluent<T> {
  const STMENUFluent(
    super.original,
    super.$query,
  );
}

class STMESSAGETMPLATFluent<T> extends _i1.PrismaFluent<T> {
  const STMESSAGETMPLATFluent(
    super.original,
    super.$query,
  );
}

class STMIMETYPEFluent<T> extends _i1.PrismaFluent<T> {
  const STMIMETYPEFluent(
    super.original,
    super.$query,
  );
}

class STMNGRGRPFluent<T> extends _i1.PrismaFluent<T> {
  const STMNGRGRPFluent(
    super.original,
    super.$query,
  );
}

class STMNGRMSTFluent<T> extends _i1.PrismaFluent<T> {
  const STMNGRMSTFluent(
    super.original,
    super.$query,
  );
}

class STMYSTNGFluent<T> extends _i1.PrismaFluent<T> {
  const STMYSTNGFluent(
    super.original,
    super.$query,
  );
}

class STPERMDTLFluent<T> extends _i1.PrismaFluent<T> {
  const STPERMDTLFluent(
    super.original,
    super.$query,
  );
}

class STPERMMSTFluent<T> extends _i1.PrismaFluent<T> {
  const STPERMMSTFluent(
    super.original,
    super.$query,
  );
}

class STPOPUPFluent<T> extends _i1.PrismaFluent<T> {
  const STPOPUPFluent(
    super.original,
    super.$query,
  );
}

class STSTNGFluent<T> extends _i1.PrismaFluent<T> {
  const STSTNGFluent(
    super.original,
    super.$query,
  );
}

class STUSERMSTFluent<T> extends _i1.PrismaFluent<T> {
  const STUSERMSTFluent(
    super.original,
    super.$query,
  );
}

class WORKREPORTDETAILTBLFluent<T> extends _i1.PrismaFluent<T> {
  const WORKREPORTDETAILTBLFluent(
    super.original,
    super.$query,
  );
}

class WORKREPORTHTMLTBLFluent<T> extends _i1.PrismaFluent<T> {
  const WORKREPORTHTMLTBLFluent(
    super.original,
    super.$query,
  );
}

class WORKREPORTHTMLTBLBACKFluent<T> extends _i1.PrismaFluent<T> {
  const WORKREPORTHTMLTBLBACKFluent(
    super.original,
    super.$query,
  );
}

class WORKREPORTMASTERTBLFluent<T> extends _i1.PrismaFluent<T> {
  const WORKREPORTMASTERTBLFluent(
    super.original,
    super.$query,
  );
}

class WORKREQUESTMSTFluent<T> extends _i1.PrismaFluent<T> {
  const WORKREQUESTMSTFluent(
    super.original,
    super.$query,
  );
}

class WORKREQUESTREFFluent<T> extends _i1.PrismaFluent<T> {
  const WORKREQUESTREFFluent(
    super.original,
    super.$query,
  );
}

extension ALLCODETBLModelDelegateExtension on _i1.ModelDelegate<AllCodeTbl> {
  ALLCODETBLFluent<AllCodeTbl?> findUnique(
      {required ALLCODETBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueALL_CODE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueALL_CODE_TBL',
    );
    final future = query(ALLCODETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? AllCodeTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return ALLCODETBLFluent<AllCodeTbl?>(
      future,
      query,
    );
  }

  ALLCODETBLFluent<AllCodeTbl> findUniqueOrThrow(
      {required ALLCODETBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueALL_CODE_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueALL_CODE_TBLOrThrow',
    );
    final future = query(ALLCODETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? AllCodeTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ALL_CODE_TBL)'));
    return ALLCODETBLFluent<AllCodeTbl>(
      future,
      query,
    );
  }

  ALLCODETBLFluent<AllCodeTbl?> findFirst({
    ALLCODETBLWhereInput? where,
    Iterable<ALLCODETBLOrderByWithRelationInput>? orderBy,
    ALLCODETBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<ALLCODETBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstALL_CODE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstALL_CODE_TBL',
    );
    final future = query(ALLCODETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? AllCodeTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return ALLCODETBLFluent<AllCodeTbl?>(
      future,
      query,
    );
  }

  ALLCODETBLFluent<AllCodeTbl> findFirstOrThrow({
    ALLCODETBLWhereInput? where,
    Iterable<ALLCODETBLOrderByWithRelationInput>? orderBy,
    ALLCODETBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<ALLCODETBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstALL_CODE_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstALL_CODE_TBLOrThrow',
    );
    final future = query(ALLCODETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? AllCodeTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ALL_CODE_TBL)'));
    return ALLCODETBLFluent<AllCodeTbl>(
      future,
      query,
    );
  }

  Future<Iterable<AllCodeTbl>> findMany({
    ALLCODETBLWhereInput? where,
    Iterable<ALLCODETBLOrderByWithRelationInput>? orderBy,
    ALLCODETBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<ALLCODETBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyALL_CODE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyALL_CODE_TBL',
    );
    final fields = ALLCODETBLScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyALLCODETBL) =>
        findManyALLCODETBL.map((Map findManyALLCODETBL) =>
            AllCodeTbl.fromJson(findManyALLCODETBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  ALLCODETBLFluent<AllCodeTbl> create({required ALLCODETBLCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneALL_CODE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneALL_CODE_TBL',
    );
    final future = query(ALLCODETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? AllCodeTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ALL_CODE_TBL)'));
    return ALLCODETBLFluent<AllCodeTbl>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<ALLCODETBLCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyALL_CODE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyALL_CODE_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyALLCODETBL) =>
        AffectedRowsOutput.fromJson(createManyALLCODETBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  ALLCODETBLFluent<AllCodeTbl?> update({
    required ALLCODETBLUpdateInput data,
    required ALLCODETBLWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneALL_CODE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneALL_CODE_TBL',
    );
    final future = query(ALLCODETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? AllCodeTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return ALLCODETBLFluent<AllCodeTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required ALLCODETBLUpdateManyMutationInput data,
    ALLCODETBLWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyALL_CODE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyALL_CODE_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyALLCODETBL) =>
        AffectedRowsOutput.fromJson(updateManyALLCODETBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  ALLCODETBLFluent<AllCodeTbl> upsert({
    required ALLCODETBLWhereUniqueInput where,
    required ALLCODETBLCreateInput create,
    required ALLCODETBLUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneALL_CODE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneALL_CODE_TBL',
    );
    final future = query(ALLCODETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? AllCodeTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ALL_CODE_TBL)'));
    return ALLCODETBLFluent<AllCodeTbl>(
      future,
      query,
    );
  }

  ALLCODETBLFluent<AllCodeTbl?> delete(
      {required ALLCODETBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneALL_CODE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneALL_CODE_TBL',
    );
    final future = query(ALLCODETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? AllCodeTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return ALLCODETBLFluent<AllCodeTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({ALLCODETBLWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyALL_CODE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyALL_CODE_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyALLCODETBL) =>
        AffectedRowsOutput.fromJson(deleteManyALLCODETBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateALLCODETBL aggregate({
    ALLCODETBLWhereInput? where,
    Iterable<ALLCODETBLOrderByWithRelationInput>? orderBy,
    ALLCODETBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateALL_CODE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateALL_CODE_TBL',
    );
    return AggregateALLCODETBL(query);
  }

  Future<Iterable<ALLCODETBLGroupByOutputType>> groupBy({
    ALLCODETBLWhereInput? where,
    Iterable<ALLCODETBLOrderByWithAggregationInput>? orderBy,
    required Iterable<ALLCODETBLScalarFieldEnum> by,
    ALLCODETBLScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByALL_CODE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByALL_CODE_TBL',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByALLCODETBL) =>
        groupByALLCODETBL.map((Map groupByALLCODETBL) =>
            ALLCODETBLGroupByOutputType.fromJson(groupByALLCODETBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension APPROVALATTACHFILETBLModelDelegateExtension
    on _i1.ModelDelegate<ApprovalAttachfileTbl> {
  APPROVALATTACHFILETBLFluent<ApprovalAttachfileTbl?> findUnique(
      {required APPROVALATTACHFILETBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueAPPROVAL_ATTACHFILE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueAPPROVAL_ATTACHFILE_TBL',
    );
    final future =
        query(APPROVALATTACHFILETBLScalarFieldEnum.values.toGraphQLFields())
            .then((json) => json is Map
                ? ApprovalAttachfileTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return APPROVALATTACHFILETBLFluent<ApprovalAttachfileTbl?>(
      future,
      query,
    );
  }

  APPROVALATTACHFILETBLFluent<ApprovalAttachfileTbl> findUniqueOrThrow(
      {required APPROVALATTACHFILETBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueAPPROVAL_ATTACHFILE_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueAPPROVAL_ATTACHFILE_TBLOrThrow',
    );
    final future = query(
            APPROVALATTACHFILETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ApprovalAttachfileTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: APPROVAL_ATTACHFILE_TBL)'));
    return APPROVALATTACHFILETBLFluent<ApprovalAttachfileTbl>(
      future,
      query,
    );
  }

  APPROVALATTACHFILETBLFluent<ApprovalAttachfileTbl?> findFirst({
    APPROVALATTACHFILETBLWhereInput? where,
    Iterable<APPROVALATTACHFILETBLOrderByWithRelationInput>? orderBy,
    APPROVALATTACHFILETBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<APPROVALATTACHFILETBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstAPPROVAL_ATTACHFILE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstAPPROVAL_ATTACHFILE_TBL',
    );
    final future =
        query(APPROVALATTACHFILETBLScalarFieldEnum.values.toGraphQLFields())
            .then((json) => json is Map
                ? ApprovalAttachfileTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return APPROVALATTACHFILETBLFluent<ApprovalAttachfileTbl?>(
      future,
      query,
    );
  }

  APPROVALATTACHFILETBLFluent<ApprovalAttachfileTbl> findFirstOrThrow({
    APPROVALATTACHFILETBLWhereInput? where,
    Iterable<APPROVALATTACHFILETBLOrderByWithRelationInput>? orderBy,
    APPROVALATTACHFILETBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<APPROVALATTACHFILETBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstAPPROVAL_ATTACHFILE_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstAPPROVAL_ATTACHFILE_TBLOrThrow',
    );
    final future = query(
            APPROVALATTACHFILETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ApprovalAttachfileTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: APPROVAL_ATTACHFILE_TBL)'));
    return APPROVALATTACHFILETBLFluent<ApprovalAttachfileTbl>(
      future,
      query,
    );
  }

  Future<Iterable<ApprovalAttachfileTbl>> findMany({
    APPROVALATTACHFILETBLWhereInput? where,
    Iterable<APPROVALATTACHFILETBLOrderByWithRelationInput>? orderBy,
    APPROVALATTACHFILETBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<APPROVALATTACHFILETBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyAPPROVAL_ATTACHFILE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyAPPROVAL_ATTACHFILE_TBL',
    );
    final fields =
        APPROVALATTACHFILETBLScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyAPPROVALATTACHFILETBL) =>
        findManyAPPROVALATTACHFILETBL.map((Map findManyAPPROVALATTACHFILETBL) =>
            ApprovalAttachfileTbl.fromJson(
                findManyAPPROVALATTACHFILETBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  APPROVALATTACHFILETBLFluent<ApprovalAttachfileTbl> create(
      {required APPROVALATTACHFILETBLCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneAPPROVAL_ATTACHFILE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneAPPROVAL_ATTACHFILE_TBL',
    );
    final future = query(
            APPROVALATTACHFILETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ApprovalAttachfileTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: APPROVAL_ATTACHFILE_TBL)'));
    return APPROVALATTACHFILETBLFluent<ApprovalAttachfileTbl>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<APPROVALATTACHFILETBLCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyAPPROVAL_ATTACHFILE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyAPPROVAL_ATTACHFILE_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyAPPROVALATTACHFILETBL) =>
        AffectedRowsOutput.fromJson(createManyAPPROVALATTACHFILETBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  APPROVALATTACHFILETBLFluent<ApprovalAttachfileTbl?> update({
    required APPROVALATTACHFILETBLUpdateInput data,
    required APPROVALATTACHFILETBLWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneAPPROVAL_ATTACHFILE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneAPPROVAL_ATTACHFILE_TBL',
    );
    final future =
        query(APPROVALATTACHFILETBLScalarFieldEnum.values.toGraphQLFields())
            .then((json) => json is Map
                ? ApprovalAttachfileTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return APPROVALATTACHFILETBLFluent<ApprovalAttachfileTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required APPROVALATTACHFILETBLUpdateManyMutationInput data,
    APPROVALATTACHFILETBLWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyAPPROVAL_ATTACHFILE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyAPPROVAL_ATTACHFILE_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyAPPROVALATTACHFILETBL) =>
        AffectedRowsOutput.fromJson(updateManyAPPROVALATTACHFILETBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  APPROVALATTACHFILETBLFluent<ApprovalAttachfileTbl> upsert({
    required APPROVALATTACHFILETBLWhereUniqueInput where,
    required APPROVALATTACHFILETBLCreateInput create,
    required APPROVALATTACHFILETBLUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneAPPROVAL_ATTACHFILE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneAPPROVAL_ATTACHFILE_TBL',
    );
    final future = query(
            APPROVALATTACHFILETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ApprovalAttachfileTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: APPROVAL_ATTACHFILE_TBL)'));
    return APPROVALATTACHFILETBLFluent<ApprovalAttachfileTbl>(
      future,
      query,
    );
  }

  APPROVALATTACHFILETBLFluent<ApprovalAttachfileTbl?> delete(
      {required APPROVALATTACHFILETBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneAPPROVAL_ATTACHFILE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneAPPROVAL_ATTACHFILE_TBL',
    );
    final future =
        query(APPROVALATTACHFILETBLScalarFieldEnum.values.toGraphQLFields())
            .then((json) => json is Map
                ? ApprovalAttachfileTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return APPROVALATTACHFILETBLFluent<ApprovalAttachfileTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany(
      {APPROVALATTACHFILETBLWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyAPPROVAL_ATTACHFILE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyAPPROVAL_ATTACHFILE_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyAPPROVALATTACHFILETBL) =>
        AffectedRowsOutput.fromJson(deleteManyAPPROVALATTACHFILETBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateAPPROVALATTACHFILETBL aggregate({
    APPROVALATTACHFILETBLWhereInput? where,
    Iterable<APPROVALATTACHFILETBLOrderByWithRelationInput>? orderBy,
    APPROVALATTACHFILETBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateAPPROVAL_ATTACHFILE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateAPPROVAL_ATTACHFILE_TBL',
    );
    return AggregateAPPROVALATTACHFILETBL(query);
  }

  Future<Iterable<APPROVALATTACHFILETBLGroupByOutputType>> groupBy({
    APPROVALATTACHFILETBLWhereInput? where,
    Iterable<APPROVALATTACHFILETBLOrderByWithAggregationInput>? orderBy,
    required Iterable<APPROVALATTACHFILETBLScalarFieldEnum> by,
    APPROVALATTACHFILETBLScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByAPPROVAL_ATTACHFILE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByAPPROVAL_ATTACHFILE_TBL',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByAPPROVALATTACHFILETBL) =>
        groupByAPPROVALATTACHFILETBL.map((Map groupByAPPROVALATTACHFILETBL) =>
            APPROVALATTACHFILETBLGroupByOutputType.fromJson(
                groupByAPPROVALATTACHFILETBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension APPROVALDOCINFOTBLModelDelegateExtension
    on _i1.ModelDelegate<ApprovalDocInfoTbl> {
  APPROVALDOCINFOTBLFluent<ApprovalDocInfoTbl?> findUnique(
      {required APPROVALDOCINFOTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueAPPROVAL_DOC_INFO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueAPPROVAL_DOC_INFO_TBL',
    );
    final future =
        query(APPROVALDOCINFOTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? ApprovalDocInfoTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return APPROVALDOCINFOTBLFluent<ApprovalDocInfoTbl?>(
      future,
      query,
    );
  }

  APPROVALDOCINFOTBLFluent<ApprovalDocInfoTbl> findUniqueOrThrow(
      {required APPROVALDOCINFOTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueAPPROVAL_DOC_INFO_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueAPPROVAL_DOC_INFO_TBLOrThrow',
    );
    final future = query(
            APPROVALDOCINFOTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ApprovalDocInfoTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: APPROVAL_DOC_INFO_TBL)'));
    return APPROVALDOCINFOTBLFluent<ApprovalDocInfoTbl>(
      future,
      query,
    );
  }

  APPROVALDOCINFOTBLFluent<ApprovalDocInfoTbl?> findFirst({
    APPROVALDOCINFOTBLWhereInput? where,
    Iterable<APPROVALDOCINFOTBLOrderByWithRelationInput>? orderBy,
    APPROVALDOCINFOTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<APPROVALDOCINFOTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstAPPROVAL_DOC_INFO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstAPPROVAL_DOC_INFO_TBL',
    );
    final future =
        query(APPROVALDOCINFOTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? ApprovalDocInfoTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return APPROVALDOCINFOTBLFluent<ApprovalDocInfoTbl?>(
      future,
      query,
    );
  }

  APPROVALDOCINFOTBLFluent<ApprovalDocInfoTbl> findFirstOrThrow({
    APPROVALDOCINFOTBLWhereInput? where,
    Iterable<APPROVALDOCINFOTBLOrderByWithRelationInput>? orderBy,
    APPROVALDOCINFOTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<APPROVALDOCINFOTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstAPPROVAL_DOC_INFO_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstAPPROVAL_DOC_INFO_TBLOrThrow',
    );
    final future = query(
            APPROVALDOCINFOTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ApprovalDocInfoTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: APPROVAL_DOC_INFO_TBL)'));
    return APPROVALDOCINFOTBLFluent<ApprovalDocInfoTbl>(
      future,
      query,
    );
  }

  Future<Iterable<ApprovalDocInfoTbl>> findMany({
    APPROVALDOCINFOTBLWhereInput? where,
    Iterable<APPROVALDOCINFOTBLOrderByWithRelationInput>? orderBy,
    APPROVALDOCINFOTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<APPROVALDOCINFOTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyAPPROVAL_DOC_INFO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyAPPROVAL_DOC_INFO_TBL',
    );
    final fields = APPROVALDOCINFOTBLScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyAPPROVALDOCINFOTBL) =>
        findManyAPPROVALDOCINFOTBL.map((Map findManyAPPROVALDOCINFOTBL) =>
            ApprovalDocInfoTbl.fromJson(findManyAPPROVALDOCINFOTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  APPROVALDOCINFOTBLFluent<ApprovalDocInfoTbl> create(
      {required APPROVALDOCINFOTBLCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneAPPROVAL_DOC_INFO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneAPPROVAL_DOC_INFO_TBL',
    );
    final future = query(
            APPROVALDOCINFOTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ApprovalDocInfoTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: APPROVAL_DOC_INFO_TBL)'));
    return APPROVALDOCINFOTBLFluent<ApprovalDocInfoTbl>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<APPROVALDOCINFOTBLCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyAPPROVAL_DOC_INFO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyAPPROVAL_DOC_INFO_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyAPPROVALDOCINFOTBL) =>
        AffectedRowsOutput.fromJson(createManyAPPROVALDOCINFOTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  APPROVALDOCINFOTBLFluent<ApprovalDocInfoTbl?> update({
    required APPROVALDOCINFOTBLUpdateInput data,
    required APPROVALDOCINFOTBLWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneAPPROVAL_DOC_INFO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneAPPROVAL_DOC_INFO_TBL',
    );
    final future =
        query(APPROVALDOCINFOTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? ApprovalDocInfoTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return APPROVALDOCINFOTBLFluent<ApprovalDocInfoTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required APPROVALDOCINFOTBLUpdateManyMutationInput data,
    APPROVALDOCINFOTBLWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyAPPROVAL_DOC_INFO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyAPPROVAL_DOC_INFO_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyAPPROVALDOCINFOTBL) =>
        AffectedRowsOutput.fromJson(updateManyAPPROVALDOCINFOTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  APPROVALDOCINFOTBLFluent<ApprovalDocInfoTbl> upsert({
    required APPROVALDOCINFOTBLWhereUniqueInput where,
    required APPROVALDOCINFOTBLCreateInput create,
    required APPROVALDOCINFOTBLUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneAPPROVAL_DOC_INFO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneAPPROVAL_DOC_INFO_TBL',
    );
    final future = query(
            APPROVALDOCINFOTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ApprovalDocInfoTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: APPROVAL_DOC_INFO_TBL)'));
    return APPROVALDOCINFOTBLFluent<ApprovalDocInfoTbl>(
      future,
      query,
    );
  }

  APPROVALDOCINFOTBLFluent<ApprovalDocInfoTbl?> delete(
      {required APPROVALDOCINFOTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneAPPROVAL_DOC_INFO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneAPPROVAL_DOC_INFO_TBL',
    );
    final future =
        query(APPROVALDOCINFOTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? ApprovalDocInfoTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return APPROVALDOCINFOTBLFluent<ApprovalDocInfoTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({APPROVALDOCINFOTBLWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyAPPROVAL_DOC_INFO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyAPPROVAL_DOC_INFO_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyAPPROVALDOCINFOTBL) =>
        AffectedRowsOutput.fromJson(deleteManyAPPROVALDOCINFOTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateAPPROVALDOCINFOTBL aggregate({
    APPROVALDOCINFOTBLWhereInput? where,
    Iterable<APPROVALDOCINFOTBLOrderByWithRelationInput>? orderBy,
    APPROVALDOCINFOTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateAPPROVAL_DOC_INFO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateAPPROVAL_DOC_INFO_TBL',
    );
    return AggregateAPPROVALDOCINFOTBL(query);
  }

  Future<Iterable<APPROVALDOCINFOTBLGroupByOutputType>> groupBy({
    APPROVALDOCINFOTBLWhereInput? where,
    Iterable<APPROVALDOCINFOTBLOrderByWithAggregationInput>? orderBy,
    required Iterable<APPROVALDOCINFOTBLScalarFieldEnum> by,
    APPROVALDOCINFOTBLScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByAPPROVAL_DOC_INFO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByAPPROVAL_DOC_INFO_TBL',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByAPPROVALDOCINFOTBL) =>
        groupByAPPROVALDOCINFOTBL.map((Map groupByAPPROVALDOCINFOTBL) =>
            APPROVALDOCINFOTBLGroupByOutputType.fromJson(
                groupByAPPROVALDOCINFOTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension APPROVALHISTORYTBLModelDelegateExtension
    on _i1.ModelDelegate<ApprovalHistoryTbl> {
  APPROVALHISTORYTBLFluent<ApprovalHistoryTbl?> findUnique(
      {required APPROVALHISTORYTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueAPPROVAL_HISTORY_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueAPPROVAL_HISTORY_TBL',
    );
    final future =
        query(APPROVALHISTORYTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? ApprovalHistoryTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return APPROVALHISTORYTBLFluent<ApprovalHistoryTbl?>(
      future,
      query,
    );
  }

  APPROVALHISTORYTBLFluent<ApprovalHistoryTbl> findUniqueOrThrow(
      {required APPROVALHISTORYTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueAPPROVAL_HISTORY_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueAPPROVAL_HISTORY_TBLOrThrow',
    );
    final future = query(
            APPROVALHISTORYTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ApprovalHistoryTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: APPROVAL_HISTORY_TBL)'));
    return APPROVALHISTORYTBLFluent<ApprovalHistoryTbl>(
      future,
      query,
    );
  }

  APPROVALHISTORYTBLFluent<ApprovalHistoryTbl?> findFirst({
    APPROVALHISTORYTBLWhereInput? where,
    Iterable<APPROVALHISTORYTBLOrderByWithRelationInput>? orderBy,
    APPROVALHISTORYTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<APPROVALHISTORYTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstAPPROVAL_HISTORY_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstAPPROVAL_HISTORY_TBL',
    );
    final future =
        query(APPROVALHISTORYTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? ApprovalHistoryTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return APPROVALHISTORYTBLFluent<ApprovalHistoryTbl?>(
      future,
      query,
    );
  }

  APPROVALHISTORYTBLFluent<ApprovalHistoryTbl> findFirstOrThrow({
    APPROVALHISTORYTBLWhereInput? where,
    Iterable<APPROVALHISTORYTBLOrderByWithRelationInput>? orderBy,
    APPROVALHISTORYTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<APPROVALHISTORYTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstAPPROVAL_HISTORY_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstAPPROVAL_HISTORY_TBLOrThrow',
    );
    final future = query(
            APPROVALHISTORYTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ApprovalHistoryTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: APPROVAL_HISTORY_TBL)'));
    return APPROVALHISTORYTBLFluent<ApprovalHistoryTbl>(
      future,
      query,
    );
  }

  Future<Iterable<ApprovalHistoryTbl>> findMany({
    APPROVALHISTORYTBLWhereInput? where,
    Iterable<APPROVALHISTORYTBLOrderByWithRelationInput>? orderBy,
    APPROVALHISTORYTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<APPROVALHISTORYTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyAPPROVAL_HISTORY_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyAPPROVAL_HISTORY_TBL',
    );
    final fields = APPROVALHISTORYTBLScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyAPPROVALHISTORYTBL) =>
        findManyAPPROVALHISTORYTBL.map((Map findManyAPPROVALHISTORYTBL) =>
            ApprovalHistoryTbl.fromJson(findManyAPPROVALHISTORYTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  APPROVALHISTORYTBLFluent<ApprovalHistoryTbl> create(
      {required APPROVALHISTORYTBLCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneAPPROVAL_HISTORY_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneAPPROVAL_HISTORY_TBL',
    );
    final future = query(
            APPROVALHISTORYTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ApprovalHistoryTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: APPROVAL_HISTORY_TBL)'));
    return APPROVALHISTORYTBLFluent<ApprovalHistoryTbl>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<APPROVALHISTORYTBLCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyAPPROVAL_HISTORY_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyAPPROVAL_HISTORY_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyAPPROVALHISTORYTBL) =>
        AffectedRowsOutput.fromJson(createManyAPPROVALHISTORYTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  APPROVALHISTORYTBLFluent<ApprovalHistoryTbl?> update({
    required APPROVALHISTORYTBLUpdateInput data,
    required APPROVALHISTORYTBLWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneAPPROVAL_HISTORY_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneAPPROVAL_HISTORY_TBL',
    );
    final future =
        query(APPROVALHISTORYTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? ApprovalHistoryTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return APPROVALHISTORYTBLFluent<ApprovalHistoryTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required APPROVALHISTORYTBLUpdateManyMutationInput data,
    APPROVALHISTORYTBLWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyAPPROVAL_HISTORY_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyAPPROVAL_HISTORY_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyAPPROVALHISTORYTBL) =>
        AffectedRowsOutput.fromJson(updateManyAPPROVALHISTORYTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  APPROVALHISTORYTBLFluent<ApprovalHistoryTbl> upsert({
    required APPROVALHISTORYTBLWhereUniqueInput where,
    required APPROVALHISTORYTBLCreateInput create,
    required APPROVALHISTORYTBLUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneAPPROVAL_HISTORY_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneAPPROVAL_HISTORY_TBL',
    );
    final future = query(
            APPROVALHISTORYTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ApprovalHistoryTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: APPROVAL_HISTORY_TBL)'));
    return APPROVALHISTORYTBLFluent<ApprovalHistoryTbl>(
      future,
      query,
    );
  }

  APPROVALHISTORYTBLFluent<ApprovalHistoryTbl?> delete(
      {required APPROVALHISTORYTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneAPPROVAL_HISTORY_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneAPPROVAL_HISTORY_TBL',
    );
    final future =
        query(APPROVALHISTORYTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? ApprovalHistoryTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return APPROVALHISTORYTBLFluent<ApprovalHistoryTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({APPROVALHISTORYTBLWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyAPPROVAL_HISTORY_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyAPPROVAL_HISTORY_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyAPPROVALHISTORYTBL) =>
        AffectedRowsOutput.fromJson(deleteManyAPPROVALHISTORYTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateAPPROVALHISTORYTBL aggregate({
    APPROVALHISTORYTBLWhereInput? where,
    Iterable<APPROVALHISTORYTBLOrderByWithRelationInput>? orderBy,
    APPROVALHISTORYTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateAPPROVAL_HISTORY_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateAPPROVAL_HISTORY_TBL',
    );
    return AggregateAPPROVALHISTORYTBL(query);
  }

  Future<Iterable<APPROVALHISTORYTBLGroupByOutputType>> groupBy({
    APPROVALHISTORYTBLWhereInput? where,
    Iterable<APPROVALHISTORYTBLOrderByWithAggregationInput>? orderBy,
    required Iterable<APPROVALHISTORYTBLScalarFieldEnum> by,
    APPROVALHISTORYTBLScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByAPPROVAL_HISTORY_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByAPPROVAL_HISTORY_TBL',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByAPPROVALHISTORYTBL) =>
        groupByAPPROVALHISTORYTBL.map((Map groupByAPPROVALHISTORYTBL) =>
            APPROVALHISTORYTBLGroupByOutputType.fromJson(
                groupByAPPROVALHISTORYTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension APPROVALMASTERTBLModelDelegateExtension
    on _i1.ModelDelegate<ApprovalMasterTbl> {
  APPROVALMASTERTBLFluent<ApprovalMasterTbl?> findUnique(
      {required APPROVALMASTERTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueAPPROVAL_MASTER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueAPPROVAL_MASTER_TBL',
    );
    final future =
        query(APPROVALMASTERTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? ApprovalMasterTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return APPROVALMASTERTBLFluent<ApprovalMasterTbl?>(
      future,
      query,
    );
  }

  APPROVALMASTERTBLFluent<ApprovalMasterTbl> findUniqueOrThrow(
      {required APPROVALMASTERTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueAPPROVAL_MASTER_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueAPPROVAL_MASTER_TBLOrThrow',
    );
    final future = query(
            APPROVALMASTERTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ApprovalMasterTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: APPROVAL_MASTER_TBL)'));
    return APPROVALMASTERTBLFluent<ApprovalMasterTbl>(
      future,
      query,
    );
  }

  APPROVALMASTERTBLFluent<ApprovalMasterTbl?> findFirst({
    APPROVALMASTERTBLWhereInput? where,
    Iterable<APPROVALMASTERTBLOrderByWithRelationInput>? orderBy,
    APPROVALMASTERTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<APPROVALMASTERTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstAPPROVAL_MASTER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstAPPROVAL_MASTER_TBL',
    );
    final future =
        query(APPROVALMASTERTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? ApprovalMasterTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return APPROVALMASTERTBLFluent<ApprovalMasterTbl?>(
      future,
      query,
    );
  }

  APPROVALMASTERTBLFluent<ApprovalMasterTbl> findFirstOrThrow({
    APPROVALMASTERTBLWhereInput? where,
    Iterable<APPROVALMASTERTBLOrderByWithRelationInput>? orderBy,
    APPROVALMASTERTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<APPROVALMASTERTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstAPPROVAL_MASTER_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstAPPROVAL_MASTER_TBLOrThrow',
    );
    final future = query(
            APPROVALMASTERTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ApprovalMasterTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: APPROVAL_MASTER_TBL)'));
    return APPROVALMASTERTBLFluent<ApprovalMasterTbl>(
      future,
      query,
    );
  }

  Future<Iterable<ApprovalMasterTbl>> findMany({
    APPROVALMASTERTBLWhereInput? where,
    Iterable<APPROVALMASTERTBLOrderByWithRelationInput>? orderBy,
    APPROVALMASTERTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<APPROVALMASTERTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyAPPROVAL_MASTER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyAPPROVAL_MASTER_TBL',
    );
    final fields = APPROVALMASTERTBLScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyAPPROVALMASTERTBL) =>
        findManyAPPROVALMASTERTBL.map((Map findManyAPPROVALMASTERTBL) =>
            ApprovalMasterTbl.fromJson(findManyAPPROVALMASTERTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  APPROVALMASTERTBLFluent<ApprovalMasterTbl> create(
      {required APPROVALMASTERTBLCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneAPPROVAL_MASTER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneAPPROVAL_MASTER_TBL',
    );
    final future = query(
            APPROVALMASTERTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ApprovalMasterTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: APPROVAL_MASTER_TBL)'));
    return APPROVALMASTERTBLFluent<ApprovalMasterTbl>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<APPROVALMASTERTBLCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyAPPROVAL_MASTER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyAPPROVAL_MASTER_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyAPPROVALMASTERTBL) =>
        AffectedRowsOutput.fromJson(createManyAPPROVALMASTERTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  APPROVALMASTERTBLFluent<ApprovalMasterTbl?> update({
    required APPROVALMASTERTBLUpdateInput data,
    required APPROVALMASTERTBLWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneAPPROVAL_MASTER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneAPPROVAL_MASTER_TBL',
    );
    final future =
        query(APPROVALMASTERTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? ApprovalMasterTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return APPROVALMASTERTBLFluent<ApprovalMasterTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required APPROVALMASTERTBLUpdateManyMutationInput data,
    APPROVALMASTERTBLWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyAPPROVAL_MASTER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyAPPROVAL_MASTER_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyAPPROVALMASTERTBL) =>
        AffectedRowsOutput.fromJson(updateManyAPPROVALMASTERTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  APPROVALMASTERTBLFluent<ApprovalMasterTbl> upsert({
    required APPROVALMASTERTBLWhereUniqueInput where,
    required APPROVALMASTERTBLCreateInput create,
    required APPROVALMASTERTBLUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneAPPROVAL_MASTER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneAPPROVAL_MASTER_TBL',
    );
    final future = query(
            APPROVALMASTERTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ApprovalMasterTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: APPROVAL_MASTER_TBL)'));
    return APPROVALMASTERTBLFluent<ApprovalMasterTbl>(
      future,
      query,
    );
  }

  APPROVALMASTERTBLFluent<ApprovalMasterTbl?> delete(
      {required APPROVALMASTERTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneAPPROVAL_MASTER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneAPPROVAL_MASTER_TBL',
    );
    final future =
        query(APPROVALMASTERTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? ApprovalMasterTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return APPROVALMASTERTBLFluent<ApprovalMasterTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({APPROVALMASTERTBLWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyAPPROVAL_MASTER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyAPPROVAL_MASTER_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyAPPROVALMASTERTBL) =>
        AffectedRowsOutput.fromJson(deleteManyAPPROVALMASTERTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateAPPROVALMASTERTBL aggregate({
    APPROVALMASTERTBLWhereInput? where,
    Iterable<APPROVALMASTERTBLOrderByWithRelationInput>? orderBy,
    APPROVALMASTERTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateAPPROVAL_MASTER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateAPPROVAL_MASTER_TBL',
    );
    return AggregateAPPROVALMASTERTBL(query);
  }

  Future<Iterable<APPROVALMASTERTBLGroupByOutputType>> groupBy({
    APPROVALMASTERTBLWhereInput? where,
    Iterable<APPROVALMASTERTBLOrderByWithAggregationInput>? orderBy,
    required Iterable<APPROVALMASTERTBLScalarFieldEnum> by,
    APPROVALMASTERTBLScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByAPPROVAL_MASTER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByAPPROVAL_MASTER_TBL',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByAPPROVALMASTERTBL) =>
        groupByAPPROVALMASTERTBL.map((Map groupByAPPROVALMASTERTBL) =>
            APPROVALMASTERTBLGroupByOutputType.fromJson(
                groupByAPPROVALMASTERTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension APPROVALMEMOTBLModelDelegateExtension
    on _i1.ModelDelegate<ApprovalMemoTbl> {
  APPROVALMEMOTBLFluent<ApprovalMemoTbl?> findUnique(
      {required APPROVALMEMOTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueAPPROVAL_MEMO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueAPPROVAL_MEMO_TBL',
    );
    final future =
        query(APPROVALMEMOTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? ApprovalMemoTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return APPROVALMEMOTBLFluent<ApprovalMemoTbl?>(
      future,
      query,
    );
  }

  APPROVALMEMOTBLFluent<ApprovalMemoTbl> findUniqueOrThrow(
      {required APPROVALMEMOTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueAPPROVAL_MEMO_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueAPPROVAL_MEMO_TBLOrThrow',
    );
    final future = query(
            APPROVALMEMOTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ApprovalMemoTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: APPROVAL_MEMO_TBL)'));
    return APPROVALMEMOTBLFluent<ApprovalMemoTbl>(
      future,
      query,
    );
  }

  APPROVALMEMOTBLFluent<ApprovalMemoTbl?> findFirst({
    APPROVALMEMOTBLWhereInput? where,
    Iterable<APPROVALMEMOTBLOrderByWithRelationInput>? orderBy,
    APPROVALMEMOTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<APPROVALMEMOTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstAPPROVAL_MEMO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstAPPROVAL_MEMO_TBL',
    );
    final future =
        query(APPROVALMEMOTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? ApprovalMemoTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return APPROVALMEMOTBLFluent<ApprovalMemoTbl?>(
      future,
      query,
    );
  }

  APPROVALMEMOTBLFluent<ApprovalMemoTbl> findFirstOrThrow({
    APPROVALMEMOTBLWhereInput? where,
    Iterable<APPROVALMEMOTBLOrderByWithRelationInput>? orderBy,
    APPROVALMEMOTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<APPROVALMEMOTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstAPPROVAL_MEMO_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstAPPROVAL_MEMO_TBLOrThrow',
    );
    final future = query(
            APPROVALMEMOTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ApprovalMemoTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: APPROVAL_MEMO_TBL)'));
    return APPROVALMEMOTBLFluent<ApprovalMemoTbl>(
      future,
      query,
    );
  }

  Future<Iterable<ApprovalMemoTbl>> findMany({
    APPROVALMEMOTBLWhereInput? where,
    Iterable<APPROVALMEMOTBLOrderByWithRelationInput>? orderBy,
    APPROVALMEMOTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<APPROVALMEMOTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyAPPROVAL_MEMO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyAPPROVAL_MEMO_TBL',
    );
    final fields = APPROVALMEMOTBLScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyAPPROVALMEMOTBL) =>
        findManyAPPROVALMEMOTBL.map((Map findManyAPPROVALMEMOTBL) =>
            ApprovalMemoTbl.fromJson(findManyAPPROVALMEMOTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  APPROVALMEMOTBLFluent<ApprovalMemoTbl> create(
      {required APPROVALMEMOTBLCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneAPPROVAL_MEMO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneAPPROVAL_MEMO_TBL',
    );
    final future = query(
            APPROVALMEMOTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ApprovalMemoTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: APPROVAL_MEMO_TBL)'));
    return APPROVALMEMOTBLFluent<ApprovalMemoTbl>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<APPROVALMEMOTBLCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyAPPROVAL_MEMO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyAPPROVAL_MEMO_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyAPPROVALMEMOTBL) =>
        AffectedRowsOutput.fromJson(createManyAPPROVALMEMOTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  APPROVALMEMOTBLFluent<ApprovalMemoTbl?> update({
    required APPROVALMEMOTBLUpdateInput data,
    required APPROVALMEMOTBLWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneAPPROVAL_MEMO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneAPPROVAL_MEMO_TBL',
    );
    final future =
        query(APPROVALMEMOTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? ApprovalMemoTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return APPROVALMEMOTBLFluent<ApprovalMemoTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required APPROVALMEMOTBLUpdateManyMutationInput data,
    APPROVALMEMOTBLWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyAPPROVAL_MEMO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyAPPROVAL_MEMO_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyAPPROVALMEMOTBL) =>
        AffectedRowsOutput.fromJson(updateManyAPPROVALMEMOTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  APPROVALMEMOTBLFluent<ApprovalMemoTbl> upsert({
    required APPROVALMEMOTBLWhereUniqueInput where,
    required APPROVALMEMOTBLCreateInput create,
    required APPROVALMEMOTBLUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneAPPROVAL_MEMO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneAPPROVAL_MEMO_TBL',
    );
    final future = query(
            APPROVALMEMOTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ApprovalMemoTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: APPROVAL_MEMO_TBL)'));
    return APPROVALMEMOTBLFluent<ApprovalMemoTbl>(
      future,
      query,
    );
  }

  APPROVALMEMOTBLFluent<ApprovalMemoTbl?> delete(
      {required APPROVALMEMOTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneAPPROVAL_MEMO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneAPPROVAL_MEMO_TBL',
    );
    final future =
        query(APPROVALMEMOTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? ApprovalMemoTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return APPROVALMEMOTBLFluent<ApprovalMemoTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({APPROVALMEMOTBLWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyAPPROVAL_MEMO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyAPPROVAL_MEMO_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyAPPROVALMEMOTBL) =>
        AffectedRowsOutput.fromJson(deleteManyAPPROVALMEMOTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateAPPROVALMEMOTBL aggregate({
    APPROVALMEMOTBLWhereInput? where,
    Iterable<APPROVALMEMOTBLOrderByWithRelationInput>? orderBy,
    APPROVALMEMOTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateAPPROVAL_MEMO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateAPPROVAL_MEMO_TBL',
    );
    return AggregateAPPROVALMEMOTBL(query);
  }

  Future<Iterable<APPROVALMEMOTBLGroupByOutputType>> groupBy({
    APPROVALMEMOTBLWhereInput? where,
    Iterable<APPROVALMEMOTBLOrderByWithAggregationInput>? orderBy,
    required Iterable<APPROVALMEMOTBLScalarFieldEnum> by,
    APPROVALMEMOTBLScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByAPPROVAL_MEMO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByAPPROVAL_MEMO_TBL',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByAPPROVALMEMOTBL) =>
        groupByAPPROVALMEMOTBL.map((Map groupByAPPROVALMEMOTBL) =>
            APPROVALMEMOTBLGroupByOutputType.fromJson(
                groupByAPPROVALMEMOTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension APPROVALTYPETBLModelDelegateExtension
    on _i1.ModelDelegate<ApprovalTypeTbl> {
  APPROVALTYPETBLFluent<ApprovalTypeTbl?> findUnique(
      {required APPROVALTYPETBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueAPPROVAL_TYPE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueAPPROVAL_TYPE_TBL',
    );
    final future =
        query(APPROVALTYPETBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? ApprovalTypeTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return APPROVALTYPETBLFluent<ApprovalTypeTbl?>(
      future,
      query,
    );
  }

  APPROVALTYPETBLFluent<ApprovalTypeTbl> findUniqueOrThrow(
      {required APPROVALTYPETBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueAPPROVAL_TYPE_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueAPPROVAL_TYPE_TBLOrThrow',
    );
    final future = query(
            APPROVALTYPETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ApprovalTypeTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: APPROVAL_TYPE_TBL)'));
    return APPROVALTYPETBLFluent<ApprovalTypeTbl>(
      future,
      query,
    );
  }

  APPROVALTYPETBLFluent<ApprovalTypeTbl?> findFirst({
    APPROVALTYPETBLWhereInput? where,
    Iterable<APPROVALTYPETBLOrderByWithRelationInput>? orderBy,
    APPROVALTYPETBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<APPROVALTYPETBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstAPPROVAL_TYPE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstAPPROVAL_TYPE_TBL',
    );
    final future =
        query(APPROVALTYPETBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? ApprovalTypeTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return APPROVALTYPETBLFluent<ApprovalTypeTbl?>(
      future,
      query,
    );
  }

  APPROVALTYPETBLFluent<ApprovalTypeTbl> findFirstOrThrow({
    APPROVALTYPETBLWhereInput? where,
    Iterable<APPROVALTYPETBLOrderByWithRelationInput>? orderBy,
    APPROVALTYPETBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<APPROVALTYPETBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstAPPROVAL_TYPE_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstAPPROVAL_TYPE_TBLOrThrow',
    );
    final future = query(
            APPROVALTYPETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ApprovalTypeTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: APPROVAL_TYPE_TBL)'));
    return APPROVALTYPETBLFluent<ApprovalTypeTbl>(
      future,
      query,
    );
  }

  Future<Iterable<ApprovalTypeTbl>> findMany({
    APPROVALTYPETBLWhereInput? where,
    Iterable<APPROVALTYPETBLOrderByWithRelationInput>? orderBy,
    APPROVALTYPETBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<APPROVALTYPETBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyAPPROVAL_TYPE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyAPPROVAL_TYPE_TBL',
    );
    final fields = APPROVALTYPETBLScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyAPPROVALTYPETBL) =>
        findManyAPPROVALTYPETBL.map((Map findManyAPPROVALTYPETBL) =>
            ApprovalTypeTbl.fromJson(findManyAPPROVALTYPETBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  APPROVALTYPETBLFluent<ApprovalTypeTbl> create(
      {required APPROVALTYPETBLCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneAPPROVAL_TYPE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneAPPROVAL_TYPE_TBL',
    );
    final future = query(
            APPROVALTYPETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ApprovalTypeTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: APPROVAL_TYPE_TBL)'));
    return APPROVALTYPETBLFluent<ApprovalTypeTbl>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<APPROVALTYPETBLCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyAPPROVAL_TYPE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyAPPROVAL_TYPE_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyAPPROVALTYPETBL) =>
        AffectedRowsOutput.fromJson(createManyAPPROVALTYPETBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  APPROVALTYPETBLFluent<ApprovalTypeTbl?> update({
    required APPROVALTYPETBLUpdateInput data,
    required APPROVALTYPETBLWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneAPPROVAL_TYPE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneAPPROVAL_TYPE_TBL',
    );
    final future =
        query(APPROVALTYPETBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? ApprovalTypeTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return APPROVALTYPETBLFluent<ApprovalTypeTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required APPROVALTYPETBLUpdateManyMutationInput data,
    APPROVALTYPETBLWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyAPPROVAL_TYPE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyAPPROVAL_TYPE_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyAPPROVALTYPETBL) =>
        AffectedRowsOutput.fromJson(updateManyAPPROVALTYPETBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  APPROVALTYPETBLFluent<ApprovalTypeTbl> upsert({
    required APPROVALTYPETBLWhereUniqueInput where,
    required APPROVALTYPETBLCreateInput create,
    required APPROVALTYPETBLUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneAPPROVAL_TYPE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneAPPROVAL_TYPE_TBL',
    );
    final future = query(
            APPROVALTYPETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ApprovalTypeTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: APPROVAL_TYPE_TBL)'));
    return APPROVALTYPETBLFluent<ApprovalTypeTbl>(
      future,
      query,
    );
  }

  APPROVALTYPETBLFluent<ApprovalTypeTbl?> delete(
      {required APPROVALTYPETBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneAPPROVAL_TYPE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneAPPROVAL_TYPE_TBL',
    );
    final future =
        query(APPROVALTYPETBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? ApprovalTypeTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return APPROVALTYPETBLFluent<ApprovalTypeTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({APPROVALTYPETBLWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyAPPROVAL_TYPE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyAPPROVAL_TYPE_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyAPPROVALTYPETBL) =>
        AffectedRowsOutput.fromJson(deleteManyAPPROVALTYPETBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateAPPROVALTYPETBL aggregate({
    APPROVALTYPETBLWhereInput? where,
    Iterable<APPROVALTYPETBLOrderByWithRelationInput>? orderBy,
    APPROVALTYPETBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateAPPROVAL_TYPE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateAPPROVAL_TYPE_TBL',
    );
    return AggregateAPPROVALTYPETBL(query);
  }

  Future<Iterable<APPROVALTYPETBLGroupByOutputType>> groupBy({
    APPROVALTYPETBLWhereInput? where,
    Iterable<APPROVALTYPETBLOrderByWithAggregationInput>? orderBy,
    required Iterable<APPROVALTYPETBLScalarFieldEnum> by,
    APPROVALTYPETBLScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByAPPROVAL_TYPE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByAPPROVAL_TYPE_TBL',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByAPPROVALTYPETBL) =>
        groupByAPPROVALTYPETBL.map((Map groupByAPPROVALTYPETBL) =>
            APPROVALTYPETBLGroupByOutputType.fromJson(
                groupByAPPROVALTYPETBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension APPROVALUSERTBLModelDelegateExtension
    on _i1.ModelDelegate<ApprovalUserTbl> {
  APPROVALUSERTBLFluent<ApprovalUserTbl?> findUnique(
      {required APPROVALUSERTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueAPPROVAL_USER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueAPPROVAL_USER_TBL',
    );
    final future =
        query(APPROVALUSERTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? ApprovalUserTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return APPROVALUSERTBLFluent<ApprovalUserTbl?>(
      future,
      query,
    );
  }

  APPROVALUSERTBLFluent<ApprovalUserTbl> findUniqueOrThrow(
      {required APPROVALUSERTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueAPPROVAL_USER_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueAPPROVAL_USER_TBLOrThrow',
    );
    final future = query(
            APPROVALUSERTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ApprovalUserTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: APPROVAL_USER_TBL)'));
    return APPROVALUSERTBLFluent<ApprovalUserTbl>(
      future,
      query,
    );
  }

  APPROVALUSERTBLFluent<ApprovalUserTbl?> findFirst({
    APPROVALUSERTBLWhereInput? where,
    Iterable<APPROVALUSERTBLOrderByWithRelationInput>? orderBy,
    APPROVALUSERTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<APPROVALUSERTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstAPPROVAL_USER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstAPPROVAL_USER_TBL',
    );
    final future =
        query(APPROVALUSERTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? ApprovalUserTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return APPROVALUSERTBLFluent<ApprovalUserTbl?>(
      future,
      query,
    );
  }

  APPROVALUSERTBLFluent<ApprovalUserTbl> findFirstOrThrow({
    APPROVALUSERTBLWhereInput? where,
    Iterable<APPROVALUSERTBLOrderByWithRelationInput>? orderBy,
    APPROVALUSERTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<APPROVALUSERTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstAPPROVAL_USER_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstAPPROVAL_USER_TBLOrThrow',
    );
    final future = query(
            APPROVALUSERTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ApprovalUserTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: APPROVAL_USER_TBL)'));
    return APPROVALUSERTBLFluent<ApprovalUserTbl>(
      future,
      query,
    );
  }

  Future<Iterable<ApprovalUserTbl>> findMany({
    APPROVALUSERTBLWhereInput? where,
    Iterable<APPROVALUSERTBLOrderByWithRelationInput>? orderBy,
    APPROVALUSERTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<APPROVALUSERTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyAPPROVAL_USER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyAPPROVAL_USER_TBL',
    );
    final fields = APPROVALUSERTBLScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyAPPROVALUSERTBL) =>
        findManyAPPROVALUSERTBL.map((Map findManyAPPROVALUSERTBL) =>
            ApprovalUserTbl.fromJson(findManyAPPROVALUSERTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  APPROVALUSERTBLFluent<ApprovalUserTbl> create(
      {required APPROVALUSERTBLCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneAPPROVAL_USER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneAPPROVAL_USER_TBL',
    );
    final future = query(
            APPROVALUSERTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ApprovalUserTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: APPROVAL_USER_TBL)'));
    return APPROVALUSERTBLFluent<ApprovalUserTbl>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<APPROVALUSERTBLCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyAPPROVAL_USER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyAPPROVAL_USER_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyAPPROVALUSERTBL) =>
        AffectedRowsOutput.fromJson(createManyAPPROVALUSERTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  APPROVALUSERTBLFluent<ApprovalUserTbl?> update({
    required APPROVALUSERTBLUpdateInput data,
    required APPROVALUSERTBLWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneAPPROVAL_USER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneAPPROVAL_USER_TBL',
    );
    final future =
        query(APPROVALUSERTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? ApprovalUserTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return APPROVALUSERTBLFluent<ApprovalUserTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required APPROVALUSERTBLUpdateManyMutationInput data,
    APPROVALUSERTBLWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyAPPROVAL_USER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyAPPROVAL_USER_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyAPPROVALUSERTBL) =>
        AffectedRowsOutput.fromJson(updateManyAPPROVALUSERTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  APPROVALUSERTBLFluent<ApprovalUserTbl> upsert({
    required APPROVALUSERTBLWhereUniqueInput where,
    required APPROVALUSERTBLCreateInput create,
    required APPROVALUSERTBLUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneAPPROVAL_USER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneAPPROVAL_USER_TBL',
    );
    final future = query(
            APPROVALUSERTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ApprovalUserTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: APPROVAL_USER_TBL)'));
    return APPROVALUSERTBLFluent<ApprovalUserTbl>(
      future,
      query,
    );
  }

  APPROVALUSERTBLFluent<ApprovalUserTbl?> delete(
      {required APPROVALUSERTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneAPPROVAL_USER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneAPPROVAL_USER_TBL',
    );
    final future =
        query(APPROVALUSERTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? ApprovalUserTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return APPROVALUSERTBLFluent<ApprovalUserTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({APPROVALUSERTBLWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyAPPROVAL_USER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyAPPROVAL_USER_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyAPPROVALUSERTBL) =>
        AffectedRowsOutput.fromJson(deleteManyAPPROVALUSERTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateAPPROVALUSERTBL aggregate({
    APPROVALUSERTBLWhereInput? where,
    Iterable<APPROVALUSERTBLOrderByWithRelationInput>? orderBy,
    APPROVALUSERTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateAPPROVAL_USER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateAPPROVAL_USER_TBL',
    );
    return AggregateAPPROVALUSERTBL(query);
  }

  Future<Iterable<APPROVALUSERTBLGroupByOutputType>> groupBy({
    APPROVALUSERTBLWhereInput? where,
    Iterable<APPROVALUSERTBLOrderByWithAggregationInput>? orderBy,
    required Iterable<APPROVALUSERTBLScalarFieldEnum> by,
    APPROVALUSERTBLScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByAPPROVAL_USER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByAPPROVAL_USER_TBL',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByAPPROVALUSERTBL) =>
        groupByAPPROVALUSERTBL.map((Map groupByAPPROVALUSERTBL) =>
            APPROVALUSERTBLGroupByOutputType.fromJson(
                groupByAPPROVALUSERTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension BOOKASSETTBLModelDelegateExtension
    on _i1.ModelDelegate<BookAssetTbl> {
  BOOKASSETTBLFluent<BookAssetTbl?> findUnique(
      {required BOOKASSETTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueBOOK_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueBOOK_ASSET_TBL',
    );
    final future = query(BOOKASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? BookAssetTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return BOOKASSETTBLFluent<BookAssetTbl?>(
      future,
      query,
    );
  }

  BOOKASSETTBLFluent<BookAssetTbl> findUniqueOrThrow(
      {required BOOKASSETTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueBOOK_ASSET_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueBOOK_ASSET_TBLOrThrow',
    );
    final future = query(BOOKASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? BookAssetTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: BOOK_ASSET_TBL)'));
    return BOOKASSETTBLFluent<BookAssetTbl>(
      future,
      query,
    );
  }

  BOOKASSETTBLFluent<BookAssetTbl?> findFirst({
    BOOKASSETTBLWhereInput? where,
    Iterable<BOOKASSETTBLOrderByWithRelationInput>? orderBy,
    BOOKASSETTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<BOOKASSETTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstBOOK_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstBOOK_ASSET_TBL',
    );
    final future = query(BOOKASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? BookAssetTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return BOOKASSETTBLFluent<BookAssetTbl?>(
      future,
      query,
    );
  }

  BOOKASSETTBLFluent<BookAssetTbl> findFirstOrThrow({
    BOOKASSETTBLWhereInput? where,
    Iterable<BOOKASSETTBLOrderByWithRelationInput>? orderBy,
    BOOKASSETTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<BOOKASSETTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstBOOK_ASSET_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstBOOK_ASSET_TBLOrThrow',
    );
    final future = query(BOOKASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? BookAssetTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: BOOK_ASSET_TBL)'));
    return BOOKASSETTBLFluent<BookAssetTbl>(
      future,
      query,
    );
  }

  Future<Iterable<BookAssetTbl>> findMany({
    BOOKASSETTBLWhereInput? where,
    Iterable<BOOKASSETTBLOrderByWithRelationInput>? orderBy,
    BOOKASSETTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<BOOKASSETTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyBOOK_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyBOOK_ASSET_TBL',
    );
    final fields = BOOKASSETTBLScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyBOOKASSETTBL) =>
        findManyBOOKASSETTBL.map((Map findManyBOOKASSETTBL) =>
            BookAssetTbl.fromJson(findManyBOOKASSETTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  BOOKASSETTBLFluent<BookAssetTbl> create(
      {required BOOKASSETTBLCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneBOOK_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneBOOK_ASSET_TBL',
    );
    final future = query(BOOKASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? BookAssetTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: BOOK_ASSET_TBL)'));
    return BOOKASSETTBLFluent<BookAssetTbl>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<BOOKASSETTBLCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyBOOK_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyBOOK_ASSET_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyBOOKASSETTBL) =>
        AffectedRowsOutput.fromJson(createManyBOOKASSETTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  BOOKASSETTBLFluent<BookAssetTbl?> update({
    required BOOKASSETTBLUpdateInput data,
    required BOOKASSETTBLWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneBOOK_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneBOOK_ASSET_TBL',
    );
    final future = query(BOOKASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? BookAssetTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return BOOKASSETTBLFluent<BookAssetTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required BOOKASSETTBLUpdateManyMutationInput data,
    BOOKASSETTBLWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyBOOK_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyBOOK_ASSET_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyBOOKASSETTBL) =>
        AffectedRowsOutput.fromJson(updateManyBOOKASSETTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  BOOKASSETTBLFluent<BookAssetTbl> upsert({
    required BOOKASSETTBLWhereUniqueInput where,
    required BOOKASSETTBLCreateInput create,
    required BOOKASSETTBLUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneBOOK_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneBOOK_ASSET_TBL',
    );
    final future = query(BOOKASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? BookAssetTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: BOOK_ASSET_TBL)'));
    return BOOKASSETTBLFluent<BookAssetTbl>(
      future,
      query,
    );
  }

  BOOKASSETTBLFluent<BookAssetTbl?> delete(
      {required BOOKASSETTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneBOOK_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneBOOK_ASSET_TBL',
    );
    final future = query(BOOKASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? BookAssetTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return BOOKASSETTBLFluent<BookAssetTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({BOOKASSETTBLWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyBOOK_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyBOOK_ASSET_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyBOOKASSETTBL) =>
        AffectedRowsOutput.fromJson(deleteManyBOOKASSETTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateBOOKASSETTBL aggregate({
    BOOKASSETTBLWhereInput? where,
    Iterable<BOOKASSETTBLOrderByWithRelationInput>? orderBy,
    BOOKASSETTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateBOOK_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateBOOK_ASSET_TBL',
    );
    return AggregateBOOKASSETTBL(query);
  }

  Future<Iterable<BOOKASSETTBLGroupByOutputType>> groupBy({
    BOOKASSETTBLWhereInput? where,
    Iterable<BOOKASSETTBLOrderByWithAggregationInput>? orderBy,
    required Iterable<BOOKASSETTBLScalarFieldEnum> by,
    BOOKASSETTBLScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByBOOK_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByBOOK_ASSET_TBL',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByBOOKASSETTBL) =>
        groupByBOOKASSETTBL.map((Map groupByBOOKASSETTBL) =>
            BOOKASSETTBLGroupByOutputType.fromJson(groupByBOOKASSETTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension CARASSETINSURTBLModelDelegateExtension
    on _i1.ModelDelegate<CarAssetInsurTbl> {
  CARASSETINSURTBLFluent<CarAssetInsurTbl?> findUnique(
      {required CARASSETINSURTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueCAR_ASSET_INSUR_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueCAR_ASSET_INSUR_TBL',
    );
    final future =
        query(CARASSETINSURTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? CarAssetInsurTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return CARASSETINSURTBLFluent<CarAssetInsurTbl?>(
      future,
      query,
    );
  }

  CARASSETINSURTBLFluent<CarAssetInsurTbl> findUniqueOrThrow(
      {required CARASSETINSURTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueCAR_ASSET_INSUR_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueCAR_ASSET_INSUR_TBLOrThrow',
    );
    final future = query(
            CARASSETINSURTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarAssetInsurTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: CAR_ASSET_INSUR_TBL)'));
    return CARASSETINSURTBLFluent<CarAssetInsurTbl>(
      future,
      query,
    );
  }

  CARASSETINSURTBLFluent<CarAssetInsurTbl?> findFirst({
    CARASSETINSURTBLWhereInput? where,
    Iterable<CARASSETINSURTBLOrderByWithRelationInput>? orderBy,
    CARASSETINSURTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<CARASSETINSURTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstCAR_ASSET_INSUR_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstCAR_ASSET_INSUR_TBL',
    );
    final future =
        query(CARASSETINSURTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? CarAssetInsurTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return CARASSETINSURTBLFluent<CarAssetInsurTbl?>(
      future,
      query,
    );
  }

  CARASSETINSURTBLFluent<CarAssetInsurTbl> findFirstOrThrow({
    CARASSETINSURTBLWhereInput? where,
    Iterable<CARASSETINSURTBLOrderByWithRelationInput>? orderBy,
    CARASSETINSURTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<CARASSETINSURTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstCAR_ASSET_INSUR_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstCAR_ASSET_INSUR_TBLOrThrow',
    );
    final future = query(
            CARASSETINSURTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarAssetInsurTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: CAR_ASSET_INSUR_TBL)'));
    return CARASSETINSURTBLFluent<CarAssetInsurTbl>(
      future,
      query,
    );
  }

  Future<Iterable<CarAssetInsurTbl>> findMany({
    CARASSETINSURTBLWhereInput? where,
    Iterable<CARASSETINSURTBLOrderByWithRelationInput>? orderBy,
    CARASSETINSURTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<CARASSETINSURTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyCAR_ASSET_INSUR_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyCAR_ASSET_INSUR_TBL',
    );
    final fields = CARASSETINSURTBLScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyCARASSETINSURTBL) =>
        findManyCARASSETINSURTBL.map((Map findManyCARASSETINSURTBL) =>
            CarAssetInsurTbl.fromJson(findManyCARASSETINSURTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  CARASSETINSURTBLFluent<CarAssetInsurTbl> create(
      {required CARASSETINSURTBLCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneCAR_ASSET_INSUR_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneCAR_ASSET_INSUR_TBL',
    );
    final future = query(
            CARASSETINSURTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarAssetInsurTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: CAR_ASSET_INSUR_TBL)'));
    return CARASSETINSURTBLFluent<CarAssetInsurTbl>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<CARASSETINSURTBLCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyCAR_ASSET_INSUR_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyCAR_ASSET_INSUR_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyCARASSETINSURTBL) =>
        AffectedRowsOutput.fromJson(createManyCARASSETINSURTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  CARASSETINSURTBLFluent<CarAssetInsurTbl?> update({
    required CARASSETINSURTBLUpdateInput data,
    required CARASSETINSURTBLWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneCAR_ASSET_INSUR_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneCAR_ASSET_INSUR_TBL',
    );
    final future =
        query(CARASSETINSURTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? CarAssetInsurTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return CARASSETINSURTBLFluent<CarAssetInsurTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required CARASSETINSURTBLUpdateManyMutationInput data,
    CARASSETINSURTBLWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyCAR_ASSET_INSUR_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyCAR_ASSET_INSUR_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyCARASSETINSURTBL) =>
        AffectedRowsOutput.fromJson(updateManyCARASSETINSURTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  CARASSETINSURTBLFluent<CarAssetInsurTbl> upsert({
    required CARASSETINSURTBLWhereUniqueInput where,
    required CARASSETINSURTBLCreateInput create,
    required CARASSETINSURTBLUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneCAR_ASSET_INSUR_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneCAR_ASSET_INSUR_TBL',
    );
    final future = query(
            CARASSETINSURTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarAssetInsurTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: CAR_ASSET_INSUR_TBL)'));
    return CARASSETINSURTBLFluent<CarAssetInsurTbl>(
      future,
      query,
    );
  }

  CARASSETINSURTBLFluent<CarAssetInsurTbl?> delete(
      {required CARASSETINSURTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneCAR_ASSET_INSUR_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneCAR_ASSET_INSUR_TBL',
    );
    final future =
        query(CARASSETINSURTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? CarAssetInsurTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return CARASSETINSURTBLFluent<CarAssetInsurTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({CARASSETINSURTBLWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyCAR_ASSET_INSUR_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyCAR_ASSET_INSUR_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyCARASSETINSURTBL) =>
        AffectedRowsOutput.fromJson(deleteManyCARASSETINSURTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateCARASSETINSURTBL aggregate({
    CARASSETINSURTBLWhereInput? where,
    Iterable<CARASSETINSURTBLOrderByWithRelationInput>? orderBy,
    CARASSETINSURTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateCAR_ASSET_INSUR_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateCAR_ASSET_INSUR_TBL',
    );
    return AggregateCARASSETINSURTBL(query);
  }

  Future<Iterable<CARASSETINSURTBLGroupByOutputType>> groupBy({
    CARASSETINSURTBLWhereInput? where,
    Iterable<CARASSETINSURTBLOrderByWithAggregationInput>? orderBy,
    required Iterable<CARASSETINSURTBLScalarFieldEnum> by,
    CARASSETINSURTBLScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByCAR_ASSET_INSUR_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByCAR_ASSET_INSUR_TBL',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByCARASSETINSURTBL) =>
        groupByCARASSETINSURTBL.map((Map groupByCARASSETINSURTBL) =>
            CARASSETINSURTBLGroupByOutputType.fromJson(
                groupByCARASSETINSURTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension CARASSETTBLModelDelegateExtension on _i1.ModelDelegate<CarAssetTbl> {
  CARASSETTBLFluent<CarAssetTbl?> findUnique(
      {required CARASSETTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueCAR_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueCAR_ASSET_TBL',
    );
    final future = query(CARASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarAssetTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return CARASSETTBLFluent<CarAssetTbl?>(
      future,
      query,
    );
  }

  CARASSETTBLFluent<CarAssetTbl> findUniqueOrThrow(
      {required CARASSETTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueCAR_ASSET_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueCAR_ASSET_TBLOrThrow',
    );
    final future = query(CARASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarAssetTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: CAR_ASSET_TBL)'));
    return CARASSETTBLFluent<CarAssetTbl>(
      future,
      query,
    );
  }

  CARASSETTBLFluent<CarAssetTbl?> findFirst({
    CARASSETTBLWhereInput? where,
    Iterable<CARASSETTBLOrderByWithRelationInput>? orderBy,
    CARASSETTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<CARASSETTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstCAR_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstCAR_ASSET_TBL',
    );
    final future = query(CARASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarAssetTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return CARASSETTBLFluent<CarAssetTbl?>(
      future,
      query,
    );
  }

  CARASSETTBLFluent<CarAssetTbl> findFirstOrThrow({
    CARASSETTBLWhereInput? where,
    Iterable<CARASSETTBLOrderByWithRelationInput>? orderBy,
    CARASSETTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<CARASSETTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstCAR_ASSET_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstCAR_ASSET_TBLOrThrow',
    );
    final future = query(CARASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarAssetTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: CAR_ASSET_TBL)'));
    return CARASSETTBLFluent<CarAssetTbl>(
      future,
      query,
    );
  }

  Future<Iterable<CarAssetTbl>> findMany({
    CARASSETTBLWhereInput? where,
    Iterable<CARASSETTBLOrderByWithRelationInput>? orderBy,
    CARASSETTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<CARASSETTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyCAR_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyCAR_ASSET_TBL',
    );
    final fields = CARASSETTBLScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyCARASSETTBL) =>
        findManyCARASSETTBL.map((Map findManyCARASSETTBL) =>
            CarAssetTbl.fromJson(findManyCARASSETTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  CARASSETTBLFluent<CarAssetTbl> create(
      {required CARASSETTBLCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneCAR_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneCAR_ASSET_TBL',
    );
    final future = query(CARASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarAssetTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: CAR_ASSET_TBL)'));
    return CARASSETTBLFluent<CarAssetTbl>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<CARASSETTBLCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyCAR_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyCAR_ASSET_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyCARASSETTBL) =>
        AffectedRowsOutput.fromJson(createManyCARASSETTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  CARASSETTBLFluent<CarAssetTbl?> update({
    required CARASSETTBLUpdateInput data,
    required CARASSETTBLWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneCAR_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneCAR_ASSET_TBL',
    );
    final future = query(CARASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarAssetTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return CARASSETTBLFluent<CarAssetTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required CARASSETTBLUpdateManyMutationInput data,
    CARASSETTBLWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyCAR_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyCAR_ASSET_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyCARASSETTBL) =>
        AffectedRowsOutput.fromJson(updateManyCARASSETTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  CARASSETTBLFluent<CarAssetTbl> upsert({
    required CARASSETTBLWhereUniqueInput where,
    required CARASSETTBLCreateInput create,
    required CARASSETTBLUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneCAR_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneCAR_ASSET_TBL',
    );
    final future = query(CARASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarAssetTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: CAR_ASSET_TBL)'));
    return CARASSETTBLFluent<CarAssetTbl>(
      future,
      query,
    );
  }

  CARASSETTBLFluent<CarAssetTbl?> delete(
      {required CARASSETTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneCAR_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneCAR_ASSET_TBL',
    );
    final future = query(CARASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarAssetTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return CARASSETTBLFluent<CarAssetTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({CARASSETTBLWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyCAR_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyCAR_ASSET_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyCARASSETTBL) =>
        AffectedRowsOutput.fromJson(deleteManyCARASSETTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateCARASSETTBL aggregate({
    CARASSETTBLWhereInput? where,
    Iterable<CARASSETTBLOrderByWithRelationInput>? orderBy,
    CARASSETTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateCAR_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateCAR_ASSET_TBL',
    );
    return AggregateCARASSETTBL(query);
  }

  Future<Iterable<CARASSETTBLGroupByOutputType>> groupBy({
    CARASSETTBLWhereInput? where,
    Iterable<CARASSETTBLOrderByWithAggregationInput>? orderBy,
    required Iterable<CARASSETTBLScalarFieldEnum> by,
    CARASSETTBLScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByCAR_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByCAR_ASSET_TBL',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByCARASSETTBL) =>
        groupByCARASSETTBL.map((Map groupByCARASSETTBL) =>
            CARASSETTBLGroupByOutputType.fromJson(groupByCARASSETTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension CARCHARGETBLModelDelegateExtension
    on _i1.ModelDelegate<CarChargeTbl> {
  CARCHARGETBLFluent<CarChargeTbl?> findUnique(
      {required CARCHARGETBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueCAR_CHARGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueCAR_CHARGE_TBL',
    );
    final future = query(CARCHARGETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarChargeTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return CARCHARGETBLFluent<CarChargeTbl?>(
      future,
      query,
    );
  }

  CARCHARGETBLFluent<CarChargeTbl> findUniqueOrThrow(
      {required CARCHARGETBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueCAR_CHARGE_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueCAR_CHARGE_TBLOrThrow',
    );
    final future = query(CARCHARGETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarChargeTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: CAR_CHARGE_TBL)'));
    return CARCHARGETBLFluent<CarChargeTbl>(
      future,
      query,
    );
  }

  CARCHARGETBLFluent<CarChargeTbl?> findFirst({
    CARCHARGETBLWhereInput? where,
    Iterable<CARCHARGETBLOrderByWithRelationInput>? orderBy,
    CARCHARGETBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<CARCHARGETBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstCAR_CHARGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstCAR_CHARGE_TBL',
    );
    final future = query(CARCHARGETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarChargeTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return CARCHARGETBLFluent<CarChargeTbl?>(
      future,
      query,
    );
  }

  CARCHARGETBLFluent<CarChargeTbl> findFirstOrThrow({
    CARCHARGETBLWhereInput? where,
    Iterable<CARCHARGETBLOrderByWithRelationInput>? orderBy,
    CARCHARGETBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<CARCHARGETBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstCAR_CHARGE_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstCAR_CHARGE_TBLOrThrow',
    );
    final future = query(CARCHARGETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarChargeTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: CAR_CHARGE_TBL)'));
    return CARCHARGETBLFluent<CarChargeTbl>(
      future,
      query,
    );
  }

  Future<Iterable<CarChargeTbl>> findMany({
    CARCHARGETBLWhereInput? where,
    Iterable<CARCHARGETBLOrderByWithRelationInput>? orderBy,
    CARCHARGETBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<CARCHARGETBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyCAR_CHARGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyCAR_CHARGE_TBL',
    );
    final fields = CARCHARGETBLScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyCARCHARGETBL) =>
        findManyCARCHARGETBL.map((Map findManyCARCHARGETBL) =>
            CarChargeTbl.fromJson(findManyCARCHARGETBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  CARCHARGETBLFluent<CarChargeTbl> create(
      {required CARCHARGETBLCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneCAR_CHARGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneCAR_CHARGE_TBL',
    );
    final future = query(CARCHARGETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarChargeTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: CAR_CHARGE_TBL)'));
    return CARCHARGETBLFluent<CarChargeTbl>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<CARCHARGETBLCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyCAR_CHARGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyCAR_CHARGE_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyCARCHARGETBL) =>
        AffectedRowsOutput.fromJson(createManyCARCHARGETBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  CARCHARGETBLFluent<CarChargeTbl?> update({
    required CARCHARGETBLUpdateInput data,
    required CARCHARGETBLWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneCAR_CHARGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneCAR_CHARGE_TBL',
    );
    final future = query(CARCHARGETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarChargeTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return CARCHARGETBLFluent<CarChargeTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required CARCHARGETBLUpdateManyMutationInput data,
    CARCHARGETBLWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyCAR_CHARGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyCAR_CHARGE_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyCARCHARGETBL) =>
        AffectedRowsOutput.fromJson(updateManyCARCHARGETBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  CARCHARGETBLFluent<CarChargeTbl> upsert({
    required CARCHARGETBLWhereUniqueInput where,
    required CARCHARGETBLCreateInput create,
    required CARCHARGETBLUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneCAR_CHARGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneCAR_CHARGE_TBL',
    );
    final future = query(CARCHARGETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarChargeTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: CAR_CHARGE_TBL)'));
    return CARCHARGETBLFluent<CarChargeTbl>(
      future,
      query,
    );
  }

  CARCHARGETBLFluent<CarChargeTbl?> delete(
      {required CARCHARGETBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneCAR_CHARGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneCAR_CHARGE_TBL',
    );
    final future = query(CARCHARGETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarChargeTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return CARCHARGETBLFluent<CarChargeTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({CARCHARGETBLWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyCAR_CHARGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyCAR_CHARGE_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyCARCHARGETBL) =>
        AffectedRowsOutput.fromJson(deleteManyCARCHARGETBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateCARCHARGETBL aggregate({
    CARCHARGETBLWhereInput? where,
    Iterable<CARCHARGETBLOrderByWithRelationInput>? orderBy,
    CARCHARGETBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateCAR_CHARGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateCAR_CHARGE_TBL',
    );
    return AggregateCARCHARGETBL(query);
  }

  Future<Iterable<CARCHARGETBLGroupByOutputType>> groupBy({
    CARCHARGETBLWhereInput? where,
    Iterable<CARCHARGETBLOrderByWithAggregationInput>? orderBy,
    required Iterable<CARCHARGETBLScalarFieldEnum> by,
    CARCHARGETBLScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByCAR_CHARGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByCAR_CHARGE_TBL',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByCARCHARGETBL) =>
        groupByCARCHARGETBL.map((Map groupByCARCHARGETBL) =>
            CARCHARGETBLGroupByOutputType.fromJson(groupByCARCHARGETBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension CARINFOTBLModelDelegateExtension on _i1.ModelDelegate<CarInfoTbl> {
  CARINFOTBLFluent<CarInfoTbl?> findUnique(
      {required CARINFOTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueCAR_INFO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueCAR_INFO_TBL',
    );
    final future = query(CARINFOTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarInfoTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return CARINFOTBLFluent<CarInfoTbl?>(
      future,
      query,
    );
  }

  CARINFOTBLFluent<CarInfoTbl> findUniqueOrThrow(
      {required CARINFOTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueCAR_INFO_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueCAR_INFO_TBLOrThrow',
    );
    final future = query(CARINFOTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarInfoTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: CAR_INFO_TBL)'));
    return CARINFOTBLFluent<CarInfoTbl>(
      future,
      query,
    );
  }

  CARINFOTBLFluent<CarInfoTbl?> findFirst({
    CARINFOTBLWhereInput? where,
    Iterable<CARINFOTBLOrderByWithRelationInput>? orderBy,
    CARINFOTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<CARINFOTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstCAR_INFO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstCAR_INFO_TBL',
    );
    final future = query(CARINFOTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarInfoTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return CARINFOTBLFluent<CarInfoTbl?>(
      future,
      query,
    );
  }

  CARINFOTBLFluent<CarInfoTbl> findFirstOrThrow({
    CARINFOTBLWhereInput? where,
    Iterable<CARINFOTBLOrderByWithRelationInput>? orderBy,
    CARINFOTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<CARINFOTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstCAR_INFO_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstCAR_INFO_TBLOrThrow',
    );
    final future = query(CARINFOTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarInfoTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: CAR_INFO_TBL)'));
    return CARINFOTBLFluent<CarInfoTbl>(
      future,
      query,
    );
  }

  Future<Iterable<CarInfoTbl>> findMany({
    CARINFOTBLWhereInput? where,
    Iterable<CARINFOTBLOrderByWithRelationInput>? orderBy,
    CARINFOTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<CARINFOTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyCAR_INFO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyCAR_INFO_TBL',
    );
    final fields = CARINFOTBLScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyCARINFOTBL) =>
        findManyCARINFOTBL.map((Map findManyCARINFOTBL) =>
            CarInfoTbl.fromJson(findManyCARINFOTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  CARINFOTBLFluent<CarInfoTbl> create({required CARINFOTBLCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneCAR_INFO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneCAR_INFO_TBL',
    );
    final future = query(CARINFOTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarInfoTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: CAR_INFO_TBL)'));
    return CARINFOTBLFluent<CarInfoTbl>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<CARINFOTBLCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyCAR_INFO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyCAR_INFO_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyCARINFOTBL) =>
        AffectedRowsOutput.fromJson(createManyCARINFOTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  CARINFOTBLFluent<CarInfoTbl?> update({
    required CARINFOTBLUpdateInput data,
    required CARINFOTBLWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneCAR_INFO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneCAR_INFO_TBL',
    );
    final future = query(CARINFOTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarInfoTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return CARINFOTBLFluent<CarInfoTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required CARINFOTBLUpdateManyMutationInput data,
    CARINFOTBLWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyCAR_INFO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyCAR_INFO_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyCARINFOTBL) =>
        AffectedRowsOutput.fromJson(updateManyCARINFOTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  CARINFOTBLFluent<CarInfoTbl> upsert({
    required CARINFOTBLWhereUniqueInput where,
    required CARINFOTBLCreateInput create,
    required CARINFOTBLUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneCAR_INFO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneCAR_INFO_TBL',
    );
    final future = query(CARINFOTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarInfoTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: CAR_INFO_TBL)'));
    return CARINFOTBLFluent<CarInfoTbl>(
      future,
      query,
    );
  }

  CARINFOTBLFluent<CarInfoTbl?> delete(
      {required CARINFOTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneCAR_INFO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneCAR_INFO_TBL',
    );
    final future = query(CARINFOTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarInfoTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return CARINFOTBLFluent<CarInfoTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({CARINFOTBLWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyCAR_INFO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyCAR_INFO_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyCARINFOTBL) =>
        AffectedRowsOutput.fromJson(deleteManyCARINFOTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateCARINFOTBL aggregate({
    CARINFOTBLWhereInput? where,
    Iterable<CARINFOTBLOrderByWithRelationInput>? orderBy,
    CARINFOTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateCAR_INFO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateCAR_INFO_TBL',
    );
    return AggregateCARINFOTBL(query);
  }

  Future<Iterable<CARINFOTBLGroupByOutputType>> groupBy({
    CARINFOTBLWhereInput? where,
    Iterable<CARINFOTBLOrderByWithAggregationInput>? orderBy,
    required Iterable<CARINFOTBLScalarFieldEnum> by,
    CARINFOTBLScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByCAR_INFO_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByCAR_INFO_TBL',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByCARINFOTBL) =>
        groupByCARINFOTBL.map((Map groupByCARINFOTBL) =>
            CARINFOTBLGroupByOutputType.fromJson(groupByCARINFOTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension CARMILEAGETBLModelDelegateExtension
    on _i1.ModelDelegate<CarMileageTbl> {
  CARMILEAGETBLFluent<CarMileageTbl?> findUnique(
      {required CARMILEAGETBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueCAR_MILEAGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueCAR_MILEAGE_TBL',
    );
    final future = query(CARMILEAGETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarMileageTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return CARMILEAGETBLFluent<CarMileageTbl?>(
      future,
      query,
    );
  }

  CARMILEAGETBLFluent<CarMileageTbl> findUniqueOrThrow(
      {required CARMILEAGETBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueCAR_MILEAGE_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueCAR_MILEAGE_TBLOrThrow',
    );
    final future = query(CARMILEAGETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarMileageTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: CAR_MILEAGE_TBL)'));
    return CARMILEAGETBLFluent<CarMileageTbl>(
      future,
      query,
    );
  }

  CARMILEAGETBLFluent<CarMileageTbl?> findFirst({
    CARMILEAGETBLWhereInput? where,
    Iterable<CARMILEAGETBLOrderByWithRelationInput>? orderBy,
    CARMILEAGETBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<CARMILEAGETBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstCAR_MILEAGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstCAR_MILEAGE_TBL',
    );
    final future = query(CARMILEAGETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarMileageTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return CARMILEAGETBLFluent<CarMileageTbl?>(
      future,
      query,
    );
  }

  CARMILEAGETBLFluent<CarMileageTbl> findFirstOrThrow({
    CARMILEAGETBLWhereInput? where,
    Iterable<CARMILEAGETBLOrderByWithRelationInput>? orderBy,
    CARMILEAGETBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<CARMILEAGETBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstCAR_MILEAGE_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstCAR_MILEAGE_TBLOrThrow',
    );
    final future = query(CARMILEAGETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarMileageTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: CAR_MILEAGE_TBL)'));
    return CARMILEAGETBLFluent<CarMileageTbl>(
      future,
      query,
    );
  }

  Future<Iterable<CarMileageTbl>> findMany({
    CARMILEAGETBLWhereInput? where,
    Iterable<CARMILEAGETBLOrderByWithRelationInput>? orderBy,
    CARMILEAGETBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<CARMILEAGETBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyCAR_MILEAGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyCAR_MILEAGE_TBL',
    );
    final fields = CARMILEAGETBLScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyCARMILEAGETBL) =>
        findManyCARMILEAGETBL.map((Map findManyCARMILEAGETBL) =>
            CarMileageTbl.fromJson(findManyCARMILEAGETBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  CARMILEAGETBLFluent<CarMileageTbl> create(
      {required CARMILEAGETBLCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneCAR_MILEAGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneCAR_MILEAGE_TBL',
    );
    final future = query(CARMILEAGETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarMileageTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: CAR_MILEAGE_TBL)'));
    return CARMILEAGETBLFluent<CarMileageTbl>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<CARMILEAGETBLCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyCAR_MILEAGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyCAR_MILEAGE_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyCARMILEAGETBL) =>
        AffectedRowsOutput.fromJson(createManyCARMILEAGETBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  CARMILEAGETBLFluent<CarMileageTbl?> update({
    required CARMILEAGETBLUpdateInput data,
    required CARMILEAGETBLWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneCAR_MILEAGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneCAR_MILEAGE_TBL',
    );
    final future = query(CARMILEAGETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarMileageTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return CARMILEAGETBLFluent<CarMileageTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required CARMILEAGETBLUpdateManyMutationInput data,
    CARMILEAGETBLWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyCAR_MILEAGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyCAR_MILEAGE_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyCARMILEAGETBL) =>
        AffectedRowsOutput.fromJson(updateManyCARMILEAGETBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  CARMILEAGETBLFluent<CarMileageTbl> upsert({
    required CARMILEAGETBLWhereUniqueInput where,
    required CARMILEAGETBLCreateInput create,
    required CARMILEAGETBLUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneCAR_MILEAGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneCAR_MILEAGE_TBL',
    );
    final future = query(CARMILEAGETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarMileageTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: CAR_MILEAGE_TBL)'));
    return CARMILEAGETBLFluent<CarMileageTbl>(
      future,
      query,
    );
  }

  CARMILEAGETBLFluent<CarMileageTbl?> delete(
      {required CARMILEAGETBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneCAR_MILEAGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneCAR_MILEAGE_TBL',
    );
    final future = query(CARMILEAGETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarMileageTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return CARMILEAGETBLFluent<CarMileageTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({CARMILEAGETBLWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyCAR_MILEAGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyCAR_MILEAGE_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyCARMILEAGETBL) =>
        AffectedRowsOutput.fromJson(deleteManyCARMILEAGETBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateCARMILEAGETBL aggregate({
    CARMILEAGETBLWhereInput? where,
    Iterable<CARMILEAGETBLOrderByWithRelationInput>? orderBy,
    CARMILEAGETBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateCAR_MILEAGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateCAR_MILEAGE_TBL',
    );
    return AggregateCARMILEAGETBL(query);
  }

  Future<Iterable<CARMILEAGETBLGroupByOutputType>> groupBy({
    CARMILEAGETBLWhereInput? where,
    Iterable<CARMILEAGETBLOrderByWithAggregationInput>? orderBy,
    required Iterable<CARMILEAGETBLScalarFieldEnum> by,
    CARMILEAGETBLScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByCAR_MILEAGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByCAR_MILEAGE_TBL',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByCARMILEAGETBL) => groupByCARMILEAGETBL.map(
        (Map groupByCARMILEAGETBL) => CARMILEAGETBLGroupByOutputType.fromJson(
            groupByCARMILEAGETBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension CARPARTREPLACETBLModelDelegateExtension
    on _i1.ModelDelegate<CarPartReplaceTbl> {
  CARPARTREPLACETBLFluent<CarPartReplaceTbl?> findUnique(
      {required CARPARTREPLACETBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueCAR_PART_REPLACE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueCAR_PART_REPLACE_TBL',
    );
    final future =
        query(CARPARTREPLACETBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? CarPartReplaceTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return CARPARTREPLACETBLFluent<CarPartReplaceTbl?>(
      future,
      query,
    );
  }

  CARPARTREPLACETBLFluent<CarPartReplaceTbl> findUniqueOrThrow(
      {required CARPARTREPLACETBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueCAR_PART_REPLACE_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueCAR_PART_REPLACE_TBLOrThrow',
    );
    final future = query(
            CARPARTREPLACETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarPartReplaceTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: CAR_PART_REPLACE_TBL)'));
    return CARPARTREPLACETBLFluent<CarPartReplaceTbl>(
      future,
      query,
    );
  }

  CARPARTREPLACETBLFluent<CarPartReplaceTbl?> findFirst({
    CARPARTREPLACETBLWhereInput? where,
    Iterable<CARPARTREPLACETBLOrderByWithRelationInput>? orderBy,
    CARPARTREPLACETBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<CARPARTREPLACETBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstCAR_PART_REPLACE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstCAR_PART_REPLACE_TBL',
    );
    final future =
        query(CARPARTREPLACETBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? CarPartReplaceTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return CARPARTREPLACETBLFluent<CarPartReplaceTbl?>(
      future,
      query,
    );
  }

  CARPARTREPLACETBLFluent<CarPartReplaceTbl> findFirstOrThrow({
    CARPARTREPLACETBLWhereInput? where,
    Iterable<CARPARTREPLACETBLOrderByWithRelationInput>? orderBy,
    CARPARTREPLACETBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<CARPARTREPLACETBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstCAR_PART_REPLACE_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstCAR_PART_REPLACE_TBLOrThrow',
    );
    final future = query(
            CARPARTREPLACETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarPartReplaceTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: CAR_PART_REPLACE_TBL)'));
    return CARPARTREPLACETBLFluent<CarPartReplaceTbl>(
      future,
      query,
    );
  }

  Future<Iterable<CarPartReplaceTbl>> findMany({
    CARPARTREPLACETBLWhereInput? where,
    Iterable<CARPARTREPLACETBLOrderByWithRelationInput>? orderBy,
    CARPARTREPLACETBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<CARPARTREPLACETBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyCAR_PART_REPLACE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyCAR_PART_REPLACE_TBL',
    );
    final fields = CARPARTREPLACETBLScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyCARPARTREPLACETBL) =>
        findManyCARPARTREPLACETBL.map((Map findManyCARPARTREPLACETBL) =>
            CarPartReplaceTbl.fromJson(findManyCARPARTREPLACETBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  CARPARTREPLACETBLFluent<CarPartReplaceTbl> create(
      {required CARPARTREPLACETBLCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneCAR_PART_REPLACE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneCAR_PART_REPLACE_TBL',
    );
    final future = query(
            CARPARTREPLACETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarPartReplaceTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: CAR_PART_REPLACE_TBL)'));
    return CARPARTREPLACETBLFluent<CarPartReplaceTbl>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<CARPARTREPLACETBLCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyCAR_PART_REPLACE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyCAR_PART_REPLACE_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyCARPARTREPLACETBL) =>
        AffectedRowsOutput.fromJson(createManyCARPARTREPLACETBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  CARPARTREPLACETBLFluent<CarPartReplaceTbl?> update({
    required CARPARTREPLACETBLUpdateInput data,
    required CARPARTREPLACETBLWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneCAR_PART_REPLACE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneCAR_PART_REPLACE_TBL',
    );
    final future =
        query(CARPARTREPLACETBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? CarPartReplaceTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return CARPARTREPLACETBLFluent<CarPartReplaceTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required CARPARTREPLACETBLUpdateManyMutationInput data,
    CARPARTREPLACETBLWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyCAR_PART_REPLACE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyCAR_PART_REPLACE_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyCARPARTREPLACETBL) =>
        AffectedRowsOutput.fromJson(updateManyCARPARTREPLACETBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  CARPARTREPLACETBLFluent<CarPartReplaceTbl> upsert({
    required CARPARTREPLACETBLWhereUniqueInput where,
    required CARPARTREPLACETBLCreateInput create,
    required CARPARTREPLACETBLUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneCAR_PART_REPLACE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneCAR_PART_REPLACE_TBL',
    );
    final future = query(
            CARPARTREPLACETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarPartReplaceTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: CAR_PART_REPLACE_TBL)'));
    return CARPARTREPLACETBLFluent<CarPartReplaceTbl>(
      future,
      query,
    );
  }

  CARPARTREPLACETBLFluent<CarPartReplaceTbl?> delete(
      {required CARPARTREPLACETBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneCAR_PART_REPLACE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneCAR_PART_REPLACE_TBL',
    );
    final future =
        query(CARPARTREPLACETBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? CarPartReplaceTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return CARPARTREPLACETBLFluent<CarPartReplaceTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({CARPARTREPLACETBLWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyCAR_PART_REPLACE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyCAR_PART_REPLACE_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyCARPARTREPLACETBL) =>
        AffectedRowsOutput.fromJson(deleteManyCARPARTREPLACETBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateCARPARTREPLACETBL aggregate({
    CARPARTREPLACETBLWhereInput? where,
    Iterable<CARPARTREPLACETBLOrderByWithRelationInput>? orderBy,
    CARPARTREPLACETBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateCAR_PART_REPLACE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateCAR_PART_REPLACE_TBL',
    );
    return AggregateCARPARTREPLACETBL(query);
  }

  Future<Iterable<CARPARTREPLACETBLGroupByOutputType>> groupBy({
    CARPARTREPLACETBLWhereInput? where,
    Iterable<CARPARTREPLACETBLOrderByWithAggregationInput>? orderBy,
    required Iterable<CARPARTREPLACETBLScalarFieldEnum> by,
    CARPARTREPLACETBLScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByCAR_PART_REPLACE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByCAR_PART_REPLACE_TBL',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByCARPARTREPLACETBL) =>
        groupByCARPARTREPLACETBL.map((Map groupByCARPARTREPLACETBL) =>
            CARPARTREPLACETBLGroupByOutputType.fromJson(
                groupByCARPARTREPLACETBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension CARREPAIRLOGModelDelegateExtension
    on _i1.ModelDelegate<CarRepairLog> {
  CARREPAIRLOGFluent<CarRepairLog?> findUnique(
      {required CARREPAIRLOGWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueCAR_REPAIR_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueCAR_REPAIR_LOG',
    );
    final future = query(CARREPAIRLOGScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarRepairLog.fromJson(json.cast<String, dynamic>())
            : null);
    return CARREPAIRLOGFluent<CarRepairLog?>(
      future,
      query,
    );
  }

  CARREPAIRLOGFluent<CarRepairLog> findUniqueOrThrow(
      {required CARREPAIRLOGWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueCAR_REPAIR_LOGOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueCAR_REPAIR_LOGOrThrow',
    );
    final future = query(CARREPAIRLOGScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarRepairLog.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: CAR_REPAIR_LOG)'));
    return CARREPAIRLOGFluent<CarRepairLog>(
      future,
      query,
    );
  }

  CARREPAIRLOGFluent<CarRepairLog?> findFirst({
    CARREPAIRLOGWhereInput? where,
    Iterable<CARREPAIRLOGOrderByWithRelationInput>? orderBy,
    CARREPAIRLOGWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<CARREPAIRLOGScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstCAR_REPAIR_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstCAR_REPAIR_LOG',
    );
    final future = query(CARREPAIRLOGScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarRepairLog.fromJson(json.cast<String, dynamic>())
            : null);
    return CARREPAIRLOGFluent<CarRepairLog?>(
      future,
      query,
    );
  }

  CARREPAIRLOGFluent<CarRepairLog> findFirstOrThrow({
    CARREPAIRLOGWhereInput? where,
    Iterable<CARREPAIRLOGOrderByWithRelationInput>? orderBy,
    CARREPAIRLOGWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<CARREPAIRLOGScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstCAR_REPAIR_LOGOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstCAR_REPAIR_LOGOrThrow',
    );
    final future = query(CARREPAIRLOGScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarRepairLog.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: CAR_REPAIR_LOG)'));
    return CARREPAIRLOGFluent<CarRepairLog>(
      future,
      query,
    );
  }

  Future<Iterable<CarRepairLog>> findMany({
    CARREPAIRLOGWhereInput? where,
    Iterable<CARREPAIRLOGOrderByWithRelationInput>? orderBy,
    CARREPAIRLOGWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<CARREPAIRLOGScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyCAR_REPAIR_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyCAR_REPAIR_LOG',
    );
    final fields = CARREPAIRLOGScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyCARREPAIRLOG) =>
        findManyCARREPAIRLOG.map((Map findManyCARREPAIRLOG) =>
            CarRepairLog.fromJson(findManyCARREPAIRLOG.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  CARREPAIRLOGFluent<CarRepairLog> create({CARREPAIRLOGCreateInput? data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneCAR_REPAIR_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneCAR_REPAIR_LOG',
    );
    final future = query(CARREPAIRLOGScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarRepairLog.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: CAR_REPAIR_LOG)'));
    return CARREPAIRLOGFluent<CarRepairLog>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<CARREPAIRLOGCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyCAR_REPAIR_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyCAR_REPAIR_LOG',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyCARREPAIRLOG) =>
        AffectedRowsOutput.fromJson(createManyCARREPAIRLOG.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  CARREPAIRLOGFluent<CarRepairLog?> update({
    required CARREPAIRLOGUpdateInput data,
    required CARREPAIRLOGWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneCAR_REPAIR_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneCAR_REPAIR_LOG',
    );
    final future = query(CARREPAIRLOGScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarRepairLog.fromJson(json.cast<String, dynamic>())
            : null);
    return CARREPAIRLOGFluent<CarRepairLog?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required CARREPAIRLOGUpdateManyMutationInput data,
    CARREPAIRLOGWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyCAR_REPAIR_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyCAR_REPAIR_LOG',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyCARREPAIRLOG) =>
        AffectedRowsOutput.fromJson(updateManyCARREPAIRLOG.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  CARREPAIRLOGFluent<CarRepairLog> upsert({
    required CARREPAIRLOGWhereUniqueInput where,
    required CARREPAIRLOGCreateInput create,
    required CARREPAIRLOGUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneCAR_REPAIR_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneCAR_REPAIR_LOG',
    );
    final future = query(CARREPAIRLOGScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarRepairLog.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: CAR_REPAIR_LOG)'));
    return CARREPAIRLOGFluent<CarRepairLog>(
      future,
      query,
    );
  }

  CARREPAIRLOGFluent<CarRepairLog?> delete(
      {required CARREPAIRLOGWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneCAR_REPAIR_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneCAR_REPAIR_LOG',
    );
    final future = query(CARREPAIRLOGScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarRepairLog.fromJson(json.cast<String, dynamic>())
            : null);
    return CARREPAIRLOGFluent<CarRepairLog?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({CARREPAIRLOGWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyCAR_REPAIR_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyCAR_REPAIR_LOG',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyCARREPAIRLOG) =>
        AffectedRowsOutput.fromJson(deleteManyCARREPAIRLOG.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateCARREPAIRLOG aggregate({
    CARREPAIRLOGWhereInput? where,
    Iterable<CARREPAIRLOGOrderByWithRelationInput>? orderBy,
    CARREPAIRLOGWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateCAR_REPAIR_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateCAR_REPAIR_LOG',
    );
    return AggregateCARREPAIRLOG(query);
  }

  Future<Iterable<CARREPAIRLOGGroupByOutputType>> groupBy({
    CARREPAIRLOGWhereInput? where,
    Iterable<CARREPAIRLOGOrderByWithAggregationInput>? orderBy,
    required Iterable<CARREPAIRLOGScalarFieldEnum> by,
    CARREPAIRLOGScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByCAR_REPAIR_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByCAR_REPAIR_LOG',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByCARREPAIRLOG) =>
        groupByCARREPAIRLOG.map((Map groupByCARREPAIRLOG) =>
            CARREPAIRLOGGroupByOutputType.fromJson(groupByCARREPAIRLOG.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension CARUSEMANAGETBLModelDelegateExtension
    on _i1.ModelDelegate<CarUseManageTbl> {
  CARUSEMANAGETBLFluent<CarUseManageTbl?> findUnique(
      {required CARUSEMANAGETBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueCAR_USE_MANAGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueCAR_USE_MANAGE_TBL',
    );
    final future =
        query(CARUSEMANAGETBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? CarUseManageTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return CARUSEMANAGETBLFluent<CarUseManageTbl?>(
      future,
      query,
    );
  }

  CARUSEMANAGETBLFluent<CarUseManageTbl> findUniqueOrThrow(
      {required CARUSEMANAGETBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueCAR_USE_MANAGE_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueCAR_USE_MANAGE_TBLOrThrow',
    );
    final future = query(
            CARUSEMANAGETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarUseManageTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: CAR_USE_MANAGE_TBL)'));
    return CARUSEMANAGETBLFluent<CarUseManageTbl>(
      future,
      query,
    );
  }

  CARUSEMANAGETBLFluent<CarUseManageTbl?> findFirst({
    CARUSEMANAGETBLWhereInput? where,
    Iterable<CARUSEMANAGETBLOrderByWithRelationInput>? orderBy,
    CARUSEMANAGETBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<CARUSEMANAGETBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstCAR_USE_MANAGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstCAR_USE_MANAGE_TBL',
    );
    final future =
        query(CARUSEMANAGETBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? CarUseManageTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return CARUSEMANAGETBLFluent<CarUseManageTbl?>(
      future,
      query,
    );
  }

  CARUSEMANAGETBLFluent<CarUseManageTbl> findFirstOrThrow({
    CARUSEMANAGETBLWhereInput? where,
    Iterable<CARUSEMANAGETBLOrderByWithRelationInput>? orderBy,
    CARUSEMANAGETBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<CARUSEMANAGETBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstCAR_USE_MANAGE_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstCAR_USE_MANAGE_TBLOrThrow',
    );
    final future = query(
            CARUSEMANAGETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarUseManageTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: CAR_USE_MANAGE_TBL)'));
    return CARUSEMANAGETBLFluent<CarUseManageTbl>(
      future,
      query,
    );
  }

  Future<Iterable<CarUseManageTbl>> findMany({
    CARUSEMANAGETBLWhereInput? where,
    Iterable<CARUSEMANAGETBLOrderByWithRelationInput>? orderBy,
    CARUSEMANAGETBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<CARUSEMANAGETBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyCAR_USE_MANAGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyCAR_USE_MANAGE_TBL',
    );
    final fields = CARUSEMANAGETBLScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyCARUSEMANAGETBL) =>
        findManyCARUSEMANAGETBL.map((Map findManyCARUSEMANAGETBL) =>
            CarUseManageTbl.fromJson(findManyCARUSEMANAGETBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  CARUSEMANAGETBLFluent<CarUseManageTbl> create(
      {required CARUSEMANAGETBLCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneCAR_USE_MANAGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneCAR_USE_MANAGE_TBL',
    );
    final future = query(
            CARUSEMANAGETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarUseManageTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: CAR_USE_MANAGE_TBL)'));
    return CARUSEMANAGETBLFluent<CarUseManageTbl>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<CARUSEMANAGETBLCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyCAR_USE_MANAGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyCAR_USE_MANAGE_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyCARUSEMANAGETBL) =>
        AffectedRowsOutput.fromJson(createManyCARUSEMANAGETBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  CARUSEMANAGETBLFluent<CarUseManageTbl?> update({
    required CARUSEMANAGETBLUpdateInput data,
    required CARUSEMANAGETBLWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneCAR_USE_MANAGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneCAR_USE_MANAGE_TBL',
    );
    final future =
        query(CARUSEMANAGETBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? CarUseManageTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return CARUSEMANAGETBLFluent<CarUseManageTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required CARUSEMANAGETBLUpdateManyMutationInput data,
    CARUSEMANAGETBLWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyCAR_USE_MANAGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyCAR_USE_MANAGE_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyCARUSEMANAGETBL) =>
        AffectedRowsOutput.fromJson(updateManyCARUSEMANAGETBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  CARUSEMANAGETBLFluent<CarUseManageTbl> upsert({
    required CARUSEMANAGETBLWhereUniqueInput where,
    required CARUSEMANAGETBLCreateInput create,
    required CARUSEMANAGETBLUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneCAR_USE_MANAGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneCAR_USE_MANAGE_TBL',
    );
    final future = query(
            CARUSEMANAGETBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? CarUseManageTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: CAR_USE_MANAGE_TBL)'));
    return CARUSEMANAGETBLFluent<CarUseManageTbl>(
      future,
      query,
    );
  }

  CARUSEMANAGETBLFluent<CarUseManageTbl?> delete(
      {required CARUSEMANAGETBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneCAR_USE_MANAGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneCAR_USE_MANAGE_TBL',
    );
    final future =
        query(CARUSEMANAGETBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? CarUseManageTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return CARUSEMANAGETBLFluent<CarUseManageTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({CARUSEMANAGETBLWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyCAR_USE_MANAGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyCAR_USE_MANAGE_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyCARUSEMANAGETBL) =>
        AffectedRowsOutput.fromJson(deleteManyCARUSEMANAGETBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateCARUSEMANAGETBL aggregate({
    CARUSEMANAGETBLWhereInput? where,
    Iterable<CARUSEMANAGETBLOrderByWithRelationInput>? orderBy,
    CARUSEMANAGETBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateCAR_USE_MANAGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateCAR_USE_MANAGE_TBL',
    );
    return AggregateCARUSEMANAGETBL(query);
  }

  Future<Iterable<CARUSEMANAGETBLGroupByOutputType>> groupBy({
    CARUSEMANAGETBLWhereInput? where,
    Iterable<CARUSEMANAGETBLOrderByWithAggregationInput>? orderBy,
    required Iterable<CARUSEMANAGETBLScalarFieldEnum> by,
    CARUSEMANAGETBLScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByCAR_USE_MANAGE_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByCAR_USE_MANAGE_TBL',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByCARUSEMANAGETBL) =>
        groupByCARUSEMANAGETBL.map((Map groupByCARUSEMANAGETBL) =>
            CARUSEMANAGETBLGroupByOutputType.fromJson(
                groupByCARUSEMANAGETBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension HOLIDAYTBLModelDelegateExtension on _i1.ModelDelegate<HolidayTbl> {
  HOLIDAYTBLFluent<HolidayTbl?> findUnique(
      {required HOLIDAYTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueHOLIDAY_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueHOLIDAY_TBL',
    );
    final future = query(HOLIDAYTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? HolidayTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return HOLIDAYTBLFluent<HolidayTbl?>(
      future,
      query,
    );
  }

  HOLIDAYTBLFluent<HolidayTbl> findUniqueOrThrow(
      {required HOLIDAYTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueHOLIDAY_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueHOLIDAY_TBLOrThrow',
    );
    final future = query(HOLIDAYTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? HolidayTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: HOLIDAY_TBL)'));
    return HOLIDAYTBLFluent<HolidayTbl>(
      future,
      query,
    );
  }

  HOLIDAYTBLFluent<HolidayTbl?> findFirst({
    HOLIDAYTBLWhereInput? where,
    Iterable<HOLIDAYTBLOrderByWithRelationInput>? orderBy,
    HOLIDAYTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<HOLIDAYTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstHOLIDAY_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstHOLIDAY_TBL',
    );
    final future = query(HOLIDAYTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? HolidayTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return HOLIDAYTBLFluent<HolidayTbl?>(
      future,
      query,
    );
  }

  HOLIDAYTBLFluent<HolidayTbl> findFirstOrThrow({
    HOLIDAYTBLWhereInput? where,
    Iterable<HOLIDAYTBLOrderByWithRelationInput>? orderBy,
    HOLIDAYTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<HOLIDAYTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstHOLIDAY_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstHOLIDAY_TBLOrThrow',
    );
    final future = query(HOLIDAYTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? HolidayTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: HOLIDAY_TBL)'));
    return HOLIDAYTBLFluent<HolidayTbl>(
      future,
      query,
    );
  }

  Future<Iterable<HolidayTbl>> findMany({
    HOLIDAYTBLWhereInput? where,
    Iterable<HOLIDAYTBLOrderByWithRelationInput>? orderBy,
    HOLIDAYTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<HOLIDAYTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyHOLIDAY_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyHOLIDAY_TBL',
    );
    final fields = HOLIDAYTBLScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyHOLIDAYTBL) =>
        findManyHOLIDAYTBL.map((Map findManyHOLIDAYTBL) =>
            HolidayTbl.fromJson(findManyHOLIDAYTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  HOLIDAYTBLFluent<HolidayTbl> create({required HOLIDAYTBLCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneHOLIDAY_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneHOLIDAY_TBL',
    );
    final future = query(HOLIDAYTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? HolidayTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: HOLIDAY_TBL)'));
    return HOLIDAYTBLFluent<HolidayTbl>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<HOLIDAYTBLCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyHOLIDAY_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyHOLIDAY_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyHOLIDAYTBL) =>
        AffectedRowsOutput.fromJson(createManyHOLIDAYTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  HOLIDAYTBLFluent<HolidayTbl?> update({
    required HOLIDAYTBLUpdateInput data,
    required HOLIDAYTBLWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneHOLIDAY_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneHOLIDAY_TBL',
    );
    final future = query(HOLIDAYTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? HolidayTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return HOLIDAYTBLFluent<HolidayTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required HOLIDAYTBLUpdateManyMutationInput data,
    HOLIDAYTBLWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyHOLIDAY_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyHOLIDAY_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyHOLIDAYTBL) =>
        AffectedRowsOutput.fromJson(updateManyHOLIDAYTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  HOLIDAYTBLFluent<HolidayTbl> upsert({
    required HOLIDAYTBLWhereUniqueInput where,
    required HOLIDAYTBLCreateInput create,
    required HOLIDAYTBLUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneHOLIDAY_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneHOLIDAY_TBL',
    );
    final future = query(HOLIDAYTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? HolidayTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: HOLIDAY_TBL)'));
    return HOLIDAYTBLFluent<HolidayTbl>(
      future,
      query,
    );
  }

  HOLIDAYTBLFluent<HolidayTbl?> delete(
      {required HOLIDAYTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneHOLIDAY_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneHOLIDAY_TBL',
    );
    final future = query(HOLIDAYTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? HolidayTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return HOLIDAYTBLFluent<HolidayTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({HOLIDAYTBLWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyHOLIDAY_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyHOLIDAY_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyHOLIDAYTBL) =>
        AffectedRowsOutput.fromJson(deleteManyHOLIDAYTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateHOLIDAYTBL aggregate({
    HOLIDAYTBLWhereInput? where,
    Iterable<HOLIDAYTBLOrderByWithRelationInput>? orderBy,
    HOLIDAYTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateHOLIDAY_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateHOLIDAY_TBL',
    );
    return AggregateHOLIDAYTBL(query);
  }

  Future<Iterable<HOLIDAYTBLGroupByOutputType>> groupBy({
    HOLIDAYTBLWhereInput? where,
    Iterable<HOLIDAYTBLOrderByWithAggregationInput>? orderBy,
    required Iterable<HOLIDAYTBLScalarFieldEnum> by,
    HOLIDAYTBLScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByHOLIDAY_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByHOLIDAY_TBL',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByHOLIDAYTBL) =>
        groupByHOLIDAYTBL.map((Map groupByHOLIDAYTBL) =>
            HOLIDAYTBLGroupByOutputType.fromJson(groupByHOLIDAYTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension MEMBERTBLModelDelegateExtension on _i1.ModelDelegate<MemberTbl> {
  MEMBERTBLFluent<MemberTbl?> findUnique(
      {required MEMBERTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueMEMBER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueMEMBER_TBL',
    );
    final future = query(MEMBERTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? MemberTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return MEMBERTBLFluent<MemberTbl?>(
      future,
      query,
    );
  }

  MEMBERTBLFluent<MemberTbl> findUniqueOrThrow(
      {required MEMBERTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueMEMBER_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueMEMBER_TBLOrThrow',
    );
    final future = query(MEMBERTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? MemberTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: MEMBER_TBL)'));
    return MEMBERTBLFluent<MemberTbl>(
      future,
      query,
    );
  }

  MEMBERTBLFluent<MemberTbl?> findFirst({
    MEMBERTBLWhereInput? where,
    Iterable<MEMBERTBLOrderByWithRelationInput>? orderBy,
    MEMBERTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<MEMBERTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstMEMBER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstMEMBER_TBL',
    );
    final future = query(MEMBERTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? MemberTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return MEMBERTBLFluent<MemberTbl?>(
      future,
      query,
    );
  }

  MEMBERTBLFluent<MemberTbl> findFirstOrThrow({
    MEMBERTBLWhereInput? where,
    Iterable<MEMBERTBLOrderByWithRelationInput>? orderBy,
    MEMBERTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<MEMBERTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstMEMBER_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstMEMBER_TBLOrThrow',
    );
    final future = query(MEMBERTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? MemberTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: MEMBER_TBL)'));
    return MEMBERTBLFluent<MemberTbl>(
      future,
      query,
    );
  }

  Future<Iterable<MemberTbl>> findMany({
    MEMBERTBLWhereInput? where,
    Iterable<MEMBERTBLOrderByWithRelationInput>? orderBy,
    MEMBERTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<MEMBERTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyMEMBER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyMEMBER_TBL',
    );
    final fields = MEMBERTBLScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyMEMBERTBL) =>
        findManyMEMBERTBL.map((Map findManyMEMBERTBL) =>
            MemberTbl.fromJson(findManyMEMBERTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  MEMBERTBLFluent<MemberTbl> create({required MEMBERTBLCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneMEMBER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneMEMBER_TBL',
    );
    final future = query(MEMBERTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? MemberTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: MEMBER_TBL)'));
    return MEMBERTBLFluent<MemberTbl>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<MEMBERTBLCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyMEMBER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyMEMBER_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyMEMBERTBL) =>
        AffectedRowsOutput.fromJson(createManyMEMBERTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  MEMBERTBLFluent<MemberTbl?> update({
    required MEMBERTBLUpdateInput data,
    required MEMBERTBLWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneMEMBER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneMEMBER_TBL',
    );
    final future = query(MEMBERTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? MemberTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return MEMBERTBLFluent<MemberTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required MEMBERTBLUpdateManyMutationInput data,
    MEMBERTBLWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyMEMBER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyMEMBER_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyMEMBERTBL) =>
        AffectedRowsOutput.fromJson(updateManyMEMBERTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  MEMBERTBLFluent<MemberTbl> upsert({
    required MEMBERTBLWhereUniqueInput where,
    required MEMBERTBLCreateInput create,
    required MEMBERTBLUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneMEMBER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneMEMBER_TBL',
    );
    final future = query(MEMBERTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? MemberTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: MEMBER_TBL)'));
    return MEMBERTBLFluent<MemberTbl>(
      future,
      query,
    );
  }

  MEMBERTBLFluent<MemberTbl?> delete(
      {required MEMBERTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneMEMBER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneMEMBER_TBL',
    );
    final future = query(MEMBERTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? MemberTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return MEMBERTBLFluent<MemberTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({MEMBERTBLWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyMEMBER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyMEMBER_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyMEMBERTBL) =>
        AffectedRowsOutput.fromJson(deleteManyMEMBERTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateMEMBERTBL aggregate({
    MEMBERTBLWhereInput? where,
    Iterable<MEMBERTBLOrderByWithRelationInput>? orderBy,
    MEMBERTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateMEMBER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateMEMBER_TBL',
    );
    return AggregateMEMBERTBL(query);
  }

  Future<Iterable<MEMBERTBLGroupByOutputType>> groupBy({
    MEMBERTBLWhereInput? where,
    Iterable<MEMBERTBLOrderByWithAggregationInput>? orderBy,
    required Iterable<MEMBERTBLScalarFieldEnum> by,
    MEMBERTBLScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByMEMBER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByMEMBER_TBL',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByMEMBERTBL) =>
        groupByMEMBERTBL.map((Map groupByMEMBERTBL) =>
            MEMBERTBLGroupByOutputType.fromJson(groupByMEMBERTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension MENUAUTHTBLModelDelegateExtension on _i1.ModelDelegate<MenuAuthTbl> {
  MENUAUTHTBLFluent<MenuAuthTbl?> findUnique(
      {required MENUAUTHTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueMENU_AUTH_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueMENU_AUTH_TBL',
    );
    final future = query(MENUAUTHTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? MenuAuthTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return MENUAUTHTBLFluent<MenuAuthTbl?>(
      future,
      query,
    );
  }

  MENUAUTHTBLFluent<MenuAuthTbl> findUniqueOrThrow(
      {required MENUAUTHTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueMENU_AUTH_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueMENU_AUTH_TBLOrThrow',
    );
    final future = query(MENUAUTHTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? MenuAuthTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: MENU_AUTH_TBL)'));
    return MENUAUTHTBLFluent<MenuAuthTbl>(
      future,
      query,
    );
  }

  MENUAUTHTBLFluent<MenuAuthTbl?> findFirst({
    MENUAUTHTBLWhereInput? where,
    Iterable<MENUAUTHTBLOrderByWithRelationInput>? orderBy,
    MENUAUTHTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<MENUAUTHTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstMENU_AUTH_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstMENU_AUTH_TBL',
    );
    final future = query(MENUAUTHTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? MenuAuthTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return MENUAUTHTBLFluent<MenuAuthTbl?>(
      future,
      query,
    );
  }

  MENUAUTHTBLFluent<MenuAuthTbl> findFirstOrThrow({
    MENUAUTHTBLWhereInput? where,
    Iterable<MENUAUTHTBLOrderByWithRelationInput>? orderBy,
    MENUAUTHTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<MENUAUTHTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstMENU_AUTH_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstMENU_AUTH_TBLOrThrow',
    );
    final future = query(MENUAUTHTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? MenuAuthTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: MENU_AUTH_TBL)'));
    return MENUAUTHTBLFluent<MenuAuthTbl>(
      future,
      query,
    );
  }

  Future<Iterable<MenuAuthTbl>> findMany({
    MENUAUTHTBLWhereInput? where,
    Iterable<MENUAUTHTBLOrderByWithRelationInput>? orderBy,
    MENUAUTHTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<MENUAUTHTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyMENU_AUTH_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyMENU_AUTH_TBL',
    );
    final fields = MENUAUTHTBLScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyMENUAUTHTBL) =>
        findManyMENUAUTHTBL.map((Map findManyMENUAUTHTBL) =>
            MenuAuthTbl.fromJson(findManyMENUAUTHTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  MENUAUTHTBLFluent<MenuAuthTbl> create(
      {required MENUAUTHTBLCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneMENU_AUTH_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneMENU_AUTH_TBL',
    );
    final future = query(MENUAUTHTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? MenuAuthTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: MENU_AUTH_TBL)'));
    return MENUAUTHTBLFluent<MenuAuthTbl>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<MENUAUTHTBLCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyMENU_AUTH_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyMENU_AUTH_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyMENUAUTHTBL) =>
        AffectedRowsOutput.fromJson(createManyMENUAUTHTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  MENUAUTHTBLFluent<MenuAuthTbl?> update({
    required MENUAUTHTBLUpdateInput data,
    required MENUAUTHTBLWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneMENU_AUTH_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneMENU_AUTH_TBL',
    );
    final future = query(MENUAUTHTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? MenuAuthTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return MENUAUTHTBLFluent<MenuAuthTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required MENUAUTHTBLUpdateManyMutationInput data,
    MENUAUTHTBLWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyMENU_AUTH_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyMENU_AUTH_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyMENUAUTHTBL) =>
        AffectedRowsOutput.fromJson(updateManyMENUAUTHTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  MENUAUTHTBLFluent<MenuAuthTbl> upsert({
    required MENUAUTHTBLWhereUniqueInput where,
    required MENUAUTHTBLCreateInput create,
    required MENUAUTHTBLUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneMENU_AUTH_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneMENU_AUTH_TBL',
    );
    final future = query(MENUAUTHTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? MenuAuthTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: MENU_AUTH_TBL)'));
    return MENUAUTHTBLFluent<MenuAuthTbl>(
      future,
      query,
    );
  }

  MENUAUTHTBLFluent<MenuAuthTbl?> delete(
      {required MENUAUTHTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneMENU_AUTH_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneMENU_AUTH_TBL',
    );
    final future = query(MENUAUTHTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? MenuAuthTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return MENUAUTHTBLFluent<MenuAuthTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({MENUAUTHTBLWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyMENU_AUTH_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyMENU_AUTH_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyMENUAUTHTBL) =>
        AffectedRowsOutput.fromJson(deleteManyMENUAUTHTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateMENUAUTHTBL aggregate({
    MENUAUTHTBLWhereInput? where,
    Iterable<MENUAUTHTBLOrderByWithRelationInput>? orderBy,
    MENUAUTHTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateMENU_AUTH_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateMENU_AUTH_TBL',
    );
    return AggregateMENUAUTHTBL(query);
  }

  Future<Iterable<MENUAUTHTBLGroupByOutputType>> groupBy({
    MENUAUTHTBLWhereInput? where,
    Iterable<MENUAUTHTBLOrderByWithAggregationInput>? orderBy,
    required Iterable<MENUAUTHTBLScalarFieldEnum> by,
    MENUAUTHTBLScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByMENU_AUTH_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByMENU_AUTH_TBL',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByMENUAUTHTBL) =>
        groupByMENUAUTHTBL.map((Map groupByMENUAUTHTBL) =>
            MENUAUTHTBLGroupByOutputType.fromJson(groupByMENUAUTHTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension MENUTBLModelDelegateExtension on _i1.ModelDelegate<MenuTbl> {
  MENUTBLFluent<MenuTbl?> findUnique({required MENUTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueMENU_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueMENU_TBL',
    );
    final future = query(MENUTBLScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? MenuTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return MENUTBLFluent<MenuTbl?>(
      future,
      query,
    );
  }

  MENUTBLFluent<MenuTbl> findUniqueOrThrow(
      {required MENUTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueMENU_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueMENU_TBLOrThrow',
    );
    final future = query(MENUTBLScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? MenuTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: MENU_TBL)'));
    return MENUTBLFluent<MenuTbl>(
      future,
      query,
    );
  }

  MENUTBLFluent<MenuTbl?> findFirst({
    MENUTBLWhereInput? where,
    Iterable<MENUTBLOrderByWithRelationInput>? orderBy,
    MENUTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<MENUTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstMENU_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstMENU_TBL',
    );
    final future = query(MENUTBLScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? MenuTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return MENUTBLFluent<MenuTbl?>(
      future,
      query,
    );
  }

  MENUTBLFluent<MenuTbl> findFirstOrThrow({
    MENUTBLWhereInput? where,
    Iterable<MENUTBLOrderByWithRelationInput>? orderBy,
    MENUTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<MENUTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstMENU_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstMENU_TBLOrThrow',
    );
    final future = query(MENUTBLScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? MenuTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: MENU_TBL)'));
    return MENUTBLFluent<MenuTbl>(
      future,
      query,
    );
  }

  Future<Iterable<MenuTbl>> findMany({
    MENUTBLWhereInput? where,
    Iterable<MENUTBLOrderByWithRelationInput>? orderBy,
    MENUTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<MENUTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyMENU_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyMENU_TBL',
    );
    final fields = MENUTBLScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyMENUTBL) => findManyMENUTBL
        .map((Map findManyMENUTBL) => MenuTbl.fromJson(findManyMENUTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  MENUTBLFluent<MenuTbl> create({required MENUTBLCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneMENU_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneMENU_TBL',
    );
    final future = query(MENUTBLScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? MenuTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: MENU_TBL)'));
    return MENUTBLFluent<MenuTbl>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<MENUTBLCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyMENU_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyMENU_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyMENUTBL) =>
        AffectedRowsOutput.fromJson(createManyMENUTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  MENUTBLFluent<MenuTbl?> update({
    required MENUTBLUpdateInput data,
    required MENUTBLWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneMENU_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneMENU_TBL',
    );
    final future = query(MENUTBLScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? MenuTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return MENUTBLFluent<MenuTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required MENUTBLUpdateManyMutationInput data,
    MENUTBLWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyMENU_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyMENU_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyMENUTBL) =>
        AffectedRowsOutput.fromJson(updateManyMENUTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  MENUTBLFluent<MenuTbl> upsert({
    required MENUTBLWhereUniqueInput where,
    required MENUTBLCreateInput create,
    required MENUTBLUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneMENU_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneMENU_TBL',
    );
    final future = query(MENUTBLScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? MenuTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: MENU_TBL)'));
    return MENUTBLFluent<MenuTbl>(
      future,
      query,
    );
  }

  MENUTBLFluent<MenuTbl?> delete({required MENUTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneMENU_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneMENU_TBL',
    );
    final future = query(MENUTBLScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? MenuTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return MENUTBLFluent<MenuTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({MENUTBLWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyMENU_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyMENU_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyMENUTBL) =>
        AffectedRowsOutput.fromJson(deleteManyMENUTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateMENUTBL aggregate({
    MENUTBLWhereInput? where,
    Iterable<MENUTBLOrderByWithRelationInput>? orderBy,
    MENUTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateMENU_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateMENU_TBL',
    );
    return AggregateMENUTBL(query);
  }

  Future<Iterable<MENUTBLGroupByOutputType>> groupBy({
    MENUTBLWhereInput? where,
    Iterable<MENUTBLOrderByWithAggregationInput>? orderBy,
    required Iterable<MENUTBLScalarFieldEnum> by,
    MENUTBLScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByMENU_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByMENU_TBL',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByMENUTBL) =>
        groupByMENUTBL.map((Map groupByMENUTBL) =>
            MENUTBLGroupByOutputType.fromJson(groupByMENUTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension OFFICEASSETTBLModelDelegateExtension
    on _i1.ModelDelegate<OfficeAssetTbl> {
  OFFICEASSETTBLFluent<OfficeAssetTbl?> findUnique(
      {required OFFICEASSETTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueOFFICE_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueOFFICE_ASSET_TBL',
    );
    final future = query(OFFICEASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? OfficeAssetTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return OFFICEASSETTBLFluent<OfficeAssetTbl?>(
      future,
      query,
    );
  }

  OFFICEASSETTBLFluent<OfficeAssetTbl> findUniqueOrThrow(
      {required OFFICEASSETTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueOFFICE_ASSET_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueOFFICE_ASSET_TBLOrThrow',
    );
    final future = query(OFFICEASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? OfficeAssetTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: OFFICE_ASSET_TBL)'));
    return OFFICEASSETTBLFluent<OfficeAssetTbl>(
      future,
      query,
    );
  }

  OFFICEASSETTBLFluent<OfficeAssetTbl?> findFirst({
    OFFICEASSETTBLWhereInput? where,
    Iterable<OFFICEASSETTBLOrderByWithRelationInput>? orderBy,
    OFFICEASSETTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<OFFICEASSETTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstOFFICE_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstOFFICE_ASSET_TBL',
    );
    final future = query(OFFICEASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? OfficeAssetTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return OFFICEASSETTBLFluent<OfficeAssetTbl?>(
      future,
      query,
    );
  }

  OFFICEASSETTBLFluent<OfficeAssetTbl> findFirstOrThrow({
    OFFICEASSETTBLWhereInput? where,
    Iterable<OFFICEASSETTBLOrderByWithRelationInput>? orderBy,
    OFFICEASSETTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<OFFICEASSETTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstOFFICE_ASSET_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstOFFICE_ASSET_TBLOrThrow',
    );
    final future = query(OFFICEASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? OfficeAssetTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: OFFICE_ASSET_TBL)'));
    return OFFICEASSETTBLFluent<OfficeAssetTbl>(
      future,
      query,
    );
  }

  Future<Iterable<OfficeAssetTbl>> findMany({
    OFFICEASSETTBLWhereInput? where,
    Iterable<OFFICEASSETTBLOrderByWithRelationInput>? orderBy,
    OFFICEASSETTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<OFFICEASSETTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyOFFICE_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyOFFICE_ASSET_TBL',
    );
    final fields = OFFICEASSETTBLScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyOFFICEASSETTBL) =>
        findManyOFFICEASSETTBL.map((Map findManyOFFICEASSETTBL) =>
            OfficeAssetTbl.fromJson(findManyOFFICEASSETTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  OFFICEASSETTBLFluent<OfficeAssetTbl> create(
      {required OFFICEASSETTBLCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneOFFICE_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneOFFICE_ASSET_TBL',
    );
    final future = query(OFFICEASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? OfficeAssetTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: OFFICE_ASSET_TBL)'));
    return OFFICEASSETTBLFluent<OfficeAssetTbl>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<OFFICEASSETTBLCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyOFFICE_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyOFFICE_ASSET_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyOFFICEASSETTBL) =>
        AffectedRowsOutput.fromJson(createManyOFFICEASSETTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  OFFICEASSETTBLFluent<OfficeAssetTbl?> update({
    required OFFICEASSETTBLUpdateInput data,
    required OFFICEASSETTBLWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneOFFICE_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneOFFICE_ASSET_TBL',
    );
    final future = query(OFFICEASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? OfficeAssetTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return OFFICEASSETTBLFluent<OfficeAssetTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required OFFICEASSETTBLUpdateManyMutationInput data,
    OFFICEASSETTBLWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyOFFICE_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyOFFICE_ASSET_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyOFFICEASSETTBL) =>
        AffectedRowsOutput.fromJson(updateManyOFFICEASSETTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  OFFICEASSETTBLFluent<OfficeAssetTbl> upsert({
    required OFFICEASSETTBLWhereUniqueInput where,
    required OFFICEASSETTBLCreateInput create,
    required OFFICEASSETTBLUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneOFFICE_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneOFFICE_ASSET_TBL',
    );
    final future = query(OFFICEASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? OfficeAssetTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: OFFICE_ASSET_TBL)'));
    return OFFICEASSETTBLFluent<OfficeAssetTbl>(
      future,
      query,
    );
  }

  OFFICEASSETTBLFluent<OfficeAssetTbl?> delete(
      {required OFFICEASSETTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneOFFICE_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneOFFICE_ASSET_TBL',
    );
    final future = query(OFFICEASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? OfficeAssetTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return OFFICEASSETTBLFluent<OfficeAssetTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({OFFICEASSETTBLWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyOFFICE_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyOFFICE_ASSET_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyOFFICEASSETTBL) =>
        AffectedRowsOutput.fromJson(deleteManyOFFICEASSETTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateOFFICEASSETTBL aggregate({
    OFFICEASSETTBLWhereInput? where,
    Iterable<OFFICEASSETTBLOrderByWithRelationInput>? orderBy,
    OFFICEASSETTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateOFFICE_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateOFFICE_ASSET_TBL',
    );
    return AggregateOFFICEASSETTBL(query);
  }

  Future<Iterable<OFFICEASSETTBLGroupByOutputType>> groupBy({
    OFFICEASSETTBLWhereInput? where,
    Iterable<OFFICEASSETTBLOrderByWithAggregationInput>? orderBy,
    required Iterable<OFFICEASSETTBLScalarFieldEnum> by,
    OFFICEASSETTBLScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByOFFICE_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByOFFICE_ASSET_TBL',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByOFFICEASSETTBL) => groupByOFFICEASSETTBL.map(
        (Map groupByOFFICEASSETTBL) => OFFICEASSETTBLGroupByOutputType.fromJson(
            groupByOFFICEASSETTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension SERVERASSETTBLModelDelegateExtension
    on _i1.ModelDelegate<ServerAssetTbl> {
  SERVERASSETTBLFluent<ServerAssetTbl?> findUnique(
      {required SERVERASSETTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueSERVER_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueSERVER_ASSET_TBL',
    );
    final future = query(SERVERASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ServerAssetTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return SERVERASSETTBLFluent<ServerAssetTbl?>(
      future,
      query,
    );
  }

  SERVERASSETTBLFluent<ServerAssetTbl> findUniqueOrThrow(
      {required SERVERASSETTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueSERVER_ASSET_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueSERVER_ASSET_TBLOrThrow',
    );
    final future = query(SERVERASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ServerAssetTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: SERVER_ASSET_TBL)'));
    return SERVERASSETTBLFluent<ServerAssetTbl>(
      future,
      query,
    );
  }

  SERVERASSETTBLFluent<ServerAssetTbl?> findFirst({
    SERVERASSETTBLWhereInput? where,
    Iterable<SERVERASSETTBLOrderByWithRelationInput>? orderBy,
    SERVERASSETTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<SERVERASSETTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstSERVER_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstSERVER_ASSET_TBL',
    );
    final future = query(SERVERASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ServerAssetTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return SERVERASSETTBLFluent<ServerAssetTbl?>(
      future,
      query,
    );
  }

  SERVERASSETTBLFluent<ServerAssetTbl> findFirstOrThrow({
    SERVERASSETTBLWhereInput? where,
    Iterable<SERVERASSETTBLOrderByWithRelationInput>? orderBy,
    SERVERASSETTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<SERVERASSETTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstSERVER_ASSET_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstSERVER_ASSET_TBLOrThrow',
    );
    final future = query(SERVERASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ServerAssetTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: SERVER_ASSET_TBL)'));
    return SERVERASSETTBLFluent<ServerAssetTbl>(
      future,
      query,
    );
  }

  Future<Iterable<ServerAssetTbl>> findMany({
    SERVERASSETTBLWhereInput? where,
    Iterable<SERVERASSETTBLOrderByWithRelationInput>? orderBy,
    SERVERASSETTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<SERVERASSETTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManySERVER_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManySERVER_ASSET_TBL',
    );
    final fields = SERVERASSETTBLScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManySERVERASSETTBL) =>
        findManySERVERASSETTBL.map((Map findManySERVERASSETTBL) =>
            ServerAssetTbl.fromJson(findManySERVERASSETTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  SERVERASSETTBLFluent<ServerAssetTbl> create(
      {required SERVERASSETTBLCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneSERVER_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneSERVER_ASSET_TBL',
    );
    final future = query(SERVERASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ServerAssetTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: SERVER_ASSET_TBL)'));
    return SERVERASSETTBLFluent<ServerAssetTbl>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<SERVERASSETTBLCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManySERVER_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManySERVER_ASSET_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManySERVERASSETTBL) =>
        AffectedRowsOutput.fromJson(createManySERVERASSETTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  SERVERASSETTBLFluent<ServerAssetTbl?> update({
    required SERVERASSETTBLUpdateInput data,
    required SERVERASSETTBLWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneSERVER_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneSERVER_ASSET_TBL',
    );
    final future = query(SERVERASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ServerAssetTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return SERVERASSETTBLFluent<ServerAssetTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required SERVERASSETTBLUpdateManyMutationInput data,
    SERVERASSETTBLWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManySERVER_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManySERVER_ASSET_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManySERVERASSETTBL) =>
        AffectedRowsOutput.fromJson(updateManySERVERASSETTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  SERVERASSETTBLFluent<ServerAssetTbl> upsert({
    required SERVERASSETTBLWhereUniqueInput where,
    required SERVERASSETTBLCreateInput create,
    required SERVERASSETTBLUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneSERVER_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneSERVER_ASSET_TBL',
    );
    final future = query(SERVERASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ServerAssetTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: SERVER_ASSET_TBL)'));
    return SERVERASSETTBLFluent<ServerAssetTbl>(
      future,
      query,
    );
  }

  SERVERASSETTBLFluent<ServerAssetTbl?> delete(
      {required SERVERASSETTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneSERVER_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneSERVER_ASSET_TBL',
    );
    final future = query(SERVERASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? ServerAssetTbl.fromJson(json.cast<String, dynamic>())
            : null);
    return SERVERASSETTBLFluent<ServerAssetTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({SERVERASSETTBLWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManySERVER_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManySERVER_ASSET_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManySERVERASSETTBL) =>
        AffectedRowsOutput.fromJson(deleteManySERVERASSETTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateSERVERASSETTBL aggregate({
    SERVERASSETTBLWhereInput? where,
    Iterable<SERVERASSETTBLOrderByWithRelationInput>? orderBy,
    SERVERASSETTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateSERVER_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateSERVER_ASSET_TBL',
    );
    return AggregateSERVERASSETTBL(query);
  }

  Future<Iterable<SERVERASSETTBLGroupByOutputType>> groupBy({
    SERVERASSETTBLWhereInput? where,
    Iterable<SERVERASSETTBLOrderByWithAggregationInput>? orderBy,
    required Iterable<SERVERASSETTBLScalarFieldEnum> by,
    SERVERASSETTBLScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupBySERVER_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupBySERVER_ASSET_TBL',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupBySERVERASSETTBL) => groupBySERVERASSETTBL.map(
        (Map groupBySERVERASSETTBL) => SERVERASSETTBLGroupByOutputType.fromJson(
            groupBySERVERASSETTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension SOFTWAREASSETTBLModelDelegateExtension
    on _i1.ModelDelegate<SoftwareAssetTbl> {
  SOFTWAREASSETTBLFluent<SoftwareAssetTbl?> findUnique(
      {required SOFTWAREASSETTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueSOFTWARE_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueSOFTWARE_ASSET_TBL',
    );
    final future =
        query(SOFTWAREASSETTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? SoftwareAssetTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return SOFTWAREASSETTBLFluent<SoftwareAssetTbl?>(
      future,
      query,
    );
  }

  SOFTWAREASSETTBLFluent<SoftwareAssetTbl> findUniqueOrThrow(
      {required SOFTWAREASSETTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueSOFTWARE_ASSET_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueSOFTWARE_ASSET_TBLOrThrow',
    );
    final future = query(
            SOFTWAREASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? SoftwareAssetTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: SOFTWARE_ASSET_TBL)'));
    return SOFTWAREASSETTBLFluent<SoftwareAssetTbl>(
      future,
      query,
    );
  }

  SOFTWAREASSETTBLFluent<SoftwareAssetTbl?> findFirst({
    SOFTWAREASSETTBLWhereInput? where,
    Iterable<SOFTWAREASSETTBLOrderByWithRelationInput>? orderBy,
    SOFTWAREASSETTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<SOFTWAREASSETTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstSOFTWARE_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstSOFTWARE_ASSET_TBL',
    );
    final future =
        query(SOFTWAREASSETTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? SoftwareAssetTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return SOFTWAREASSETTBLFluent<SoftwareAssetTbl?>(
      future,
      query,
    );
  }

  SOFTWAREASSETTBLFluent<SoftwareAssetTbl> findFirstOrThrow({
    SOFTWAREASSETTBLWhereInput? where,
    Iterable<SOFTWAREASSETTBLOrderByWithRelationInput>? orderBy,
    SOFTWAREASSETTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<SOFTWAREASSETTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstSOFTWARE_ASSET_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstSOFTWARE_ASSET_TBLOrThrow',
    );
    final future = query(
            SOFTWAREASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? SoftwareAssetTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: SOFTWARE_ASSET_TBL)'));
    return SOFTWAREASSETTBLFluent<SoftwareAssetTbl>(
      future,
      query,
    );
  }

  Future<Iterable<SoftwareAssetTbl>> findMany({
    SOFTWAREASSETTBLWhereInput? where,
    Iterable<SOFTWAREASSETTBLOrderByWithRelationInput>? orderBy,
    SOFTWAREASSETTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<SOFTWAREASSETTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManySOFTWARE_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManySOFTWARE_ASSET_TBL',
    );
    final fields = SOFTWAREASSETTBLScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManySOFTWAREASSETTBL) =>
        findManySOFTWAREASSETTBL.map((Map findManySOFTWAREASSETTBL) =>
            SoftwareAssetTbl.fromJson(findManySOFTWAREASSETTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  SOFTWAREASSETTBLFluent<SoftwareAssetTbl> create(
      {required SOFTWAREASSETTBLCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneSOFTWARE_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneSOFTWARE_ASSET_TBL',
    );
    final future = query(
            SOFTWAREASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? SoftwareAssetTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: SOFTWARE_ASSET_TBL)'));
    return SOFTWAREASSETTBLFluent<SoftwareAssetTbl>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<SOFTWAREASSETTBLCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManySOFTWARE_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManySOFTWARE_ASSET_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManySOFTWAREASSETTBL) =>
        AffectedRowsOutput.fromJson(createManySOFTWAREASSETTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  SOFTWAREASSETTBLFluent<SoftwareAssetTbl?> update({
    required SOFTWAREASSETTBLUpdateInput data,
    required SOFTWAREASSETTBLWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneSOFTWARE_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneSOFTWARE_ASSET_TBL',
    );
    final future =
        query(SOFTWAREASSETTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? SoftwareAssetTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return SOFTWAREASSETTBLFluent<SoftwareAssetTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required SOFTWAREASSETTBLUpdateManyMutationInput data,
    SOFTWAREASSETTBLWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManySOFTWARE_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManySOFTWARE_ASSET_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManySOFTWAREASSETTBL) =>
        AffectedRowsOutput.fromJson(updateManySOFTWAREASSETTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  SOFTWAREASSETTBLFluent<SoftwareAssetTbl> upsert({
    required SOFTWAREASSETTBLWhereUniqueInput where,
    required SOFTWAREASSETTBLCreateInput create,
    required SOFTWAREASSETTBLUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneSOFTWARE_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneSOFTWARE_ASSET_TBL',
    );
    final future = query(
            SOFTWAREASSETTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? SoftwareAssetTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: SOFTWARE_ASSET_TBL)'));
    return SOFTWAREASSETTBLFluent<SoftwareAssetTbl>(
      future,
      query,
    );
  }

  SOFTWAREASSETTBLFluent<SoftwareAssetTbl?> delete(
      {required SOFTWAREASSETTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneSOFTWARE_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneSOFTWARE_ASSET_TBL',
    );
    final future =
        query(SOFTWAREASSETTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? SoftwareAssetTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return SOFTWAREASSETTBLFluent<SoftwareAssetTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({SOFTWAREASSETTBLWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManySOFTWARE_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManySOFTWARE_ASSET_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManySOFTWAREASSETTBL) =>
        AffectedRowsOutput.fromJson(deleteManySOFTWAREASSETTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateSOFTWAREASSETTBL aggregate({
    SOFTWAREASSETTBLWhereInput? where,
    Iterable<SOFTWAREASSETTBLOrderByWithRelationInput>? orderBy,
    SOFTWAREASSETTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateSOFTWARE_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateSOFTWARE_ASSET_TBL',
    );
    return AggregateSOFTWAREASSETTBL(query);
  }

  Future<Iterable<SOFTWAREASSETTBLGroupByOutputType>> groupBy({
    SOFTWAREASSETTBLWhereInput? where,
    Iterable<SOFTWAREASSETTBLOrderByWithAggregationInput>? orderBy,
    required Iterable<SOFTWAREASSETTBLScalarFieldEnum> by,
    SOFTWAREASSETTBLScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupBySOFTWARE_ASSET_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupBySOFTWARE_ASSET_TBL',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupBySOFTWAREASSETTBL) =>
        groupBySOFTWAREASSETTBL.map((Map groupBySOFTWAREASSETTBL) =>
            SOFTWAREASSETTBLGroupByOutputType.fromJson(
                groupBySOFTWAREASSETTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension STADMINMENUModelDelegateExtension on _i1.ModelDelegate<StAdminMenu> {
  STADMINMENUFluent<StAdminMenu?> findUnique(
      {required STADMINMENUWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_ADMIN_MENU',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_ADMIN_MENU',
    );
    final future = query(STADMINMENUScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StAdminMenu.fromJson(json.cast<String, dynamic>())
            : null);
    return STADMINMENUFluent<StAdminMenu?>(
      future,
      query,
    );
  }

  STADMINMENUFluent<StAdminMenu> findUniqueOrThrow(
      {required STADMINMENUWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_ADMIN_MENUOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_ADMIN_MENUOrThrow',
    );
    final future = query(STADMINMENUScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StAdminMenu.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_ADMIN_MENU)'));
    return STADMINMENUFluent<StAdminMenu>(
      future,
      query,
    );
  }

  STADMINMENUFluent<StAdminMenu?> findFirst({
    STADMINMENUWhereInput? where,
    Iterable<STADMINMENUOrderByWithRelationInput>? orderBy,
    STADMINMENUWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STADMINMENUScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_ADMIN_MENU',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_ADMIN_MENU',
    );
    final future = query(STADMINMENUScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StAdminMenu.fromJson(json.cast<String, dynamic>())
            : null);
    return STADMINMENUFluent<StAdminMenu?>(
      future,
      query,
    );
  }

  STADMINMENUFluent<StAdminMenu> findFirstOrThrow({
    STADMINMENUWhereInput? where,
    Iterable<STADMINMENUOrderByWithRelationInput>? orderBy,
    STADMINMENUWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STADMINMENUScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_ADMIN_MENUOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_ADMIN_MENUOrThrow',
    );
    final future = query(STADMINMENUScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StAdminMenu.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_ADMIN_MENU)'));
    return STADMINMENUFluent<StAdminMenu>(
      future,
      query,
    );
  }

  Future<Iterable<StAdminMenu>> findMany({
    STADMINMENUWhereInput? where,
    Iterable<STADMINMENUOrderByWithRelationInput>? orderBy,
    STADMINMENUWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STADMINMENUScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyST_ADMIN_MENU',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyST_ADMIN_MENU',
    );
    final fields = STADMINMENUScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManySTADMINMENU) =>
        findManySTADMINMENU.map((Map findManySTADMINMENU) =>
            StAdminMenu.fromJson(findManySTADMINMENU.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  STADMINMENUFluent<StAdminMenu> create(
      {required STADMINMENUCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneST_ADMIN_MENU',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneST_ADMIN_MENU',
    );
    final future = query(STADMINMENUScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StAdminMenu.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_ADMIN_MENU)'));
    return STADMINMENUFluent<StAdminMenu>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<STADMINMENUCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyST_ADMIN_MENU',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyST_ADMIN_MENU',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManySTADMINMENU) =>
        AffectedRowsOutput.fromJson(createManySTADMINMENU.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STADMINMENUFluent<StAdminMenu?> update({
    required STADMINMENUUpdateInput data,
    required STADMINMENUWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneST_ADMIN_MENU',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneST_ADMIN_MENU',
    );
    final future = query(STADMINMENUScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StAdminMenu.fromJson(json.cast<String, dynamic>())
            : null);
    return STADMINMENUFluent<StAdminMenu?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required STADMINMENUUpdateManyMutationInput data,
    STADMINMENUWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyST_ADMIN_MENU',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyST_ADMIN_MENU',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManySTADMINMENU) =>
        AffectedRowsOutput.fromJson(updateManySTADMINMENU.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STADMINMENUFluent<StAdminMenu> upsert({
    required STADMINMENUWhereUniqueInput where,
    required STADMINMENUCreateInput create,
    required STADMINMENUUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneST_ADMIN_MENU',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneST_ADMIN_MENU',
    );
    final future = query(STADMINMENUScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StAdminMenu.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_ADMIN_MENU)'));
    return STADMINMENUFluent<StAdminMenu>(
      future,
      query,
    );
  }

  STADMINMENUFluent<StAdminMenu?> delete(
      {required STADMINMENUWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneST_ADMIN_MENU',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneST_ADMIN_MENU',
    );
    final future = query(STADMINMENUScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StAdminMenu.fromJson(json.cast<String, dynamic>())
            : null);
    return STADMINMENUFluent<StAdminMenu?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({STADMINMENUWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyST_ADMIN_MENU',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyST_ADMIN_MENU',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManySTADMINMENU) =>
        AffectedRowsOutput.fromJson(deleteManySTADMINMENU.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateSTADMINMENU aggregate({
    STADMINMENUWhereInput? where,
    Iterable<STADMINMENUOrderByWithRelationInput>? orderBy,
    STADMINMENUWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateST_ADMIN_MENU',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateST_ADMIN_MENU',
    );
    return AggregateSTADMINMENU(query);
  }

  Future<Iterable<STADMINMENUGroupByOutputType>> groupBy({
    STADMINMENUWhereInput? where,
    Iterable<STADMINMENUOrderByWithAggregationInput>? orderBy,
    required Iterable<STADMINMENUScalarFieldEnum> by,
    STADMINMENUScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByST_ADMIN_MENU',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByST_ADMIN_MENU',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupBySTADMINMENU) =>
        groupBySTADMINMENU.map((Map groupBySTADMINMENU) =>
            STADMINMENUGroupByOutputType.fromJson(groupBySTADMINMENU.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension STALARMModelDelegateExtension on _i1.ModelDelegate<StAlarm> {
  STALARMFluent<StAlarm?> findUnique({required STALARMWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_ALARM',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_ALARM',
    );
    final future = query(STALARMScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StAlarm.fromJson(json.cast<String, dynamic>())
            : null);
    return STALARMFluent<StAlarm?>(
      future,
      query,
    );
  }

  STALARMFluent<StAlarm> findUniqueOrThrow(
      {required STALARMWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_ALARMOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_ALARMOrThrow',
    );
    final future = query(STALARMScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StAlarm.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_ALARM)'));
    return STALARMFluent<StAlarm>(
      future,
      query,
    );
  }

  STALARMFluent<StAlarm?> findFirst({
    STALARMWhereInput? where,
    Iterable<STALARMOrderByWithRelationInput>? orderBy,
    STALARMWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STALARMScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_ALARM',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_ALARM',
    );
    final future = query(STALARMScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StAlarm.fromJson(json.cast<String, dynamic>())
            : null);
    return STALARMFluent<StAlarm?>(
      future,
      query,
    );
  }

  STALARMFluent<StAlarm> findFirstOrThrow({
    STALARMWhereInput? where,
    Iterable<STALARMOrderByWithRelationInput>? orderBy,
    STALARMWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STALARMScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_ALARMOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_ALARMOrThrow',
    );
    final future = query(STALARMScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StAlarm.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_ALARM)'));
    return STALARMFluent<StAlarm>(
      future,
      query,
    );
  }

  Future<Iterable<StAlarm>> findMany({
    STALARMWhereInput? where,
    Iterable<STALARMOrderByWithRelationInput>? orderBy,
    STALARMWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STALARMScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyST_ALARM',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyST_ALARM',
    );
    final fields = STALARMScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManySTALARM) => findManySTALARM
        .map((Map findManySTALARM) => StAlarm.fromJson(findManySTALARM.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  STALARMFluent<StAlarm> create({required STALARMCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneST_ALARM',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneST_ALARM',
    );
    final future = query(STALARMScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StAlarm.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_ALARM)'));
    return STALARMFluent<StAlarm>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<STALARMCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyST_ALARM',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyST_ALARM',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManySTALARM) =>
        AffectedRowsOutput.fromJson(createManySTALARM.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STALARMFluent<StAlarm?> update({
    required STALARMUpdateInput data,
    required STALARMWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneST_ALARM',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneST_ALARM',
    );
    final future = query(STALARMScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StAlarm.fromJson(json.cast<String, dynamic>())
            : null);
    return STALARMFluent<StAlarm?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required STALARMUpdateManyMutationInput data,
    STALARMWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyST_ALARM',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyST_ALARM',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManySTALARM) =>
        AffectedRowsOutput.fromJson(updateManySTALARM.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STALARMFluent<StAlarm> upsert({
    required STALARMWhereUniqueInput where,
    required STALARMCreateInput create,
    required STALARMUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneST_ALARM',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneST_ALARM',
    );
    final future = query(STALARMScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StAlarm.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_ALARM)'));
    return STALARMFluent<StAlarm>(
      future,
      query,
    );
  }

  STALARMFluent<StAlarm?> delete({required STALARMWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneST_ALARM',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneST_ALARM',
    );
    final future = query(STALARMScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StAlarm.fromJson(json.cast<String, dynamic>())
            : null);
    return STALARMFluent<StAlarm?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({STALARMWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyST_ALARM',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyST_ALARM',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManySTALARM) =>
        AffectedRowsOutput.fromJson(deleteManySTALARM.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateSTALARM aggregate({
    STALARMWhereInput? where,
    Iterable<STALARMOrderByWithRelationInput>? orderBy,
    STALARMWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateST_ALARM',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateST_ALARM',
    );
    return AggregateSTALARM(query);
  }

  Future<Iterable<STALARMGroupByOutputType>> groupBy({
    STALARMWhereInput? where,
    Iterable<STALARMOrderByWithAggregationInput>? orderBy,
    required Iterable<STALARMScalarFieldEnum> by,
    STALARMScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByST_ALARM',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByST_ALARM',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupBySTALARM) =>
        groupBySTALARM.map((Map groupBySTALARM) =>
            STALARMGroupByOutputType.fromJson(groupBySTALARM.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension STAUDITLOGModelDelegateExtension on _i1.ModelDelegate<StAuditLog> {
  STAUDITLOGFluent<StAuditLog?> findUnique(
      {required STAUDITLOGWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_AUDIT_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_AUDIT_LOG',
    );
    final future = query(STAUDITLOGScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StAuditLog.fromJson(json.cast<String, dynamic>())
            : null);
    return STAUDITLOGFluent<StAuditLog?>(
      future,
      query,
    );
  }

  STAUDITLOGFluent<StAuditLog> findUniqueOrThrow(
      {required STAUDITLOGWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_AUDIT_LOGOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_AUDIT_LOGOrThrow',
    );
    final future = query(STAUDITLOGScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StAuditLog.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_AUDIT_LOG)'));
    return STAUDITLOGFluent<StAuditLog>(
      future,
      query,
    );
  }

  STAUDITLOGFluent<StAuditLog?> findFirst({
    STAUDITLOGWhereInput? where,
    Iterable<STAUDITLOGOrderByWithRelationInput>? orderBy,
    STAUDITLOGWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STAUDITLOGScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_AUDIT_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_AUDIT_LOG',
    );
    final future = query(STAUDITLOGScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StAuditLog.fromJson(json.cast<String, dynamic>())
            : null);
    return STAUDITLOGFluent<StAuditLog?>(
      future,
      query,
    );
  }

  STAUDITLOGFluent<StAuditLog> findFirstOrThrow({
    STAUDITLOGWhereInput? where,
    Iterable<STAUDITLOGOrderByWithRelationInput>? orderBy,
    STAUDITLOGWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STAUDITLOGScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_AUDIT_LOGOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_AUDIT_LOGOrThrow',
    );
    final future = query(STAUDITLOGScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StAuditLog.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_AUDIT_LOG)'));
    return STAUDITLOGFluent<StAuditLog>(
      future,
      query,
    );
  }

  Future<Iterable<StAuditLog>> findMany({
    STAUDITLOGWhereInput? where,
    Iterable<STAUDITLOGOrderByWithRelationInput>? orderBy,
    STAUDITLOGWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STAUDITLOGScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyST_AUDIT_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyST_AUDIT_LOG',
    );
    final fields = STAUDITLOGScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManySTAUDITLOG) =>
        findManySTAUDITLOG.map((Map findManySTAUDITLOG) =>
            StAuditLog.fromJson(findManySTAUDITLOG.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  STAUDITLOGFluent<StAuditLog> create({required STAUDITLOGCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneST_AUDIT_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneST_AUDIT_LOG',
    );
    final future = query(STAUDITLOGScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StAuditLog.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_AUDIT_LOG)'));
    return STAUDITLOGFluent<StAuditLog>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<STAUDITLOGCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyST_AUDIT_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyST_AUDIT_LOG',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManySTAUDITLOG) =>
        AffectedRowsOutput.fromJson(createManySTAUDITLOG.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STAUDITLOGFluent<StAuditLog?> update({
    required STAUDITLOGUpdateInput data,
    required STAUDITLOGWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneST_AUDIT_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneST_AUDIT_LOG',
    );
    final future = query(STAUDITLOGScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StAuditLog.fromJson(json.cast<String, dynamic>())
            : null);
    return STAUDITLOGFluent<StAuditLog?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required STAUDITLOGUpdateManyMutationInput data,
    STAUDITLOGWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyST_AUDIT_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyST_AUDIT_LOG',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManySTAUDITLOG) =>
        AffectedRowsOutput.fromJson(updateManySTAUDITLOG.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STAUDITLOGFluent<StAuditLog> upsert({
    required STAUDITLOGWhereUniqueInput where,
    required STAUDITLOGCreateInput create,
    required STAUDITLOGUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneST_AUDIT_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneST_AUDIT_LOG',
    );
    final future = query(STAUDITLOGScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StAuditLog.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_AUDIT_LOG)'));
    return STAUDITLOGFluent<StAuditLog>(
      future,
      query,
    );
  }

  STAUDITLOGFluent<StAuditLog?> delete(
      {required STAUDITLOGWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneST_AUDIT_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneST_AUDIT_LOG',
    );
    final future = query(STAUDITLOGScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StAuditLog.fromJson(json.cast<String, dynamic>())
            : null);
    return STAUDITLOGFluent<StAuditLog?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({STAUDITLOGWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyST_AUDIT_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyST_AUDIT_LOG',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManySTAUDITLOG) =>
        AffectedRowsOutput.fromJson(deleteManySTAUDITLOG.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateSTAUDITLOG aggregate({
    STAUDITLOGWhereInput? where,
    Iterable<STAUDITLOGOrderByWithRelationInput>? orderBy,
    STAUDITLOGWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateST_AUDIT_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateST_AUDIT_LOG',
    );
    return AggregateSTAUDITLOG(query);
  }

  Future<Iterable<STAUDITLOGGroupByOutputType>> groupBy({
    STAUDITLOGWhereInput? where,
    Iterable<STAUDITLOGOrderByWithAggregationInput>? orderBy,
    required Iterable<STAUDITLOGScalarFieldEnum> by,
    STAUDITLOGScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByST_AUDIT_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByST_AUDIT_LOG',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupBySTAUDITLOG) =>
        groupBySTAUDITLOG.map((Map groupBySTAUDITLOG) =>
            STAUDITLOGGroupByOutputType.fromJson(groupBySTAUDITLOG.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension STBANNERModelDelegateExtension on _i1.ModelDelegate<StBanner> {
  STBANNERFluent<StBanner?> findUnique(
      {required STBANNERWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_BANNER',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_BANNER',
    );
    final future = query(STBANNERScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StBanner.fromJson(json.cast<String, dynamic>())
            : null);
    return STBANNERFluent<StBanner?>(
      future,
      query,
    );
  }

  STBANNERFluent<StBanner> findUniqueOrThrow(
      {required STBANNERWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_BANNEROrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_BANNEROrThrow',
    );
    final future = query(STBANNERScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StBanner.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_BANNER)'));
    return STBANNERFluent<StBanner>(
      future,
      query,
    );
  }

  STBANNERFluent<StBanner?> findFirst({
    STBANNERWhereInput? where,
    Iterable<STBANNEROrderByWithRelationInput>? orderBy,
    STBANNERWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STBANNERScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_BANNER',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_BANNER',
    );
    final future = query(STBANNERScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StBanner.fromJson(json.cast<String, dynamic>())
            : null);
    return STBANNERFluent<StBanner?>(
      future,
      query,
    );
  }

  STBANNERFluent<StBanner> findFirstOrThrow({
    STBANNERWhereInput? where,
    Iterable<STBANNEROrderByWithRelationInput>? orderBy,
    STBANNERWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STBANNERScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_BANNEROrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_BANNEROrThrow',
    );
    final future = query(STBANNERScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StBanner.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_BANNER)'));
    return STBANNERFluent<StBanner>(
      future,
      query,
    );
  }

  Future<Iterable<StBanner>> findMany({
    STBANNERWhereInput? where,
    Iterable<STBANNEROrderByWithRelationInput>? orderBy,
    STBANNERWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STBANNERScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyST_BANNER',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyST_BANNER',
    );
    final fields = STBANNERScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManySTBANNER) => findManySTBANNER.map(
        (Map findManySTBANNER) => StBanner.fromJson(findManySTBANNER.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  STBANNERFluent<StBanner> create({required STBANNERCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneST_BANNER',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneST_BANNER',
    );
    final future = query(STBANNERScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StBanner.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_BANNER)'));
    return STBANNERFluent<StBanner>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<STBANNERCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyST_BANNER',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyST_BANNER',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManySTBANNER) =>
        AffectedRowsOutput.fromJson(createManySTBANNER.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STBANNERFluent<StBanner?> update({
    required STBANNERUpdateInput data,
    required STBANNERWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneST_BANNER',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneST_BANNER',
    );
    final future = query(STBANNERScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StBanner.fromJson(json.cast<String, dynamic>())
            : null);
    return STBANNERFluent<StBanner?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required STBANNERUpdateManyMutationInput data,
    STBANNERWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyST_BANNER',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyST_BANNER',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManySTBANNER) =>
        AffectedRowsOutput.fromJson(updateManySTBANNER.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STBANNERFluent<StBanner> upsert({
    required STBANNERWhereUniqueInput where,
    required STBANNERCreateInput create,
    required STBANNERUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneST_BANNER',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneST_BANNER',
    );
    final future = query(STBANNERScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StBanner.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_BANNER)'));
    return STBANNERFluent<StBanner>(
      future,
      query,
    );
  }

  STBANNERFluent<StBanner?> delete({required STBANNERWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneST_BANNER',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneST_BANNER',
    );
    final future = query(STBANNERScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StBanner.fromJson(json.cast<String, dynamic>())
            : null);
    return STBANNERFluent<StBanner?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({STBANNERWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyST_BANNER',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyST_BANNER',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManySTBANNER) =>
        AffectedRowsOutput.fromJson(deleteManySTBANNER.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateSTBANNER aggregate({
    STBANNERWhereInput? where,
    Iterable<STBANNEROrderByWithRelationInput>? orderBy,
    STBANNERWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateST_BANNER',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateST_BANNER',
    );
    return AggregateSTBANNER(query);
  }

  Future<Iterable<STBANNERGroupByOutputType>> groupBy({
    STBANNERWhereInput? where,
    Iterable<STBANNEROrderByWithAggregationInput>? orderBy,
    required Iterable<STBANNERScalarFieldEnum> by,
    STBANNERScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByST_BANNER',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByST_BANNER',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupBySTBANNER) =>
        groupBySTBANNER.map((Map groupBySTBANNER) =>
            STBANNERGroupByOutputType.fromJson(groupBySTBANNER.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension STBOARDCOLUMNModelDelegateExtension
    on _i1.ModelDelegate<StBoardColumn> {
  STBOARDCOLUMNFluent<StBoardColumn?> findUnique(
      {required STBOARDCOLUMNWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_BOARD_COLUMN',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_BOARD_COLUMN',
    );
    final future = query(STBOARDCOLUMNScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardColumn.fromJson(json.cast<String, dynamic>())
            : null);
    return STBOARDCOLUMNFluent<StBoardColumn?>(
      future,
      query,
    );
  }

  STBOARDCOLUMNFluent<StBoardColumn> findUniqueOrThrow(
      {required STBOARDCOLUMNWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_BOARD_COLUMNOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_BOARD_COLUMNOrThrow',
    );
    final future = query(STBOARDCOLUMNScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardColumn.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_BOARD_COLUMN)'));
    return STBOARDCOLUMNFluent<StBoardColumn>(
      future,
      query,
    );
  }

  STBOARDCOLUMNFluent<StBoardColumn?> findFirst({
    STBOARDCOLUMNWhereInput? where,
    Iterable<STBOARDCOLUMNOrderByWithRelationInput>? orderBy,
    STBOARDCOLUMNWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STBOARDCOLUMNScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_BOARD_COLUMN',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_BOARD_COLUMN',
    );
    final future = query(STBOARDCOLUMNScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardColumn.fromJson(json.cast<String, dynamic>())
            : null);
    return STBOARDCOLUMNFluent<StBoardColumn?>(
      future,
      query,
    );
  }

  STBOARDCOLUMNFluent<StBoardColumn> findFirstOrThrow({
    STBOARDCOLUMNWhereInput? where,
    Iterable<STBOARDCOLUMNOrderByWithRelationInput>? orderBy,
    STBOARDCOLUMNWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STBOARDCOLUMNScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_BOARD_COLUMNOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_BOARD_COLUMNOrThrow',
    );
    final future = query(STBOARDCOLUMNScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardColumn.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_BOARD_COLUMN)'));
    return STBOARDCOLUMNFluent<StBoardColumn>(
      future,
      query,
    );
  }

  Future<Iterable<StBoardColumn>> findMany({
    STBOARDCOLUMNWhereInput? where,
    Iterable<STBOARDCOLUMNOrderByWithRelationInput>? orderBy,
    STBOARDCOLUMNWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STBOARDCOLUMNScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyST_BOARD_COLUMN',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyST_BOARD_COLUMN',
    );
    final fields = STBOARDCOLUMNScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManySTBOARDCOLUMN) =>
        findManySTBOARDCOLUMN.map((Map findManySTBOARDCOLUMN) =>
            StBoardColumn.fromJson(findManySTBOARDCOLUMN.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  STBOARDCOLUMNFluent<StBoardColumn> create(
      {required STBOARDCOLUMNCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneST_BOARD_COLUMN',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneST_BOARD_COLUMN',
    );
    final future = query(STBOARDCOLUMNScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardColumn.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_BOARD_COLUMN)'));
    return STBOARDCOLUMNFluent<StBoardColumn>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<STBOARDCOLUMNCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyST_BOARD_COLUMN',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyST_BOARD_COLUMN',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManySTBOARDCOLUMN) =>
        AffectedRowsOutput.fromJson(createManySTBOARDCOLUMN.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STBOARDCOLUMNFluent<StBoardColumn?> update({
    required STBOARDCOLUMNUpdateInput data,
    required STBOARDCOLUMNWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneST_BOARD_COLUMN',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneST_BOARD_COLUMN',
    );
    final future = query(STBOARDCOLUMNScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardColumn.fromJson(json.cast<String, dynamic>())
            : null);
    return STBOARDCOLUMNFluent<StBoardColumn?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required STBOARDCOLUMNUpdateManyMutationInput data,
    STBOARDCOLUMNWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyST_BOARD_COLUMN',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyST_BOARD_COLUMN',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManySTBOARDCOLUMN) =>
        AffectedRowsOutput.fromJson(updateManySTBOARDCOLUMN.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STBOARDCOLUMNFluent<StBoardColumn> upsert({
    required STBOARDCOLUMNWhereUniqueInput where,
    required STBOARDCOLUMNCreateInput create,
    required STBOARDCOLUMNUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneST_BOARD_COLUMN',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneST_BOARD_COLUMN',
    );
    final future = query(STBOARDCOLUMNScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardColumn.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_BOARD_COLUMN)'));
    return STBOARDCOLUMNFluent<StBoardColumn>(
      future,
      query,
    );
  }

  STBOARDCOLUMNFluent<StBoardColumn?> delete(
      {required STBOARDCOLUMNWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneST_BOARD_COLUMN',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneST_BOARD_COLUMN',
    );
    final future = query(STBOARDCOLUMNScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardColumn.fromJson(json.cast<String, dynamic>())
            : null);
    return STBOARDCOLUMNFluent<StBoardColumn?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({STBOARDCOLUMNWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyST_BOARD_COLUMN',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyST_BOARD_COLUMN',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManySTBOARDCOLUMN) =>
        AffectedRowsOutput.fromJson(deleteManySTBOARDCOLUMN.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateSTBOARDCOLUMN aggregate({
    STBOARDCOLUMNWhereInput? where,
    Iterable<STBOARDCOLUMNOrderByWithRelationInput>? orderBy,
    STBOARDCOLUMNWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateST_BOARD_COLUMN',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateST_BOARD_COLUMN',
    );
    return AggregateSTBOARDCOLUMN(query);
  }

  Future<Iterable<STBOARDCOLUMNGroupByOutputType>> groupBy({
    STBOARDCOLUMNWhereInput? where,
    Iterable<STBOARDCOLUMNOrderByWithAggregationInput>? orderBy,
    required Iterable<STBOARDCOLUMNScalarFieldEnum> by,
    STBOARDCOLUMNScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByST_BOARD_COLUMN',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByST_BOARD_COLUMN',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupBySTBOARDCOLUMN) => groupBySTBOARDCOLUMN.map(
        (Map groupBySTBOARDCOLUMN) => STBOARDCOLUMNGroupByOutputType.fromJson(
            groupBySTBOARDCOLUMN.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension STBOARDCOLUMNDFTModelDelegateExtension
    on _i1.ModelDelegate<StBoardColumnDft> {
  STBOARDCOLUMNDFTFluent<StBoardColumnDft?> findUnique(
      {required STBOARDCOLUMNDFTWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_BOARD_COLUMN_DFT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_BOARD_COLUMN_DFT',
    );
    final future =
        query(STBOARDCOLUMNDFTScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? StBoardColumnDft.fromJson(json.cast<String, dynamic>())
                : null);
    return STBOARDCOLUMNDFTFluent<StBoardColumnDft?>(
      future,
      query,
    );
  }

  STBOARDCOLUMNDFTFluent<StBoardColumnDft> findUniqueOrThrow(
      {required STBOARDCOLUMNDFTWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_BOARD_COLUMN_DFTOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_BOARD_COLUMN_DFTOrThrow',
    );
    final future = query(
            STBOARDCOLUMNDFTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardColumnDft.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_BOARD_COLUMN_DFT)'));
    return STBOARDCOLUMNDFTFluent<StBoardColumnDft>(
      future,
      query,
    );
  }

  STBOARDCOLUMNDFTFluent<StBoardColumnDft?> findFirst({
    STBOARDCOLUMNDFTWhereInput? where,
    Iterable<STBOARDCOLUMNDFTOrderByWithRelationInput>? orderBy,
    STBOARDCOLUMNDFTWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STBOARDCOLUMNDFTScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_BOARD_COLUMN_DFT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_BOARD_COLUMN_DFT',
    );
    final future =
        query(STBOARDCOLUMNDFTScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? StBoardColumnDft.fromJson(json.cast<String, dynamic>())
                : null);
    return STBOARDCOLUMNDFTFluent<StBoardColumnDft?>(
      future,
      query,
    );
  }

  STBOARDCOLUMNDFTFluent<StBoardColumnDft> findFirstOrThrow({
    STBOARDCOLUMNDFTWhereInput? where,
    Iterable<STBOARDCOLUMNDFTOrderByWithRelationInput>? orderBy,
    STBOARDCOLUMNDFTWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STBOARDCOLUMNDFTScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_BOARD_COLUMN_DFTOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_BOARD_COLUMN_DFTOrThrow',
    );
    final future = query(
            STBOARDCOLUMNDFTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardColumnDft.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_BOARD_COLUMN_DFT)'));
    return STBOARDCOLUMNDFTFluent<StBoardColumnDft>(
      future,
      query,
    );
  }

  Future<Iterable<StBoardColumnDft>> findMany({
    STBOARDCOLUMNDFTWhereInput? where,
    Iterable<STBOARDCOLUMNDFTOrderByWithRelationInput>? orderBy,
    STBOARDCOLUMNDFTWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STBOARDCOLUMNDFTScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyST_BOARD_COLUMN_DFT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyST_BOARD_COLUMN_DFT',
    );
    final fields = STBOARDCOLUMNDFTScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManySTBOARDCOLUMNDFT) =>
        findManySTBOARDCOLUMNDFT.map((Map findManySTBOARDCOLUMNDFT) =>
            StBoardColumnDft.fromJson(findManySTBOARDCOLUMNDFT.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  STBOARDCOLUMNDFTFluent<StBoardColumnDft> create(
      {required STBOARDCOLUMNDFTCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneST_BOARD_COLUMN_DFT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneST_BOARD_COLUMN_DFT',
    );
    final future = query(
            STBOARDCOLUMNDFTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardColumnDft.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_BOARD_COLUMN_DFT)'));
    return STBOARDCOLUMNDFTFluent<StBoardColumnDft>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<STBOARDCOLUMNDFTCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyST_BOARD_COLUMN_DFT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyST_BOARD_COLUMN_DFT',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManySTBOARDCOLUMNDFT) =>
        AffectedRowsOutput.fromJson(createManySTBOARDCOLUMNDFT.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STBOARDCOLUMNDFTFluent<StBoardColumnDft?> update({
    required STBOARDCOLUMNDFTUpdateInput data,
    required STBOARDCOLUMNDFTWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneST_BOARD_COLUMN_DFT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneST_BOARD_COLUMN_DFT',
    );
    final future =
        query(STBOARDCOLUMNDFTScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? StBoardColumnDft.fromJson(json.cast<String, dynamic>())
                : null);
    return STBOARDCOLUMNDFTFluent<StBoardColumnDft?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required STBOARDCOLUMNDFTUpdateManyMutationInput data,
    STBOARDCOLUMNDFTWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyST_BOARD_COLUMN_DFT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyST_BOARD_COLUMN_DFT',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManySTBOARDCOLUMNDFT) =>
        AffectedRowsOutput.fromJson(updateManySTBOARDCOLUMNDFT.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STBOARDCOLUMNDFTFluent<StBoardColumnDft> upsert({
    required STBOARDCOLUMNDFTWhereUniqueInput where,
    required STBOARDCOLUMNDFTCreateInput create,
    required STBOARDCOLUMNDFTUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneST_BOARD_COLUMN_DFT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneST_BOARD_COLUMN_DFT',
    );
    final future = query(
            STBOARDCOLUMNDFTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardColumnDft.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_BOARD_COLUMN_DFT)'));
    return STBOARDCOLUMNDFTFluent<StBoardColumnDft>(
      future,
      query,
    );
  }

  STBOARDCOLUMNDFTFluent<StBoardColumnDft?> delete(
      {required STBOARDCOLUMNDFTWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneST_BOARD_COLUMN_DFT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneST_BOARD_COLUMN_DFT',
    );
    final future =
        query(STBOARDCOLUMNDFTScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? StBoardColumnDft.fromJson(json.cast<String, dynamic>())
                : null);
    return STBOARDCOLUMNDFTFluent<StBoardColumnDft?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({STBOARDCOLUMNDFTWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyST_BOARD_COLUMN_DFT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyST_BOARD_COLUMN_DFT',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManySTBOARDCOLUMNDFT) =>
        AffectedRowsOutput.fromJson(deleteManySTBOARDCOLUMNDFT.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateSTBOARDCOLUMNDFT aggregate({
    STBOARDCOLUMNDFTWhereInput? where,
    Iterable<STBOARDCOLUMNDFTOrderByWithRelationInput>? orderBy,
    STBOARDCOLUMNDFTWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateST_BOARD_COLUMN_DFT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateST_BOARD_COLUMN_DFT',
    );
    return AggregateSTBOARDCOLUMNDFT(query);
  }

  Future<Iterable<STBOARDCOLUMNDFTGroupByOutputType>> groupBy({
    STBOARDCOLUMNDFTWhereInput? where,
    Iterable<STBOARDCOLUMNDFTOrderByWithAggregationInput>? orderBy,
    required Iterable<STBOARDCOLUMNDFTScalarFieldEnum> by,
    STBOARDCOLUMNDFTScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByST_BOARD_COLUMN_DFT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByST_BOARD_COLUMN_DFT',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupBySTBOARDCOLUMNDFT) =>
        groupBySTBOARDCOLUMNDFT.map((Map groupBySTBOARDCOLUMNDFT) =>
            STBOARDCOLUMNDFTGroupByOutputType.fromJson(
                groupBySTBOARDCOLUMNDFT.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension STBOARDCOMMENTModelDelegateExtension
    on _i1.ModelDelegate<StBoardComment> {
  STBOARDCOMMENTFluent<StBoardComment?> findUnique(
      {required STBOARDCOMMENTWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_BOARD_COMMENT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_BOARD_COMMENT',
    );
    final future = query(STBOARDCOMMENTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardComment.fromJson(json.cast<String, dynamic>())
            : null);
    return STBOARDCOMMENTFluent<StBoardComment?>(
      future,
      query,
    );
  }

  STBOARDCOMMENTFluent<StBoardComment> findUniqueOrThrow(
      {required STBOARDCOMMENTWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_BOARD_COMMENTOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_BOARD_COMMENTOrThrow',
    );
    final future = query(STBOARDCOMMENTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardComment.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_BOARD_COMMENT)'));
    return STBOARDCOMMENTFluent<StBoardComment>(
      future,
      query,
    );
  }

  STBOARDCOMMENTFluent<StBoardComment?> findFirst({
    STBOARDCOMMENTWhereInput? where,
    Iterable<STBOARDCOMMENTOrderByWithRelationInput>? orderBy,
    STBOARDCOMMENTWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STBOARDCOMMENTScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_BOARD_COMMENT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_BOARD_COMMENT',
    );
    final future = query(STBOARDCOMMENTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardComment.fromJson(json.cast<String, dynamic>())
            : null);
    return STBOARDCOMMENTFluent<StBoardComment?>(
      future,
      query,
    );
  }

  STBOARDCOMMENTFluent<StBoardComment> findFirstOrThrow({
    STBOARDCOMMENTWhereInput? where,
    Iterable<STBOARDCOMMENTOrderByWithRelationInput>? orderBy,
    STBOARDCOMMENTWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STBOARDCOMMENTScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_BOARD_COMMENTOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_BOARD_COMMENTOrThrow',
    );
    final future = query(STBOARDCOMMENTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardComment.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_BOARD_COMMENT)'));
    return STBOARDCOMMENTFluent<StBoardComment>(
      future,
      query,
    );
  }

  Future<Iterable<StBoardComment>> findMany({
    STBOARDCOMMENTWhereInput? where,
    Iterable<STBOARDCOMMENTOrderByWithRelationInput>? orderBy,
    STBOARDCOMMENTWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STBOARDCOMMENTScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyST_BOARD_COMMENT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyST_BOARD_COMMENT',
    );
    final fields = STBOARDCOMMENTScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManySTBOARDCOMMENT) =>
        findManySTBOARDCOMMENT.map((Map findManySTBOARDCOMMENT) =>
            StBoardComment.fromJson(findManySTBOARDCOMMENT.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  STBOARDCOMMENTFluent<StBoardComment> create(
      {required STBOARDCOMMENTCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneST_BOARD_COMMENT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneST_BOARD_COMMENT',
    );
    final future = query(STBOARDCOMMENTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardComment.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_BOARD_COMMENT)'));
    return STBOARDCOMMENTFluent<StBoardComment>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<STBOARDCOMMENTCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyST_BOARD_COMMENT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyST_BOARD_COMMENT',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManySTBOARDCOMMENT) =>
        AffectedRowsOutput.fromJson(createManySTBOARDCOMMENT.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STBOARDCOMMENTFluent<StBoardComment?> update({
    required STBOARDCOMMENTUpdateInput data,
    required STBOARDCOMMENTWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneST_BOARD_COMMENT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneST_BOARD_COMMENT',
    );
    final future = query(STBOARDCOMMENTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardComment.fromJson(json.cast<String, dynamic>())
            : null);
    return STBOARDCOMMENTFluent<StBoardComment?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required STBOARDCOMMENTUpdateManyMutationInput data,
    STBOARDCOMMENTWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyST_BOARD_COMMENT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyST_BOARD_COMMENT',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManySTBOARDCOMMENT) =>
        AffectedRowsOutput.fromJson(updateManySTBOARDCOMMENT.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STBOARDCOMMENTFluent<StBoardComment> upsert({
    required STBOARDCOMMENTWhereUniqueInput where,
    required STBOARDCOMMENTCreateInput create,
    required STBOARDCOMMENTUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneST_BOARD_COMMENT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneST_BOARD_COMMENT',
    );
    final future = query(STBOARDCOMMENTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardComment.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_BOARD_COMMENT)'));
    return STBOARDCOMMENTFluent<StBoardComment>(
      future,
      query,
    );
  }

  STBOARDCOMMENTFluent<StBoardComment?> delete(
      {required STBOARDCOMMENTWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneST_BOARD_COMMENT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneST_BOARD_COMMENT',
    );
    final future = query(STBOARDCOMMENTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardComment.fromJson(json.cast<String, dynamic>())
            : null);
    return STBOARDCOMMENTFluent<StBoardComment?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({STBOARDCOMMENTWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyST_BOARD_COMMENT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyST_BOARD_COMMENT',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManySTBOARDCOMMENT) =>
        AffectedRowsOutput.fromJson(deleteManySTBOARDCOMMENT.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateSTBOARDCOMMENT aggregate({
    STBOARDCOMMENTWhereInput? where,
    Iterable<STBOARDCOMMENTOrderByWithRelationInput>? orderBy,
    STBOARDCOMMENTWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateST_BOARD_COMMENT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateST_BOARD_COMMENT',
    );
    return AggregateSTBOARDCOMMENT(query);
  }

  Future<Iterable<STBOARDCOMMENTGroupByOutputType>> groupBy({
    STBOARDCOMMENTWhereInput? where,
    Iterable<STBOARDCOMMENTOrderByWithAggregationInput>? orderBy,
    required Iterable<STBOARDCOMMENTScalarFieldEnum> by,
    STBOARDCOMMENTScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByST_BOARD_COMMENT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByST_BOARD_COMMENT',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupBySTBOARDCOMMENT) => groupBySTBOARDCOMMENT.map(
        (Map groupBySTBOARDCOMMENT) => STBOARDCOMMENTGroupByOutputType.fromJson(
            groupBySTBOARDCOMMENT.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension STBOARDFILEModelDelegateExtension on _i1.ModelDelegate<StBoardFile> {
  STBOARDFILEFluent<StBoardFile?> findUnique(
      {required STBOARDFILEWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_BOARD_FILE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_BOARD_FILE',
    );
    final future = query(STBOARDFILEScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardFile.fromJson(json.cast<String, dynamic>())
            : null);
    return STBOARDFILEFluent<StBoardFile?>(
      future,
      query,
    );
  }

  STBOARDFILEFluent<StBoardFile> findUniqueOrThrow(
      {required STBOARDFILEWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_BOARD_FILEOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_BOARD_FILEOrThrow',
    );
    final future = query(STBOARDFILEScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardFile.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_BOARD_FILE)'));
    return STBOARDFILEFluent<StBoardFile>(
      future,
      query,
    );
  }

  STBOARDFILEFluent<StBoardFile?> findFirst({
    STBOARDFILEWhereInput? where,
    Iterable<STBOARDFILEOrderByWithRelationInput>? orderBy,
    STBOARDFILEWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STBOARDFILEScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_BOARD_FILE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_BOARD_FILE',
    );
    final future = query(STBOARDFILEScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardFile.fromJson(json.cast<String, dynamic>())
            : null);
    return STBOARDFILEFluent<StBoardFile?>(
      future,
      query,
    );
  }

  STBOARDFILEFluent<StBoardFile> findFirstOrThrow({
    STBOARDFILEWhereInput? where,
    Iterable<STBOARDFILEOrderByWithRelationInput>? orderBy,
    STBOARDFILEWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STBOARDFILEScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_BOARD_FILEOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_BOARD_FILEOrThrow',
    );
    final future = query(STBOARDFILEScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardFile.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_BOARD_FILE)'));
    return STBOARDFILEFluent<StBoardFile>(
      future,
      query,
    );
  }

  Future<Iterable<StBoardFile>> findMany({
    STBOARDFILEWhereInput? where,
    Iterable<STBOARDFILEOrderByWithRelationInput>? orderBy,
    STBOARDFILEWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STBOARDFILEScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyST_BOARD_FILE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyST_BOARD_FILE',
    );
    final fields = STBOARDFILEScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManySTBOARDFILE) =>
        findManySTBOARDFILE.map((Map findManySTBOARDFILE) =>
            StBoardFile.fromJson(findManySTBOARDFILE.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  STBOARDFILEFluent<StBoardFile> create(
      {required STBOARDFILECreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneST_BOARD_FILE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneST_BOARD_FILE',
    );
    final future = query(STBOARDFILEScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardFile.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_BOARD_FILE)'));
    return STBOARDFILEFluent<StBoardFile>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<STBOARDFILECreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyST_BOARD_FILE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyST_BOARD_FILE',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManySTBOARDFILE) =>
        AffectedRowsOutput.fromJson(createManySTBOARDFILE.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STBOARDFILEFluent<StBoardFile?> update({
    required STBOARDFILEUpdateInput data,
    required STBOARDFILEWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneST_BOARD_FILE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneST_BOARD_FILE',
    );
    final future = query(STBOARDFILEScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardFile.fromJson(json.cast<String, dynamic>())
            : null);
    return STBOARDFILEFluent<StBoardFile?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required STBOARDFILEUpdateManyMutationInput data,
    STBOARDFILEWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyST_BOARD_FILE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyST_BOARD_FILE',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManySTBOARDFILE) =>
        AffectedRowsOutput.fromJson(updateManySTBOARDFILE.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STBOARDFILEFluent<StBoardFile> upsert({
    required STBOARDFILEWhereUniqueInput where,
    required STBOARDFILECreateInput create,
    required STBOARDFILEUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneST_BOARD_FILE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneST_BOARD_FILE',
    );
    final future = query(STBOARDFILEScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardFile.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_BOARD_FILE)'));
    return STBOARDFILEFluent<StBoardFile>(
      future,
      query,
    );
  }

  STBOARDFILEFluent<StBoardFile?> delete(
      {required STBOARDFILEWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneST_BOARD_FILE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneST_BOARD_FILE',
    );
    final future = query(STBOARDFILEScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardFile.fromJson(json.cast<String, dynamic>())
            : null);
    return STBOARDFILEFluent<StBoardFile?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({STBOARDFILEWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyST_BOARD_FILE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyST_BOARD_FILE',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManySTBOARDFILE) =>
        AffectedRowsOutput.fromJson(deleteManySTBOARDFILE.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateSTBOARDFILE aggregate({
    STBOARDFILEWhereInput? where,
    Iterable<STBOARDFILEOrderByWithRelationInput>? orderBy,
    STBOARDFILEWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateST_BOARD_FILE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateST_BOARD_FILE',
    );
    return AggregateSTBOARDFILE(query);
  }

  Future<Iterable<STBOARDFILEGroupByOutputType>> groupBy({
    STBOARDFILEWhereInput? where,
    Iterable<STBOARDFILEOrderByWithAggregationInput>? orderBy,
    required Iterable<STBOARDFILEScalarFieldEnum> by,
    STBOARDFILEScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByST_BOARD_FILE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByST_BOARD_FILE',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupBySTBOARDFILE) =>
        groupBySTBOARDFILE.map((Map groupBySTBOARDFILE) =>
            STBOARDFILEGroupByOutputType.fromJson(groupBySTBOARDFILE.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension STBOARDMSTModelDelegateExtension on _i1.ModelDelegate<StBoardMst> {
  STBOARDMSTFluent<StBoardMst?> findUnique(
      {required STBOARDMSTWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_BOARD_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_BOARD_MST',
    );
    final future = query(STBOARDMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardMst.fromJson(json.cast<String, dynamic>())
            : null);
    return STBOARDMSTFluent<StBoardMst?>(
      future,
      query,
    );
  }

  STBOARDMSTFluent<StBoardMst> findUniqueOrThrow(
      {required STBOARDMSTWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_BOARD_MSTOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_BOARD_MSTOrThrow',
    );
    final future = query(STBOARDMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardMst.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_BOARD_MST)'));
    return STBOARDMSTFluent<StBoardMst>(
      future,
      query,
    );
  }

  STBOARDMSTFluent<StBoardMst?> findFirst({
    STBOARDMSTWhereInput? where,
    Iterable<STBOARDMSTOrderByWithRelationInput>? orderBy,
    STBOARDMSTWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STBOARDMSTScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_BOARD_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_BOARD_MST',
    );
    final future = query(STBOARDMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardMst.fromJson(json.cast<String, dynamic>())
            : null);
    return STBOARDMSTFluent<StBoardMst?>(
      future,
      query,
    );
  }

  STBOARDMSTFluent<StBoardMst> findFirstOrThrow({
    STBOARDMSTWhereInput? where,
    Iterable<STBOARDMSTOrderByWithRelationInput>? orderBy,
    STBOARDMSTWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STBOARDMSTScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_BOARD_MSTOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_BOARD_MSTOrThrow',
    );
    final future = query(STBOARDMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardMst.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_BOARD_MST)'));
    return STBOARDMSTFluent<StBoardMst>(
      future,
      query,
    );
  }

  Future<Iterable<StBoardMst>> findMany({
    STBOARDMSTWhereInput? where,
    Iterable<STBOARDMSTOrderByWithRelationInput>? orderBy,
    STBOARDMSTWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STBOARDMSTScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyST_BOARD_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyST_BOARD_MST',
    );
    final fields = STBOARDMSTScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManySTBOARDMST) =>
        findManySTBOARDMST.map((Map findManySTBOARDMST) =>
            StBoardMst.fromJson(findManySTBOARDMST.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  STBOARDMSTFluent<StBoardMst> create({required STBOARDMSTCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneST_BOARD_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneST_BOARD_MST',
    );
    final future = query(STBOARDMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardMst.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_BOARD_MST)'));
    return STBOARDMSTFluent<StBoardMst>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<STBOARDMSTCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyST_BOARD_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyST_BOARD_MST',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManySTBOARDMST) =>
        AffectedRowsOutput.fromJson(createManySTBOARDMST.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STBOARDMSTFluent<StBoardMst?> update({
    required STBOARDMSTUpdateInput data,
    required STBOARDMSTWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneST_BOARD_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneST_BOARD_MST',
    );
    final future = query(STBOARDMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardMst.fromJson(json.cast<String, dynamic>())
            : null);
    return STBOARDMSTFluent<StBoardMst?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required STBOARDMSTUpdateManyMutationInput data,
    STBOARDMSTWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyST_BOARD_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyST_BOARD_MST',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManySTBOARDMST) =>
        AffectedRowsOutput.fromJson(updateManySTBOARDMST.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STBOARDMSTFluent<StBoardMst> upsert({
    required STBOARDMSTWhereUniqueInput where,
    required STBOARDMSTCreateInput create,
    required STBOARDMSTUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneST_BOARD_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneST_BOARD_MST',
    );
    final future = query(STBOARDMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardMst.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_BOARD_MST)'));
    return STBOARDMSTFluent<StBoardMst>(
      future,
      query,
    );
  }

  STBOARDMSTFluent<StBoardMst?> delete(
      {required STBOARDMSTWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneST_BOARD_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneST_BOARD_MST',
    );
    final future = query(STBOARDMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardMst.fromJson(json.cast<String, dynamic>())
            : null);
    return STBOARDMSTFluent<StBoardMst?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({STBOARDMSTWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyST_BOARD_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyST_BOARD_MST',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManySTBOARDMST) =>
        AffectedRowsOutput.fromJson(deleteManySTBOARDMST.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateSTBOARDMST aggregate({
    STBOARDMSTWhereInput? where,
    Iterable<STBOARDMSTOrderByWithRelationInput>? orderBy,
    STBOARDMSTWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateST_BOARD_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateST_BOARD_MST',
    );
    return AggregateSTBOARDMST(query);
  }

  Future<Iterable<STBOARDMSTGroupByOutputType>> groupBy({
    STBOARDMSTWhereInput? where,
    Iterable<STBOARDMSTOrderByWithAggregationInput>? orderBy,
    required Iterable<STBOARDMSTScalarFieldEnum> by,
    STBOARDMSTScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByST_BOARD_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByST_BOARD_MST',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupBySTBOARDMST) =>
        groupBySTBOARDMST.map((Map groupBySTBOARDMST) =>
            STBOARDMSTGroupByOutputType.fromJson(groupBySTBOARDMST.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension STBOARDSTNGModelDelegateExtension on _i1.ModelDelegate<StBoardStng> {
  STBOARDSTNGFluent<StBoardStng?> findUnique(
      {required STBOARDSTNGWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_BOARD_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_BOARD_STNG',
    );
    final future = query(STBOARDSTNGScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardStng.fromJson(json.cast<String, dynamic>())
            : null);
    return STBOARDSTNGFluent<StBoardStng?>(
      future,
      query,
    );
  }

  STBOARDSTNGFluent<StBoardStng> findUniqueOrThrow(
      {required STBOARDSTNGWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_BOARD_STNGOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_BOARD_STNGOrThrow',
    );
    final future = query(STBOARDSTNGScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardStng.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_BOARD_STNG)'));
    return STBOARDSTNGFluent<StBoardStng>(
      future,
      query,
    );
  }

  STBOARDSTNGFluent<StBoardStng?> findFirst({
    STBOARDSTNGWhereInput? where,
    Iterable<STBOARDSTNGOrderByWithRelationInput>? orderBy,
    STBOARDSTNGWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STBOARDSTNGScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_BOARD_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_BOARD_STNG',
    );
    final future = query(STBOARDSTNGScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardStng.fromJson(json.cast<String, dynamic>())
            : null);
    return STBOARDSTNGFluent<StBoardStng?>(
      future,
      query,
    );
  }

  STBOARDSTNGFluent<StBoardStng> findFirstOrThrow({
    STBOARDSTNGWhereInput? where,
    Iterable<STBOARDSTNGOrderByWithRelationInput>? orderBy,
    STBOARDSTNGWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STBOARDSTNGScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_BOARD_STNGOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_BOARD_STNGOrThrow',
    );
    final future = query(STBOARDSTNGScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardStng.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_BOARD_STNG)'));
    return STBOARDSTNGFluent<StBoardStng>(
      future,
      query,
    );
  }

  Future<Iterable<StBoardStng>> findMany({
    STBOARDSTNGWhereInput? where,
    Iterable<STBOARDSTNGOrderByWithRelationInput>? orderBy,
    STBOARDSTNGWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STBOARDSTNGScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyST_BOARD_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyST_BOARD_STNG',
    );
    final fields = STBOARDSTNGScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManySTBOARDSTNG) =>
        findManySTBOARDSTNG.map((Map findManySTBOARDSTNG) =>
            StBoardStng.fromJson(findManySTBOARDSTNG.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  STBOARDSTNGFluent<StBoardStng> create(
      {required STBOARDSTNGCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneST_BOARD_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneST_BOARD_STNG',
    );
    final future = query(STBOARDSTNGScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardStng.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_BOARD_STNG)'));
    return STBOARDSTNGFluent<StBoardStng>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<STBOARDSTNGCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyST_BOARD_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyST_BOARD_STNG',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManySTBOARDSTNG) =>
        AffectedRowsOutput.fromJson(createManySTBOARDSTNG.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STBOARDSTNGFluent<StBoardStng?> update({
    required STBOARDSTNGUpdateInput data,
    required STBOARDSTNGWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneST_BOARD_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneST_BOARD_STNG',
    );
    final future = query(STBOARDSTNGScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardStng.fromJson(json.cast<String, dynamic>())
            : null);
    return STBOARDSTNGFluent<StBoardStng?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required STBOARDSTNGUpdateManyMutationInput data,
    STBOARDSTNGWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyST_BOARD_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyST_BOARD_STNG',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManySTBOARDSTNG) =>
        AffectedRowsOutput.fromJson(updateManySTBOARDSTNG.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STBOARDSTNGFluent<StBoardStng> upsert({
    required STBOARDSTNGWhereUniqueInput where,
    required STBOARDSTNGCreateInput create,
    required STBOARDSTNGUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneST_BOARD_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneST_BOARD_STNG',
    );
    final future = query(STBOARDSTNGScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardStng.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_BOARD_STNG)'));
    return STBOARDSTNGFluent<StBoardStng>(
      future,
      query,
    );
  }

  STBOARDSTNGFluent<StBoardStng?> delete(
      {required STBOARDSTNGWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneST_BOARD_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneST_BOARD_STNG',
    );
    final future = query(STBOARDSTNGScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StBoardStng.fromJson(json.cast<String, dynamic>())
            : null);
    return STBOARDSTNGFluent<StBoardStng?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({STBOARDSTNGWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyST_BOARD_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyST_BOARD_STNG',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManySTBOARDSTNG) =>
        AffectedRowsOutput.fromJson(deleteManySTBOARDSTNG.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateSTBOARDSTNG aggregate({
    STBOARDSTNGWhereInput? where,
    Iterable<STBOARDSTNGOrderByWithRelationInput>? orderBy,
    STBOARDSTNGWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateST_BOARD_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateST_BOARD_STNG',
    );
    return AggregateSTBOARDSTNG(query);
  }

  Future<Iterable<STBOARDSTNGGroupByOutputType>> groupBy({
    STBOARDSTNGWhereInput? where,
    Iterable<STBOARDSTNGOrderByWithAggregationInput>? orderBy,
    required Iterable<STBOARDSTNGScalarFieldEnum> by,
    STBOARDSTNGScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByST_BOARD_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByST_BOARD_STNG',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupBySTBOARDSTNG) =>
        groupBySTBOARDSTNG.map((Map groupBySTBOARDSTNG) =>
            STBOARDSTNGGroupByOutputType.fromJson(groupBySTBOARDSTNG.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension STCCLModelDelegateExtension on _i1.ModelDelegate<StCcl> {
  STCCLFluent<StCcl?> findUnique({required STCCLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_CCL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_CCL',
    );
    final future = query(STCCLScalarFieldEnum.values.toGraphQLFields()).then(
        (json) =>
            json is Map ? StCcl.fromJson(json.cast<String, dynamic>()) : null);
    return STCCLFluent<StCcl?>(
      future,
      query,
    );
  }

  STCCLFluent<StCcl> findUniqueOrThrow({required STCCLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_CCLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_CCLOrThrow',
    );
    final future = query(STCCLScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StCcl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_CCL)'));
    return STCCLFluent<StCcl>(
      future,
      query,
    );
  }

  STCCLFluent<StCcl?> findFirst({
    STCCLWhereInput? where,
    Iterable<STCCLOrderByWithRelationInput>? orderBy,
    STCCLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STCCLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_CCL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_CCL',
    );
    final future = query(STCCLScalarFieldEnum.values.toGraphQLFields()).then(
        (json) =>
            json is Map ? StCcl.fromJson(json.cast<String, dynamic>()) : null);
    return STCCLFluent<StCcl?>(
      future,
      query,
    );
  }

  STCCLFluent<StCcl> findFirstOrThrow({
    STCCLWhereInput? where,
    Iterable<STCCLOrderByWithRelationInput>? orderBy,
    STCCLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STCCLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_CCLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_CCLOrThrow',
    );
    final future = query(STCCLScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StCcl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_CCL)'));
    return STCCLFluent<StCcl>(
      future,
      query,
    );
  }

  Future<Iterable<StCcl>> findMany({
    STCCLWhereInput? where,
    Iterable<STCCLOrderByWithRelationInput>? orderBy,
    STCCLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STCCLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyST_CCL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyST_CCL',
    );
    final fields = STCCLScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManySTCCL) => findManySTCCL
        .map((Map findManySTCCL) => StCcl.fromJson(findManySTCCL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  STCCLFluent<StCcl> create({required STCCLCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneST_CCL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneST_CCL',
    );
    final future = query(STCCLScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StCcl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_CCL)'));
    return STCCLFluent<StCcl>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<STCCLCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyST_CCL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyST_CCL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManySTCCL) =>
        AffectedRowsOutput.fromJson(createManySTCCL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STCCLFluent<StCcl?> update({
    required STCCLUpdateInput data,
    required STCCLWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneST_CCL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneST_CCL',
    );
    final future = query(STCCLScalarFieldEnum.values.toGraphQLFields()).then(
        (json) =>
            json is Map ? StCcl.fromJson(json.cast<String, dynamic>()) : null);
    return STCCLFluent<StCcl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required STCCLUpdateManyMutationInput data,
    STCCLWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyST_CCL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyST_CCL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManySTCCL) =>
        AffectedRowsOutput.fromJson(updateManySTCCL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STCCLFluent<StCcl> upsert({
    required STCCLWhereUniqueInput where,
    required STCCLCreateInput create,
    required STCCLUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneST_CCL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneST_CCL',
    );
    final future = query(STCCLScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StCcl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_CCL)'));
    return STCCLFluent<StCcl>(
      future,
      query,
    );
  }

  STCCLFluent<StCcl?> delete({required STCCLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneST_CCL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneST_CCL',
    );
    final future = query(STCCLScalarFieldEnum.values.toGraphQLFields()).then(
        (json) =>
            json is Map ? StCcl.fromJson(json.cast<String, dynamic>()) : null);
    return STCCLFluent<StCcl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({STCCLWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyST_CCL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyST_CCL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManySTCCL) =>
        AffectedRowsOutput.fromJson(deleteManySTCCL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateSTCCL aggregate({
    STCCLWhereInput? where,
    Iterable<STCCLOrderByWithRelationInput>? orderBy,
    STCCLWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateST_CCL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateST_CCL',
    );
    return AggregateSTCCL(query);
  }

  Future<Iterable<STCCLGroupByOutputType>> groupBy({
    STCCLWhereInput? where,
    Iterable<STCCLOrderByWithAggregationInput>? orderBy,
    required Iterable<STCCLScalarFieldEnum> by,
    STCCLScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByST_CCL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByST_CCL',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupBySTCCL) =>
        groupBySTCCL.map((Map groupBySTCCL) =>
            STCCLGroupByOutputType.fromJson(groupBySTCCL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension STCODEMSTModelDelegateExtension on _i1.ModelDelegate<StCodeMst> {
  STCODEMSTFluent<StCodeMst?> findUnique(
      {required STCODEMSTWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_CODE_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_CODE_MST',
    );
    final future = query(STCODEMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StCodeMst.fromJson(json.cast<String, dynamic>())
            : null);
    return STCODEMSTFluent<StCodeMst?>(
      future,
      query,
    );
  }

  STCODEMSTFluent<StCodeMst> findUniqueOrThrow(
      {required STCODEMSTWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_CODE_MSTOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_CODE_MSTOrThrow',
    );
    final future = query(STCODEMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StCodeMst.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_CODE_MST)'));
    return STCODEMSTFluent<StCodeMst>(
      future,
      query,
    );
  }

  STCODEMSTFluent<StCodeMst?> findFirst({
    STCODEMSTWhereInput? where,
    Iterable<STCODEMSTOrderByWithRelationInput>? orderBy,
    STCODEMSTWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STCODEMSTScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_CODE_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_CODE_MST',
    );
    final future = query(STCODEMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StCodeMst.fromJson(json.cast<String, dynamic>())
            : null);
    return STCODEMSTFluent<StCodeMst?>(
      future,
      query,
    );
  }

  STCODEMSTFluent<StCodeMst> findFirstOrThrow({
    STCODEMSTWhereInput? where,
    Iterable<STCODEMSTOrderByWithRelationInput>? orderBy,
    STCODEMSTWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STCODEMSTScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_CODE_MSTOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_CODE_MSTOrThrow',
    );
    final future = query(STCODEMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StCodeMst.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_CODE_MST)'));
    return STCODEMSTFluent<StCodeMst>(
      future,
      query,
    );
  }

  Future<Iterable<StCodeMst>> findMany({
    STCODEMSTWhereInput? where,
    Iterable<STCODEMSTOrderByWithRelationInput>? orderBy,
    STCODEMSTWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STCODEMSTScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyST_CODE_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyST_CODE_MST',
    );
    final fields = STCODEMSTScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManySTCODEMST) =>
        findManySTCODEMST.map((Map findManySTCODEMST) =>
            StCodeMst.fromJson(findManySTCODEMST.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  STCODEMSTFluent<StCodeMst> create({required STCODEMSTCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneST_CODE_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneST_CODE_MST',
    );
    final future = query(STCODEMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StCodeMst.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_CODE_MST)'));
    return STCODEMSTFluent<StCodeMst>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<STCODEMSTCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyST_CODE_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyST_CODE_MST',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManySTCODEMST) =>
        AffectedRowsOutput.fromJson(createManySTCODEMST.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STCODEMSTFluent<StCodeMst?> update({
    required STCODEMSTUpdateInput data,
    required STCODEMSTWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneST_CODE_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneST_CODE_MST',
    );
    final future = query(STCODEMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StCodeMst.fromJson(json.cast<String, dynamic>())
            : null);
    return STCODEMSTFluent<StCodeMst?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required STCODEMSTUpdateManyMutationInput data,
    STCODEMSTWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyST_CODE_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyST_CODE_MST',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManySTCODEMST) =>
        AffectedRowsOutput.fromJson(updateManySTCODEMST.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STCODEMSTFluent<StCodeMst> upsert({
    required STCODEMSTWhereUniqueInput where,
    required STCODEMSTCreateInput create,
    required STCODEMSTUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneST_CODE_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneST_CODE_MST',
    );
    final future = query(STCODEMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StCodeMst.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_CODE_MST)'));
    return STCODEMSTFluent<StCodeMst>(
      future,
      query,
    );
  }

  STCODEMSTFluent<StCodeMst?> delete(
      {required STCODEMSTWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneST_CODE_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneST_CODE_MST',
    );
    final future = query(STCODEMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StCodeMst.fromJson(json.cast<String, dynamic>())
            : null);
    return STCODEMSTFluent<StCodeMst?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({STCODEMSTWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyST_CODE_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyST_CODE_MST',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManySTCODEMST) =>
        AffectedRowsOutput.fromJson(deleteManySTCODEMST.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateSTCODEMST aggregate({
    STCODEMSTWhereInput? where,
    Iterable<STCODEMSTOrderByWithRelationInput>? orderBy,
    STCODEMSTWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateST_CODE_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateST_CODE_MST',
    );
    return AggregateSTCODEMST(query);
  }

  Future<Iterable<STCODEMSTGroupByOutputType>> groupBy({
    STCODEMSTWhereInput? where,
    Iterable<STCODEMSTOrderByWithAggregationInput>? orderBy,
    required Iterable<STCODEMSTScalarFieldEnum> by,
    STCODEMSTScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByST_CODE_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByST_CODE_MST',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupBySTCODEMST) =>
        groupBySTCODEMST.map((Map groupBySTCODEMST) =>
            STCODEMSTGroupByOutputType.fromJson(groupBySTCODEMST.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension STCONNECTLOGModelDelegateExtension
    on _i1.ModelDelegate<StConnectLog> {
  STCONNECTLOGFluent<StConnectLog?> findUnique(
      {required STCONNECTLOGWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_CONNECT_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_CONNECT_LOG',
    );
    final future = query(STCONNECTLOGScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StConnectLog.fromJson(json.cast<String, dynamic>())
            : null);
    return STCONNECTLOGFluent<StConnectLog?>(
      future,
      query,
    );
  }

  STCONNECTLOGFluent<StConnectLog> findUniqueOrThrow(
      {required STCONNECTLOGWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_CONNECT_LOGOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_CONNECT_LOGOrThrow',
    );
    final future = query(STCONNECTLOGScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StConnectLog.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_CONNECT_LOG)'));
    return STCONNECTLOGFluent<StConnectLog>(
      future,
      query,
    );
  }

  STCONNECTLOGFluent<StConnectLog?> findFirst({
    STCONNECTLOGWhereInput? where,
    Iterable<STCONNECTLOGOrderByWithRelationInput>? orderBy,
    STCONNECTLOGWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STCONNECTLOGScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_CONNECT_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_CONNECT_LOG',
    );
    final future = query(STCONNECTLOGScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StConnectLog.fromJson(json.cast<String, dynamic>())
            : null);
    return STCONNECTLOGFluent<StConnectLog?>(
      future,
      query,
    );
  }

  STCONNECTLOGFluent<StConnectLog> findFirstOrThrow({
    STCONNECTLOGWhereInput? where,
    Iterable<STCONNECTLOGOrderByWithRelationInput>? orderBy,
    STCONNECTLOGWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STCONNECTLOGScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_CONNECT_LOGOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_CONNECT_LOGOrThrow',
    );
    final future = query(STCONNECTLOGScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StConnectLog.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_CONNECT_LOG)'));
    return STCONNECTLOGFluent<StConnectLog>(
      future,
      query,
    );
  }

  Future<Iterable<StConnectLog>> findMany({
    STCONNECTLOGWhereInput? where,
    Iterable<STCONNECTLOGOrderByWithRelationInput>? orderBy,
    STCONNECTLOGWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STCONNECTLOGScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyST_CONNECT_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyST_CONNECT_LOG',
    );
    final fields = STCONNECTLOGScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManySTCONNECTLOG) =>
        findManySTCONNECTLOG.map((Map findManySTCONNECTLOG) =>
            StConnectLog.fromJson(findManySTCONNECTLOG.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  STCONNECTLOGFluent<StConnectLog> create(
      {required STCONNECTLOGCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneST_CONNECT_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneST_CONNECT_LOG',
    );
    final future = query(STCONNECTLOGScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StConnectLog.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_CONNECT_LOG)'));
    return STCONNECTLOGFluent<StConnectLog>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<STCONNECTLOGCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyST_CONNECT_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyST_CONNECT_LOG',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManySTCONNECTLOG) =>
        AffectedRowsOutput.fromJson(createManySTCONNECTLOG.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STCONNECTLOGFluent<StConnectLog?> update({
    required STCONNECTLOGUpdateInput data,
    required STCONNECTLOGWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneST_CONNECT_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneST_CONNECT_LOG',
    );
    final future = query(STCONNECTLOGScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StConnectLog.fromJson(json.cast<String, dynamic>())
            : null);
    return STCONNECTLOGFluent<StConnectLog?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required STCONNECTLOGUpdateManyMutationInput data,
    STCONNECTLOGWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyST_CONNECT_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyST_CONNECT_LOG',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManySTCONNECTLOG) =>
        AffectedRowsOutput.fromJson(updateManySTCONNECTLOG.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STCONNECTLOGFluent<StConnectLog> upsert({
    required STCONNECTLOGWhereUniqueInput where,
    required STCONNECTLOGCreateInput create,
    required STCONNECTLOGUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneST_CONNECT_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneST_CONNECT_LOG',
    );
    final future = query(STCONNECTLOGScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StConnectLog.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_CONNECT_LOG)'));
    return STCONNECTLOGFluent<StConnectLog>(
      future,
      query,
    );
  }

  STCONNECTLOGFluent<StConnectLog?> delete(
      {required STCONNECTLOGWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneST_CONNECT_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneST_CONNECT_LOG',
    );
    final future = query(STCONNECTLOGScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StConnectLog.fromJson(json.cast<String, dynamic>())
            : null);
    return STCONNECTLOGFluent<StConnectLog?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({STCONNECTLOGWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyST_CONNECT_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyST_CONNECT_LOG',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManySTCONNECTLOG) =>
        AffectedRowsOutput.fromJson(deleteManySTCONNECTLOG.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateSTCONNECTLOG aggregate({
    STCONNECTLOGWhereInput? where,
    Iterable<STCONNECTLOGOrderByWithRelationInput>? orderBy,
    STCONNECTLOGWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateST_CONNECT_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateST_CONNECT_LOG',
    );
    return AggregateSTCONNECTLOG(query);
  }

  Future<Iterable<STCONNECTLOGGroupByOutputType>> groupBy({
    STCONNECTLOGWhereInput? where,
    Iterable<STCONNECTLOGOrderByWithAggregationInput>? orderBy,
    required Iterable<STCONNECTLOGScalarFieldEnum> by,
    STCONNECTLOGScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByST_CONNECT_LOG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByST_CONNECT_LOG',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupBySTCONNECTLOG) =>
        groupBySTCONNECTLOG.map((Map groupBySTCONNECTLOG) =>
            STCONNECTLOGGroupByOutputType.fromJson(groupBySTCONNECTLOG.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension STCONTENTSFILEModelDelegateExtension
    on _i1.ModelDelegate<StContentsFile> {
  STCONTENTSFILEFluent<StContentsFile?> findUnique(
      {required STCONTENTSFILEWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_CONTENTS_FILE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_CONTENTS_FILE',
    );
    final future = query(STCONTENTSFILEScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StContentsFile.fromJson(json.cast<String, dynamic>())
            : null);
    return STCONTENTSFILEFluent<StContentsFile?>(
      future,
      query,
    );
  }

  STCONTENTSFILEFluent<StContentsFile> findUniqueOrThrow(
      {required STCONTENTSFILEWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_CONTENTS_FILEOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_CONTENTS_FILEOrThrow',
    );
    final future = query(STCONTENTSFILEScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StContentsFile.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_CONTENTS_FILE)'));
    return STCONTENTSFILEFluent<StContentsFile>(
      future,
      query,
    );
  }

  STCONTENTSFILEFluent<StContentsFile?> findFirst({
    STCONTENTSFILEWhereInput? where,
    Iterable<STCONTENTSFILEOrderByWithRelationInput>? orderBy,
    STCONTENTSFILEWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STCONTENTSFILEScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_CONTENTS_FILE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_CONTENTS_FILE',
    );
    final future = query(STCONTENTSFILEScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StContentsFile.fromJson(json.cast<String, dynamic>())
            : null);
    return STCONTENTSFILEFluent<StContentsFile?>(
      future,
      query,
    );
  }

  STCONTENTSFILEFluent<StContentsFile> findFirstOrThrow({
    STCONTENTSFILEWhereInput? where,
    Iterable<STCONTENTSFILEOrderByWithRelationInput>? orderBy,
    STCONTENTSFILEWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STCONTENTSFILEScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_CONTENTS_FILEOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_CONTENTS_FILEOrThrow',
    );
    final future = query(STCONTENTSFILEScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StContentsFile.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_CONTENTS_FILE)'));
    return STCONTENTSFILEFluent<StContentsFile>(
      future,
      query,
    );
  }

  Future<Iterable<StContentsFile>> findMany({
    STCONTENTSFILEWhereInput? where,
    Iterable<STCONTENTSFILEOrderByWithRelationInput>? orderBy,
    STCONTENTSFILEWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STCONTENTSFILEScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyST_CONTENTS_FILE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyST_CONTENTS_FILE',
    );
    final fields = STCONTENTSFILEScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManySTCONTENTSFILE) =>
        findManySTCONTENTSFILE.map((Map findManySTCONTENTSFILE) =>
            StContentsFile.fromJson(findManySTCONTENTSFILE.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  STCONTENTSFILEFluent<StContentsFile> create(
      {required STCONTENTSFILECreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneST_CONTENTS_FILE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneST_CONTENTS_FILE',
    );
    final future = query(STCONTENTSFILEScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StContentsFile.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_CONTENTS_FILE)'));
    return STCONTENTSFILEFluent<StContentsFile>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<STCONTENTSFILECreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyST_CONTENTS_FILE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyST_CONTENTS_FILE',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManySTCONTENTSFILE) =>
        AffectedRowsOutput.fromJson(createManySTCONTENTSFILE.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STCONTENTSFILEFluent<StContentsFile?> update({
    required STCONTENTSFILEUpdateInput data,
    required STCONTENTSFILEWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneST_CONTENTS_FILE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneST_CONTENTS_FILE',
    );
    final future = query(STCONTENTSFILEScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StContentsFile.fromJson(json.cast<String, dynamic>())
            : null);
    return STCONTENTSFILEFluent<StContentsFile?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required STCONTENTSFILEUpdateManyMutationInput data,
    STCONTENTSFILEWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyST_CONTENTS_FILE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyST_CONTENTS_FILE',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManySTCONTENTSFILE) =>
        AffectedRowsOutput.fromJson(updateManySTCONTENTSFILE.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STCONTENTSFILEFluent<StContentsFile> upsert({
    required STCONTENTSFILEWhereUniqueInput where,
    required STCONTENTSFILECreateInput create,
    required STCONTENTSFILEUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneST_CONTENTS_FILE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneST_CONTENTS_FILE',
    );
    final future = query(STCONTENTSFILEScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StContentsFile.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_CONTENTS_FILE)'));
    return STCONTENTSFILEFluent<StContentsFile>(
      future,
      query,
    );
  }

  STCONTENTSFILEFluent<StContentsFile?> delete(
      {required STCONTENTSFILEWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneST_CONTENTS_FILE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneST_CONTENTS_FILE',
    );
    final future = query(STCONTENTSFILEScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StContentsFile.fromJson(json.cast<String, dynamic>())
            : null);
    return STCONTENTSFILEFluent<StContentsFile?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({STCONTENTSFILEWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyST_CONTENTS_FILE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyST_CONTENTS_FILE',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManySTCONTENTSFILE) =>
        AffectedRowsOutput.fromJson(deleteManySTCONTENTSFILE.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateSTCONTENTSFILE aggregate({
    STCONTENTSFILEWhereInput? where,
    Iterable<STCONTENTSFILEOrderByWithRelationInput>? orderBy,
    STCONTENTSFILEWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateST_CONTENTS_FILE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateST_CONTENTS_FILE',
    );
    return AggregateSTCONTENTSFILE(query);
  }

  Future<Iterable<STCONTENTSFILEGroupByOutputType>> groupBy({
    STCONTENTSFILEWhereInput? where,
    Iterable<STCONTENTSFILEOrderByWithAggregationInput>? orderBy,
    required Iterable<STCONTENTSFILEScalarFieldEnum> by,
    STCONTENTSFILEScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByST_CONTENTS_FILE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByST_CONTENTS_FILE',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupBySTCONTENTSFILE) => groupBySTCONTENTSFILE.map(
        (Map groupBySTCONTENTSFILE) => STCONTENTSFILEGroupByOutputType.fromJson(
            groupBySTCONTENTSFILE.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension STCONTENTSMSTModelDelegateExtension
    on _i1.ModelDelegate<StContentsMst> {
  STCONTENTSMSTFluent<StContentsMst?> findUnique(
      {required STCONTENTSMSTWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_CONTENTS_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_CONTENTS_MST',
    );
    final future = query(STCONTENTSMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StContentsMst.fromJson(json.cast<String, dynamic>())
            : null);
    return STCONTENTSMSTFluent<StContentsMst?>(
      future,
      query,
    );
  }

  STCONTENTSMSTFluent<StContentsMst> findUniqueOrThrow(
      {required STCONTENTSMSTWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_CONTENTS_MSTOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_CONTENTS_MSTOrThrow',
    );
    final future = query(STCONTENTSMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StContentsMst.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_CONTENTS_MST)'));
    return STCONTENTSMSTFluent<StContentsMst>(
      future,
      query,
    );
  }

  STCONTENTSMSTFluent<StContentsMst?> findFirst({
    STCONTENTSMSTWhereInput? where,
    Iterable<STCONTENTSMSTOrderByWithRelationInput>? orderBy,
    STCONTENTSMSTWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STCONTENTSMSTScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_CONTENTS_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_CONTENTS_MST',
    );
    final future = query(STCONTENTSMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StContentsMst.fromJson(json.cast<String, dynamic>())
            : null);
    return STCONTENTSMSTFluent<StContentsMst?>(
      future,
      query,
    );
  }

  STCONTENTSMSTFluent<StContentsMst> findFirstOrThrow({
    STCONTENTSMSTWhereInput? where,
    Iterable<STCONTENTSMSTOrderByWithRelationInput>? orderBy,
    STCONTENTSMSTWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STCONTENTSMSTScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_CONTENTS_MSTOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_CONTENTS_MSTOrThrow',
    );
    final future = query(STCONTENTSMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StContentsMst.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_CONTENTS_MST)'));
    return STCONTENTSMSTFluent<StContentsMst>(
      future,
      query,
    );
  }

  Future<Iterable<StContentsMst>> findMany({
    STCONTENTSMSTWhereInput? where,
    Iterable<STCONTENTSMSTOrderByWithRelationInput>? orderBy,
    STCONTENTSMSTWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STCONTENTSMSTScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyST_CONTENTS_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyST_CONTENTS_MST',
    );
    final fields = STCONTENTSMSTScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManySTCONTENTSMST) =>
        findManySTCONTENTSMST.map((Map findManySTCONTENTSMST) =>
            StContentsMst.fromJson(findManySTCONTENTSMST.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  STCONTENTSMSTFluent<StContentsMst> create(
      {required STCONTENTSMSTCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneST_CONTENTS_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneST_CONTENTS_MST',
    );
    final future = query(STCONTENTSMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StContentsMst.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_CONTENTS_MST)'));
    return STCONTENTSMSTFluent<StContentsMst>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<STCONTENTSMSTCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyST_CONTENTS_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyST_CONTENTS_MST',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManySTCONTENTSMST) =>
        AffectedRowsOutput.fromJson(createManySTCONTENTSMST.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STCONTENTSMSTFluent<StContentsMst?> update({
    required STCONTENTSMSTUpdateInput data,
    required STCONTENTSMSTWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneST_CONTENTS_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneST_CONTENTS_MST',
    );
    final future = query(STCONTENTSMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StContentsMst.fromJson(json.cast<String, dynamic>())
            : null);
    return STCONTENTSMSTFluent<StContentsMst?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required STCONTENTSMSTUpdateManyMutationInput data,
    STCONTENTSMSTWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyST_CONTENTS_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyST_CONTENTS_MST',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManySTCONTENTSMST) =>
        AffectedRowsOutput.fromJson(updateManySTCONTENTSMST.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STCONTENTSMSTFluent<StContentsMst> upsert({
    required STCONTENTSMSTWhereUniqueInput where,
    required STCONTENTSMSTCreateInput create,
    required STCONTENTSMSTUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneST_CONTENTS_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneST_CONTENTS_MST',
    );
    final future = query(STCONTENTSMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StContentsMst.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_CONTENTS_MST)'));
    return STCONTENTSMSTFluent<StContentsMst>(
      future,
      query,
    );
  }

  STCONTENTSMSTFluent<StContentsMst?> delete(
      {required STCONTENTSMSTWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneST_CONTENTS_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneST_CONTENTS_MST',
    );
    final future = query(STCONTENTSMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StContentsMst.fromJson(json.cast<String, dynamic>())
            : null);
    return STCONTENTSMSTFluent<StContentsMst?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({STCONTENTSMSTWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyST_CONTENTS_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyST_CONTENTS_MST',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManySTCONTENTSMST) =>
        AffectedRowsOutput.fromJson(deleteManySTCONTENTSMST.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateSTCONTENTSMST aggregate({
    STCONTENTSMSTWhereInput? where,
    Iterable<STCONTENTSMSTOrderByWithRelationInput>? orderBy,
    STCONTENTSMSTWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateST_CONTENTS_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateST_CONTENTS_MST',
    );
    return AggregateSTCONTENTSMST(query);
  }

  Future<Iterable<STCONTENTSMSTGroupByOutputType>> groupBy({
    STCONTENTSMSTWhereInput? where,
    Iterable<STCONTENTSMSTOrderByWithAggregationInput>? orderBy,
    required Iterable<STCONTENTSMSTScalarFieldEnum> by,
    STCONTENTSMSTScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByST_CONTENTS_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByST_CONTENTS_MST',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupBySTCONTENTSMST) => groupBySTCONTENTSMST.map(
        (Map groupBySTCONTENTSMST) => STCONTENTSMSTGroupByOutputType.fromJson(
            groupBySTCONTENTSMST.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension STDEPTModelDelegateExtension on _i1.ModelDelegate<StDept> {
  STDEPTFluent<StDept?> findUnique({required STDEPTWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_DEPT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_DEPT',
    );
    final future = query(STDEPTScalarFieldEnum.values.toGraphQLFields()).then(
        (json) =>
            json is Map ? StDept.fromJson(json.cast<String, dynamic>()) : null);
    return STDEPTFluent<StDept?>(
      future,
      query,
    );
  }

  STDEPTFluent<StDept> findUniqueOrThrow(
      {required STDEPTWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_DEPTOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_DEPTOrThrow',
    );
    final future = query(STDEPTScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StDept.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_DEPT)'));
    return STDEPTFluent<StDept>(
      future,
      query,
    );
  }

  STDEPTFluent<StDept?> findFirst({
    STDEPTWhereInput? where,
    Iterable<STDEPTOrderByWithRelationInput>? orderBy,
    STDEPTWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STDEPTScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_DEPT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_DEPT',
    );
    final future = query(STDEPTScalarFieldEnum.values.toGraphQLFields()).then(
        (json) =>
            json is Map ? StDept.fromJson(json.cast<String, dynamic>()) : null);
    return STDEPTFluent<StDept?>(
      future,
      query,
    );
  }

  STDEPTFluent<StDept> findFirstOrThrow({
    STDEPTWhereInput? where,
    Iterable<STDEPTOrderByWithRelationInput>? orderBy,
    STDEPTWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STDEPTScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_DEPTOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_DEPTOrThrow',
    );
    final future = query(STDEPTScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StDept.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_DEPT)'));
    return STDEPTFluent<StDept>(
      future,
      query,
    );
  }

  Future<Iterable<StDept>> findMany({
    STDEPTWhereInput? where,
    Iterable<STDEPTOrderByWithRelationInput>? orderBy,
    STDEPTWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STDEPTScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyST_DEPT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyST_DEPT',
    );
    final fields = STDEPTScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManySTDEPT) => findManySTDEPT
        .map((Map findManySTDEPT) => StDept.fromJson(findManySTDEPT.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  STDEPTFluent<StDept> create({required STDEPTCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneST_DEPT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneST_DEPT',
    );
    final future = query(STDEPTScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StDept.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_DEPT)'));
    return STDEPTFluent<StDept>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<STDEPTCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyST_DEPT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyST_DEPT',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManySTDEPT) =>
        AffectedRowsOutput.fromJson(createManySTDEPT.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STDEPTFluent<StDept?> update({
    required STDEPTUpdateInput data,
    required STDEPTWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneST_DEPT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneST_DEPT',
    );
    final future = query(STDEPTScalarFieldEnum.values.toGraphQLFields()).then(
        (json) =>
            json is Map ? StDept.fromJson(json.cast<String, dynamic>()) : null);
    return STDEPTFluent<StDept?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required STDEPTUpdateManyMutationInput data,
    STDEPTWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyST_DEPT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyST_DEPT',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManySTDEPT) =>
        AffectedRowsOutput.fromJson(updateManySTDEPT.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STDEPTFluent<StDept> upsert({
    required STDEPTWhereUniqueInput where,
    required STDEPTCreateInput create,
    required STDEPTUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneST_DEPT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneST_DEPT',
    );
    final future = query(STDEPTScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StDept.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_DEPT)'));
    return STDEPTFluent<StDept>(
      future,
      query,
    );
  }

  STDEPTFluent<StDept?> delete({required STDEPTWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneST_DEPT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneST_DEPT',
    );
    final future = query(STDEPTScalarFieldEnum.values.toGraphQLFields()).then(
        (json) =>
            json is Map ? StDept.fromJson(json.cast<String, dynamic>()) : null);
    return STDEPTFluent<StDept?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({STDEPTWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyST_DEPT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyST_DEPT',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManySTDEPT) =>
        AffectedRowsOutput.fromJson(deleteManySTDEPT.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateSTDEPT aggregate({
    STDEPTWhereInput? where,
    Iterable<STDEPTOrderByWithRelationInput>? orderBy,
    STDEPTWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateST_DEPT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateST_DEPT',
    );
    return AggregateSTDEPT(query);
  }

  Future<Iterable<STDEPTGroupByOutputType>> groupBy({
    STDEPTWhereInput? where,
    Iterable<STDEPTOrderByWithAggregationInput>? orderBy,
    required Iterable<STDEPTScalarFieldEnum> by,
    STDEPTScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByST_DEPT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByST_DEPT',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupBySTDEPT) =>
        groupBySTDEPT.map((Map groupBySTDEPT) =>
            STDEPTGroupByOutputType.fromJson(groupBySTDEPT.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension STDEPTEMPModelDelegateExtension on _i1.ModelDelegate<StDeptEmp> {
  STDEPTEMPFluent<StDeptEmp?> findUnique(
      {required STDEPTEMPWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_DEPT_EMP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_DEPT_EMP',
    );
    final future = query(STDEPTEMPScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StDeptEmp.fromJson(json.cast<String, dynamic>())
            : null);
    return STDEPTEMPFluent<StDeptEmp?>(
      future,
      query,
    );
  }

  STDEPTEMPFluent<StDeptEmp> findUniqueOrThrow(
      {required STDEPTEMPWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_DEPT_EMPOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_DEPT_EMPOrThrow',
    );
    final future = query(STDEPTEMPScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StDeptEmp.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_DEPT_EMP)'));
    return STDEPTEMPFluent<StDeptEmp>(
      future,
      query,
    );
  }

  STDEPTEMPFluent<StDeptEmp?> findFirst({
    STDEPTEMPWhereInput? where,
    Iterable<STDEPTEMPOrderByWithRelationInput>? orderBy,
    STDEPTEMPWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STDEPTEMPScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_DEPT_EMP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_DEPT_EMP',
    );
    final future = query(STDEPTEMPScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StDeptEmp.fromJson(json.cast<String, dynamic>())
            : null);
    return STDEPTEMPFluent<StDeptEmp?>(
      future,
      query,
    );
  }

  STDEPTEMPFluent<StDeptEmp> findFirstOrThrow({
    STDEPTEMPWhereInput? where,
    Iterable<STDEPTEMPOrderByWithRelationInput>? orderBy,
    STDEPTEMPWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STDEPTEMPScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_DEPT_EMPOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_DEPT_EMPOrThrow',
    );
    final future = query(STDEPTEMPScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StDeptEmp.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_DEPT_EMP)'));
    return STDEPTEMPFluent<StDeptEmp>(
      future,
      query,
    );
  }

  Future<Iterable<StDeptEmp>> findMany({
    STDEPTEMPWhereInput? where,
    Iterable<STDEPTEMPOrderByWithRelationInput>? orderBy,
    STDEPTEMPWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STDEPTEMPScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyST_DEPT_EMP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyST_DEPT_EMP',
    );
    final fields = STDEPTEMPScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManySTDEPTEMP) =>
        findManySTDEPTEMP.map((Map findManySTDEPTEMP) =>
            StDeptEmp.fromJson(findManySTDEPTEMP.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  STDEPTEMPFluent<StDeptEmp> create({required STDEPTEMPCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneST_DEPT_EMP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneST_DEPT_EMP',
    );
    final future = query(STDEPTEMPScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StDeptEmp.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_DEPT_EMP)'));
    return STDEPTEMPFluent<StDeptEmp>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<STDEPTEMPCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyST_DEPT_EMP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyST_DEPT_EMP',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManySTDEPTEMP) =>
        AffectedRowsOutput.fromJson(createManySTDEPTEMP.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STDEPTEMPFluent<StDeptEmp?> update({
    required STDEPTEMPUpdateInput data,
    required STDEPTEMPWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneST_DEPT_EMP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneST_DEPT_EMP',
    );
    final future = query(STDEPTEMPScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StDeptEmp.fromJson(json.cast<String, dynamic>())
            : null);
    return STDEPTEMPFluent<StDeptEmp?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required STDEPTEMPUpdateManyMutationInput data,
    STDEPTEMPWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyST_DEPT_EMP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyST_DEPT_EMP',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManySTDEPTEMP) =>
        AffectedRowsOutput.fromJson(updateManySTDEPTEMP.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STDEPTEMPFluent<StDeptEmp> upsert({
    required STDEPTEMPWhereUniqueInput where,
    required STDEPTEMPCreateInput create,
    required STDEPTEMPUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneST_DEPT_EMP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneST_DEPT_EMP',
    );
    final future = query(STDEPTEMPScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StDeptEmp.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_DEPT_EMP)'));
    return STDEPTEMPFluent<StDeptEmp>(
      future,
      query,
    );
  }

  STDEPTEMPFluent<StDeptEmp?> delete(
      {required STDEPTEMPWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneST_DEPT_EMP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneST_DEPT_EMP',
    );
    final future = query(STDEPTEMPScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StDeptEmp.fromJson(json.cast<String, dynamic>())
            : null);
    return STDEPTEMPFluent<StDeptEmp?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({STDEPTEMPWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyST_DEPT_EMP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyST_DEPT_EMP',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManySTDEPTEMP) =>
        AffectedRowsOutput.fromJson(deleteManySTDEPTEMP.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateSTDEPTEMP aggregate({
    STDEPTEMPWhereInput? where,
    Iterable<STDEPTEMPOrderByWithRelationInput>? orderBy,
    STDEPTEMPWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateST_DEPT_EMP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateST_DEPT_EMP',
    );
    return AggregateSTDEPTEMP(query);
  }

  Future<Iterable<STDEPTEMPGroupByOutputType>> groupBy({
    STDEPTEMPWhereInput? where,
    Iterable<STDEPTEMPOrderByWithAggregationInput>? orderBy,
    required Iterable<STDEPTEMPScalarFieldEnum> by,
    STDEPTEMPScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByST_DEPT_EMP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByST_DEPT_EMP',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupBySTDEPTEMP) =>
        groupBySTDEPTEMP.map((Map groupBySTDEPTEMP) =>
            STDEPTEMPGroupByOutputType.fromJson(groupBySTDEPTEMP.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension STMENUModelDelegateExtension on _i1.ModelDelegate<StMenu> {
  STMENUFluent<StMenu?> findUnique({required STMENUWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_MENU',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_MENU',
    );
    final future = query(STMENUScalarFieldEnum.values.toGraphQLFields()).then(
        (json) =>
            json is Map ? StMenu.fromJson(json.cast<String, dynamic>()) : null);
    return STMENUFluent<StMenu?>(
      future,
      query,
    );
  }

  STMENUFluent<StMenu> findUniqueOrThrow(
      {required STMENUWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_MENUOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_MENUOrThrow',
    );
    final future = query(STMENUScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StMenu.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_MENU)'));
    return STMENUFluent<StMenu>(
      future,
      query,
    );
  }

  STMENUFluent<StMenu?> findFirst({
    STMENUWhereInput? where,
    Iterable<STMENUOrderByWithRelationInput>? orderBy,
    STMENUWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STMENUScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_MENU',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_MENU',
    );
    final future = query(STMENUScalarFieldEnum.values.toGraphQLFields()).then(
        (json) =>
            json is Map ? StMenu.fromJson(json.cast<String, dynamic>()) : null);
    return STMENUFluent<StMenu?>(
      future,
      query,
    );
  }

  STMENUFluent<StMenu> findFirstOrThrow({
    STMENUWhereInput? where,
    Iterable<STMENUOrderByWithRelationInput>? orderBy,
    STMENUWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STMENUScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_MENUOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_MENUOrThrow',
    );
    final future = query(STMENUScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StMenu.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_MENU)'));
    return STMENUFluent<StMenu>(
      future,
      query,
    );
  }

  Future<Iterable<StMenu>> findMany({
    STMENUWhereInput? where,
    Iterable<STMENUOrderByWithRelationInput>? orderBy,
    STMENUWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STMENUScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyST_MENU',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyST_MENU',
    );
    final fields = STMENUScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManySTMENU) => findManySTMENU
        .map((Map findManySTMENU) => StMenu.fromJson(findManySTMENU.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  STMENUFluent<StMenu> create({required STMENUCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneST_MENU',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneST_MENU',
    );
    final future = query(STMENUScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StMenu.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_MENU)'));
    return STMENUFluent<StMenu>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<STMENUCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyST_MENU',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyST_MENU',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManySTMENU) =>
        AffectedRowsOutput.fromJson(createManySTMENU.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STMENUFluent<StMenu?> update({
    required STMENUUpdateInput data,
    required STMENUWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneST_MENU',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneST_MENU',
    );
    final future = query(STMENUScalarFieldEnum.values.toGraphQLFields()).then(
        (json) =>
            json is Map ? StMenu.fromJson(json.cast<String, dynamic>()) : null);
    return STMENUFluent<StMenu?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required STMENUUpdateManyMutationInput data,
    STMENUWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyST_MENU',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyST_MENU',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManySTMENU) =>
        AffectedRowsOutput.fromJson(updateManySTMENU.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STMENUFluent<StMenu> upsert({
    required STMENUWhereUniqueInput where,
    required STMENUCreateInput create,
    required STMENUUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneST_MENU',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneST_MENU',
    );
    final future = query(STMENUScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StMenu.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_MENU)'));
    return STMENUFluent<StMenu>(
      future,
      query,
    );
  }

  STMENUFluent<StMenu?> delete({required STMENUWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneST_MENU',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneST_MENU',
    );
    final future = query(STMENUScalarFieldEnum.values.toGraphQLFields()).then(
        (json) =>
            json is Map ? StMenu.fromJson(json.cast<String, dynamic>()) : null);
    return STMENUFluent<StMenu?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({STMENUWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyST_MENU',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyST_MENU',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManySTMENU) =>
        AffectedRowsOutput.fromJson(deleteManySTMENU.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateSTMENU aggregate({
    STMENUWhereInput? where,
    Iterable<STMENUOrderByWithRelationInput>? orderBy,
    STMENUWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateST_MENU',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateST_MENU',
    );
    return AggregateSTMENU(query);
  }

  Future<Iterable<STMENUGroupByOutputType>> groupBy({
    STMENUWhereInput? where,
    Iterable<STMENUOrderByWithAggregationInput>? orderBy,
    required Iterable<STMENUScalarFieldEnum> by,
    STMENUScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByST_MENU',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByST_MENU',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupBySTMENU) =>
        groupBySTMENU.map((Map groupBySTMENU) =>
            STMENUGroupByOutputType.fromJson(groupBySTMENU.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension STMESSAGETMPLATModelDelegateExtension
    on _i1.ModelDelegate<StMessageTmplat> {
  STMESSAGETMPLATFluent<StMessageTmplat?> findUnique(
      {required STMESSAGETMPLATWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_MESSAGE_TMPLAT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_MESSAGE_TMPLAT',
    );
    final future =
        query(STMESSAGETMPLATScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? StMessageTmplat.fromJson(json.cast<String, dynamic>())
                : null);
    return STMESSAGETMPLATFluent<StMessageTmplat?>(
      future,
      query,
    );
  }

  STMESSAGETMPLATFluent<StMessageTmplat> findUniqueOrThrow(
      {required STMESSAGETMPLATWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_MESSAGE_TMPLATOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_MESSAGE_TMPLATOrThrow',
    );
    final future = query(
            STMESSAGETMPLATScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StMessageTmplat.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_MESSAGE_TMPLAT)'));
    return STMESSAGETMPLATFluent<StMessageTmplat>(
      future,
      query,
    );
  }

  STMESSAGETMPLATFluent<StMessageTmplat?> findFirst({
    STMESSAGETMPLATWhereInput? where,
    Iterable<STMESSAGETMPLATOrderByWithRelationInput>? orderBy,
    STMESSAGETMPLATWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STMESSAGETMPLATScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_MESSAGE_TMPLAT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_MESSAGE_TMPLAT',
    );
    final future =
        query(STMESSAGETMPLATScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? StMessageTmplat.fromJson(json.cast<String, dynamic>())
                : null);
    return STMESSAGETMPLATFluent<StMessageTmplat?>(
      future,
      query,
    );
  }

  STMESSAGETMPLATFluent<StMessageTmplat> findFirstOrThrow({
    STMESSAGETMPLATWhereInput? where,
    Iterable<STMESSAGETMPLATOrderByWithRelationInput>? orderBy,
    STMESSAGETMPLATWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STMESSAGETMPLATScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_MESSAGE_TMPLATOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_MESSAGE_TMPLATOrThrow',
    );
    final future = query(
            STMESSAGETMPLATScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StMessageTmplat.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_MESSAGE_TMPLAT)'));
    return STMESSAGETMPLATFluent<StMessageTmplat>(
      future,
      query,
    );
  }

  Future<Iterable<StMessageTmplat>> findMany({
    STMESSAGETMPLATWhereInput? where,
    Iterable<STMESSAGETMPLATOrderByWithRelationInput>? orderBy,
    STMESSAGETMPLATWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STMESSAGETMPLATScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyST_MESSAGE_TMPLAT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyST_MESSAGE_TMPLAT',
    );
    final fields = STMESSAGETMPLATScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManySTMESSAGETMPLAT) =>
        findManySTMESSAGETMPLAT.map((Map findManySTMESSAGETMPLAT) =>
            StMessageTmplat.fromJson(findManySTMESSAGETMPLAT.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  STMESSAGETMPLATFluent<StMessageTmplat> create(
      {required STMESSAGETMPLATCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneST_MESSAGE_TMPLAT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneST_MESSAGE_TMPLAT',
    );
    final future = query(
            STMESSAGETMPLATScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StMessageTmplat.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_MESSAGE_TMPLAT)'));
    return STMESSAGETMPLATFluent<StMessageTmplat>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<STMESSAGETMPLATCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyST_MESSAGE_TMPLAT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyST_MESSAGE_TMPLAT',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManySTMESSAGETMPLAT) =>
        AffectedRowsOutput.fromJson(createManySTMESSAGETMPLAT.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STMESSAGETMPLATFluent<StMessageTmplat?> update({
    required STMESSAGETMPLATUpdateInput data,
    required STMESSAGETMPLATWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneST_MESSAGE_TMPLAT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneST_MESSAGE_TMPLAT',
    );
    final future =
        query(STMESSAGETMPLATScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? StMessageTmplat.fromJson(json.cast<String, dynamic>())
                : null);
    return STMESSAGETMPLATFluent<StMessageTmplat?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required STMESSAGETMPLATUpdateManyMutationInput data,
    STMESSAGETMPLATWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyST_MESSAGE_TMPLAT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyST_MESSAGE_TMPLAT',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManySTMESSAGETMPLAT) =>
        AffectedRowsOutput.fromJson(updateManySTMESSAGETMPLAT.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STMESSAGETMPLATFluent<StMessageTmplat> upsert({
    required STMESSAGETMPLATWhereUniqueInput where,
    required STMESSAGETMPLATCreateInput create,
    required STMESSAGETMPLATUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneST_MESSAGE_TMPLAT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneST_MESSAGE_TMPLAT',
    );
    final future = query(
            STMESSAGETMPLATScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StMessageTmplat.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_MESSAGE_TMPLAT)'));
    return STMESSAGETMPLATFluent<StMessageTmplat>(
      future,
      query,
    );
  }

  STMESSAGETMPLATFluent<StMessageTmplat?> delete(
      {required STMESSAGETMPLATWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneST_MESSAGE_TMPLAT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneST_MESSAGE_TMPLAT',
    );
    final future =
        query(STMESSAGETMPLATScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? StMessageTmplat.fromJson(json.cast<String, dynamic>())
                : null);
    return STMESSAGETMPLATFluent<StMessageTmplat?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({STMESSAGETMPLATWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyST_MESSAGE_TMPLAT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyST_MESSAGE_TMPLAT',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManySTMESSAGETMPLAT) =>
        AffectedRowsOutput.fromJson(deleteManySTMESSAGETMPLAT.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateSTMESSAGETMPLAT aggregate({
    STMESSAGETMPLATWhereInput? where,
    Iterable<STMESSAGETMPLATOrderByWithRelationInput>? orderBy,
    STMESSAGETMPLATWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateST_MESSAGE_TMPLAT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateST_MESSAGE_TMPLAT',
    );
    return AggregateSTMESSAGETMPLAT(query);
  }

  Future<Iterable<STMESSAGETMPLATGroupByOutputType>> groupBy({
    STMESSAGETMPLATWhereInput? where,
    Iterable<STMESSAGETMPLATOrderByWithAggregationInput>? orderBy,
    required Iterable<STMESSAGETMPLATScalarFieldEnum> by,
    STMESSAGETMPLATScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByST_MESSAGE_TMPLAT',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByST_MESSAGE_TMPLAT',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupBySTMESSAGETMPLAT) =>
        groupBySTMESSAGETMPLAT.map((Map groupBySTMESSAGETMPLAT) =>
            STMESSAGETMPLATGroupByOutputType.fromJson(
                groupBySTMESSAGETMPLAT.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension STMIMETYPEModelDelegateExtension on _i1.ModelDelegate<StMimeType> {
  STMIMETYPEFluent<StMimeType?> findUnique(
      {required STMIMETYPEWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_MIME_TYPE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_MIME_TYPE',
    );
    final future = query(STMIMETYPEScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StMimeType.fromJson(json.cast<String, dynamic>())
            : null);
    return STMIMETYPEFluent<StMimeType?>(
      future,
      query,
    );
  }

  STMIMETYPEFluent<StMimeType> findUniqueOrThrow(
      {required STMIMETYPEWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_MIME_TYPEOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_MIME_TYPEOrThrow',
    );
    final future = query(STMIMETYPEScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StMimeType.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_MIME_TYPE)'));
    return STMIMETYPEFluent<StMimeType>(
      future,
      query,
    );
  }

  STMIMETYPEFluent<StMimeType?> findFirst({
    STMIMETYPEWhereInput? where,
    Iterable<STMIMETYPEOrderByWithRelationInput>? orderBy,
    STMIMETYPEWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STMIMETYPEScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_MIME_TYPE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_MIME_TYPE',
    );
    final future = query(STMIMETYPEScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StMimeType.fromJson(json.cast<String, dynamic>())
            : null);
    return STMIMETYPEFluent<StMimeType?>(
      future,
      query,
    );
  }

  STMIMETYPEFluent<StMimeType> findFirstOrThrow({
    STMIMETYPEWhereInput? where,
    Iterable<STMIMETYPEOrderByWithRelationInput>? orderBy,
    STMIMETYPEWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STMIMETYPEScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_MIME_TYPEOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_MIME_TYPEOrThrow',
    );
    final future = query(STMIMETYPEScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StMimeType.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_MIME_TYPE)'));
    return STMIMETYPEFluent<StMimeType>(
      future,
      query,
    );
  }

  Future<Iterable<StMimeType>> findMany({
    STMIMETYPEWhereInput? where,
    Iterable<STMIMETYPEOrderByWithRelationInput>? orderBy,
    STMIMETYPEWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STMIMETYPEScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyST_MIME_TYPE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyST_MIME_TYPE',
    );
    final fields = STMIMETYPEScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManySTMIMETYPE) =>
        findManySTMIMETYPE.map((Map findManySTMIMETYPE) =>
            StMimeType.fromJson(findManySTMIMETYPE.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  STMIMETYPEFluent<StMimeType> create({required STMIMETYPECreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneST_MIME_TYPE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneST_MIME_TYPE',
    );
    final future = query(STMIMETYPEScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StMimeType.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_MIME_TYPE)'));
    return STMIMETYPEFluent<StMimeType>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<STMIMETYPECreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyST_MIME_TYPE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyST_MIME_TYPE',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManySTMIMETYPE) =>
        AffectedRowsOutput.fromJson(createManySTMIMETYPE.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STMIMETYPEFluent<StMimeType?> update({
    required STMIMETYPEUpdateInput data,
    required STMIMETYPEWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneST_MIME_TYPE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneST_MIME_TYPE',
    );
    final future = query(STMIMETYPEScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StMimeType.fromJson(json.cast<String, dynamic>())
            : null);
    return STMIMETYPEFluent<StMimeType?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required STMIMETYPEUpdateManyMutationInput data,
    STMIMETYPEWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyST_MIME_TYPE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyST_MIME_TYPE',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManySTMIMETYPE) =>
        AffectedRowsOutput.fromJson(updateManySTMIMETYPE.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STMIMETYPEFluent<StMimeType> upsert({
    required STMIMETYPEWhereUniqueInput where,
    required STMIMETYPECreateInput create,
    required STMIMETYPEUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneST_MIME_TYPE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneST_MIME_TYPE',
    );
    final future = query(STMIMETYPEScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StMimeType.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_MIME_TYPE)'));
    return STMIMETYPEFluent<StMimeType>(
      future,
      query,
    );
  }

  STMIMETYPEFluent<StMimeType?> delete(
      {required STMIMETYPEWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneST_MIME_TYPE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneST_MIME_TYPE',
    );
    final future = query(STMIMETYPEScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StMimeType.fromJson(json.cast<String, dynamic>())
            : null);
    return STMIMETYPEFluent<StMimeType?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({STMIMETYPEWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyST_MIME_TYPE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyST_MIME_TYPE',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManySTMIMETYPE) =>
        AffectedRowsOutput.fromJson(deleteManySTMIMETYPE.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateSTMIMETYPE aggregate({
    STMIMETYPEWhereInput? where,
    Iterable<STMIMETYPEOrderByWithRelationInput>? orderBy,
    STMIMETYPEWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateST_MIME_TYPE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateST_MIME_TYPE',
    );
    return AggregateSTMIMETYPE(query);
  }

  Future<Iterable<STMIMETYPEGroupByOutputType>> groupBy({
    STMIMETYPEWhereInput? where,
    Iterable<STMIMETYPEOrderByWithAggregationInput>? orderBy,
    required Iterable<STMIMETYPEScalarFieldEnum> by,
    STMIMETYPEScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByST_MIME_TYPE',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByST_MIME_TYPE',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupBySTMIMETYPE) =>
        groupBySTMIMETYPE.map((Map groupBySTMIMETYPE) =>
            STMIMETYPEGroupByOutputType.fromJson(groupBySTMIMETYPE.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension STMNGRGRPModelDelegateExtension on _i1.ModelDelegate<StMngrGrp> {
  STMNGRGRPFluent<StMngrGrp?> findUnique(
      {required STMNGRGRPWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_MNGR_GRP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_MNGR_GRP',
    );
    final future = query(STMNGRGRPScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StMngrGrp.fromJson(json.cast<String, dynamic>())
            : null);
    return STMNGRGRPFluent<StMngrGrp?>(
      future,
      query,
    );
  }

  STMNGRGRPFluent<StMngrGrp> findUniqueOrThrow(
      {required STMNGRGRPWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_MNGR_GRPOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_MNGR_GRPOrThrow',
    );
    final future = query(STMNGRGRPScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StMngrGrp.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_MNGR_GRP)'));
    return STMNGRGRPFluent<StMngrGrp>(
      future,
      query,
    );
  }

  STMNGRGRPFluent<StMngrGrp?> findFirst({
    STMNGRGRPWhereInput? where,
    Iterable<STMNGRGRPOrderByWithRelationInput>? orderBy,
    STMNGRGRPWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STMNGRGRPScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_MNGR_GRP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_MNGR_GRP',
    );
    final future = query(STMNGRGRPScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StMngrGrp.fromJson(json.cast<String, dynamic>())
            : null);
    return STMNGRGRPFluent<StMngrGrp?>(
      future,
      query,
    );
  }

  STMNGRGRPFluent<StMngrGrp> findFirstOrThrow({
    STMNGRGRPWhereInput? where,
    Iterable<STMNGRGRPOrderByWithRelationInput>? orderBy,
    STMNGRGRPWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STMNGRGRPScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_MNGR_GRPOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_MNGR_GRPOrThrow',
    );
    final future = query(STMNGRGRPScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StMngrGrp.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_MNGR_GRP)'));
    return STMNGRGRPFluent<StMngrGrp>(
      future,
      query,
    );
  }

  Future<Iterable<StMngrGrp>> findMany({
    STMNGRGRPWhereInput? where,
    Iterable<STMNGRGRPOrderByWithRelationInput>? orderBy,
    STMNGRGRPWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STMNGRGRPScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyST_MNGR_GRP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyST_MNGR_GRP',
    );
    final fields = STMNGRGRPScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManySTMNGRGRP) =>
        findManySTMNGRGRP.map((Map findManySTMNGRGRP) =>
            StMngrGrp.fromJson(findManySTMNGRGRP.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  STMNGRGRPFluent<StMngrGrp> create({required STMNGRGRPCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneST_MNGR_GRP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneST_MNGR_GRP',
    );
    final future = query(STMNGRGRPScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StMngrGrp.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_MNGR_GRP)'));
    return STMNGRGRPFluent<StMngrGrp>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<STMNGRGRPCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyST_MNGR_GRP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyST_MNGR_GRP',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManySTMNGRGRP) =>
        AffectedRowsOutput.fromJson(createManySTMNGRGRP.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STMNGRGRPFluent<StMngrGrp?> update({
    required STMNGRGRPUpdateInput data,
    required STMNGRGRPWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneST_MNGR_GRP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneST_MNGR_GRP',
    );
    final future = query(STMNGRGRPScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StMngrGrp.fromJson(json.cast<String, dynamic>())
            : null);
    return STMNGRGRPFluent<StMngrGrp?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required STMNGRGRPUpdateManyMutationInput data,
    STMNGRGRPWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyST_MNGR_GRP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyST_MNGR_GRP',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManySTMNGRGRP) =>
        AffectedRowsOutput.fromJson(updateManySTMNGRGRP.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STMNGRGRPFluent<StMngrGrp> upsert({
    required STMNGRGRPWhereUniqueInput where,
    required STMNGRGRPCreateInput create,
    required STMNGRGRPUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneST_MNGR_GRP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneST_MNGR_GRP',
    );
    final future = query(STMNGRGRPScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StMngrGrp.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_MNGR_GRP)'));
    return STMNGRGRPFluent<StMngrGrp>(
      future,
      query,
    );
  }

  STMNGRGRPFluent<StMngrGrp?> delete(
      {required STMNGRGRPWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneST_MNGR_GRP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneST_MNGR_GRP',
    );
    final future = query(STMNGRGRPScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StMngrGrp.fromJson(json.cast<String, dynamic>())
            : null);
    return STMNGRGRPFluent<StMngrGrp?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({STMNGRGRPWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyST_MNGR_GRP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyST_MNGR_GRP',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManySTMNGRGRP) =>
        AffectedRowsOutput.fromJson(deleteManySTMNGRGRP.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateSTMNGRGRP aggregate({
    STMNGRGRPWhereInput? where,
    Iterable<STMNGRGRPOrderByWithRelationInput>? orderBy,
    STMNGRGRPWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateST_MNGR_GRP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateST_MNGR_GRP',
    );
    return AggregateSTMNGRGRP(query);
  }

  Future<Iterable<STMNGRGRPGroupByOutputType>> groupBy({
    STMNGRGRPWhereInput? where,
    Iterable<STMNGRGRPOrderByWithAggregationInput>? orderBy,
    required Iterable<STMNGRGRPScalarFieldEnum> by,
    STMNGRGRPScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByST_MNGR_GRP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByST_MNGR_GRP',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupBySTMNGRGRP) =>
        groupBySTMNGRGRP.map((Map groupBySTMNGRGRP) =>
            STMNGRGRPGroupByOutputType.fromJson(groupBySTMNGRGRP.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension STMNGRMSTModelDelegateExtension on _i1.ModelDelegate<StMngrMst> {
  STMNGRMSTFluent<StMngrMst?> findUnique(
      {required STMNGRMSTWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_MNGR_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_MNGR_MST',
    );
    final future = query(STMNGRMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StMngrMst.fromJson(json.cast<String, dynamic>())
            : null);
    return STMNGRMSTFluent<StMngrMst?>(
      future,
      query,
    );
  }

  STMNGRMSTFluent<StMngrMst> findUniqueOrThrow(
      {required STMNGRMSTWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_MNGR_MSTOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_MNGR_MSTOrThrow',
    );
    final future = query(STMNGRMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StMngrMst.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_MNGR_MST)'));
    return STMNGRMSTFluent<StMngrMst>(
      future,
      query,
    );
  }

  STMNGRMSTFluent<StMngrMst?> findFirst({
    STMNGRMSTWhereInput? where,
    Iterable<STMNGRMSTOrderByWithRelationInput>? orderBy,
    STMNGRMSTWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STMNGRMSTScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_MNGR_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_MNGR_MST',
    );
    final future = query(STMNGRMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StMngrMst.fromJson(json.cast<String, dynamic>())
            : null);
    return STMNGRMSTFluent<StMngrMst?>(
      future,
      query,
    );
  }

  STMNGRMSTFluent<StMngrMst> findFirstOrThrow({
    STMNGRMSTWhereInput? where,
    Iterable<STMNGRMSTOrderByWithRelationInput>? orderBy,
    STMNGRMSTWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STMNGRMSTScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_MNGR_MSTOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_MNGR_MSTOrThrow',
    );
    final future = query(STMNGRMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StMngrMst.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_MNGR_MST)'));
    return STMNGRMSTFluent<StMngrMst>(
      future,
      query,
    );
  }

  Future<Iterable<StMngrMst>> findMany({
    STMNGRMSTWhereInput? where,
    Iterable<STMNGRMSTOrderByWithRelationInput>? orderBy,
    STMNGRMSTWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STMNGRMSTScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyST_MNGR_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyST_MNGR_MST',
    );
    final fields = STMNGRMSTScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManySTMNGRMST) =>
        findManySTMNGRMST.map((Map findManySTMNGRMST) =>
            StMngrMst.fromJson(findManySTMNGRMST.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  STMNGRMSTFluent<StMngrMst> create({required STMNGRMSTCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneST_MNGR_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneST_MNGR_MST',
    );
    final future = query(STMNGRMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StMngrMst.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_MNGR_MST)'));
    return STMNGRMSTFluent<StMngrMst>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<STMNGRMSTCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyST_MNGR_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyST_MNGR_MST',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManySTMNGRMST) =>
        AffectedRowsOutput.fromJson(createManySTMNGRMST.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STMNGRMSTFluent<StMngrMst?> update({
    required STMNGRMSTUpdateInput data,
    required STMNGRMSTWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneST_MNGR_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneST_MNGR_MST',
    );
    final future = query(STMNGRMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StMngrMst.fromJson(json.cast<String, dynamic>())
            : null);
    return STMNGRMSTFluent<StMngrMst?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required STMNGRMSTUpdateManyMutationInput data,
    STMNGRMSTWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyST_MNGR_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyST_MNGR_MST',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManySTMNGRMST) =>
        AffectedRowsOutput.fromJson(updateManySTMNGRMST.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STMNGRMSTFluent<StMngrMst> upsert({
    required STMNGRMSTWhereUniqueInput where,
    required STMNGRMSTCreateInput create,
    required STMNGRMSTUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneST_MNGR_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneST_MNGR_MST',
    );
    final future = query(STMNGRMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StMngrMst.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_MNGR_MST)'));
    return STMNGRMSTFluent<StMngrMst>(
      future,
      query,
    );
  }

  STMNGRMSTFluent<StMngrMst?> delete(
      {required STMNGRMSTWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneST_MNGR_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneST_MNGR_MST',
    );
    final future = query(STMNGRMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StMngrMst.fromJson(json.cast<String, dynamic>())
            : null);
    return STMNGRMSTFluent<StMngrMst?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({STMNGRMSTWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyST_MNGR_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyST_MNGR_MST',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManySTMNGRMST) =>
        AffectedRowsOutput.fromJson(deleteManySTMNGRMST.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateSTMNGRMST aggregate({
    STMNGRMSTWhereInput? where,
    Iterable<STMNGRMSTOrderByWithRelationInput>? orderBy,
    STMNGRMSTWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateST_MNGR_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateST_MNGR_MST',
    );
    return AggregateSTMNGRMST(query);
  }

  Future<Iterable<STMNGRMSTGroupByOutputType>> groupBy({
    STMNGRMSTWhereInput? where,
    Iterable<STMNGRMSTOrderByWithAggregationInput>? orderBy,
    required Iterable<STMNGRMSTScalarFieldEnum> by,
    STMNGRMSTScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByST_MNGR_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByST_MNGR_MST',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupBySTMNGRMST) =>
        groupBySTMNGRMST.map((Map groupBySTMNGRMST) =>
            STMNGRMSTGroupByOutputType.fromJson(groupBySTMNGRMST.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension STMYSTNGModelDelegateExtension on _i1.ModelDelegate<StMyStng> {
  STMYSTNGFluent<StMyStng?> findUnique(
      {required STMYSTNGWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_MY_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_MY_STNG',
    );
    final future = query(STMYSTNGScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StMyStng.fromJson(json.cast<String, dynamic>())
            : null);
    return STMYSTNGFluent<StMyStng?>(
      future,
      query,
    );
  }

  STMYSTNGFluent<StMyStng> findUniqueOrThrow(
      {required STMYSTNGWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_MY_STNGOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_MY_STNGOrThrow',
    );
    final future = query(STMYSTNGScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StMyStng.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_MY_STNG)'));
    return STMYSTNGFluent<StMyStng>(
      future,
      query,
    );
  }

  STMYSTNGFluent<StMyStng?> findFirst({
    STMYSTNGWhereInput? where,
    Iterable<STMYSTNGOrderByWithRelationInput>? orderBy,
    STMYSTNGWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STMYSTNGScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_MY_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_MY_STNG',
    );
    final future = query(STMYSTNGScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StMyStng.fromJson(json.cast<String, dynamic>())
            : null);
    return STMYSTNGFluent<StMyStng?>(
      future,
      query,
    );
  }

  STMYSTNGFluent<StMyStng> findFirstOrThrow({
    STMYSTNGWhereInput? where,
    Iterable<STMYSTNGOrderByWithRelationInput>? orderBy,
    STMYSTNGWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STMYSTNGScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_MY_STNGOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_MY_STNGOrThrow',
    );
    final future = query(STMYSTNGScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StMyStng.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_MY_STNG)'));
    return STMYSTNGFluent<StMyStng>(
      future,
      query,
    );
  }

  Future<Iterable<StMyStng>> findMany({
    STMYSTNGWhereInput? where,
    Iterable<STMYSTNGOrderByWithRelationInput>? orderBy,
    STMYSTNGWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STMYSTNGScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyST_MY_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyST_MY_STNG',
    );
    final fields = STMYSTNGScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManySTMYSTNG) => findManySTMYSTNG.map(
        (Map findManySTMYSTNG) => StMyStng.fromJson(findManySTMYSTNG.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  STMYSTNGFluent<StMyStng> create({required STMYSTNGCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneST_MY_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneST_MY_STNG',
    );
    final future = query(STMYSTNGScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StMyStng.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_MY_STNG)'));
    return STMYSTNGFluent<StMyStng>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<STMYSTNGCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyST_MY_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyST_MY_STNG',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManySTMYSTNG) =>
        AffectedRowsOutput.fromJson(createManySTMYSTNG.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STMYSTNGFluent<StMyStng?> update({
    required STMYSTNGUpdateInput data,
    required STMYSTNGWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneST_MY_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneST_MY_STNG',
    );
    final future = query(STMYSTNGScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StMyStng.fromJson(json.cast<String, dynamic>())
            : null);
    return STMYSTNGFluent<StMyStng?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required STMYSTNGUpdateManyMutationInput data,
    STMYSTNGWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyST_MY_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyST_MY_STNG',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManySTMYSTNG) =>
        AffectedRowsOutput.fromJson(updateManySTMYSTNG.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STMYSTNGFluent<StMyStng> upsert({
    required STMYSTNGWhereUniqueInput where,
    required STMYSTNGCreateInput create,
    required STMYSTNGUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneST_MY_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneST_MY_STNG',
    );
    final future = query(STMYSTNGScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StMyStng.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_MY_STNG)'));
    return STMYSTNGFluent<StMyStng>(
      future,
      query,
    );
  }

  STMYSTNGFluent<StMyStng?> delete({required STMYSTNGWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneST_MY_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneST_MY_STNG',
    );
    final future = query(STMYSTNGScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StMyStng.fromJson(json.cast<String, dynamic>())
            : null);
    return STMYSTNGFluent<StMyStng?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({STMYSTNGWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyST_MY_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyST_MY_STNG',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManySTMYSTNG) =>
        AffectedRowsOutput.fromJson(deleteManySTMYSTNG.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateSTMYSTNG aggregate({
    STMYSTNGWhereInput? where,
    Iterable<STMYSTNGOrderByWithRelationInput>? orderBy,
    STMYSTNGWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateST_MY_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateST_MY_STNG',
    );
    return AggregateSTMYSTNG(query);
  }

  Future<Iterable<STMYSTNGGroupByOutputType>> groupBy({
    STMYSTNGWhereInput? where,
    Iterable<STMYSTNGOrderByWithAggregationInput>? orderBy,
    required Iterable<STMYSTNGScalarFieldEnum> by,
    STMYSTNGScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByST_MY_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByST_MY_STNG',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupBySTMYSTNG) =>
        groupBySTMYSTNG.map((Map groupBySTMYSTNG) =>
            STMYSTNGGroupByOutputType.fromJson(groupBySTMYSTNG.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension STPERMDTLModelDelegateExtension on _i1.ModelDelegate<StPermDtl> {
  STPERMDTLFluent<StPermDtl?> findUnique(
      {required STPERMDTLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_PERM_DTL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_PERM_DTL',
    );
    final future = query(STPERMDTLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StPermDtl.fromJson(json.cast<String, dynamic>())
            : null);
    return STPERMDTLFluent<StPermDtl?>(
      future,
      query,
    );
  }

  STPERMDTLFluent<StPermDtl> findUniqueOrThrow(
      {required STPERMDTLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_PERM_DTLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_PERM_DTLOrThrow',
    );
    final future = query(STPERMDTLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StPermDtl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_PERM_DTL)'));
    return STPERMDTLFluent<StPermDtl>(
      future,
      query,
    );
  }

  STPERMDTLFluent<StPermDtl?> findFirst({
    STPERMDTLWhereInput? where,
    Iterable<STPERMDTLOrderByWithRelationInput>? orderBy,
    STPERMDTLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STPERMDTLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_PERM_DTL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_PERM_DTL',
    );
    final future = query(STPERMDTLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StPermDtl.fromJson(json.cast<String, dynamic>())
            : null);
    return STPERMDTLFluent<StPermDtl?>(
      future,
      query,
    );
  }

  STPERMDTLFluent<StPermDtl> findFirstOrThrow({
    STPERMDTLWhereInput? where,
    Iterable<STPERMDTLOrderByWithRelationInput>? orderBy,
    STPERMDTLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STPERMDTLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_PERM_DTLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_PERM_DTLOrThrow',
    );
    final future = query(STPERMDTLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StPermDtl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_PERM_DTL)'));
    return STPERMDTLFluent<StPermDtl>(
      future,
      query,
    );
  }

  Future<Iterable<StPermDtl>> findMany({
    STPERMDTLWhereInput? where,
    Iterable<STPERMDTLOrderByWithRelationInput>? orderBy,
    STPERMDTLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STPERMDTLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyST_PERM_DTL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyST_PERM_DTL',
    );
    final fields = STPERMDTLScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManySTPERMDTL) =>
        findManySTPERMDTL.map((Map findManySTPERMDTL) =>
            StPermDtl.fromJson(findManySTPERMDTL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  STPERMDTLFluent<StPermDtl> create({required STPERMDTLCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneST_PERM_DTL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneST_PERM_DTL',
    );
    final future = query(STPERMDTLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StPermDtl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_PERM_DTL)'));
    return STPERMDTLFluent<StPermDtl>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<STPERMDTLCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyST_PERM_DTL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyST_PERM_DTL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManySTPERMDTL) =>
        AffectedRowsOutput.fromJson(createManySTPERMDTL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STPERMDTLFluent<StPermDtl?> update({
    required STPERMDTLUpdateInput data,
    required STPERMDTLWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneST_PERM_DTL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneST_PERM_DTL',
    );
    final future = query(STPERMDTLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StPermDtl.fromJson(json.cast<String, dynamic>())
            : null);
    return STPERMDTLFluent<StPermDtl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required STPERMDTLUpdateManyMutationInput data,
    STPERMDTLWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyST_PERM_DTL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyST_PERM_DTL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManySTPERMDTL) =>
        AffectedRowsOutput.fromJson(updateManySTPERMDTL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STPERMDTLFluent<StPermDtl> upsert({
    required STPERMDTLWhereUniqueInput where,
    required STPERMDTLCreateInput create,
    required STPERMDTLUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneST_PERM_DTL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneST_PERM_DTL',
    );
    final future = query(STPERMDTLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StPermDtl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_PERM_DTL)'));
    return STPERMDTLFluent<StPermDtl>(
      future,
      query,
    );
  }

  STPERMDTLFluent<StPermDtl?> delete(
      {required STPERMDTLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneST_PERM_DTL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneST_PERM_DTL',
    );
    final future = query(STPERMDTLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StPermDtl.fromJson(json.cast<String, dynamic>())
            : null);
    return STPERMDTLFluent<StPermDtl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({STPERMDTLWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyST_PERM_DTL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyST_PERM_DTL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManySTPERMDTL) =>
        AffectedRowsOutput.fromJson(deleteManySTPERMDTL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateSTPERMDTL aggregate({
    STPERMDTLWhereInput? where,
    Iterable<STPERMDTLOrderByWithRelationInput>? orderBy,
    STPERMDTLWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateST_PERM_DTL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateST_PERM_DTL',
    );
    return AggregateSTPERMDTL(query);
  }

  Future<Iterable<STPERMDTLGroupByOutputType>> groupBy({
    STPERMDTLWhereInput? where,
    Iterable<STPERMDTLOrderByWithAggregationInput>? orderBy,
    required Iterable<STPERMDTLScalarFieldEnum> by,
    STPERMDTLScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByST_PERM_DTL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByST_PERM_DTL',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupBySTPERMDTL) =>
        groupBySTPERMDTL.map((Map groupBySTPERMDTL) =>
            STPERMDTLGroupByOutputType.fromJson(groupBySTPERMDTL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension STPERMMSTModelDelegateExtension on _i1.ModelDelegate<StPermMst> {
  STPERMMSTFluent<StPermMst?> findUnique(
      {required STPERMMSTWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_PERM_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_PERM_MST',
    );
    final future = query(STPERMMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StPermMst.fromJson(json.cast<String, dynamic>())
            : null);
    return STPERMMSTFluent<StPermMst?>(
      future,
      query,
    );
  }

  STPERMMSTFluent<StPermMst> findUniqueOrThrow(
      {required STPERMMSTWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_PERM_MSTOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_PERM_MSTOrThrow',
    );
    final future = query(STPERMMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StPermMst.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_PERM_MST)'));
    return STPERMMSTFluent<StPermMst>(
      future,
      query,
    );
  }

  STPERMMSTFluent<StPermMst?> findFirst({
    STPERMMSTWhereInput? where,
    Iterable<STPERMMSTOrderByWithRelationInput>? orderBy,
    STPERMMSTWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STPERMMSTScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_PERM_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_PERM_MST',
    );
    final future = query(STPERMMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StPermMst.fromJson(json.cast<String, dynamic>())
            : null);
    return STPERMMSTFluent<StPermMst?>(
      future,
      query,
    );
  }

  STPERMMSTFluent<StPermMst> findFirstOrThrow({
    STPERMMSTWhereInput? where,
    Iterable<STPERMMSTOrderByWithRelationInput>? orderBy,
    STPERMMSTWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STPERMMSTScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_PERM_MSTOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_PERM_MSTOrThrow',
    );
    final future = query(STPERMMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StPermMst.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_PERM_MST)'));
    return STPERMMSTFluent<StPermMst>(
      future,
      query,
    );
  }

  Future<Iterable<StPermMst>> findMany({
    STPERMMSTWhereInput? where,
    Iterable<STPERMMSTOrderByWithRelationInput>? orderBy,
    STPERMMSTWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STPERMMSTScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyST_PERM_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyST_PERM_MST',
    );
    final fields = STPERMMSTScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManySTPERMMST) =>
        findManySTPERMMST.map((Map findManySTPERMMST) =>
            StPermMst.fromJson(findManySTPERMMST.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  STPERMMSTFluent<StPermMst> create({required STPERMMSTCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneST_PERM_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneST_PERM_MST',
    );
    final future = query(STPERMMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StPermMst.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_PERM_MST)'));
    return STPERMMSTFluent<StPermMst>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<STPERMMSTCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyST_PERM_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyST_PERM_MST',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManySTPERMMST) =>
        AffectedRowsOutput.fromJson(createManySTPERMMST.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STPERMMSTFluent<StPermMst?> update({
    required STPERMMSTUpdateInput data,
    required STPERMMSTWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneST_PERM_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneST_PERM_MST',
    );
    final future = query(STPERMMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StPermMst.fromJson(json.cast<String, dynamic>())
            : null);
    return STPERMMSTFluent<StPermMst?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required STPERMMSTUpdateManyMutationInput data,
    STPERMMSTWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyST_PERM_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyST_PERM_MST',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManySTPERMMST) =>
        AffectedRowsOutput.fromJson(updateManySTPERMMST.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STPERMMSTFluent<StPermMst> upsert({
    required STPERMMSTWhereUniqueInput where,
    required STPERMMSTCreateInput create,
    required STPERMMSTUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneST_PERM_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneST_PERM_MST',
    );
    final future = query(STPERMMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StPermMst.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_PERM_MST)'));
    return STPERMMSTFluent<StPermMst>(
      future,
      query,
    );
  }

  STPERMMSTFluent<StPermMst?> delete(
      {required STPERMMSTWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneST_PERM_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneST_PERM_MST',
    );
    final future = query(STPERMMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StPermMst.fromJson(json.cast<String, dynamic>())
            : null);
    return STPERMMSTFluent<StPermMst?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({STPERMMSTWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyST_PERM_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyST_PERM_MST',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManySTPERMMST) =>
        AffectedRowsOutput.fromJson(deleteManySTPERMMST.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateSTPERMMST aggregate({
    STPERMMSTWhereInput? where,
    Iterable<STPERMMSTOrderByWithRelationInput>? orderBy,
    STPERMMSTWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateST_PERM_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateST_PERM_MST',
    );
    return AggregateSTPERMMST(query);
  }

  Future<Iterable<STPERMMSTGroupByOutputType>> groupBy({
    STPERMMSTWhereInput? where,
    Iterable<STPERMMSTOrderByWithAggregationInput>? orderBy,
    required Iterable<STPERMMSTScalarFieldEnum> by,
    STPERMMSTScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByST_PERM_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByST_PERM_MST',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupBySTPERMMST) =>
        groupBySTPERMMST.map((Map groupBySTPERMMST) =>
            STPERMMSTGroupByOutputType.fromJson(groupBySTPERMMST.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension STPOPUPModelDelegateExtension on _i1.ModelDelegate<StPopup> {
  STPOPUPFluent<StPopup?> findUnique({required STPOPUPWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_POPUP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_POPUP',
    );
    final future = query(STPOPUPScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StPopup.fromJson(json.cast<String, dynamic>())
            : null);
    return STPOPUPFluent<StPopup?>(
      future,
      query,
    );
  }

  STPOPUPFluent<StPopup> findUniqueOrThrow(
      {required STPOPUPWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_POPUPOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_POPUPOrThrow',
    );
    final future = query(STPOPUPScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StPopup.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_POPUP)'));
    return STPOPUPFluent<StPopup>(
      future,
      query,
    );
  }

  STPOPUPFluent<StPopup?> findFirst({
    STPOPUPWhereInput? where,
    Iterable<STPOPUPOrderByWithRelationInput>? orderBy,
    STPOPUPWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STPOPUPScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_POPUP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_POPUP',
    );
    final future = query(STPOPUPScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StPopup.fromJson(json.cast<String, dynamic>())
            : null);
    return STPOPUPFluent<StPopup?>(
      future,
      query,
    );
  }

  STPOPUPFluent<StPopup> findFirstOrThrow({
    STPOPUPWhereInput? where,
    Iterable<STPOPUPOrderByWithRelationInput>? orderBy,
    STPOPUPWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STPOPUPScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_POPUPOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_POPUPOrThrow',
    );
    final future = query(STPOPUPScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StPopup.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_POPUP)'));
    return STPOPUPFluent<StPopup>(
      future,
      query,
    );
  }

  Future<Iterable<StPopup>> findMany({
    STPOPUPWhereInput? where,
    Iterable<STPOPUPOrderByWithRelationInput>? orderBy,
    STPOPUPWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STPOPUPScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyST_POPUP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyST_POPUP',
    );
    final fields = STPOPUPScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManySTPOPUP) => findManySTPOPUP
        .map((Map findManySTPOPUP) => StPopup.fromJson(findManySTPOPUP.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  STPOPUPFluent<StPopup> create({required STPOPUPCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneST_POPUP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneST_POPUP',
    );
    final future = query(STPOPUPScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StPopup.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_POPUP)'));
    return STPOPUPFluent<StPopup>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<STPOPUPCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyST_POPUP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyST_POPUP',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManySTPOPUP) =>
        AffectedRowsOutput.fromJson(createManySTPOPUP.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STPOPUPFluent<StPopup?> update({
    required STPOPUPUpdateInput data,
    required STPOPUPWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneST_POPUP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneST_POPUP',
    );
    final future = query(STPOPUPScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StPopup.fromJson(json.cast<String, dynamic>())
            : null);
    return STPOPUPFluent<StPopup?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required STPOPUPUpdateManyMutationInput data,
    STPOPUPWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyST_POPUP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyST_POPUP',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManySTPOPUP) =>
        AffectedRowsOutput.fromJson(updateManySTPOPUP.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STPOPUPFluent<StPopup> upsert({
    required STPOPUPWhereUniqueInput where,
    required STPOPUPCreateInput create,
    required STPOPUPUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneST_POPUP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneST_POPUP',
    );
    final future = query(STPOPUPScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StPopup.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_POPUP)'));
    return STPOPUPFluent<StPopup>(
      future,
      query,
    );
  }

  STPOPUPFluent<StPopup?> delete({required STPOPUPWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneST_POPUP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneST_POPUP',
    );
    final future = query(STPOPUPScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StPopup.fromJson(json.cast<String, dynamic>())
            : null);
    return STPOPUPFluent<StPopup?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({STPOPUPWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyST_POPUP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyST_POPUP',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManySTPOPUP) =>
        AffectedRowsOutput.fromJson(deleteManySTPOPUP.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateSTPOPUP aggregate({
    STPOPUPWhereInput? where,
    Iterable<STPOPUPOrderByWithRelationInput>? orderBy,
    STPOPUPWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateST_POPUP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateST_POPUP',
    );
    return AggregateSTPOPUP(query);
  }

  Future<Iterable<STPOPUPGroupByOutputType>> groupBy({
    STPOPUPWhereInput? where,
    Iterable<STPOPUPOrderByWithAggregationInput>? orderBy,
    required Iterable<STPOPUPScalarFieldEnum> by,
    STPOPUPScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByST_POPUP',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByST_POPUP',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupBySTPOPUP) =>
        groupBySTPOPUP.map((Map groupBySTPOPUP) =>
            STPOPUPGroupByOutputType.fromJson(groupBySTPOPUP.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension STSTNGModelDelegateExtension on _i1.ModelDelegate<StStng> {
  STSTNGFluent<StStng?> findUnique({required STSTNGWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_STNG',
    );
    final future = query(STSTNGScalarFieldEnum.values.toGraphQLFields()).then(
        (json) =>
            json is Map ? StStng.fromJson(json.cast<String, dynamic>()) : null);
    return STSTNGFluent<StStng?>(
      future,
      query,
    );
  }

  STSTNGFluent<StStng> findUniqueOrThrow(
      {required STSTNGWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_STNGOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_STNGOrThrow',
    );
    final future = query(STSTNGScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StStng.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_STNG)'));
    return STSTNGFluent<StStng>(
      future,
      query,
    );
  }

  STSTNGFluent<StStng?> findFirst({
    STSTNGWhereInput? where,
    Iterable<STSTNGOrderByWithRelationInput>? orderBy,
    STSTNGWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STSTNGScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_STNG',
    );
    final future = query(STSTNGScalarFieldEnum.values.toGraphQLFields()).then(
        (json) =>
            json is Map ? StStng.fromJson(json.cast<String, dynamic>()) : null);
    return STSTNGFluent<StStng?>(
      future,
      query,
    );
  }

  STSTNGFluent<StStng> findFirstOrThrow({
    STSTNGWhereInput? where,
    Iterable<STSTNGOrderByWithRelationInput>? orderBy,
    STSTNGWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STSTNGScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_STNGOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_STNGOrThrow',
    );
    final future = query(STSTNGScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StStng.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_STNG)'));
    return STSTNGFluent<StStng>(
      future,
      query,
    );
  }

  Future<Iterable<StStng>> findMany({
    STSTNGWhereInput? where,
    Iterable<STSTNGOrderByWithRelationInput>? orderBy,
    STSTNGWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STSTNGScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyST_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyST_STNG',
    );
    final fields = STSTNGScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManySTSTNG) => findManySTSTNG
        .map((Map findManySTSTNG) => StStng.fromJson(findManySTSTNG.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  STSTNGFluent<StStng> create({required STSTNGCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneST_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneST_STNG',
    );
    final future = query(STSTNGScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StStng.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_STNG)'));
    return STSTNGFluent<StStng>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<STSTNGCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyST_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyST_STNG',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManySTSTNG) =>
        AffectedRowsOutput.fromJson(createManySTSTNG.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STSTNGFluent<StStng?> update({
    required STSTNGUpdateInput data,
    required STSTNGWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneST_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneST_STNG',
    );
    final future = query(STSTNGScalarFieldEnum.values.toGraphQLFields()).then(
        (json) =>
            json is Map ? StStng.fromJson(json.cast<String, dynamic>()) : null);
    return STSTNGFluent<StStng?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required STSTNGUpdateManyMutationInput data,
    STSTNGWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyST_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyST_STNG',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManySTSTNG) =>
        AffectedRowsOutput.fromJson(updateManySTSTNG.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STSTNGFluent<StStng> upsert({
    required STSTNGWhereUniqueInput where,
    required STSTNGCreateInput create,
    required STSTNGUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneST_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneST_STNG',
    );
    final future = query(STSTNGScalarFieldEnum.values.toGraphQLFields()).then(
        (json) => json is Map
            ? StStng.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_STNG)'));
    return STSTNGFluent<StStng>(
      future,
      query,
    );
  }

  STSTNGFluent<StStng?> delete({required STSTNGWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneST_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneST_STNG',
    );
    final future = query(STSTNGScalarFieldEnum.values.toGraphQLFields()).then(
        (json) =>
            json is Map ? StStng.fromJson(json.cast<String, dynamic>()) : null);
    return STSTNGFluent<StStng?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({STSTNGWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyST_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyST_STNG',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManySTSTNG) =>
        AffectedRowsOutput.fromJson(deleteManySTSTNG.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateSTSTNG aggregate({
    STSTNGWhereInput? where,
    Iterable<STSTNGOrderByWithRelationInput>? orderBy,
    STSTNGWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateST_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateST_STNG',
    );
    return AggregateSTSTNG(query);
  }

  Future<Iterable<STSTNGGroupByOutputType>> groupBy({
    STSTNGWhereInput? where,
    Iterable<STSTNGOrderByWithAggregationInput>? orderBy,
    required Iterable<STSTNGScalarFieldEnum> by,
    STSTNGScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByST_STNG',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByST_STNG',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupBySTSTNG) =>
        groupBySTSTNG.map((Map groupBySTSTNG) =>
            STSTNGGroupByOutputType.fromJson(groupBySTSTNG.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension STUSERMSTModelDelegateExtension on _i1.ModelDelegate<StUserMst> {
  STUSERMSTFluent<StUserMst?> findUnique(
      {required STUSERMSTWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_USER_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_USER_MST',
    );
    final future = query(STUSERMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StUserMst.fromJson(json.cast<String, dynamic>())
            : null);
    return STUSERMSTFluent<StUserMst?>(
      future,
      query,
    );
  }

  STUSERMSTFluent<StUserMst> findUniqueOrThrow(
      {required STUSERMSTWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueST_USER_MSTOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueST_USER_MSTOrThrow',
    );
    final future = query(STUSERMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StUserMst.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_USER_MST)'));
    return STUSERMSTFluent<StUserMst>(
      future,
      query,
    );
  }

  STUSERMSTFluent<StUserMst?> findFirst({
    STUSERMSTWhereInput? where,
    Iterable<STUSERMSTOrderByWithRelationInput>? orderBy,
    STUSERMSTWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STUSERMSTScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_USER_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_USER_MST',
    );
    final future = query(STUSERMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StUserMst.fromJson(json.cast<String, dynamic>())
            : null);
    return STUSERMSTFluent<StUserMst?>(
      future,
      query,
    );
  }

  STUSERMSTFluent<StUserMst> findFirstOrThrow({
    STUSERMSTWhereInput? where,
    Iterable<STUSERMSTOrderByWithRelationInput>? orderBy,
    STUSERMSTWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STUSERMSTScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstST_USER_MSTOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstST_USER_MSTOrThrow',
    );
    final future = query(STUSERMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StUserMst.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_USER_MST)'));
    return STUSERMSTFluent<StUserMst>(
      future,
      query,
    );
  }

  Future<Iterable<StUserMst>> findMany({
    STUSERMSTWhereInput? where,
    Iterable<STUSERMSTOrderByWithRelationInput>? orderBy,
    STUSERMSTWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<STUSERMSTScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyST_USER_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyST_USER_MST',
    );
    final fields = STUSERMSTScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManySTUSERMST) =>
        findManySTUSERMST.map((Map findManySTUSERMST) =>
            StUserMst.fromJson(findManySTUSERMST.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  STUSERMSTFluent<StUserMst> create({required STUSERMSTCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneST_USER_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneST_USER_MST',
    );
    final future = query(STUSERMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StUserMst.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_USER_MST)'));
    return STUSERMSTFluent<StUserMst>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<STUSERMSTCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyST_USER_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyST_USER_MST',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManySTUSERMST) =>
        AffectedRowsOutput.fromJson(createManySTUSERMST.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STUSERMSTFluent<StUserMst?> update({
    required STUSERMSTUpdateInput data,
    required STUSERMSTWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneST_USER_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneST_USER_MST',
    );
    final future = query(STUSERMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StUserMst.fromJson(json.cast<String, dynamic>())
            : null);
    return STUSERMSTFluent<StUserMst?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required STUSERMSTUpdateManyMutationInput data,
    STUSERMSTWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyST_USER_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyST_USER_MST',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManySTUSERMST) =>
        AffectedRowsOutput.fromJson(updateManySTUSERMST.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  STUSERMSTFluent<StUserMst> upsert({
    required STUSERMSTWhereUniqueInput where,
    required STUSERMSTCreateInput create,
    required STUSERMSTUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneST_USER_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneST_USER_MST',
    );
    final future = query(STUSERMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StUserMst.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: ST_USER_MST)'));
    return STUSERMSTFluent<StUserMst>(
      future,
      query,
    );
  }

  STUSERMSTFluent<StUserMst?> delete(
      {required STUSERMSTWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneST_USER_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneST_USER_MST',
    );
    final future = query(STUSERMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? StUserMst.fromJson(json.cast<String, dynamic>())
            : null);
    return STUSERMSTFluent<StUserMst?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({STUSERMSTWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyST_USER_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyST_USER_MST',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManySTUSERMST) =>
        AffectedRowsOutput.fromJson(deleteManySTUSERMST.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateSTUSERMST aggregate({
    STUSERMSTWhereInput? where,
    Iterable<STUSERMSTOrderByWithRelationInput>? orderBy,
    STUSERMSTWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateST_USER_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateST_USER_MST',
    );
    return AggregateSTUSERMST(query);
  }

  Future<Iterable<STUSERMSTGroupByOutputType>> groupBy({
    STUSERMSTWhereInput? where,
    Iterable<STUSERMSTOrderByWithAggregationInput>? orderBy,
    required Iterable<STUSERMSTScalarFieldEnum> by,
    STUSERMSTScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByST_USER_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByST_USER_MST',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupBySTUSERMST) =>
        groupBySTUSERMST.map((Map groupBySTUSERMST) =>
            STUSERMSTGroupByOutputType.fromJson(groupBySTUSERMST.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension WORKREPORTDETAILTBLModelDelegateExtension
    on _i1.ModelDelegate<WorkReportDetailTbl> {
  WORKREPORTDETAILTBLFluent<WorkReportDetailTbl?> findUnique(
      {required WORKREPORTDETAILTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueWORK_REPORT_DETAIL_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueWORK_REPORT_DETAIL_TBL',
    );
    final future =
        query(WORKREPORTDETAILTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? WorkReportDetailTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return WORKREPORTDETAILTBLFluent<WorkReportDetailTbl?>(
      future,
      query,
    );
  }

  WORKREPORTDETAILTBLFluent<WorkReportDetailTbl> findUniqueOrThrow(
      {required WORKREPORTDETAILTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueWORK_REPORT_DETAIL_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueWORK_REPORT_DETAIL_TBLOrThrow',
    );
    final future = query(
            WORKREPORTDETAILTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? WorkReportDetailTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: WORK_REPORT_DETAIL_TBL)'));
    return WORKREPORTDETAILTBLFluent<WorkReportDetailTbl>(
      future,
      query,
    );
  }

  WORKREPORTDETAILTBLFluent<WorkReportDetailTbl?> findFirst({
    WORKREPORTDETAILTBLWhereInput? where,
    Iterable<WORKREPORTDETAILTBLOrderByWithRelationInput>? orderBy,
    WORKREPORTDETAILTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<WORKREPORTDETAILTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstWORK_REPORT_DETAIL_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstWORK_REPORT_DETAIL_TBL',
    );
    final future =
        query(WORKREPORTDETAILTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? WorkReportDetailTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return WORKREPORTDETAILTBLFluent<WorkReportDetailTbl?>(
      future,
      query,
    );
  }

  WORKREPORTDETAILTBLFluent<WorkReportDetailTbl> findFirstOrThrow({
    WORKREPORTDETAILTBLWhereInput? where,
    Iterable<WORKREPORTDETAILTBLOrderByWithRelationInput>? orderBy,
    WORKREPORTDETAILTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<WORKREPORTDETAILTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstWORK_REPORT_DETAIL_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstWORK_REPORT_DETAIL_TBLOrThrow',
    );
    final future = query(
            WORKREPORTDETAILTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? WorkReportDetailTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: WORK_REPORT_DETAIL_TBL)'));
    return WORKREPORTDETAILTBLFluent<WorkReportDetailTbl>(
      future,
      query,
    );
  }

  Future<Iterable<WorkReportDetailTbl>> findMany({
    WORKREPORTDETAILTBLWhereInput? where,
    Iterable<WORKREPORTDETAILTBLOrderByWithRelationInput>? orderBy,
    WORKREPORTDETAILTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<WORKREPORTDETAILTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyWORK_REPORT_DETAIL_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyWORK_REPORT_DETAIL_TBL',
    );
    final fields = WORKREPORTDETAILTBLScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyWORKREPORTDETAILTBL) =>
        findManyWORKREPORTDETAILTBL.map((Map findManyWORKREPORTDETAILTBL) =>
            WorkReportDetailTbl.fromJson(findManyWORKREPORTDETAILTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  WORKREPORTDETAILTBLFluent<WorkReportDetailTbl> create(
      {required WORKREPORTDETAILTBLCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneWORK_REPORT_DETAIL_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneWORK_REPORT_DETAIL_TBL',
    );
    final future = query(
            WORKREPORTDETAILTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? WorkReportDetailTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: WORK_REPORT_DETAIL_TBL)'));
    return WORKREPORTDETAILTBLFluent<WorkReportDetailTbl>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<WORKREPORTDETAILTBLCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyWORK_REPORT_DETAIL_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyWORK_REPORT_DETAIL_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyWORKREPORTDETAILTBL) =>
        AffectedRowsOutput.fromJson(createManyWORKREPORTDETAILTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  WORKREPORTDETAILTBLFluent<WorkReportDetailTbl?> update({
    required WORKREPORTDETAILTBLUpdateInput data,
    required WORKREPORTDETAILTBLWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneWORK_REPORT_DETAIL_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneWORK_REPORT_DETAIL_TBL',
    );
    final future =
        query(WORKREPORTDETAILTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? WorkReportDetailTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return WORKREPORTDETAILTBLFluent<WorkReportDetailTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required WORKREPORTDETAILTBLUpdateManyMutationInput data,
    WORKREPORTDETAILTBLWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyWORK_REPORT_DETAIL_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyWORK_REPORT_DETAIL_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyWORKREPORTDETAILTBL) =>
        AffectedRowsOutput.fromJson(updateManyWORKREPORTDETAILTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  WORKREPORTDETAILTBLFluent<WorkReportDetailTbl> upsert({
    required WORKREPORTDETAILTBLWhereUniqueInput where,
    required WORKREPORTDETAILTBLCreateInput create,
    required WORKREPORTDETAILTBLUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneWORK_REPORT_DETAIL_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneWORK_REPORT_DETAIL_TBL',
    );
    final future = query(
            WORKREPORTDETAILTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? WorkReportDetailTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: WORK_REPORT_DETAIL_TBL)'));
    return WORKREPORTDETAILTBLFluent<WorkReportDetailTbl>(
      future,
      query,
    );
  }

  WORKREPORTDETAILTBLFluent<WorkReportDetailTbl?> delete(
      {required WORKREPORTDETAILTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneWORK_REPORT_DETAIL_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneWORK_REPORT_DETAIL_TBL',
    );
    final future =
        query(WORKREPORTDETAILTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? WorkReportDetailTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return WORKREPORTDETAILTBLFluent<WorkReportDetailTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany(
      {WORKREPORTDETAILTBLWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyWORK_REPORT_DETAIL_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyWORK_REPORT_DETAIL_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyWORKREPORTDETAILTBL) =>
        AffectedRowsOutput.fromJson(deleteManyWORKREPORTDETAILTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateWORKREPORTDETAILTBL aggregate({
    WORKREPORTDETAILTBLWhereInput? where,
    Iterable<WORKREPORTDETAILTBLOrderByWithRelationInput>? orderBy,
    WORKREPORTDETAILTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateWORK_REPORT_DETAIL_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateWORK_REPORT_DETAIL_TBL',
    );
    return AggregateWORKREPORTDETAILTBL(query);
  }

  Future<Iterable<WORKREPORTDETAILTBLGroupByOutputType>> groupBy({
    WORKREPORTDETAILTBLWhereInput? where,
    Iterable<WORKREPORTDETAILTBLOrderByWithAggregationInput>? orderBy,
    required Iterable<WORKREPORTDETAILTBLScalarFieldEnum> by,
    WORKREPORTDETAILTBLScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByWORK_REPORT_DETAIL_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByWORK_REPORT_DETAIL_TBL',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByWORKREPORTDETAILTBL) =>
        groupByWORKREPORTDETAILTBL.map((Map groupByWORKREPORTDETAILTBL) =>
            WORKREPORTDETAILTBLGroupByOutputType.fromJson(
                groupByWORKREPORTDETAILTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension WORKREPORTHTMLTBLModelDelegateExtension
    on _i1.ModelDelegate<WorkReportHtmlTbl> {
  WORKREPORTHTMLTBLFluent<WorkReportHtmlTbl?> findUnique(
      {required WORKREPORTHTMLTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueWORK_REPORT_HTML_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueWORK_REPORT_HTML_TBL',
    );
    final future =
        query(WORKREPORTHTMLTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? WorkReportHtmlTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return WORKREPORTHTMLTBLFluent<WorkReportHtmlTbl?>(
      future,
      query,
    );
  }

  WORKREPORTHTMLTBLFluent<WorkReportHtmlTbl> findUniqueOrThrow(
      {required WORKREPORTHTMLTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueWORK_REPORT_HTML_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueWORK_REPORT_HTML_TBLOrThrow',
    );
    final future = query(
            WORKREPORTHTMLTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? WorkReportHtmlTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: WORK_REPORT_HTML_TBL)'));
    return WORKREPORTHTMLTBLFluent<WorkReportHtmlTbl>(
      future,
      query,
    );
  }

  WORKREPORTHTMLTBLFluent<WorkReportHtmlTbl?> findFirst({
    WORKREPORTHTMLTBLWhereInput? where,
    Iterable<WORKREPORTHTMLTBLOrderByWithRelationInput>? orderBy,
    WORKREPORTHTMLTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<WORKREPORTHTMLTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstWORK_REPORT_HTML_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstWORK_REPORT_HTML_TBL',
    );
    final future =
        query(WORKREPORTHTMLTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? WorkReportHtmlTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return WORKREPORTHTMLTBLFluent<WorkReportHtmlTbl?>(
      future,
      query,
    );
  }

  WORKREPORTHTMLTBLFluent<WorkReportHtmlTbl> findFirstOrThrow({
    WORKREPORTHTMLTBLWhereInput? where,
    Iterable<WORKREPORTHTMLTBLOrderByWithRelationInput>? orderBy,
    WORKREPORTHTMLTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<WORKREPORTHTMLTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstWORK_REPORT_HTML_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstWORK_REPORT_HTML_TBLOrThrow',
    );
    final future = query(
            WORKREPORTHTMLTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? WorkReportHtmlTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: WORK_REPORT_HTML_TBL)'));
    return WORKREPORTHTMLTBLFluent<WorkReportHtmlTbl>(
      future,
      query,
    );
  }

  Future<Iterable<WorkReportHtmlTbl>> findMany({
    WORKREPORTHTMLTBLWhereInput? where,
    Iterable<WORKREPORTHTMLTBLOrderByWithRelationInput>? orderBy,
    WORKREPORTHTMLTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<WORKREPORTHTMLTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyWORK_REPORT_HTML_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyWORK_REPORT_HTML_TBL',
    );
    final fields = WORKREPORTHTMLTBLScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyWORKREPORTHTMLTBL) =>
        findManyWORKREPORTHTMLTBL.map((Map findManyWORKREPORTHTMLTBL) =>
            WorkReportHtmlTbl.fromJson(findManyWORKREPORTHTMLTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  WORKREPORTHTMLTBLFluent<WorkReportHtmlTbl> create(
      {required WORKREPORTHTMLTBLCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneWORK_REPORT_HTML_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneWORK_REPORT_HTML_TBL',
    );
    final future = query(
            WORKREPORTHTMLTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? WorkReportHtmlTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: WORK_REPORT_HTML_TBL)'));
    return WORKREPORTHTMLTBLFluent<WorkReportHtmlTbl>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<WORKREPORTHTMLTBLCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyWORK_REPORT_HTML_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyWORK_REPORT_HTML_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyWORKREPORTHTMLTBL) =>
        AffectedRowsOutput.fromJson(createManyWORKREPORTHTMLTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  WORKREPORTHTMLTBLFluent<WorkReportHtmlTbl?> update({
    required WORKREPORTHTMLTBLUpdateInput data,
    required WORKREPORTHTMLTBLWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneWORK_REPORT_HTML_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneWORK_REPORT_HTML_TBL',
    );
    final future =
        query(WORKREPORTHTMLTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? WorkReportHtmlTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return WORKREPORTHTMLTBLFluent<WorkReportHtmlTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required WORKREPORTHTMLTBLUpdateManyMutationInput data,
    WORKREPORTHTMLTBLWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyWORK_REPORT_HTML_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyWORK_REPORT_HTML_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyWORKREPORTHTMLTBL) =>
        AffectedRowsOutput.fromJson(updateManyWORKREPORTHTMLTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  WORKREPORTHTMLTBLFluent<WorkReportHtmlTbl> upsert({
    required WORKREPORTHTMLTBLWhereUniqueInput where,
    required WORKREPORTHTMLTBLCreateInput create,
    required WORKREPORTHTMLTBLUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneWORK_REPORT_HTML_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneWORK_REPORT_HTML_TBL',
    );
    final future = query(
            WORKREPORTHTMLTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? WorkReportHtmlTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: WORK_REPORT_HTML_TBL)'));
    return WORKREPORTHTMLTBLFluent<WorkReportHtmlTbl>(
      future,
      query,
    );
  }

  WORKREPORTHTMLTBLFluent<WorkReportHtmlTbl?> delete(
      {required WORKREPORTHTMLTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneWORK_REPORT_HTML_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneWORK_REPORT_HTML_TBL',
    );
    final future =
        query(WORKREPORTHTMLTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? WorkReportHtmlTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return WORKREPORTHTMLTBLFluent<WorkReportHtmlTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({WORKREPORTHTMLTBLWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyWORK_REPORT_HTML_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyWORK_REPORT_HTML_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyWORKREPORTHTMLTBL) =>
        AffectedRowsOutput.fromJson(deleteManyWORKREPORTHTMLTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateWORKREPORTHTMLTBL aggregate({
    WORKREPORTHTMLTBLWhereInput? where,
    Iterable<WORKREPORTHTMLTBLOrderByWithRelationInput>? orderBy,
    WORKREPORTHTMLTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateWORK_REPORT_HTML_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateWORK_REPORT_HTML_TBL',
    );
    return AggregateWORKREPORTHTMLTBL(query);
  }

  Future<Iterable<WORKREPORTHTMLTBLGroupByOutputType>> groupBy({
    WORKREPORTHTMLTBLWhereInput? where,
    Iterable<WORKREPORTHTMLTBLOrderByWithAggregationInput>? orderBy,
    required Iterable<WORKREPORTHTMLTBLScalarFieldEnum> by,
    WORKREPORTHTMLTBLScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByWORK_REPORT_HTML_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByWORK_REPORT_HTML_TBL',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByWORKREPORTHTMLTBL) =>
        groupByWORKREPORTHTMLTBL.map((Map groupByWORKREPORTHTMLTBL) =>
            WORKREPORTHTMLTBLGroupByOutputType.fromJson(
                groupByWORKREPORTHTMLTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension WORKREPORTHTMLTBLBACKModelDelegateExtension
    on _i1.ModelDelegate<WorkReportHtmlTblBack> {
  WORKREPORTHTMLTBLBACKFluent<WorkReportHtmlTblBack?> findUnique(
      {required WORKREPORTHTMLTBLBACKWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueWORK_REPORT_HTML_TBL_BACK',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueWORK_REPORT_HTML_TBL_BACK',
    );
    final future =
        query(WORKREPORTHTMLTBLBACKScalarFieldEnum.values.toGraphQLFields())
            .then((json) => json is Map
                ? WorkReportHtmlTblBack.fromJson(json.cast<String, dynamic>())
                : null);
    return WORKREPORTHTMLTBLBACKFluent<WorkReportHtmlTblBack?>(
      future,
      query,
    );
  }

  WORKREPORTHTMLTBLBACKFluent<WorkReportHtmlTblBack> findUniqueOrThrow(
      {required WORKREPORTHTMLTBLBACKWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueWORK_REPORT_HTML_TBL_BACKOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueWORK_REPORT_HTML_TBL_BACKOrThrow',
    );
    final future = query(
            WORKREPORTHTMLTBLBACKScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? WorkReportHtmlTblBack.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: WORK_REPORT_HTML_TBL_BACK)'));
    return WORKREPORTHTMLTBLBACKFluent<WorkReportHtmlTblBack>(
      future,
      query,
    );
  }

  WORKREPORTHTMLTBLBACKFluent<WorkReportHtmlTblBack?> findFirst({
    WORKREPORTHTMLTBLBACKWhereInput? where,
    Iterable<WORKREPORTHTMLTBLBACKOrderByWithRelationInput>? orderBy,
    WORKREPORTHTMLTBLBACKWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<WORKREPORTHTMLTBLBACKScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstWORK_REPORT_HTML_TBL_BACK',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstWORK_REPORT_HTML_TBL_BACK',
    );
    final future =
        query(WORKREPORTHTMLTBLBACKScalarFieldEnum.values.toGraphQLFields())
            .then((json) => json is Map
                ? WorkReportHtmlTblBack.fromJson(json.cast<String, dynamic>())
                : null);
    return WORKREPORTHTMLTBLBACKFluent<WorkReportHtmlTblBack?>(
      future,
      query,
    );
  }

  WORKREPORTHTMLTBLBACKFluent<WorkReportHtmlTblBack> findFirstOrThrow({
    WORKREPORTHTMLTBLBACKWhereInput? where,
    Iterable<WORKREPORTHTMLTBLBACKOrderByWithRelationInput>? orderBy,
    WORKREPORTHTMLTBLBACKWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<WORKREPORTHTMLTBLBACKScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstWORK_REPORT_HTML_TBL_BACKOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstWORK_REPORT_HTML_TBL_BACKOrThrow',
    );
    final future = query(
            WORKREPORTHTMLTBLBACKScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? WorkReportHtmlTblBack.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: WORK_REPORT_HTML_TBL_BACK)'));
    return WORKREPORTHTMLTBLBACKFluent<WorkReportHtmlTblBack>(
      future,
      query,
    );
  }

  Future<Iterable<WorkReportHtmlTblBack>> findMany({
    WORKREPORTHTMLTBLBACKWhereInput? where,
    Iterable<WORKREPORTHTMLTBLBACKOrderByWithRelationInput>? orderBy,
    WORKREPORTHTMLTBLBACKWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<WORKREPORTHTMLTBLBACKScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyWORK_REPORT_HTML_TBL_BACK',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyWORK_REPORT_HTML_TBL_BACK',
    );
    final fields =
        WORKREPORTHTMLTBLBACKScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyWORKREPORTHTMLTBLBACK) =>
        findManyWORKREPORTHTMLTBLBACK.map((Map findManyWORKREPORTHTMLTBLBACK) =>
            WorkReportHtmlTblBack.fromJson(
                findManyWORKREPORTHTMLTBLBACK.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  WORKREPORTHTMLTBLBACKFluent<WorkReportHtmlTblBack> create(
      {required WORKREPORTHTMLTBLBACKCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneWORK_REPORT_HTML_TBL_BACK',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneWORK_REPORT_HTML_TBL_BACK',
    );
    final future = query(
            WORKREPORTHTMLTBLBACKScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? WorkReportHtmlTblBack.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: WORK_REPORT_HTML_TBL_BACK)'));
    return WORKREPORTHTMLTBLBACKFluent<WorkReportHtmlTblBack>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<WORKREPORTHTMLTBLBACKCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyWORK_REPORT_HTML_TBL_BACK',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyWORK_REPORT_HTML_TBL_BACK',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyWORKREPORTHTMLTBLBACK) =>
        AffectedRowsOutput.fromJson(createManyWORKREPORTHTMLTBLBACK.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  WORKREPORTHTMLTBLBACKFluent<WorkReportHtmlTblBack?> update({
    required WORKREPORTHTMLTBLBACKUpdateInput data,
    required WORKREPORTHTMLTBLBACKWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneWORK_REPORT_HTML_TBL_BACK',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneWORK_REPORT_HTML_TBL_BACK',
    );
    final future =
        query(WORKREPORTHTMLTBLBACKScalarFieldEnum.values.toGraphQLFields())
            .then((json) => json is Map
                ? WorkReportHtmlTblBack.fromJson(json.cast<String, dynamic>())
                : null);
    return WORKREPORTHTMLTBLBACKFluent<WorkReportHtmlTblBack?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required WORKREPORTHTMLTBLBACKUpdateManyMutationInput data,
    WORKREPORTHTMLTBLBACKWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyWORK_REPORT_HTML_TBL_BACK',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyWORK_REPORT_HTML_TBL_BACK',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyWORKREPORTHTMLTBLBACK) =>
        AffectedRowsOutput.fromJson(updateManyWORKREPORTHTMLTBLBACK.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  WORKREPORTHTMLTBLBACKFluent<WorkReportHtmlTblBack> upsert({
    required WORKREPORTHTMLTBLBACKWhereUniqueInput where,
    required WORKREPORTHTMLTBLBACKCreateInput create,
    required WORKREPORTHTMLTBLBACKUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneWORK_REPORT_HTML_TBL_BACK',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneWORK_REPORT_HTML_TBL_BACK',
    );
    final future = query(
            WORKREPORTHTMLTBLBACKScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? WorkReportHtmlTblBack.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: WORK_REPORT_HTML_TBL_BACK)'));
    return WORKREPORTHTMLTBLBACKFluent<WorkReportHtmlTblBack>(
      future,
      query,
    );
  }

  WORKREPORTHTMLTBLBACKFluent<WorkReportHtmlTblBack?> delete(
      {required WORKREPORTHTMLTBLBACKWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneWORK_REPORT_HTML_TBL_BACK',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneWORK_REPORT_HTML_TBL_BACK',
    );
    final future =
        query(WORKREPORTHTMLTBLBACKScalarFieldEnum.values.toGraphQLFields())
            .then((json) => json is Map
                ? WorkReportHtmlTblBack.fromJson(json.cast<String, dynamic>())
                : null);
    return WORKREPORTHTMLTBLBACKFluent<WorkReportHtmlTblBack?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany(
      {WORKREPORTHTMLTBLBACKWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyWORK_REPORT_HTML_TBL_BACK',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyWORK_REPORT_HTML_TBL_BACK',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyWORKREPORTHTMLTBLBACK) =>
        AffectedRowsOutput.fromJson(deleteManyWORKREPORTHTMLTBLBACK.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateWORKREPORTHTMLTBLBACK aggregate({
    WORKREPORTHTMLTBLBACKWhereInput? where,
    Iterable<WORKREPORTHTMLTBLBACKOrderByWithRelationInput>? orderBy,
    WORKREPORTHTMLTBLBACKWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateWORK_REPORT_HTML_TBL_BACK',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateWORK_REPORT_HTML_TBL_BACK',
    );
    return AggregateWORKREPORTHTMLTBLBACK(query);
  }

  Future<Iterable<WORKREPORTHTMLTBLBACKGroupByOutputType>> groupBy({
    WORKREPORTHTMLTBLBACKWhereInput? where,
    Iterable<WORKREPORTHTMLTBLBACKOrderByWithAggregationInput>? orderBy,
    required Iterable<WORKREPORTHTMLTBLBACKScalarFieldEnum> by,
    WORKREPORTHTMLTBLBACKScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByWORK_REPORT_HTML_TBL_BACK',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByWORK_REPORT_HTML_TBL_BACK',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByWORKREPORTHTMLTBLBACK) =>
        groupByWORKREPORTHTMLTBLBACK.map((Map groupByWORKREPORTHTMLTBLBACK) =>
            WORKREPORTHTMLTBLBACKGroupByOutputType.fromJson(
                groupByWORKREPORTHTMLTBLBACK.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension WORKREPORTMASTERTBLModelDelegateExtension
    on _i1.ModelDelegate<WorkReportMasterTbl> {
  WORKREPORTMASTERTBLFluent<WorkReportMasterTbl?> findUnique(
      {required WORKREPORTMASTERTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueWORK_REPORT_MASTER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueWORK_REPORT_MASTER_TBL',
    );
    final future =
        query(WORKREPORTMASTERTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? WorkReportMasterTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return WORKREPORTMASTERTBLFluent<WorkReportMasterTbl?>(
      future,
      query,
    );
  }

  WORKREPORTMASTERTBLFluent<WorkReportMasterTbl> findUniqueOrThrow(
      {required WORKREPORTMASTERTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueWORK_REPORT_MASTER_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueWORK_REPORT_MASTER_TBLOrThrow',
    );
    final future = query(
            WORKREPORTMASTERTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? WorkReportMasterTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: WORK_REPORT_MASTER_TBL)'));
    return WORKREPORTMASTERTBLFluent<WorkReportMasterTbl>(
      future,
      query,
    );
  }

  WORKREPORTMASTERTBLFluent<WorkReportMasterTbl?> findFirst({
    WORKREPORTMASTERTBLWhereInput? where,
    Iterable<WORKREPORTMASTERTBLOrderByWithRelationInput>? orderBy,
    WORKREPORTMASTERTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<WORKREPORTMASTERTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstWORK_REPORT_MASTER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstWORK_REPORT_MASTER_TBL',
    );
    final future =
        query(WORKREPORTMASTERTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? WorkReportMasterTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return WORKREPORTMASTERTBLFluent<WorkReportMasterTbl?>(
      future,
      query,
    );
  }

  WORKREPORTMASTERTBLFluent<WorkReportMasterTbl> findFirstOrThrow({
    WORKREPORTMASTERTBLWhereInput? where,
    Iterable<WORKREPORTMASTERTBLOrderByWithRelationInput>? orderBy,
    WORKREPORTMASTERTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<WORKREPORTMASTERTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstWORK_REPORT_MASTER_TBLOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstWORK_REPORT_MASTER_TBLOrThrow',
    );
    final future = query(
            WORKREPORTMASTERTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? WorkReportMasterTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: WORK_REPORT_MASTER_TBL)'));
    return WORKREPORTMASTERTBLFluent<WorkReportMasterTbl>(
      future,
      query,
    );
  }

  Future<Iterable<WorkReportMasterTbl>> findMany({
    WORKREPORTMASTERTBLWhereInput? where,
    Iterable<WORKREPORTMASTERTBLOrderByWithRelationInput>? orderBy,
    WORKREPORTMASTERTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<WORKREPORTMASTERTBLScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyWORK_REPORT_MASTER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyWORK_REPORT_MASTER_TBL',
    );
    final fields = WORKREPORTMASTERTBLScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyWORKREPORTMASTERTBL) =>
        findManyWORKREPORTMASTERTBL.map((Map findManyWORKREPORTMASTERTBL) =>
            WorkReportMasterTbl.fromJson(findManyWORKREPORTMASTERTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  WORKREPORTMASTERTBLFluent<WorkReportMasterTbl> create(
      {required WORKREPORTMASTERTBLCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneWORK_REPORT_MASTER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneWORK_REPORT_MASTER_TBL',
    );
    final future = query(
            WORKREPORTMASTERTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? WorkReportMasterTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: WORK_REPORT_MASTER_TBL)'));
    return WORKREPORTMASTERTBLFluent<WorkReportMasterTbl>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<WORKREPORTMASTERTBLCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyWORK_REPORT_MASTER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyWORK_REPORT_MASTER_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyWORKREPORTMASTERTBL) =>
        AffectedRowsOutput.fromJson(createManyWORKREPORTMASTERTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  WORKREPORTMASTERTBLFluent<WorkReportMasterTbl?> update({
    required WORKREPORTMASTERTBLUpdateInput data,
    required WORKREPORTMASTERTBLWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneWORK_REPORT_MASTER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneWORK_REPORT_MASTER_TBL',
    );
    final future =
        query(WORKREPORTMASTERTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? WorkReportMasterTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return WORKREPORTMASTERTBLFluent<WorkReportMasterTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required WORKREPORTMASTERTBLUpdateManyMutationInput data,
    WORKREPORTMASTERTBLWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyWORK_REPORT_MASTER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyWORK_REPORT_MASTER_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyWORKREPORTMASTERTBL) =>
        AffectedRowsOutput.fromJson(updateManyWORKREPORTMASTERTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  WORKREPORTMASTERTBLFluent<WorkReportMasterTbl> upsert({
    required WORKREPORTMASTERTBLWhereUniqueInput where,
    required WORKREPORTMASTERTBLCreateInput create,
    required WORKREPORTMASTERTBLUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneWORK_REPORT_MASTER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneWORK_REPORT_MASTER_TBL',
    );
    final future = query(
            WORKREPORTMASTERTBLScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? WorkReportMasterTbl.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: WORK_REPORT_MASTER_TBL)'));
    return WORKREPORTMASTERTBLFluent<WorkReportMasterTbl>(
      future,
      query,
    );
  }

  WORKREPORTMASTERTBLFluent<WorkReportMasterTbl?> delete(
      {required WORKREPORTMASTERTBLWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneWORK_REPORT_MASTER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneWORK_REPORT_MASTER_TBL',
    );
    final future =
        query(WORKREPORTMASTERTBLScalarFieldEnum.values.toGraphQLFields()).then(
            (json) => json is Map
                ? WorkReportMasterTbl.fromJson(json.cast<String, dynamic>())
                : null);
    return WORKREPORTMASTERTBLFluent<WorkReportMasterTbl?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany(
      {WORKREPORTMASTERTBLWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyWORK_REPORT_MASTER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyWORK_REPORT_MASTER_TBL',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyWORKREPORTMASTERTBL) =>
        AffectedRowsOutput.fromJson(deleteManyWORKREPORTMASTERTBL.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateWORKREPORTMASTERTBL aggregate({
    WORKREPORTMASTERTBLWhereInput? where,
    Iterable<WORKREPORTMASTERTBLOrderByWithRelationInput>? orderBy,
    WORKREPORTMASTERTBLWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateWORK_REPORT_MASTER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateWORK_REPORT_MASTER_TBL',
    );
    return AggregateWORKREPORTMASTERTBL(query);
  }

  Future<Iterable<WORKREPORTMASTERTBLGroupByOutputType>> groupBy({
    WORKREPORTMASTERTBLWhereInput? where,
    Iterable<WORKREPORTMASTERTBLOrderByWithAggregationInput>? orderBy,
    required Iterable<WORKREPORTMASTERTBLScalarFieldEnum> by,
    WORKREPORTMASTERTBLScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByWORK_REPORT_MASTER_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByWORK_REPORT_MASTER_TBL',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByWORKREPORTMASTERTBL) =>
        groupByWORKREPORTMASTERTBL.map((Map groupByWORKREPORTMASTERTBL) =>
            WORKREPORTMASTERTBLGroupByOutputType.fromJson(
                groupByWORKREPORTMASTERTBL.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension WORKREQUESTMSTModelDelegateExtension
    on _i1.ModelDelegate<WorkRequestMst> {
  WORKREQUESTMSTFluent<WorkRequestMst?> findUnique(
      {required WORKREQUESTMSTWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueWORK_REQUEST_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueWORK_REQUEST_MST',
    );
    final future = query(WORKREQUESTMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? WorkRequestMst.fromJson(json.cast<String, dynamic>())
            : null);
    return WORKREQUESTMSTFluent<WorkRequestMst?>(
      future,
      query,
    );
  }

  WORKREQUESTMSTFluent<WorkRequestMst> findUniqueOrThrow(
      {required WORKREQUESTMSTWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueWORK_REQUEST_MSTOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueWORK_REQUEST_MSTOrThrow',
    );
    final future = query(WORKREQUESTMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? WorkRequestMst.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: WORK_REQUEST_MST)'));
    return WORKREQUESTMSTFluent<WorkRequestMst>(
      future,
      query,
    );
  }

  WORKREQUESTMSTFluent<WorkRequestMst?> findFirst({
    WORKREQUESTMSTWhereInput? where,
    Iterable<WORKREQUESTMSTOrderByWithRelationInput>? orderBy,
    WORKREQUESTMSTWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<WORKREQUESTMSTScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstWORK_REQUEST_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstWORK_REQUEST_MST',
    );
    final future = query(WORKREQUESTMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? WorkRequestMst.fromJson(json.cast<String, dynamic>())
            : null);
    return WORKREQUESTMSTFluent<WorkRequestMst?>(
      future,
      query,
    );
  }

  WORKREQUESTMSTFluent<WorkRequestMst> findFirstOrThrow({
    WORKREQUESTMSTWhereInput? where,
    Iterable<WORKREQUESTMSTOrderByWithRelationInput>? orderBy,
    WORKREQUESTMSTWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<WORKREQUESTMSTScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstWORK_REQUEST_MSTOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstWORK_REQUEST_MSTOrThrow',
    );
    final future = query(WORKREQUESTMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? WorkRequestMst.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: WORK_REQUEST_MST)'));
    return WORKREQUESTMSTFluent<WorkRequestMst>(
      future,
      query,
    );
  }

  Future<Iterable<WorkRequestMst>> findMany({
    WORKREQUESTMSTWhereInput? where,
    Iterable<WORKREQUESTMSTOrderByWithRelationInput>? orderBy,
    WORKREQUESTMSTWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<WORKREQUESTMSTScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyWORK_REQUEST_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyWORK_REQUEST_MST',
    );
    final fields = WORKREQUESTMSTScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyWORKREQUESTMST) =>
        findManyWORKREQUESTMST.map((Map findManyWORKREQUESTMST) =>
            WorkRequestMst.fromJson(findManyWORKREQUESTMST.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  WORKREQUESTMSTFluent<WorkRequestMst> create(
      {required WORKREQUESTMSTCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneWORK_REQUEST_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneWORK_REQUEST_MST',
    );
    final future = query(WORKREQUESTMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? WorkRequestMst.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: WORK_REQUEST_MST)'));
    return WORKREQUESTMSTFluent<WorkRequestMst>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<WORKREQUESTMSTCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyWORK_REQUEST_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyWORK_REQUEST_MST',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyWORKREQUESTMST) =>
        AffectedRowsOutput.fromJson(createManyWORKREQUESTMST.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  WORKREQUESTMSTFluent<WorkRequestMst?> update({
    required WORKREQUESTMSTUpdateInput data,
    required WORKREQUESTMSTWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneWORK_REQUEST_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneWORK_REQUEST_MST',
    );
    final future = query(WORKREQUESTMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? WorkRequestMst.fromJson(json.cast<String, dynamic>())
            : null);
    return WORKREQUESTMSTFluent<WorkRequestMst?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required WORKREQUESTMSTUpdateManyMutationInput data,
    WORKREQUESTMSTWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyWORK_REQUEST_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyWORK_REQUEST_MST',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyWORKREQUESTMST) =>
        AffectedRowsOutput.fromJson(updateManyWORKREQUESTMST.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  WORKREQUESTMSTFluent<WorkRequestMst> upsert({
    required WORKREQUESTMSTWhereUniqueInput where,
    required WORKREQUESTMSTCreateInput create,
    required WORKREQUESTMSTUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneWORK_REQUEST_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneWORK_REQUEST_MST',
    );
    final future = query(WORKREQUESTMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? WorkRequestMst.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: WORK_REQUEST_MST)'));
    return WORKREQUESTMSTFluent<WorkRequestMst>(
      future,
      query,
    );
  }

  WORKREQUESTMSTFluent<WorkRequestMst?> delete(
      {required WORKREQUESTMSTWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneWORK_REQUEST_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneWORK_REQUEST_MST',
    );
    final future = query(WORKREQUESTMSTScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? WorkRequestMst.fromJson(json.cast<String, dynamic>())
            : null);
    return WORKREQUESTMSTFluent<WorkRequestMst?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({WORKREQUESTMSTWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyWORK_REQUEST_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyWORK_REQUEST_MST',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyWORKREQUESTMST) =>
        AffectedRowsOutput.fromJson(deleteManyWORKREQUESTMST.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateWORKREQUESTMST aggregate({
    WORKREQUESTMSTWhereInput? where,
    Iterable<WORKREQUESTMSTOrderByWithRelationInput>? orderBy,
    WORKREQUESTMSTWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateWORK_REQUEST_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateWORK_REQUEST_MST',
    );
    return AggregateWORKREQUESTMST(query);
  }

  Future<Iterable<WORKREQUESTMSTGroupByOutputType>> groupBy({
    WORKREQUESTMSTWhereInput? where,
    Iterable<WORKREQUESTMSTOrderByWithAggregationInput>? orderBy,
    required Iterable<WORKREQUESTMSTScalarFieldEnum> by,
    WORKREQUESTMSTScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByWORK_REQUEST_MST',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByWORK_REQUEST_MST',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByWORKREQUESTMST) => groupByWORKREQUESTMST.map(
        (Map groupByWORKREQUESTMST) => WORKREQUESTMSTGroupByOutputType.fromJson(
            groupByWORKREQUESTMST.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

extension WORKREQUESTREFModelDelegateExtension
    on _i1.ModelDelegate<WorkRequestRef> {
  WORKREQUESTREFFluent<WorkRequestRef?> findUnique(
      {required WORKREQUESTREFWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueWORK_REQUEST_REF',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueWORK_REQUEST_REF',
    );
    final future = query(WORKREQUESTREFScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? WorkRequestRef.fromJson(json.cast<String, dynamic>())
            : null);
    return WORKREQUESTREFFluent<WorkRequestRef?>(
      future,
      query,
    );
  }

  WORKREQUESTREFFluent<WorkRequestRef> findUniqueOrThrow(
      {required WORKREQUESTREFWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findUniqueWORK_REQUEST_REFOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findUniqueWORK_REQUEST_REFOrThrow',
    );
    final future = query(WORKREQUESTREFScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? WorkRequestRef.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: WORK_REQUEST_REF)'));
    return WORKREQUESTREFFluent<WorkRequestRef>(
      future,
      query,
    );
  }

  WORKREQUESTREFFluent<WorkRequestRef?> findFirst({
    WORKREQUESTREFWhereInput? where,
    Iterable<WORKREQUESTREFOrderByWithRelationInput>? orderBy,
    WORKREQUESTREFWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<WORKREQUESTREFScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstWORK_REQUEST_REF',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstWORK_REQUEST_REF',
    );
    final future = query(WORKREQUESTREFScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? WorkRequestRef.fromJson(json.cast<String, dynamic>())
            : null);
    return WORKREQUESTREFFluent<WorkRequestRef?>(
      future,
      query,
    );
  }

  WORKREQUESTREFFluent<WorkRequestRef> findFirstOrThrow({
    WORKREQUESTREFWhereInput? where,
    Iterable<WORKREQUESTREFOrderByWithRelationInput>? orderBy,
    WORKREQUESTREFWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<WORKREQUESTREFScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findFirstWORK_REQUEST_REFOrThrow',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findFirstWORK_REQUEST_REFOrThrow',
    );
    final future = query(WORKREQUESTREFScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? WorkRequestRef.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: WORK_REQUEST_REF)'));
    return WORKREQUESTREFFluent<WorkRequestRef>(
      future,
      query,
    );
  }

  Future<Iterable<WorkRequestRef>> findMany({
    WORKREQUESTREFWhereInput? where,
    Iterable<WORKREQUESTREFOrderByWithRelationInput>? orderBy,
    WORKREQUESTREFWhereUniqueInput? cursor,
    int? take,
    int? skip,
    Iterable<WORKREQUESTREFScalarFieldEnum>? distinct,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
      _i2.GraphQLArg(
        r'distinct',
        distinct,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'findManyWORK_REQUEST_REF',
          fields: fields,
          args: args,
        )
      ]),
      key: r'findManyWORK_REQUEST_REF',
    );
    final fields = WORKREQUESTREFScalarFieldEnum.values.toGraphQLFields();
    compiler(Iterable<Map> findManyWORKREQUESTREF) =>
        findManyWORKREQUESTREF.map((Map findManyWORKREQUESTREF) =>
            WorkRequestRef.fromJson(findManyWORKREQUESTREF.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }

  WORKREQUESTREFFluent<WorkRequestRef> create(
      {required WORKREQUESTREFCreateInput data}) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createOneWORK_REQUEST_REF',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createOneWORK_REQUEST_REF',
    );
    final future = query(WORKREQUESTREFScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? WorkRequestRef.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: WORK_REQUEST_REF)'));
    return WORKREQUESTREFFluent<WorkRequestRef>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> createMany({
    required Iterable<WORKREQUESTREFCreateManyInput> data,
    bool? skipDuplicates,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'skipDuplicates',
        skipDuplicates,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'createManyWORK_REQUEST_REF',
          fields: fields,
          args: args,
        )
      ]),
      key: r'createManyWORK_REQUEST_REF',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map createManyWORKREQUESTREF) =>
        AffectedRowsOutput.fromJson(createManyWORKREQUESTREF.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  WORKREQUESTREFFluent<WorkRequestRef?> update({
    required WORKREQUESTREFUpdateInput data,
    required WORKREQUESTREFWhereUniqueInput where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateOneWORK_REQUEST_REF',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateOneWORK_REQUEST_REF',
    );
    final future = query(WORKREQUESTREFScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? WorkRequestRef.fromJson(json.cast<String, dynamic>())
            : null);
    return WORKREQUESTREFFluent<WorkRequestRef?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> updateMany({
    required WORKREQUESTREFUpdateManyMutationInput data,
    WORKREQUESTREFWhereInput? where,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'data',
        data,
      ),
      _i2.GraphQLArg(
        r'where',
        where,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'updateManyWORK_REQUEST_REF',
          fields: fields,
          args: args,
        )
      ]),
      key: r'updateManyWORK_REQUEST_REF',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map updateManyWORKREQUESTREF) =>
        AffectedRowsOutput.fromJson(updateManyWORKREQUESTREF.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  WORKREQUESTREFFluent<WorkRequestRef> upsert({
    required WORKREQUESTREFWhereUniqueInput where,
    required WORKREQUESTREFCreateInput create,
    required WORKREQUESTREFUpdateInput update,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'create',
        create,
      ),
      _i2.GraphQLArg(
        r'update',
        update,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'upsertOneWORK_REQUEST_REF',
          fields: fields,
          args: args,
        )
      ]),
      key: r'upsertOneWORK_REQUEST_REF',
    );
    final future = query(WORKREQUESTREFScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? WorkRequestRef.fromJson(json.cast<String, dynamic>())
            : throw Exception(
                'Not found OutputTypeRefType.string(value: WORK_REQUEST_REF)'));
    return WORKREQUESTREFFluent<WorkRequestRef>(
      future,
      query,
    );
  }

  WORKREQUESTREFFluent<WorkRequestRef?> delete(
      {required WORKREQUESTREFWhereUniqueInput where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteOneWORK_REQUEST_REF',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteOneWORK_REQUEST_REF',
    );
    final future = query(WORKREQUESTREFScalarFieldEnum.values.toGraphQLFields())
        .then((json) => json is Map
            ? WorkRequestRef.fromJson(json.cast<String, dynamic>())
            : null);
    return WORKREQUESTREFFluent<WorkRequestRef?>(
      future,
      query,
    );
  }

  Future<AffectedRowsOutput> deleteMany({WORKREQUESTREFWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $mutation([
        _i2.GraphQLField(
          r'deleteManyWORK_REQUEST_REF',
          fields: fields,
          args: args,
        )
      ]),
      key: r'deleteManyWORK_REQUEST_REF',
    );
    final fields = const ['count'].map((e) => _i2.GraphQLField(e));
    compiler(Map deleteManyWORKREQUESTREF) =>
        AffectedRowsOutput.fromJson(deleteManyWORKREQUESTREF.cast());
    return query(fields).then((json) => json is Map
        ? compiler(json)
        : throw Exception('Unable to parse response'));
  }

  AggregateWORKREQUESTREF aggregate({
    WORKREQUESTREFWhereInput? where,
    Iterable<WORKREQUESTREFOrderByWithRelationInput>? orderBy,
    WORKREQUESTREFWhereUniqueInput? cursor,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'cursor',
        cursor,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'aggregateWORK_REQUEST_REF',
          fields: fields,
          args: args,
        )
      ]),
      key: r'aggregateWORK_REQUEST_REF',
    );
    return AggregateWORKREQUESTREF(query);
  }

  Future<Iterable<WORKREQUESTREFGroupByOutputType>> groupBy({
    WORKREQUESTREFWhereInput? where,
    Iterable<WORKREQUESTREFOrderByWithAggregationInput>? orderBy,
    required Iterable<WORKREQUESTREFScalarFieldEnum> by,
    WORKREQUESTREFScalarWhereWithAggregatesInput? having,
    int? take,
    int? skip,
  }) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      ),
      _i2.GraphQLArg(
        r'orderBy',
        orderBy,
      ),
      _i2.GraphQLArg(
        r'by',
        by,
      ),
      _i2.GraphQLArg(
        r'having',
        having,
      ),
      _i2.GraphQLArg(
        r'take',
        take,
      ),
      _i2.GraphQLArg(
        r'skip',
        skip,
      ),
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'groupByWORK_REQUEST_REF',
          fields: fields,
          args: args,
        )
      ]),
      key: r'groupByWORK_REQUEST_REF',
    );
    final fields = by.map((e) => _i2.GraphQLField(e.originalName ?? e.name));
    compiler(Iterable<Map> groupByWORKREQUESTREF) => groupByWORKREQUESTREF.map(
        (Map groupByWORKREQUESTREF) => WORKREQUESTREFGroupByOutputType.fromJson(
            groupByWORKREQUESTREF.cast()));
    return query(fields).then((json) => json is Iterable
        ? compiler(json.cast())
        : throw Exception('Unable to parse response'));
  }
}

@_i1.jsonSerializable
class ALLCODETBLGroupByOutputType implements _i1.JsonSerializable {
  const ALLCODETBLGroupByOutputType({
    this.codeType,
    this.codeName,
    this.unitType,
    this.unitName,
    this.sort,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory ALLCODETBLGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$ALLCODETBLGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'CODE_TYPE')
  final String? codeType;

  @JsonKey(name: r'CODE_NAME')
  final String? codeName;

  @JsonKey(name: r'UNIT_TYPE')
  final String? unitType;

  @JsonKey(name: r'UNIT_NAME')
  final String? unitName;

  @JsonKey(name: r'SORT')
  final int? sort;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() => _$ALLCODETBLGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class APPROVALATTACHFILETBLGroupByOutputType implements _i1.JsonSerializable {
  const APPROVALATTACHFILETBLGroupByOutputType({
    this.approvalId,
    this.seq,
    this.oriFileNm,
    this.saveFileNm,
    this.fileSize,
    this.regDate,
  });

  factory APPROVALATTACHFILETBLGroupByOutputType.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALATTACHFILETBLGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final String? approvalId;

  @JsonKey(name: r'SEQ')
  final double? seq;

  @JsonKey(name: r'ORI_FILE_NM')
  final String? oriFileNm;

  @JsonKey(name: r'SAVE_FILE_NM')
  final String? saveFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final int? fileSize;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALATTACHFILETBLGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class APPROVALDOCINFOTBLGroupByOutputType implements _i1.JsonSerializable {
  const APPROVALDOCINFOTBLGroupByOutputType({
    this.seq,
    this.docType,
    this.docNm,
    this.title,
    this.approvalLineType,
    this.approvalLineContent,
    this.approvalLineContentBak,
    this.content,
    this.writerId,
    this.userNm,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
  });

  factory APPROVALDOCINFOTBLGroupByOutputType.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALDOCINFOTBLGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'DOC_TYPE')
  final String? docType;

  @JsonKey(name: r'DOC_NM')
  final String? docNm;

  @JsonKey(name: r'TITLE')
  final String? title;

  @JsonKey(name: r'APPROVAL_LINE_TYPE')
  final String? approvalLineType;

  @JsonKey(name: r'APPROVAL_LINE_CONTENT')
  final String? approvalLineContent;

  @JsonKey(name: r'APPROVAL_LINE_CONTENT_BAK')
  final String? approvalLineContentBak;

  @JsonKey(name: r'CONTENT')
  final String? content;

  @JsonKey(name: r'WRITER_ID')
  final String? writerId;

  @JsonKey(name: r'USER_NM')
  final String? userNm;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALDOCINFOTBLGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class APPROVALHISTORYTBLGroupByOutputType implements _i1.JsonSerializable {
  const APPROVALHISTORYTBLGroupByOutputType({
    this.seq,
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.docType,
    this.keepPriod,
    this.keepDate,
    this.grade,
    this.status,
    this.content,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALHISTORYTBLGroupByOutputType.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALHISTORYTBLGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'APPROVAL_ID')
  final String? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final String? writerId;

  @JsonKey(name: r'WRITER_NM')
  final String? writerNm;

  @JsonKey(name: r'DOC_TYPE')
  final String? docType;

  @JsonKey(name: r'KEEP_PRIOD')
  final int? keepPriod;

  @JsonKey(name: r'KEEP_DATE')
  final DateTime? keepDate;

  @JsonKey(name: r'GRADE')
  final String? grade;

  @JsonKey(name: r'STATUS')
  final String? status;

  @JsonKey(name: r'CONTENT')
  final String? content;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALHISTORYTBLGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class APPROVALMASTERTBLGroupByOutputType implements _i1.JsonSerializable {
  const APPROVALMASTERTBLGroupByOutputType({
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.docType,
    this.keepPriod,
    this.keepDate,
    this.grade,
    this.status,
    this.title,
    this.header,
    this.content,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
    this.regDate,
    this.completeDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALMASTERTBLGroupByOutputType.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALMASTERTBLGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final String? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final String? writerId;

  @JsonKey(name: r'WRITER_NM')
  final String? writerNm;

  @JsonKey(name: r'DOC_TYPE')
  final String? docType;

  @JsonKey(name: r'KEEP_PRIOD')
  final int? keepPriod;

  @JsonKey(name: r'KEEP_DATE')
  final DateTime? keepDate;

  @JsonKey(name: r'GRADE')
  final String? grade;

  @JsonKey(name: r'STATUS')
  final String? status;

  @JsonKey(name: r'TITLE')
  final String? title;

  @JsonKey(name: r'HEADER')
  final String? header;

  @JsonKey(name: r'CONTENT')
  final String? content;

  @JsonKey(name: r'M1')
  final double? m1;

  @JsonKey(name: r'M2')
  final double? m2;

  @JsonKey(name: r'M3')
  final double? m3;

  @JsonKey(name: r'M4')
  final double? m4;

  @JsonKey(name: r'M5')
  final double? m5;

  @JsonKey(name: r'M6')
  final double? m6;

  @JsonKey(name: r'M7')
  final double? m7;

  @JsonKey(name: r'M8')
  final double? m8;

  @JsonKey(name: r'M9')
  final double? m9;

  @JsonKey(name: r'M10')
  final double? m10;

  @JsonKey(name: r'M11')
  final double? m11;

  @JsonKey(name: r'M12')
  final double? m12;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'COMPLETE_DATE')
  final DateTime? completeDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALMASTERTBLGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class APPROVALMEMOTBLGroupByOutputType implements _i1.JsonSerializable {
  const APPROVALMEMOTBLGroupByOutputType({
    this.seq,
    this.approvalId,
    this.writerId,
    this.writerNm,
    this.content,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALMEMOTBLGroupByOutputType.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALMEMOTBLGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'APPROVAL_ID')
  final String? approvalId;

  @JsonKey(name: r'WRITER_ID')
  final String? writerId;

  @JsonKey(name: r'WRITER_NM')
  final String? writerNm;

  @JsonKey(name: r'CONTENT')
  final String? content;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALMEMOTBLGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class APPROVALTYPETBLGroupByOutputType implements _i1.JsonSerializable {
  const APPROVALTYPETBLGroupByOutputType({
    this.type,
    this.content,
    this.contentBak,
    this.useYn,
    this.delYn,
  });

  factory APPROVALTYPETBLGroupByOutputType.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALTYPETBLGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'TYPE')
  final String? type;

  @JsonKey(name: r'CONTENT')
  final String? content;

  @JsonKey(name: r'CONTENT_BAK')
  final String? contentBak;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALTYPETBLGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class APPROVALUSERTBLGroupByOutputType implements _i1.JsonSerializable {
  const APPROVALUSERTBLGroupByOutputType({
    this.approvalId,
    this.approvalUsrId,
    this.approvalUsrGradeCd,
    this.approvalUsrType,
    this.approvalUsrSort,
    this.approvalProcUserYn,
    this.approvalProcYn,
    this.approvalProcDate,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory APPROVALUSERTBLGroupByOutputType.fromJson(
          Map<String, dynamic> json) =>
      _$APPROVALUSERTBLGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'APPROVAL_ID')
  final String? approvalId;

  @JsonKey(name: r'APPROVAL_USR_ID')
  final String? approvalUsrId;

  @JsonKey(name: r'APPROVAL_USR_GRADE_CD')
  final String? approvalUsrGradeCd;

  @JsonKey(name: r'APPROVAL_USR_TYPE')
  final String? approvalUsrType;

  @JsonKey(name: r'APPROVAL_USR_SORT')
  final int? approvalUsrSort;

  @JsonKey(name: r'APPROVAL_PROC_USER_YN')
  final String? approvalProcUserYn;

  @JsonKey(name: r'APPROVAL_PROC_YN')
  final String? approvalProcYn;

  @JsonKey(name: r'APPROVAL_PROC_DATE')
  final DateTime? approvalProcDate;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$APPROVALUSERTBLGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class BOOKASSETTBLGroupByOutputType implements _i1.JsonSerializable {
  const BOOKASSETTBLGroupByOutputType({
    this.seq,
    this.assetNo,
    this.bookNm,
    this.cnt,
    this.publisher,
    this.amount,
    this.buyDate,
    this.mngDept,
    this.rentYn,
    this.rentUser,
    this.remarks,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory BOOKASSETTBLGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$BOOKASSETTBLGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'ASSET_NO')
  final String? assetNo;

  @JsonKey(name: r'BOOK_NM')
  final String? bookNm;

  @JsonKey(name: r'CNT')
  final int? cnt;

  @JsonKey(name: r'PUBLISHER')
  final String? publisher;

  @JsonKey(name: r'AMOUNT')
  final int? amount;

  @JsonKey(name: r'BUY_DATE')
  final String? buyDate;

  @JsonKey(name: r'MNG_DEPT')
  final String? mngDept;

  @JsonKey(name: r'RENT_YN')
  final String? rentYn;

  @JsonKey(name: r'RENT_USER')
  final String? rentUser;

  @JsonKey(name: r'REMARKS')
  final String? remarks;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() => _$BOOKASSETTBLGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class CARASSETINSURTBLGroupByOutputType implements _i1.JsonSerializable {
  const CARASSETINSURTBLGroupByOutputType({
    this.seq,
    this.mseq,
    this.guarantee,
  });

  factory CARASSETINSURTBLGroupByOutputType.fromJson(
          Map<String, dynamic> json) =>
      _$CARASSETINSURTBLGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'MSEQ')
  final BigInt? mseq;

  @JsonKey(name: r'GUARANTEE')
  final String? guarantee;

  @override
  Map<String, dynamic> toJson() =>
      _$CARASSETINSURTBLGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class CARASSETTBLGroupByOutputType implements _i1.JsonSerializable {
  const CARASSETTBLGroupByOutputType({
    this.seq,
    this.assetNo,
    this.modelNo,
    this.carNo,
    this.owner,
    this.ownerType,
    this.amount,
    this.buyDate,
    this.seller,
    this.remarks,
    this.mngrNm,
    this.fuel,
    this.manuDt,
    this.effic,
    this.insur,
    this.insurMngr,
    this.emgTel,
    this.storeNm,
    this.storeTel,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory CARASSETTBLGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$CARASSETTBLGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'ASSET_NO')
  final String? assetNo;

  @JsonKey(name: r'MODEL_NO')
  final String? modelNo;

  @JsonKey(name: r'CAR_NO')
  final String? carNo;

  @JsonKey(name: r'OWNER')
  final String? owner;

  @JsonKey(name: r'OWNER_TYPE')
  final String? ownerType;

  @JsonKey(name: r'AMOUNT')
  final int? amount;

  @JsonKey(name: r'BUY_DATE')
  final String? buyDate;

  @JsonKey(name: r'SELLER')
  final String? seller;

  @JsonKey(name: r'REMARKS')
  final String? remarks;

  @JsonKey(name: r'MNGR_NM')
  final String? mngrNm;

  @JsonKey(name: r'FUEL')
  final String? fuel;

  @JsonKey(name: r'MANU_DT')
  final String? manuDt;

  @JsonKey(name: r'EFFIC')
  final String? effic;

  @JsonKey(name: r'INSUR')
  final String? insur;

  @JsonKey(name: r'INSUR_MNGR')
  final String? insurMngr;

  @JsonKey(name: r'EMG_TEL')
  final String? emgTel;

  @JsonKey(name: r'STORE_NM')
  final String? storeNm;

  @JsonKey(name: r'STORE_TEL')
  final String? storeTel;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() => _$CARASSETTBLGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class CARCHARGETBLGroupByOutputType implements _i1.JsonSerializable {
  const CARCHARGETBLGroupByOutputType({
    this.seq,
    this.item,
    this.charge,
    this.writerId,
    this.memo,
    this.regDate,
  });

  factory CARCHARGETBLGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$CARCHARGETBLGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'ITEM')
  final String? item;

  @JsonKey(name: r'CHARGE')
  final BigInt? charge;

  @JsonKey(name: r'WRITER_ID')
  final String? writerId;

  @JsonKey(name: r'MEMO')
  final String? memo;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @override
  Map<String, dynamic> toJson() => _$CARCHARGETBLGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class CARINFOTBLGroupByOutputType implements _i1.JsonSerializable {
  const CARINFOTBLGroupByOutputType({
    this.sort,
    this.carManageNo,
    this.model,
    this.userId,
    this.regDate,
    this.disusedYn,
  });

  factory CARINFOTBLGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$CARINFOTBLGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'SORT')
  final BigInt? sort;

  @JsonKey(name: r'CAR_MANAGE_NO')
  final String? carManageNo;

  @JsonKey(name: r'MODEL')
  final String? model;

  @JsonKey(name: r'USER_ID')
  final String? userId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'DISUSED_YN')
  final String? disusedYn;

  @override
  Map<String, dynamic> toJson() => _$CARINFOTBLGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class CARMILEAGETBLGroupByOutputType implements _i1.JsonSerializable {
  const CARMILEAGETBLGroupByOutputType({
    this.seq,
    this.carManageNo,
    this.forUse,
    this.stPoint,
    this.destination,
    this.mileage,
    this.totalMileage,
    this.recordDate,
    this.writerId,
    this.editorId,
    this.regDate,
    this.apprYn,
  });

  factory CARMILEAGETBLGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$CARMILEAGETBLGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'CAR_MANAGE_NO')
  final String? carManageNo;

  @JsonKey(name: r'FOR_USE')
  final String? forUse;

  @JsonKey(name: r'ST_POINT')
  final String? stPoint;

  @JsonKey(name: r'DESTINATION')
  final String? destination;

  @JsonKey(name: r'MILEAGE')
  final BigInt? mileage;

  @JsonKey(name: r'TOTAL_MILEAGE')
  final BigInt? totalMileage;

  @JsonKey(name: r'RECORD_DATE')
  final String? recordDate;

  @JsonKey(name: r'WRITER_ID')
  final String? writerId;

  @JsonKey(name: r'EDITOR_ID')
  final String? editorId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'APPR_YN')
  final String? apprYn;

  @override
  Map<String, dynamic> toJson() => _$CARMILEAGETBLGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class CARPARTREPLACETBLGroupByOutputType implements _i1.JsonSerializable {
  const CARPARTREPLACETBLGroupByOutputType({
    this.seq,
    this.partNm,
    this.replacePeriod,
    this.reTotalMileage,
    this.nowTotalMileage,
    this.remainMileage,
    this.replaceCount,
    this.partReDate,
    this.writerId,
    this.regDate,
  });

  factory CARPARTREPLACETBLGroupByOutputType.fromJson(
          Map<String, dynamic> json) =>
      _$CARPARTREPLACETBLGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'PART_NM')
  final String? partNm;

  @JsonKey(name: r'REPLACE_PERIOD')
  final BigInt? replacePeriod;

  @JsonKey(name: r'RE_TOTAL_MILEAGE')
  final BigInt? reTotalMileage;

  @JsonKey(name: r'NOW_TOTAL_MILEAGE')
  final BigInt? nowTotalMileage;

  @JsonKey(name: r'REMAIN_MILEAGE')
  final BigInt? remainMileage;

  @JsonKey(name: r'REPLACE_COUNT')
  final BigInt? replaceCount;

  @JsonKey(name: r'PART_RE_DATE')
  final String? partReDate;

  @JsonKey(name: r'WRITER_ID')
  final String? writerId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @override
  Map<String, dynamic> toJson() =>
      _$CARPARTREPLACETBLGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class CARREPAIRLOGGroupByOutputType implements _i1.JsonSerializable {
  const CARREPAIRLOGGroupByOutputType({
    this.seq,
    this.mseq,
    this.assetNo,
    this.repairDe,
    this.repairAmount,
    this.repairStore,
    this.repairLog,
    this.repairOwner,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory CARREPAIRLOGGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$CARREPAIRLOGGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'MSEQ')
  final BigInt? mseq;

  @JsonKey(name: r'ASSET_NO')
  final String? assetNo;

  @JsonKey(name: r'REPAIR_DE')
  final String? repairDe;

  @JsonKey(name: r'REPAIR_AMOUNT')
  final String? repairAmount;

  @JsonKey(name: r'REPAIR_STORE')
  final String? repairStore;

  @JsonKey(name: r'REPAIR_LOG')
  final String? repairLog;

  @JsonKey(name: r'REPAIR_OWNER')
  final String? repairOwner;

  @JsonKey(name: r'FILE_TP')
  final String? fileTp;

  @JsonKey(name: r'FLPTH')
  final String? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final String? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final String? streFileNm;

  @JsonKey(name: r'REG_ID')
  final String? regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$CARREPAIRLOGGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class CARUSEMANAGETBLGroupByOutputType implements _i1.JsonSerializable {
  const CARUSEMANAGETBLGroupByOutputType({
    this.seq,
    this.carNo,
    this.carType,
    this.destination,
    this.purpose,
    this.users,
    this.useStartDate,
    this.useEndDate,
    this.useBeforeDistance,
    this.useAfterDistance,
    this.remarks,
    this.acceptYn,
    this.regUser,
    this.regDate,
    this.useStartHour,
    this.useEndHour,
    this.cardApply,
  });

  factory CARUSEMANAGETBLGroupByOutputType.fromJson(
          Map<String, dynamic> json) =>
      _$CARUSEMANAGETBLGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'CAR_NO')
  final String? carNo;

  @JsonKey(name: r'CAR_TYPE')
  final String? carType;

  @JsonKey(name: r'DESTINATION')
  final String? destination;

  @JsonKey(name: r'PURPOSE')
  final String? purpose;

  @JsonKey(name: r'USERS')
  final String? users;

  @JsonKey(name: r'USE_START_DATE')
  final DateTime? useStartDate;

  @JsonKey(name: r'USE_END_DATE')
  final DateTime? useEndDate;

  @JsonKey(name: r'USE_BEFORE_DISTANCE')
  final double? useBeforeDistance;

  @JsonKey(name: r'USE_AFTER_DISTANCE')
  final double? useAfterDistance;

  @JsonKey(name: r'REMARKS')
  final String? remarks;

  @JsonKey(name: r'ACCEPT_YN')
  final String? acceptYn;

  @JsonKey(name: r'REG_USER')
  final String? regUser;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'USE_START_HOUR')
  final String? useStartHour;

  @JsonKey(name: r'USE_END_HOUR')
  final String? useEndHour;

  @JsonKey(name: r'CARD_APPLY')
  final String? cardApply;

  @override
  Map<String, dynamic> toJson() =>
      _$CARUSEMANAGETBLGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class HOLIDAYTBLGroupByOutputType implements _i1.JsonSerializable {
  const HOLIDAYTBLGroupByOutputType({
    this.userId,
    this.stdYear,
    this.m1,
    this.m2,
    this.m3,
    this.m4,
    this.m5,
    this.m6,
    this.m7,
    this.m8,
    this.m9,
    this.m10,
    this.m11,
    this.m12,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory HOLIDAYTBLGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$HOLIDAYTBLGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'USER_ID')
  final String? userId;

  @JsonKey(name: r'STD_YEAR')
  final String? stdYear;

  @JsonKey(name: r'M1')
  final double? m1;

  @JsonKey(name: r'M2')
  final double? m2;

  @JsonKey(name: r'M3')
  final double? m3;

  @JsonKey(name: r'M4')
  final double? m4;

  @JsonKey(name: r'M5')
  final double? m5;

  @JsonKey(name: r'M6')
  final double? m6;

  @JsonKey(name: r'M7')
  final double? m7;

  @JsonKey(name: r'M8')
  final double? m8;

  @JsonKey(name: r'M9')
  final double? m9;

  @JsonKey(name: r'M10')
  final double? m10;

  @JsonKey(name: r'M11')
  final double? m11;

  @JsonKey(name: r'M12')
  final double? m12;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() => _$HOLIDAYTBLGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class MEMBERTBLGroupByOutputType implements _i1.JsonSerializable {
  const MEMBERTBLGroupByOutputType({
    this.userId,
    this.passwd,
    this.userNm,
    this.dept,
    this.grade,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
    this.lastLoginDate,
    this.memo,
  });

  factory MEMBERTBLGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$MEMBERTBLGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'USER_ID')
  final String? userId;

  @JsonKey(name: r'PASSWD')
  final String? passwd;

  @JsonKey(name: r'USER_NM')
  final String? userNm;

  @JsonKey(name: r'DEPT')
  final String? dept;

  @JsonKey(name: r'GRADE')
  final String? grade;

  @JsonKey(name: r'JOIN_DATE')
  final DateTime? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final DateTime? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final DateTime? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final int? pwdWrongCnt;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'LAST_LOGIN_DATE')
  final DateTime? lastLoginDate;

  @JsonKey(name: r'MEMO')
  final String? memo;

  @override
  Map<String, dynamic> toJson() => _$MEMBERTBLGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class MENUAUTHTBLGroupByOutputType implements _i1.JsonSerializable {
  const MENUAUTHTBLGroupByOutputType({
    this.userId,
    this.menuId,
    this.readYn,
    this.writeYn,
    this.regId,
    this.updId,
    this.regDate,
    this.updDate,
  });

  factory MENUAUTHTBLGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$MENUAUTHTBLGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'USER_ID')
  final String? userId;

  @JsonKey(name: r'MENU_ID')
  final String? menuId;

  @JsonKey(name: r'READ_YN')
  final String? readYn;

  @JsonKey(name: r'WRITE_YN')
  final String? writeYn;

  @JsonKey(name: r'REG_ID')
  final String? regId;

  @JsonKey(name: r'UPD_ID')
  final String? updId;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() => _$MENUAUTHTBLGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class MENUTBLGroupByOutputType implements _i1.JsonSerializable {
  const MENUTBLGroupByOutputType({
    this.menuId,
    this.menuNm,
    this.depth,
    this.sort,
    this.ownerId,
    this.url,
    this.writerId,
    this.regDate,
    this.updDate,
    this.useYn,
    this.delYn,
    this.dispYn,
    this.menuIcon,
  });

  factory MENUTBLGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$MENUTBLGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'MENU_ID')
  final String? menuId;

  @JsonKey(name: r'MENU_NM')
  final String? menuNm;

  @JsonKey(name: r'DEPTH')
  final int? depth;

  @JsonKey(name: r'SORT')
  final int? sort;

  @JsonKey(name: r'OWNER_ID')
  final String? ownerId;

  @JsonKey(name: r'URL')
  final String? url;

  @JsonKey(name: r'WRITER_ID')
  final String? writerId;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'DISP_YN')
  final String? dispYn;

  @JsonKey(name: r'MENU_ICON')
  final String? menuIcon;

  @override
  Map<String, dynamic> toJson() => _$MENUTBLGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class OFFICEASSETTBLGroupByOutputType implements _i1.JsonSerializable {
  const OFFICEASSETTBLGroupByOutputType({
    this.seq,
    this.assetNo,
    this.assetType,
    this.seller,
    this.buyDate,
    this.modelNo,
    this.serialNo,
    this.amount,
    this.keepYear,
    this.mngDept,
    this.assetAccount,
    this.remarks,
    this.carryOut,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory OFFICEASSETTBLGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$OFFICEASSETTBLGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'ASSET_NO')
  final String? assetNo;

  @JsonKey(name: r'ASSET_TYPE')
  final String? assetType;

  @JsonKey(name: r'SELLER')
  final String? seller;

  @JsonKey(name: r'BUY_DATE')
  final String? buyDate;

  @JsonKey(name: r'MODEL_NO')
  final String? modelNo;

  @JsonKey(name: r'SERIAL_NO')
  final String? serialNo;

  @JsonKey(name: r'AMOUNT')
  final int? amount;

  @JsonKey(name: r'KEEP_YEAR')
  final double? keepYear;

  @JsonKey(name: r'MNG_DEPT')
  final String? mngDept;

  @JsonKey(name: r'ASSET_ACCOUNT')
  final String? assetAccount;

  @JsonKey(name: r'REMARKS')
  final String? remarks;

  @JsonKey(name: r'CARRY_OUT')
  final String? carryOut;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$OFFICEASSETTBLGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class SERVERASSETTBLGroupByOutputType implements _i1.JsonSerializable {
  const SERVERASSETTBLGroupByOutputType({
    this.seq,
    this.assetNo,
    this.assetType,
    this.maker,
    this.cnt,
    this.amount,
    this.buyDate,
    this.seller,
    this.modelNo,
    this.serialNo,
    this.hostname,
    this.builtLoc,
    this.useDesc,
    this.osInfo,
    this.cpuInfo,
    this.ramInfo,
    this.hddInfo,
    this.ssdInfo,
    this.odd,
    this.remarks,
    this.carryOut,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory SERVERASSETTBLGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$SERVERASSETTBLGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'ASSET_NO')
  final String? assetNo;

  @JsonKey(name: r'ASSET_TYPE')
  final String? assetType;

  @JsonKey(name: r'MAKER')
  final String? maker;

  @JsonKey(name: r'CNT')
  final double? cnt;

  @JsonKey(name: r'AMOUNT')
  final int? amount;

  @JsonKey(name: r'BUY_DATE')
  final String? buyDate;

  @JsonKey(name: r'SELLER')
  final String? seller;

  @JsonKey(name: r'MODEL_NO')
  final String? modelNo;

  @JsonKey(name: r'SERIAL_NO')
  final String? serialNo;

  @JsonKey(name: r'HOSTNAME')
  final String? hostname;

  @JsonKey(name: r'BUILT_LOC')
  final String? builtLoc;

  @JsonKey(name: r'USE_DESC')
  final String? useDesc;

  @JsonKey(name: r'OS_INFO')
  final String? osInfo;

  @JsonKey(name: r'CPU_INFO')
  final String? cpuInfo;

  @JsonKey(name: r'RAM_INFO')
  final String? ramInfo;

  @JsonKey(name: r'HDD_INFO')
  final String? hddInfo;

  @JsonKey(name: r'SSD_INFO')
  final String? ssdInfo;

  @JsonKey(name: r'ODD')
  final String? odd;

  @JsonKey(name: r'REMARKS')
  final String? remarks;

  @JsonKey(name: r'CARRY_OUT')
  final String? carryOut;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$SERVERASSETTBLGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class SOFTWAREASSETTBLGroupByOutputType implements _i1.JsonSerializable {
  const SOFTWAREASSETTBLGroupByOutputType({
    this.seq,
    this.assetNo,
    this.softwareNm,
    this.versionNm,
    this.cnt,
    this.amount,
    this.buyDate,
    this.serialNo,
    this.licenseNo,
    this.userNm,
    this.remarks,
    this.useYn,
    this.delYn,
    this.regDate,
    this.updDate,
  });

  factory SOFTWAREASSETTBLGroupByOutputType.fromJson(
          Map<String, dynamic> json) =>
      _$SOFTWAREASSETTBLGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'ASSET_NO')
  final String? assetNo;

  @JsonKey(name: r'SOFTWARE_NM')
  final String? softwareNm;

  @JsonKey(name: r'VERSION_NM')
  final String? versionNm;

  @JsonKey(name: r'CNT')
  final double? cnt;

  @JsonKey(name: r'AMOUNT')
  final int? amount;

  @JsonKey(name: r'BUY_DATE')
  final String? buyDate;

  @JsonKey(name: r'SERIAL_NO')
  final String? serialNo;

  @JsonKey(name: r'LICENSE_NO')
  final String? licenseNo;

  @JsonKey(name: r'USER_NM')
  final String? userNm;

  @JsonKey(name: r'REMARKS')
  final String? remarks;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @override
  Map<String, dynamic> toJson() =>
      _$SOFTWAREASSETTBLGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class STADMINMENUGroupByOutputType implements _i1.JsonSerializable {
  const STADMINMENUGroupByOutputType({
    this.menuCd,
    this.menuNm,
    this.menuPath,
    this.menuSrt,
    this.menuDeps,
    this.menuIcon,
    this.menuTp,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STADMINMENUGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$STADMINMENUGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'MENU_CD')
  final String? menuCd;

  @JsonKey(name: r'MENU_NM')
  final String? menuNm;

  @JsonKey(name: r'MENU_PATH')
  final String? menuPath;

  @JsonKey(name: r'MENU_SRT')
  final int? menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final int? menuDeps;

  @JsonKey(name: r'MENU_ICON')
  final String? menuIcon;

  @JsonKey(name: r'MENU_TP')
  final String? menuTp;

  @JsonKey(name: r'REG_ID')
  final String? regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STADMINMENUGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class STALARMGroupByOutputType implements _i1.JsonSerializable {
  const STALARMGroupByOutputType({
    this.seq,
    this.msgCd,
    this.msgCnts,
    this.sendDate,
    this.sendDiv,
    this.sendDeptCd,
    this.sendId,
    this.recvId,
    this.popYn,
    this.editId,
    this.editDate,
  });

  factory STALARMGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$STALARMGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'SEQ')
  final int? seq;

  @JsonKey(name: r'MSG_CD')
  final String? msgCd;

  @JsonKey(name: r'MSG_CNTS')
  final String? msgCnts;

  @JsonKey(name: r'SEND_DATE')
  final String? sendDate;

  @JsonKey(name: r'SEND_DIV')
  final String? sendDiv;

  @JsonKey(name: r'SEND_DEPT_CD')
  final String? sendDeptCd;

  @JsonKey(name: r'SEND_ID')
  final String? sendId;

  @JsonKey(name: r'RECV_ID')
  final String? recvId;

  @JsonKey(name: r'POP_YN')
  final String? popYn;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @override
  Map<String, dynamic> toJson() => _$STALARMGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class STAUDITLOGGroupByOutputType implements _i1.JsonSerializable {
  const STAUDITLOGGroupByOutputType({
    this.seq,
    this.logCode,
    this.logCnts,
    this.errCode,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STAUDITLOGGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$STAUDITLOGGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'SEQ')
  final int? seq;

  @JsonKey(name: r'LOG_CODE')
  final String? logCode;

  @JsonKey(name: r'LOG_CNTS')
  final String? logCnts;

  @JsonKey(name: r'ERR_CODE')
  final String? errCode;

  @JsonKey(name: r'REG_ID')
  final String? regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STAUDITLOGGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class STBANNERGroupByOutputType implements _i1.JsonSerializable {
  const STBANNERGroupByOutputType({
    this.bannerCd,
    this.lkUrl,
    this.lkTarget,
    this.flpth,
    this.fileNm,
    this.useYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBANNERGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$STBANNERGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'BANNER_CD')
  final String? bannerCd;

  @JsonKey(name: r'LK_URL')
  final String? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final String? lkTarget;

  @JsonKey(name: r'FLPTH')
  final String? flpth;

  @JsonKey(name: r'FILE_NM')
  final String? fileNm;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'REG_ID')
  final String? regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STBANNERGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNGroupByOutputType implements _i1.JsonSerializable {
  const STBOARDCOLUMNGroupByOutputType({
    this.boardCd,
    this.sort,
    this.colCd,
    this.colNm,
    this.regId,
    this.regDate,
  });

  factory STBOARDCOLUMNGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$STBOARDCOLUMNGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'BOARD_CD')
  final String? boardCd;

  @JsonKey(name: r'SORT')
  final int? sort;

  @JsonKey(name: r'COL_CD')
  final String? colCd;

  @JsonKey(name: r'COL_NM')
  final String? colNm;

  @JsonKey(name: r'REG_ID')
  final String? regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @override
  Map<String, dynamic> toJson() => _$STBOARDCOLUMNGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOLUMNDFTGroupByOutputType implements _i1.JsonSerializable {
  const STBOARDCOLUMNDFTGroupByOutputType({
    this.boardTy,
    this.sort,
    this.colCd,
    this.colNm,
    this.editId,
    this.editDate,
    this.delYn,
  });

  factory STBOARDCOLUMNDFTGroupByOutputType.fromJson(
          Map<String, dynamic> json) =>
      _$STBOARDCOLUMNDFTGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'BOARD_TY')
  final String? boardTy;

  @JsonKey(name: r'SORT')
  final int? sort;

  @JsonKey(name: r'COL_CD')
  final String? colCd;

  @JsonKey(name: r'COL_NM')
  final String? colNm;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOLUMNDFTGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class STBOARDCOMMENTGroupByOutputType implements _i1.JsonSerializable {
  const STBOARDCOMMENTGroupByOutputType({
    this.seq,
    this.mseq,
    this.boardCd,
    this.cnts,
    this.upperSeq,
    this.replyYn,
    this.regAdminYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDCOMMENTGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$STBOARDCOMMENTGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'SEQ')
  final int? seq;

  @JsonKey(name: r'MSEQ')
  final int? mseq;

  @JsonKey(name: r'BOARD_CD')
  final String? boardCd;

  @JsonKey(name: r'CNTS')
  final String? cnts;

  @JsonKey(name: r'UPPER_SEQ')
  final int? upperSeq;

  @JsonKey(name: r'REPLY_YN')
  final String? replyYn;

  @JsonKey(name: r'REG_ADMIN_YN')
  final String? regAdminYn;

  @JsonKey(name: r'REG_ID')
  final String? regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STBOARDCOMMENTGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class STBOARDFILEGroupByOutputType implements _i1.JsonSerializable {
  const STBOARDFILEGroupByOutputType({
    this.seq,
    this.mseq,
    this.boardCd,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileSize,
    this.repreYn,
    this.dwldCo,
  });

  factory STBOARDFILEGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$STBOARDFILEGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'SEQ')
  final int? seq;

  @JsonKey(name: r'MSEQ')
  final int? mseq;

  @JsonKey(name: r'BOARD_CD')
  final String? boardCd;

  @JsonKey(name: r'FILE_TP')
  final String? fileTp;

  @JsonKey(name: r'FLPTH')
  final String? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final String? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final String? streFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final int? fileSize;

  @JsonKey(name: r'REPRE_YN')
  final String? repreYn;

  @JsonKey(name: r'DWLD_CO')
  final int? dwldCo;

  @override
  Map<String, dynamic> toJson() => _$STBOARDFILEGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class STBOARDMSTGroupByOutputType implements _i1.JsonSerializable {
  const STBOARDMSTGroupByOutputType({
    this.seq,
    this.boardCd,
    this.clsCd,
    this.ttl,
    this.cnts,
    this.fileYn,
    this.imageYn,
    this.noticeYn,
    this.lkUrl,
    this.lkTarget,
    this.readCnt,
    this.regAdminYn,
    this.replyYn,
    this.upperSeq,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDMSTGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$STBOARDMSTGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'SEQ')
  final int? seq;

  @JsonKey(name: r'BOARD_CD')
  final String? boardCd;

  @JsonKey(name: r'CLS_CD')
  final String? clsCd;

  @JsonKey(name: r'TTL')
  final String? ttl;

  @JsonKey(name: r'CNTS')
  final String? cnts;

  @JsonKey(name: r'FILE_YN')
  final String? fileYn;

  @JsonKey(name: r'IMAGE_YN')
  final String? imageYn;

  @JsonKey(name: r'NOTICE_YN')
  final String? noticeYn;

  @JsonKey(name: r'LK_URL')
  final String? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final String? lkTarget;

  @JsonKey(name: r'READ_CNT')
  final int? readCnt;

  @JsonKey(name: r'REG_ADMIN_YN')
  final String? regAdminYn;

  @JsonKey(name: r'REPLY_YN')
  final String? replyYn;

  @JsonKey(name: r'UPPER_SEQ')
  final int? upperSeq;

  @JsonKey(name: r'REG_ID')
  final String? regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STBOARDMSTGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class STBOARDSTNGGroupByOutputType implements _i1.JsonSerializable {
  const STBOARDSTNGGroupByOutputType({
    this.boardCd,
    this.boardNm,
    this.boardTy,
    this.editorYn,
    this.rlsYn,
    this.cclSeq,
    this.listCnt,
    this.writeYn,
    this.commentYn,
    this.replyYn,
    this.attachYn,
    this.attachSize,
    this.attachCnt,
    this.attachExt,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STBOARDSTNGGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$STBOARDSTNGGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'BOARD_CD')
  final String? boardCd;

  @JsonKey(name: r'BOARD_NM')
  final String? boardNm;

  @JsonKey(name: r'BOARD_TY')
  final String? boardTy;

  @JsonKey(name: r'EDITOR_YN')
  final String? editorYn;

  @JsonKey(name: r'RLS_YN')
  final String? rlsYn;

  @JsonKey(name: r'CCL_SEQ')
  final int? cclSeq;

  @JsonKey(name: r'LIST_CNT')
  final int? listCnt;

  @JsonKey(name: r'WRITE_YN')
  final String? writeYn;

  @JsonKey(name: r'COMMENT_YN')
  final String? commentYn;

  @JsonKey(name: r'REPLY_YN')
  final String? replyYn;

  @JsonKey(name: r'ATTACH_YN')
  final String? attachYn;

  @JsonKey(name: r'ATTACH_SIZE')
  final String? attachSize;

  @JsonKey(name: r'ATTACH_CNT')
  final String? attachCnt;

  @JsonKey(name: r'ATTACH_EXT')
  final String? attachExt;

  @JsonKey(name: r'REG_ID')
  final String? regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STBOARDSTNGGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class STCCLGroupByOutputType implements _i1.JsonSerializable {
  const STCCLGroupByOutputType({
    this.seq,
    this.cclType,
    this.cclNm,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileExtsn,
    this.fileSize,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCCLGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$STCCLGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'SEQ')
  final int? seq;

  @JsonKey(name: r'CCL_TYPE')
  final String? cclType;

  @JsonKey(name: r'CCL_NM')
  final String? cclNm;

  @JsonKey(name: r'FLPTH')
  final String? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final String? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final String? streFileNm;

  @JsonKey(name: r'FILE_EXTSN')
  final String? fileExtsn;

  @JsonKey(name: r'FILE_SIZE')
  final int? fileSize;

  @JsonKey(name: r'REG_ID')
  final String? regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STCCLGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class STCODEMSTGroupByOutputType implements _i1.JsonSerializable {
  const STCODEMSTGroupByOutputType({
    this.cdGrp,
    this.cdKey,
    this.cdVal,
    this.cdDesc,
    this.cdSrt,
    this.depth,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCODEMSTGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$STCODEMSTGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'CD_GRP')
  final String? cdGrp;

  @JsonKey(name: r'CD_KEY')
  final String? cdKey;

  @JsonKey(name: r'CD_VAL')
  final String? cdVal;

  @JsonKey(name: r'CD_DESC')
  final String? cdDesc;

  @JsonKey(name: r'CD_SRT')
  final int? cdSrt;

  @JsonKey(name: r'DEPTH')
  final int? depth;

  @JsonKey(name: r'REG_ID')
  final String? regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STCODEMSTGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class STCONNECTLOGGroupByOutputType implements _i1.JsonSerializable {
  const STCONNECTLOGGroupByOutputType({
    this.seq,
    this.userId,
    this.connType,
    this.osType,
    this.browserType,
    this.conneIp,
    this.regDate,
  });

  factory STCONNECTLOGGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$STCONNECTLOGGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'SEQ')
  final int? seq;

  @JsonKey(name: r'USER_ID')
  final String? userId;

  @JsonKey(name: r'CONN_TYPE')
  final String? connType;

  @JsonKey(name: r'OS_TYPE')
  final String? osType;

  @JsonKey(name: r'BROWSER_TYPE')
  final String? browserType;

  @JsonKey(name: r'CONNE_IP')
  final String? conneIp;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @override
  Map<String, dynamic> toJson() => _$STCONNECTLOGGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSFILEGroupByOutputType implements _i1.JsonSerializable {
  const STCONTENTSFILEGroupByOutputType({
    this.seq,
    this.mseq,
    this.fileTp,
    this.flpth,
    this.orginalFileNm,
    this.streFileNm,
    this.fileSize,
  });

  factory STCONTENTSFILEGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$STCONTENTSFILEGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'SEQ')
  final int? seq;

  @JsonKey(name: r'MSEQ')
  final String? mseq;

  @JsonKey(name: r'FILE_TP')
  final String? fileTp;

  @JsonKey(name: r'FLPTH')
  final String? flpth;

  @JsonKey(name: r'ORGINAL_FILE_NM')
  final String? orginalFileNm;

  @JsonKey(name: r'STRE_FILE_NM')
  final String? streFileNm;

  @JsonKey(name: r'FILE_SIZE')
  final int? fileSize;

  @override
  Map<String, dynamic> toJson() =>
      _$STCONTENTSFILEGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class STCONTENTSMSTGroupByOutputType implements _i1.JsonSerializable {
  const STCONTENTSMSTGroupByOutputType({
    this.seq,
    this.cntsNm,
    this.pubDate,
    this.pubState,
    this.cn,
    this.srchYn,
    this.fileYn,
    this.imageYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STCONTENTSMSTGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$STCONTENTSMSTGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'SEQ')
  final int? seq;

  @JsonKey(name: r'CNTS_NM')
  final String? cntsNm;

  @JsonKey(name: r'PUB_DATE')
  final String? pubDate;

  @JsonKey(name: r'PUB_STATE')
  final String? pubState;

  @JsonKey(name: r'CN')
  final String? cn;

  @JsonKey(name: r'SRCH_YN')
  final String? srchYn;

  @JsonKey(name: r'FILE_YN')
  final String? fileYn;

  @JsonKey(name: r'IMAGE_YN')
  final String? imageYn;

  @JsonKey(name: r'REG_ID')
  final String? regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STCONTENTSMSTGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class STDEPTGroupByOutputType implements _i1.JsonSerializable {
  const STDEPTGroupByOutputType({
    this.deptCd,
    this.deptNm,
    this.upperDeptCd,
    this.upperDeptNm,
    this.sort,
    this.mainYn,
    this.deptDesc,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STDEPTGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$STDEPTGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'DEPT_CD')
  final String? deptCd;

  @JsonKey(name: r'DEPT_NM')
  final String? deptNm;

  @JsonKey(name: r'UPPER_DEPT_CD')
  final String? upperDeptCd;

  @JsonKey(name: r'UPPER_DEPT_NM')
  final String? upperDeptNm;

  @JsonKey(name: r'SORT')
  final int? sort;

  @JsonKey(name: r'MAIN_YN')
  final String? mainYn;

  @JsonKey(name: r'DEPT_DESC')
  final String? deptDesc;

  @JsonKey(name: r'REG_ID')
  final String? regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STDEPTGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class STDEPTEMPGroupByOutputType implements _i1.JsonSerializable {
  const STDEPTEMPGroupByOutputType({
    this.empNo,
    this.empNm,
    this.deptCd,
    this.deptNm,
    this.fctnCd,
    this.fctnNm,
    this.ofcpCd,
    this.ofcpNm,
    this.emailAddr,
    this.offmTelno,
    this.htelTelno,
    this.deptYn,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STDEPTEMPGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$STDEPTEMPGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'EMP_NO')
  final String? empNo;

  @JsonKey(name: r'EMP_NM')
  final String? empNm;

  @JsonKey(name: r'DEPT_CD')
  final String? deptCd;

  @JsonKey(name: r'DEPT_NM')
  final String? deptNm;

  @JsonKey(name: r'FCTN_CD')
  final String? fctnCd;

  @JsonKey(name: r'FCTN_NM')
  final String? fctnNm;

  @JsonKey(name: r'OFCP_CD')
  final String? ofcpCd;

  @JsonKey(name: r'OFCP_NM')
  final String? ofcpNm;

  @JsonKey(name: r'EMAIL_ADDR')
  final String? emailAddr;

  @JsonKey(name: r'OFFM_TELNO')
  final String? offmTelno;

  @JsonKey(name: r'HTEL_TELNO')
  final String? htelTelno;

  @JsonKey(name: r'DEPT_YN')
  final String? deptYn;

  @JsonKey(name: r'REG_ID')
  final String? regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STDEPTEMPGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class STMENUGroupByOutputType implements _i1.JsonSerializable {
  const STMENUGroupByOutputType({
    this.menuCd,
    this.menuNm,
    this.menuPath,
    this.menuMapping,
    this.menuSrt,
    this.menuDeps,
    this.menuIcon,
    this.menuTp,
    this.mainExpsrYn,
    this.subExpsrYn,
    this.upendClas,
    this.upendCn,
    this.cclType,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMENUGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$STMENUGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'MENU_CD')
  final String? menuCd;

  @JsonKey(name: r'MENU_NM')
  final String? menuNm;

  @JsonKey(name: r'MENU_PATH')
  final String? menuPath;

  @JsonKey(name: r'MENU_MAPPING')
  final String? menuMapping;

  @JsonKey(name: r'MENU_SRT')
  final int? menuSrt;

  @JsonKey(name: r'MENU_DEPS')
  final int? menuDeps;

  @JsonKey(name: r'MENU_ICON')
  final String? menuIcon;

  @JsonKey(name: r'MENU_TP')
  final String? menuTp;

  @JsonKey(name: r'MAIN_EXPSR_YN')
  final String? mainExpsrYn;

  @JsonKey(name: r'SUB_EXPSR_YN')
  final String? subExpsrYn;

  @JsonKey(name: r'UPEND_CLAS')
  final String? upendClas;

  @JsonKey(name: r'UPEND_CN')
  final String? upendCn;

  @JsonKey(name: r'CCL_TYPE')
  final String? cclType;

  @JsonKey(name: r'REG_ID')
  final String? regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STMENUGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class STMESSAGETMPLATGroupByOutputType implements _i1.JsonSerializable {
  const STMESSAGETMPLATGroupByOutputType({
    this.msgDivCd,
    this.msgCd,
    this.msgNm,
    this.msgTmplat,
    this.useYn,
    this.editId,
    this.editDate,
  });

  factory STMESSAGETMPLATGroupByOutputType.fromJson(
          Map<String, dynamic> json) =>
      _$STMESSAGETMPLATGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'MSG_DIV_CD')
  final String? msgDivCd;

  @JsonKey(name: r'MSG_CD')
  final String? msgCd;

  @JsonKey(name: r'MSG_NM')
  final String? msgNm;

  @JsonKey(name: r'MSG_TMPLAT')
  final String? msgTmplat;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @override
  Map<String, dynamic> toJson() =>
      _$STMESSAGETMPLATGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class STMIMETYPEGroupByOutputType implements _i1.JsonSerializable {
  const STMIMETYPEGroupByOutputType({
    this.seq,
    this.extnNm,
    this.fileMt,
  });

  factory STMIMETYPEGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$STMIMETYPEGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'SEQ')
  final int? seq;

  @JsonKey(name: r'EXTN_NM')
  final String? extnNm;

  @JsonKey(name: r'FILE_MT')
  final String? fileMt;

  @override
  Map<String, dynamic> toJson() => _$STMIMETYPEGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class STMNGRGRPGroupByOutputType implements _i1.JsonSerializable {
  const STMNGRGRPGroupByOutputType({
    this.grpCd,
    this.grpNm,
    this.grpDesc,
    this.sort,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMNGRGRPGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$STMNGRGRPGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'GRP_CD')
  final String? grpCd;

  @JsonKey(name: r'GRP_NM')
  final String? grpNm;

  @JsonKey(name: r'GRP_DESC')
  final String? grpDesc;

  @JsonKey(name: r'SORT')
  final int? sort;

  @JsonKey(name: r'REG_ID')
  final String? regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STMNGRGRPGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class STMNGRMSTGroupByOutputType implements _i1.JsonSerializable {
  const STMNGRMSTGroupByOutputType({
    this.mngrId,
    this.mngrNm,
    this.mngrPw,
    this.grpCd,
    this.grade,
    this.permCd,
    this.acsYn,
    this.clph,
    this.empNo,
    this.joinDate,
    this.retireDate,
    this.pwdChgDate,
    this.pwdWrongCnt,
    this.pwdWrongDate,
    this.lstLoginDate,
    this.flpth,
    this.fileNm,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STMNGRMSTGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$STMNGRMSTGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'MNGR_ID')
  final String? mngrId;

  @JsonKey(name: r'MNGR_NM')
  final String? mngrNm;

  @JsonKey(name: r'MNGR_PW')
  final String? mngrPw;

  @JsonKey(name: r'GRP_CD')
  final String? grpCd;

  @JsonKey(name: r'GRADE')
  final String? grade;

  @JsonKey(name: r'PERM_CD')
  final String? permCd;

  @JsonKey(name: r'ACS_YN')
  final String? acsYn;

  @JsonKey(name: r'CLPH')
  final String? clph;

  @JsonKey(name: r'EMP_NO')
  final String? empNo;

  @JsonKey(name: r'JOIN_DATE')
  final String? joinDate;

  @JsonKey(name: r'RETIRE_DATE')
  final DateTime? retireDate;

  @JsonKey(name: r'PWD_CHG_DATE')
  final DateTime? pwdChgDate;

  @JsonKey(name: r'PWD_WRONG_CNT')
  final int? pwdWrongCnt;

  @JsonKey(name: r'PWD_WRONG_DATE')
  final String? pwdWrongDate;

  @JsonKey(name: r'LST_LOGIN_DATE')
  final String? lstLoginDate;

  @JsonKey(name: r'FLPTH')
  final String? flpth;

  @JsonKey(name: r'FILE_NM')
  final String? fileNm;

  @JsonKey(name: r'REG_ID')
  final String? regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STMNGRMSTGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class STMYSTNGGroupByOutputType implements _i1.JsonSerializable {
  const STMYSTNGGroupByOutputType({
    this.userId,
    this.stngCd,
    this.userDiv,
    this.stngData,
  });

  factory STMYSTNGGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$STMYSTNGGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'USER_ID')
  final String? userId;

  @JsonKey(name: r'STNG_CD')
  final String? stngCd;

  @JsonKey(name: r'USER_DIV')
  final String? userDiv;

  @JsonKey(name: r'STNG_DATA')
  final String? stngData;

  @override
  Map<String, dynamic> toJson() => _$STMYSTNGGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class STPERMDTLGroupByOutputType implements _i1.JsonSerializable {
  const STPERMDTLGroupByOutputType({
    this.permCd,
    this.menuCd,
    this.readYn,
    this.regYn,
    this.mdfcnYn,
    this.delYn,
    this.manageYn,
    this.regId,
    this.regDate,
  });

  factory STPERMDTLGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$STPERMDTLGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'PERM_CD')
  final String? permCd;

  @JsonKey(name: r'MENU_CD')
  final String? menuCd;

  @JsonKey(name: r'READ_YN')
  final String? readYn;

  @JsonKey(name: r'REG_YN')
  final String? regYn;

  @JsonKey(name: r'MDFCN_YN')
  final String? mdfcnYn;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @JsonKey(name: r'MANAGE_YN')
  final String? manageYn;

  @JsonKey(name: r'REG_ID')
  final String? regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @override
  Map<String, dynamic> toJson() => _$STPERMDTLGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class STPERMMSTGroupByOutputType implements _i1.JsonSerializable {
  const STPERMMSTGroupByOutputType({
    this.permCd,
    this.permNm,
    this.sort,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STPERMMSTGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$STPERMMSTGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'PERM_CD')
  final String? permCd;

  @JsonKey(name: r'PERM_NM')
  final String? permNm;

  @JsonKey(name: r'SORT')
  final String? sort;

  @JsonKey(name: r'REG_ID')
  final String? regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STPERMMSTGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class STPOPUPGroupByOutputType implements _i1.JsonSerializable {
  const STPOPUPGroupByOutputType({
    this.popCd,
    this.popNm,
    this.popTy,
    this.imgText,
    this.lkUrl,
    this.lkTarget,
    this.bgngDate,
    this.endDate,
    this.spwgPred,
    this.flpth,
    this.fileNm,
    this.useYn,
    this.beforeCd,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STPOPUPGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$STPOPUPGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'POP_CD')
  final String? popCd;

  @JsonKey(name: r'POP_NM')
  final String? popNm;

  @JsonKey(name: r'POP_TY')
  final String? popTy;

  @JsonKey(name: r'IMG_TEXT')
  final String? imgText;

  @JsonKey(name: r'LK_URL')
  final String? lkUrl;

  @JsonKey(name: r'LK_TARGET')
  final String? lkTarget;

  @JsonKey(name: r'BGNG_DATE')
  final String? bgngDate;

  @JsonKey(name: r'END_DATE')
  final String? endDate;

  @JsonKey(name: r'SPWG_PRED')
  final String? spwgPred;

  @JsonKey(name: r'FLPTH')
  final String? flpth;

  @JsonKey(name: r'FILE_NM')
  final String? fileNm;

  @JsonKey(name: r'USE_YN')
  final String? useYn;

  @JsonKey(name: r'BEFORE_CD')
  final String? beforeCd;

  @JsonKey(name: r'REG_ID')
  final String? regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STPOPUPGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class STSTNGGroupByOutputType implements _i1.JsonSerializable {
  const STSTNGGroupByOutputType({
    this.stngCd,
    this.stngData,
    this.title,
    this.descCn,
    this.sort,
    this.editId,
    this.editDate,
  });

  factory STSTNGGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$STSTNGGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'STNG_CD')
  final String? stngCd;

  @JsonKey(name: r'STNG_DATA')
  final String? stngData;

  @JsonKey(name: r'TITLE')
  final String? title;

  @JsonKey(name: r'DESC_CN')
  final String? descCn;

  @JsonKey(name: r'SORT')
  final int? sort;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @override
  Map<String, dynamic> toJson() => _$STSTNGGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class STUSERMSTGroupByOutputType implements _i1.JsonSerializable {
  const STUSERMSTGroupByOutputType({
    this.userId,
    this.userNm,
    this.userPw,
    this.userDiv,
    this.status,
    this.prevLoginYn,
    this.withdrawnYn,
    this.clph,
    this.email,
    this.lstLoginDate,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory STUSERMSTGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$STUSERMSTGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'USER_ID')
  final String? userId;

  @JsonKey(name: r'USER_NM')
  final String? userNm;

  @JsonKey(name: r'USER_PW')
  final String? userPw;

  @JsonKey(name: r'USER_DIV')
  final String? userDiv;

  @JsonKey(name: r'STATUS')
  final String? status;

  @JsonKey(name: r'PREV_LOGIN_YN')
  final String? prevLoginYn;

  @JsonKey(name: r'WITHDRAWN_YN')
  final String? withdrawnYn;

  @JsonKey(name: r'CLPH')
  final String? clph;

  @JsonKey(name: r'EMAIL')
  final String? email;

  @JsonKey(name: r'LST_LOGIN_DATE')
  final String? lstLoginDate;

  @JsonKey(name: r'REG_ID')
  final String? regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() => _$STUSERMSTGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTDETAILTBLGroupByOutputType implements _i1.JsonSerializable {
  const WORKREPORTDETAILTBLGroupByOutputType({
    this.reportId,
    this.seq,
    this.projectNm,
    this.projectSubNm,
    this.detailContent,
    this.worker,
    this.grade,
    this.processRate,
    this.workDate,
    this.processType,
    this.subjectYn,
    this.regUser,
    this.regDate,
    this.completeDate,
  });

  factory WORKREPORTDETAILTBLGroupByOutputType.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTDETAILTBLGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final String? reportId;

  @JsonKey(name: r'SEQ')
  final BigInt? seq;

  @JsonKey(name: r'PROJECT_NM')
  final String? projectNm;

  @JsonKey(name: r'PROJECT_SUB_NM')
  final String? projectSubNm;

  @JsonKey(name: r'DETAIL_CONTENT')
  final String? detailContent;

  @JsonKey(name: r'WORKER')
  final String? worker;

  @JsonKey(name: r'GRADE')
  final String? grade;

  @JsonKey(name: r'PROCESS_RATE')
  final String? processRate;

  @JsonKey(name: r'WORK_DATE')
  final String? workDate;

  @JsonKey(name: r'PROCESS_TYPE')
  final String? processType;

  @JsonKey(name: r'SUBJECT_YN')
  final String? subjectYn;

  @JsonKey(name: r'REG_USER')
  final String? regUser;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'COMPLETE_DATE')
  final String? completeDate;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTDETAILTBLGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLGroupByOutputType implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLGroupByOutputType({
    this.reportId,
    this.userId,
    this.title,
    this.htmlContent,
    this.regDate,
    this.delYn,
  });

  factory WORKREPORTHTMLTBLGroupByOutputType.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final String? reportId;

  @JsonKey(name: r'USER_ID')
  final String? userId;

  @JsonKey(name: r'TITLE')
  final String? title;

  @JsonKey(name: r'HTML_CONTENT')
  final String? htmlContent;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTHTMLTBLGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTHTMLTBLBACKGroupByOutputType implements _i1.JsonSerializable {
  const WORKREPORTHTMLTBLBACKGroupByOutputType({
    this.reportId,
    this.userId,
    this.title,
    this.htmlContent,
    this.regDate,
    this.delYn,
  });

  factory WORKREPORTHTMLTBLBACKGroupByOutputType.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTHTMLTBLBACKGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final String? reportId;

  @JsonKey(name: r'USER_ID')
  final String? userId;

  @JsonKey(name: r'TITLE')
  final String? title;

  @JsonKey(name: r'HTML_CONTENT')
  final String? htmlContent;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTHTMLTBLBACKGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class WORKREPORTMASTERTBLGroupByOutputType implements _i1.JsonSerializable {
  const WORKREPORTMASTERTBLGroupByOutputType({
    this.reportId,
    this.title,
    this.dept,
    this.regDate,
    this.updDate,
    this.delYn,
  });

  factory WORKREPORTMASTERTBLGroupByOutputType.fromJson(
          Map<String, dynamic> json) =>
      _$WORKREPORTMASTERTBLGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'REPORT_ID')
  final String? reportId;

  @JsonKey(name: r'TITLE')
  final String? title;

  @JsonKey(name: r'DEPT')
  final String? dept;

  @JsonKey(name: r'REG_DATE')
  final DateTime? regDate;

  @JsonKey(name: r'UPD_DATE')
  final DateTime? updDate;

  @JsonKey(name: r'DEL_YN')
  final String? delYn;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREPORTMASTERTBLGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTMSTGroupByOutputType implements _i1.JsonSerializable {
  const WORKREQUESTMSTGroupByOutputType({
    this.seq,
    this.rqstrDpnm,
    this.rqstrNm,
    this.rqstrId,
    this.rqstrDate,
    this.hopeDate,
    this.chrDprNm,
    this.chrNm,
    this.chrId,
    this.chrChk,
    this.title,
    this.cn,
    this.etc,
    this.doc,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory WORKREQUESTMSTGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$WORKREQUESTMSTGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'SEQ')
  final int? seq;

  @JsonKey(name: r'RQSTR_DPNM')
  final String? rqstrDpnm;

  @JsonKey(name: r'RQSTR_NM')
  final String? rqstrNm;

  @JsonKey(name: r'RQSTR_ID')
  final String? rqstrId;

  @JsonKey(name: r'RQSTR_DATE')
  final String? rqstrDate;

  @JsonKey(name: r'HOPE_DATE')
  final String? hopeDate;

  @JsonKey(name: r'CHR_DPR_NM')
  final String? chrDprNm;

  @JsonKey(name: r'CHR_NM')
  final String? chrNm;

  @JsonKey(name: r'CHR_ID')
  final String? chrId;

  @JsonKey(name: r'CHR_CHK')
  final String? chrChk;

  @JsonKey(name: r'TITLE')
  final String? title;

  @JsonKey(name: r'CN')
  final String? cn;

  @JsonKey(name: r'ETC')
  final String? etc;

  @JsonKey(name: r'DOC')
  final String? doc;

  @JsonKey(name: r'REG_ID')
  final String? regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREQUESTMSTGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class WORKREQUESTREFGroupByOutputType implements _i1.JsonSerializable {
  const WORKREQUESTREFGroupByOutputType({
    this.seq,
    this.mseq,
    this.refId,
    this.refNm,
    this.refDep,
    this.refGrade,
    this.regId,
    this.regDate,
    this.editId,
    this.editDate,
    this.delId,
    this.delDate,
  });

  factory WORKREQUESTREFGroupByOutputType.fromJson(Map<String, dynamic> json) =>
      _$WORKREQUESTREFGroupByOutputTypeFromJson(json);

  @JsonKey(name: r'SEQ')
  final int? seq;

  @JsonKey(name: r'MSEQ')
  final int? mseq;

  @JsonKey(name: r'REF_ID')
  final String? refId;

  @JsonKey(name: r'REF_NM')
  final String? refNm;

  @JsonKey(name: r'REF_DEP')
  final String? refDep;

  @JsonKey(name: r'REF_GRADE')
  final String? refGrade;

  @JsonKey(name: r'REG_ID')
  final String? regId;

  @JsonKey(name: r'REG_DATE')
  final String? regDate;

  @JsonKey(name: r'EDIT_ID')
  final String? editId;

  @JsonKey(name: r'EDIT_DATE')
  final String? editDate;

  @JsonKey(name: r'DEL_ID')
  final String? delId;

  @JsonKey(name: r'DEL_DATE')
  final String? delDate;

  @override
  Map<String, dynamic> toJson() =>
      _$WORKREQUESTREFGroupByOutputTypeToJson(this);
}

@_i1.jsonSerializable
class AffectedRowsOutput implements _i1.JsonSerializable {
  const AffectedRowsOutput({this.count});

  factory AffectedRowsOutput.fromJson(Map<String, dynamic> json) =>
      _$AffectedRowsOutputFromJson(json);

  final int? count;

  @override
  Map<String, dynamic> toJson() => _$AffectedRowsOutputToJson(this);
}

class AggregateALLCODETBL {
  const AggregateALLCODETBL(this.$query);

  final _i1.PrismaFluentQuery $query;

  ALLCODETBLCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return ALLCODETBLCountAggregateOutputType(query);
  }

  ALLCODETBLAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return ALLCODETBLAvgAggregateOutputType(query);
  }

  ALLCODETBLSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return ALLCODETBLSumAggregateOutputType(query);
  }

  ALLCODETBLMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return ALLCODETBLMinAggregateOutputType(query);
  }

  ALLCODETBLMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return ALLCODETBLMaxAggregateOutputType(query);
  }
}

class AggregateAPPROVALATTACHFILETBL {
  const AggregateAPPROVALATTACHFILETBL(this.$query);

  final _i1.PrismaFluentQuery $query;

  APPROVALATTACHFILETBLCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return APPROVALATTACHFILETBLCountAggregateOutputType(query);
  }

  APPROVALATTACHFILETBLAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return APPROVALATTACHFILETBLAvgAggregateOutputType(query);
  }

  APPROVALATTACHFILETBLSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return APPROVALATTACHFILETBLSumAggregateOutputType(query);
  }

  APPROVALATTACHFILETBLMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return APPROVALATTACHFILETBLMinAggregateOutputType(query);
  }

  APPROVALATTACHFILETBLMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return APPROVALATTACHFILETBLMaxAggregateOutputType(query);
  }
}

class AggregateAPPROVALDOCINFOTBL {
  const AggregateAPPROVALDOCINFOTBL(this.$query);

  final _i1.PrismaFluentQuery $query;

  APPROVALDOCINFOTBLCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return APPROVALDOCINFOTBLCountAggregateOutputType(query);
  }

  APPROVALDOCINFOTBLAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return APPROVALDOCINFOTBLAvgAggregateOutputType(query);
  }

  APPROVALDOCINFOTBLSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return APPROVALDOCINFOTBLSumAggregateOutputType(query);
  }

  APPROVALDOCINFOTBLMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return APPROVALDOCINFOTBLMinAggregateOutputType(query);
  }

  APPROVALDOCINFOTBLMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return APPROVALDOCINFOTBLMaxAggregateOutputType(query);
  }
}

class AggregateAPPROVALHISTORYTBL {
  const AggregateAPPROVALHISTORYTBL(this.$query);

  final _i1.PrismaFluentQuery $query;

  APPROVALHISTORYTBLCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return APPROVALHISTORYTBLCountAggregateOutputType(query);
  }

  APPROVALHISTORYTBLAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return APPROVALHISTORYTBLAvgAggregateOutputType(query);
  }

  APPROVALHISTORYTBLSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return APPROVALHISTORYTBLSumAggregateOutputType(query);
  }

  APPROVALHISTORYTBLMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return APPROVALHISTORYTBLMinAggregateOutputType(query);
  }

  APPROVALHISTORYTBLMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return APPROVALHISTORYTBLMaxAggregateOutputType(query);
  }
}

class AggregateAPPROVALMASTERTBL {
  const AggregateAPPROVALMASTERTBL(this.$query);

  final _i1.PrismaFluentQuery $query;

  APPROVALMASTERTBLCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return APPROVALMASTERTBLCountAggregateOutputType(query);
  }

  APPROVALMASTERTBLAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return APPROVALMASTERTBLAvgAggregateOutputType(query);
  }

  APPROVALMASTERTBLSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return APPROVALMASTERTBLSumAggregateOutputType(query);
  }

  APPROVALMASTERTBLMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return APPROVALMASTERTBLMinAggregateOutputType(query);
  }

  APPROVALMASTERTBLMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return APPROVALMASTERTBLMaxAggregateOutputType(query);
  }
}

class AggregateAPPROVALMEMOTBL {
  const AggregateAPPROVALMEMOTBL(this.$query);

  final _i1.PrismaFluentQuery $query;

  APPROVALMEMOTBLCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return APPROVALMEMOTBLCountAggregateOutputType(query);
  }

  APPROVALMEMOTBLAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return APPROVALMEMOTBLAvgAggregateOutputType(query);
  }

  APPROVALMEMOTBLSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return APPROVALMEMOTBLSumAggregateOutputType(query);
  }

  APPROVALMEMOTBLMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return APPROVALMEMOTBLMinAggregateOutputType(query);
  }

  APPROVALMEMOTBLMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return APPROVALMEMOTBLMaxAggregateOutputType(query);
  }
}

class AggregateAPPROVALTYPETBL {
  const AggregateAPPROVALTYPETBL(this.$query);

  final _i1.PrismaFluentQuery $query;

  APPROVALTYPETBLCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return APPROVALTYPETBLCountAggregateOutputType(query);
  }

  APPROVALTYPETBLMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return APPROVALTYPETBLMinAggregateOutputType(query);
  }

  APPROVALTYPETBLMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return APPROVALTYPETBLMaxAggregateOutputType(query);
  }
}

class AggregateAPPROVALUSERTBL {
  const AggregateAPPROVALUSERTBL(this.$query);

  final _i1.PrismaFluentQuery $query;

  APPROVALUSERTBLCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return APPROVALUSERTBLCountAggregateOutputType(query);
  }

  APPROVALUSERTBLAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return APPROVALUSERTBLAvgAggregateOutputType(query);
  }

  APPROVALUSERTBLSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return APPROVALUSERTBLSumAggregateOutputType(query);
  }

  APPROVALUSERTBLMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return APPROVALUSERTBLMinAggregateOutputType(query);
  }

  APPROVALUSERTBLMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return APPROVALUSERTBLMaxAggregateOutputType(query);
  }
}

class AggregateBOOKASSETTBL {
  const AggregateBOOKASSETTBL(this.$query);

  final _i1.PrismaFluentQuery $query;

  BOOKASSETTBLCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return BOOKASSETTBLCountAggregateOutputType(query);
  }

  BOOKASSETTBLAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return BOOKASSETTBLAvgAggregateOutputType(query);
  }

  BOOKASSETTBLSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return BOOKASSETTBLSumAggregateOutputType(query);
  }

  BOOKASSETTBLMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return BOOKASSETTBLMinAggregateOutputType(query);
  }

  BOOKASSETTBLMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return BOOKASSETTBLMaxAggregateOutputType(query);
  }
}

class AggregateCARASSETINSURTBL {
  const AggregateCARASSETINSURTBL(this.$query);

  final _i1.PrismaFluentQuery $query;

  CARASSETINSURTBLCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return CARASSETINSURTBLCountAggregateOutputType(query);
  }

  CARASSETINSURTBLAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return CARASSETINSURTBLAvgAggregateOutputType(query);
  }

  CARASSETINSURTBLSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return CARASSETINSURTBLSumAggregateOutputType(query);
  }

  CARASSETINSURTBLMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return CARASSETINSURTBLMinAggregateOutputType(query);
  }

  CARASSETINSURTBLMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return CARASSETINSURTBLMaxAggregateOutputType(query);
  }
}

class AggregateCARASSETTBL {
  const AggregateCARASSETTBL(this.$query);

  final _i1.PrismaFluentQuery $query;

  CARASSETTBLCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return CARASSETTBLCountAggregateOutputType(query);
  }

  CARASSETTBLAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return CARASSETTBLAvgAggregateOutputType(query);
  }

  CARASSETTBLSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return CARASSETTBLSumAggregateOutputType(query);
  }

  CARASSETTBLMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return CARASSETTBLMinAggregateOutputType(query);
  }

  CARASSETTBLMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return CARASSETTBLMaxAggregateOutputType(query);
  }
}

class AggregateCARCHARGETBL {
  const AggregateCARCHARGETBL(this.$query);

  final _i1.PrismaFluentQuery $query;

  CARCHARGETBLCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return CARCHARGETBLCountAggregateOutputType(query);
  }

  CARCHARGETBLAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return CARCHARGETBLAvgAggregateOutputType(query);
  }

  CARCHARGETBLSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return CARCHARGETBLSumAggregateOutputType(query);
  }

  CARCHARGETBLMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return CARCHARGETBLMinAggregateOutputType(query);
  }

  CARCHARGETBLMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return CARCHARGETBLMaxAggregateOutputType(query);
  }
}

class AggregateCARINFOTBL {
  const AggregateCARINFOTBL(this.$query);

  final _i1.PrismaFluentQuery $query;

  CARINFOTBLCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return CARINFOTBLCountAggregateOutputType(query);
  }

  CARINFOTBLAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return CARINFOTBLAvgAggregateOutputType(query);
  }

  CARINFOTBLSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return CARINFOTBLSumAggregateOutputType(query);
  }

  CARINFOTBLMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return CARINFOTBLMinAggregateOutputType(query);
  }

  CARINFOTBLMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return CARINFOTBLMaxAggregateOutputType(query);
  }
}

class AggregateCARMILEAGETBL {
  const AggregateCARMILEAGETBL(this.$query);

  final _i1.PrismaFluentQuery $query;

  CARMILEAGETBLCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return CARMILEAGETBLCountAggregateOutputType(query);
  }

  CARMILEAGETBLAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return CARMILEAGETBLAvgAggregateOutputType(query);
  }

  CARMILEAGETBLSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return CARMILEAGETBLSumAggregateOutputType(query);
  }

  CARMILEAGETBLMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return CARMILEAGETBLMinAggregateOutputType(query);
  }

  CARMILEAGETBLMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return CARMILEAGETBLMaxAggregateOutputType(query);
  }
}

class AggregateCARPARTREPLACETBL {
  const AggregateCARPARTREPLACETBL(this.$query);

  final _i1.PrismaFluentQuery $query;

  CARPARTREPLACETBLCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return CARPARTREPLACETBLCountAggregateOutputType(query);
  }

  CARPARTREPLACETBLAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return CARPARTREPLACETBLAvgAggregateOutputType(query);
  }

  CARPARTREPLACETBLSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return CARPARTREPLACETBLSumAggregateOutputType(query);
  }

  CARPARTREPLACETBLMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return CARPARTREPLACETBLMinAggregateOutputType(query);
  }

  CARPARTREPLACETBLMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return CARPARTREPLACETBLMaxAggregateOutputType(query);
  }
}

class AggregateCARREPAIRLOG {
  const AggregateCARREPAIRLOG(this.$query);

  final _i1.PrismaFluentQuery $query;

  CARREPAIRLOGCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return CARREPAIRLOGCountAggregateOutputType(query);
  }

  CARREPAIRLOGAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return CARREPAIRLOGAvgAggregateOutputType(query);
  }

  CARREPAIRLOGSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return CARREPAIRLOGSumAggregateOutputType(query);
  }

  CARREPAIRLOGMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return CARREPAIRLOGMinAggregateOutputType(query);
  }

  CARREPAIRLOGMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return CARREPAIRLOGMaxAggregateOutputType(query);
  }
}

class AggregateCARUSEMANAGETBL {
  const AggregateCARUSEMANAGETBL(this.$query);

  final _i1.PrismaFluentQuery $query;

  CARUSEMANAGETBLCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return CARUSEMANAGETBLCountAggregateOutputType(query);
  }

  CARUSEMANAGETBLAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return CARUSEMANAGETBLAvgAggregateOutputType(query);
  }

  CARUSEMANAGETBLSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return CARUSEMANAGETBLSumAggregateOutputType(query);
  }

  CARUSEMANAGETBLMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return CARUSEMANAGETBLMinAggregateOutputType(query);
  }

  CARUSEMANAGETBLMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return CARUSEMANAGETBLMaxAggregateOutputType(query);
  }
}

class AggregateHOLIDAYTBL {
  const AggregateHOLIDAYTBL(this.$query);

  final _i1.PrismaFluentQuery $query;

  HOLIDAYTBLCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return HOLIDAYTBLCountAggregateOutputType(query);
  }

  HOLIDAYTBLAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return HOLIDAYTBLAvgAggregateOutputType(query);
  }

  HOLIDAYTBLSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return HOLIDAYTBLSumAggregateOutputType(query);
  }

  HOLIDAYTBLMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return HOLIDAYTBLMinAggregateOutputType(query);
  }

  HOLIDAYTBLMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return HOLIDAYTBLMaxAggregateOutputType(query);
  }
}

class AggregateMEMBERTBL {
  const AggregateMEMBERTBL(this.$query);

  final _i1.PrismaFluentQuery $query;

  MEMBERTBLCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return MEMBERTBLCountAggregateOutputType(query);
  }

  MEMBERTBLAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return MEMBERTBLAvgAggregateOutputType(query);
  }

  MEMBERTBLSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return MEMBERTBLSumAggregateOutputType(query);
  }

  MEMBERTBLMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return MEMBERTBLMinAggregateOutputType(query);
  }

  MEMBERTBLMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return MEMBERTBLMaxAggregateOutputType(query);
  }
}

class AggregateMENUAUTHTBL {
  const AggregateMENUAUTHTBL(this.$query);

  final _i1.PrismaFluentQuery $query;

  MENUAUTHTBLCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return MENUAUTHTBLCountAggregateOutputType(query);
  }

  MENUAUTHTBLMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return MENUAUTHTBLMinAggregateOutputType(query);
  }

  MENUAUTHTBLMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return MENUAUTHTBLMaxAggregateOutputType(query);
  }
}

class AggregateMENUTBL {
  const AggregateMENUTBL(this.$query);

  final _i1.PrismaFluentQuery $query;

  MENUTBLCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return MENUTBLCountAggregateOutputType(query);
  }

  MENUTBLAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return MENUTBLAvgAggregateOutputType(query);
  }

  MENUTBLSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return MENUTBLSumAggregateOutputType(query);
  }

  MENUTBLMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return MENUTBLMinAggregateOutputType(query);
  }

  MENUTBLMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return MENUTBLMaxAggregateOutputType(query);
  }
}

class AggregateOFFICEASSETTBL {
  const AggregateOFFICEASSETTBL(this.$query);

  final _i1.PrismaFluentQuery $query;

  OFFICEASSETTBLCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return OFFICEASSETTBLCountAggregateOutputType(query);
  }

  OFFICEASSETTBLAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return OFFICEASSETTBLAvgAggregateOutputType(query);
  }

  OFFICEASSETTBLSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return OFFICEASSETTBLSumAggregateOutputType(query);
  }

  OFFICEASSETTBLMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return OFFICEASSETTBLMinAggregateOutputType(query);
  }

  OFFICEASSETTBLMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return OFFICEASSETTBLMaxAggregateOutputType(query);
  }
}

class AggregateSERVERASSETTBL {
  const AggregateSERVERASSETTBL(this.$query);

  final _i1.PrismaFluentQuery $query;

  SERVERASSETTBLCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return SERVERASSETTBLCountAggregateOutputType(query);
  }

  SERVERASSETTBLAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return SERVERASSETTBLAvgAggregateOutputType(query);
  }

  SERVERASSETTBLSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return SERVERASSETTBLSumAggregateOutputType(query);
  }

  SERVERASSETTBLMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return SERVERASSETTBLMinAggregateOutputType(query);
  }

  SERVERASSETTBLMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return SERVERASSETTBLMaxAggregateOutputType(query);
  }
}

class AggregateSOFTWAREASSETTBL {
  const AggregateSOFTWAREASSETTBL(this.$query);

  final _i1.PrismaFluentQuery $query;

  SOFTWAREASSETTBLCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return SOFTWAREASSETTBLCountAggregateOutputType(query);
  }

  SOFTWAREASSETTBLAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return SOFTWAREASSETTBLAvgAggregateOutputType(query);
  }

  SOFTWAREASSETTBLSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return SOFTWAREASSETTBLSumAggregateOutputType(query);
  }

  SOFTWAREASSETTBLMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return SOFTWAREASSETTBLMinAggregateOutputType(query);
  }

  SOFTWAREASSETTBLMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return SOFTWAREASSETTBLMaxAggregateOutputType(query);
  }
}

class AggregateSTADMINMENU {
  const AggregateSTADMINMENU(this.$query);

  final _i1.PrismaFluentQuery $query;

  STADMINMENUCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return STADMINMENUCountAggregateOutputType(query);
  }

  STADMINMENUAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return STADMINMENUAvgAggregateOutputType(query);
  }

  STADMINMENUSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return STADMINMENUSumAggregateOutputType(query);
  }

  STADMINMENUMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return STADMINMENUMinAggregateOutputType(query);
  }

  STADMINMENUMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return STADMINMENUMaxAggregateOutputType(query);
  }
}

class AggregateSTALARM {
  const AggregateSTALARM(this.$query);

  final _i1.PrismaFluentQuery $query;

  STALARMCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return STALARMCountAggregateOutputType(query);
  }

  STALARMAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return STALARMAvgAggregateOutputType(query);
  }

  STALARMSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return STALARMSumAggregateOutputType(query);
  }

  STALARMMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return STALARMMinAggregateOutputType(query);
  }

  STALARMMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return STALARMMaxAggregateOutputType(query);
  }
}

class AggregateSTAUDITLOG {
  const AggregateSTAUDITLOG(this.$query);

  final _i1.PrismaFluentQuery $query;

  STAUDITLOGCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return STAUDITLOGCountAggregateOutputType(query);
  }

  STAUDITLOGAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return STAUDITLOGAvgAggregateOutputType(query);
  }

  STAUDITLOGSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return STAUDITLOGSumAggregateOutputType(query);
  }

  STAUDITLOGMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return STAUDITLOGMinAggregateOutputType(query);
  }

  STAUDITLOGMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return STAUDITLOGMaxAggregateOutputType(query);
  }
}

class AggregateSTBANNER {
  const AggregateSTBANNER(this.$query);

  final _i1.PrismaFluentQuery $query;

  STBANNERCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return STBANNERCountAggregateOutputType(query);
  }

  STBANNERMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return STBANNERMinAggregateOutputType(query);
  }

  STBANNERMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return STBANNERMaxAggregateOutputType(query);
  }
}

class AggregateSTBOARDCOLUMN {
  const AggregateSTBOARDCOLUMN(this.$query);

  final _i1.PrismaFluentQuery $query;

  STBOARDCOLUMNCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return STBOARDCOLUMNCountAggregateOutputType(query);
  }

  STBOARDCOLUMNAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return STBOARDCOLUMNAvgAggregateOutputType(query);
  }

  STBOARDCOLUMNSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return STBOARDCOLUMNSumAggregateOutputType(query);
  }

  STBOARDCOLUMNMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return STBOARDCOLUMNMinAggregateOutputType(query);
  }

  STBOARDCOLUMNMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return STBOARDCOLUMNMaxAggregateOutputType(query);
  }
}

class AggregateSTBOARDCOLUMNDFT {
  const AggregateSTBOARDCOLUMNDFT(this.$query);

  final _i1.PrismaFluentQuery $query;

  STBOARDCOLUMNDFTCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return STBOARDCOLUMNDFTCountAggregateOutputType(query);
  }

  STBOARDCOLUMNDFTAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return STBOARDCOLUMNDFTAvgAggregateOutputType(query);
  }

  STBOARDCOLUMNDFTSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return STBOARDCOLUMNDFTSumAggregateOutputType(query);
  }

  STBOARDCOLUMNDFTMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return STBOARDCOLUMNDFTMinAggregateOutputType(query);
  }

  STBOARDCOLUMNDFTMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return STBOARDCOLUMNDFTMaxAggregateOutputType(query);
  }
}

class AggregateSTBOARDCOMMENT {
  const AggregateSTBOARDCOMMENT(this.$query);

  final _i1.PrismaFluentQuery $query;

  STBOARDCOMMENTCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return STBOARDCOMMENTCountAggregateOutputType(query);
  }

  STBOARDCOMMENTAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return STBOARDCOMMENTAvgAggregateOutputType(query);
  }

  STBOARDCOMMENTSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return STBOARDCOMMENTSumAggregateOutputType(query);
  }

  STBOARDCOMMENTMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return STBOARDCOMMENTMinAggregateOutputType(query);
  }

  STBOARDCOMMENTMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return STBOARDCOMMENTMaxAggregateOutputType(query);
  }
}

class AggregateSTBOARDFILE {
  const AggregateSTBOARDFILE(this.$query);

  final _i1.PrismaFluentQuery $query;

  STBOARDFILECountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return STBOARDFILECountAggregateOutputType(query);
  }

  STBOARDFILEAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return STBOARDFILEAvgAggregateOutputType(query);
  }

  STBOARDFILESumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return STBOARDFILESumAggregateOutputType(query);
  }

  STBOARDFILEMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return STBOARDFILEMinAggregateOutputType(query);
  }

  STBOARDFILEMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return STBOARDFILEMaxAggregateOutputType(query);
  }
}

class AggregateSTBOARDMST {
  const AggregateSTBOARDMST(this.$query);

  final _i1.PrismaFluentQuery $query;

  STBOARDMSTCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return STBOARDMSTCountAggregateOutputType(query);
  }

  STBOARDMSTAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return STBOARDMSTAvgAggregateOutputType(query);
  }

  STBOARDMSTSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return STBOARDMSTSumAggregateOutputType(query);
  }

  STBOARDMSTMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return STBOARDMSTMinAggregateOutputType(query);
  }

  STBOARDMSTMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return STBOARDMSTMaxAggregateOutputType(query);
  }
}

class AggregateSTBOARDSTNG {
  const AggregateSTBOARDSTNG(this.$query);

  final _i1.PrismaFluentQuery $query;

  STBOARDSTNGCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return STBOARDSTNGCountAggregateOutputType(query);
  }

  STBOARDSTNGAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return STBOARDSTNGAvgAggregateOutputType(query);
  }

  STBOARDSTNGSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return STBOARDSTNGSumAggregateOutputType(query);
  }

  STBOARDSTNGMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return STBOARDSTNGMinAggregateOutputType(query);
  }

  STBOARDSTNGMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return STBOARDSTNGMaxAggregateOutputType(query);
  }
}

class AggregateSTCCL {
  const AggregateSTCCL(this.$query);

  final _i1.PrismaFluentQuery $query;

  STCCLCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return STCCLCountAggregateOutputType(query);
  }

  STCCLAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return STCCLAvgAggregateOutputType(query);
  }

  STCCLSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return STCCLSumAggregateOutputType(query);
  }

  STCCLMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return STCCLMinAggregateOutputType(query);
  }

  STCCLMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return STCCLMaxAggregateOutputType(query);
  }
}

class AggregateSTCODEMST {
  const AggregateSTCODEMST(this.$query);

  final _i1.PrismaFluentQuery $query;

  STCODEMSTCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return STCODEMSTCountAggregateOutputType(query);
  }

  STCODEMSTAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return STCODEMSTAvgAggregateOutputType(query);
  }

  STCODEMSTSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return STCODEMSTSumAggregateOutputType(query);
  }

  STCODEMSTMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return STCODEMSTMinAggregateOutputType(query);
  }

  STCODEMSTMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return STCODEMSTMaxAggregateOutputType(query);
  }
}

class AggregateSTCONNECTLOG {
  const AggregateSTCONNECTLOG(this.$query);

  final _i1.PrismaFluentQuery $query;

  STCONNECTLOGCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return STCONNECTLOGCountAggregateOutputType(query);
  }

  STCONNECTLOGAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return STCONNECTLOGAvgAggregateOutputType(query);
  }

  STCONNECTLOGSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return STCONNECTLOGSumAggregateOutputType(query);
  }

  STCONNECTLOGMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return STCONNECTLOGMinAggregateOutputType(query);
  }

  STCONNECTLOGMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return STCONNECTLOGMaxAggregateOutputType(query);
  }
}

class AggregateSTCONTENTSFILE {
  const AggregateSTCONTENTSFILE(this.$query);

  final _i1.PrismaFluentQuery $query;

  STCONTENTSFILECountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return STCONTENTSFILECountAggregateOutputType(query);
  }

  STCONTENTSFILEAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return STCONTENTSFILEAvgAggregateOutputType(query);
  }

  STCONTENTSFILESumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return STCONTENTSFILESumAggregateOutputType(query);
  }

  STCONTENTSFILEMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return STCONTENTSFILEMinAggregateOutputType(query);
  }

  STCONTENTSFILEMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return STCONTENTSFILEMaxAggregateOutputType(query);
  }
}

class AggregateSTCONTENTSMST {
  const AggregateSTCONTENTSMST(this.$query);

  final _i1.PrismaFluentQuery $query;

  STCONTENTSMSTCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return STCONTENTSMSTCountAggregateOutputType(query);
  }

  STCONTENTSMSTAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return STCONTENTSMSTAvgAggregateOutputType(query);
  }

  STCONTENTSMSTSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return STCONTENTSMSTSumAggregateOutputType(query);
  }

  STCONTENTSMSTMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return STCONTENTSMSTMinAggregateOutputType(query);
  }

  STCONTENTSMSTMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return STCONTENTSMSTMaxAggregateOutputType(query);
  }
}

class AggregateSTDEPT {
  const AggregateSTDEPT(this.$query);

  final _i1.PrismaFluentQuery $query;

  STDEPTCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return STDEPTCountAggregateOutputType(query);
  }

  STDEPTAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return STDEPTAvgAggregateOutputType(query);
  }

  STDEPTSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return STDEPTSumAggregateOutputType(query);
  }

  STDEPTMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return STDEPTMinAggregateOutputType(query);
  }

  STDEPTMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return STDEPTMaxAggregateOutputType(query);
  }
}

class AggregateSTDEPTEMP {
  const AggregateSTDEPTEMP(this.$query);

  final _i1.PrismaFluentQuery $query;

  STDEPTEMPCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return STDEPTEMPCountAggregateOutputType(query);
  }

  STDEPTEMPMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return STDEPTEMPMinAggregateOutputType(query);
  }

  STDEPTEMPMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return STDEPTEMPMaxAggregateOutputType(query);
  }
}

class AggregateSTMENU {
  const AggregateSTMENU(this.$query);

  final _i1.PrismaFluentQuery $query;

  STMENUCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return STMENUCountAggregateOutputType(query);
  }

  STMENUAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return STMENUAvgAggregateOutputType(query);
  }

  STMENUSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return STMENUSumAggregateOutputType(query);
  }

  STMENUMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return STMENUMinAggregateOutputType(query);
  }

  STMENUMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return STMENUMaxAggregateOutputType(query);
  }
}

class AggregateSTMESSAGETMPLAT {
  const AggregateSTMESSAGETMPLAT(this.$query);

  final _i1.PrismaFluentQuery $query;

  STMESSAGETMPLATCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return STMESSAGETMPLATCountAggregateOutputType(query);
  }

  STMESSAGETMPLATMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return STMESSAGETMPLATMinAggregateOutputType(query);
  }

  STMESSAGETMPLATMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return STMESSAGETMPLATMaxAggregateOutputType(query);
  }
}

class AggregateSTMIMETYPE {
  const AggregateSTMIMETYPE(this.$query);

  final _i1.PrismaFluentQuery $query;

  STMIMETYPECountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return STMIMETYPECountAggregateOutputType(query);
  }

  STMIMETYPEAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return STMIMETYPEAvgAggregateOutputType(query);
  }

  STMIMETYPESumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return STMIMETYPESumAggregateOutputType(query);
  }

  STMIMETYPEMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return STMIMETYPEMinAggregateOutputType(query);
  }

  STMIMETYPEMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return STMIMETYPEMaxAggregateOutputType(query);
  }
}

class AggregateSTMNGRGRP {
  const AggregateSTMNGRGRP(this.$query);

  final _i1.PrismaFluentQuery $query;

  STMNGRGRPCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return STMNGRGRPCountAggregateOutputType(query);
  }

  STMNGRGRPAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return STMNGRGRPAvgAggregateOutputType(query);
  }

  STMNGRGRPSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return STMNGRGRPSumAggregateOutputType(query);
  }

  STMNGRGRPMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return STMNGRGRPMinAggregateOutputType(query);
  }

  STMNGRGRPMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return STMNGRGRPMaxAggregateOutputType(query);
  }
}

class AggregateSTMNGRMST {
  const AggregateSTMNGRMST(this.$query);

  final _i1.PrismaFluentQuery $query;

  STMNGRMSTCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return STMNGRMSTCountAggregateOutputType(query);
  }

  STMNGRMSTAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return STMNGRMSTAvgAggregateOutputType(query);
  }

  STMNGRMSTSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return STMNGRMSTSumAggregateOutputType(query);
  }

  STMNGRMSTMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return STMNGRMSTMinAggregateOutputType(query);
  }

  STMNGRMSTMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return STMNGRMSTMaxAggregateOutputType(query);
  }
}

class AggregateSTMYSTNG {
  const AggregateSTMYSTNG(this.$query);

  final _i1.PrismaFluentQuery $query;

  STMYSTNGCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return STMYSTNGCountAggregateOutputType(query);
  }

  STMYSTNGMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return STMYSTNGMinAggregateOutputType(query);
  }

  STMYSTNGMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return STMYSTNGMaxAggregateOutputType(query);
  }
}

class AggregateSTPERMDTL {
  const AggregateSTPERMDTL(this.$query);

  final _i1.PrismaFluentQuery $query;

  STPERMDTLCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return STPERMDTLCountAggregateOutputType(query);
  }

  STPERMDTLMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return STPERMDTLMinAggregateOutputType(query);
  }

  STPERMDTLMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return STPERMDTLMaxAggregateOutputType(query);
  }
}

class AggregateSTPERMMST {
  const AggregateSTPERMMST(this.$query);

  final _i1.PrismaFluentQuery $query;

  STPERMMSTCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return STPERMMSTCountAggregateOutputType(query);
  }

  STPERMMSTMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return STPERMMSTMinAggregateOutputType(query);
  }

  STPERMMSTMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return STPERMMSTMaxAggregateOutputType(query);
  }
}

class AggregateSTPOPUP {
  const AggregateSTPOPUP(this.$query);

  final _i1.PrismaFluentQuery $query;

  STPOPUPCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return STPOPUPCountAggregateOutputType(query);
  }

  STPOPUPMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return STPOPUPMinAggregateOutputType(query);
  }

  STPOPUPMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return STPOPUPMaxAggregateOutputType(query);
  }
}

class AggregateSTSTNG {
  const AggregateSTSTNG(this.$query);

  final _i1.PrismaFluentQuery $query;

  STSTNGCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return STSTNGCountAggregateOutputType(query);
  }

  STSTNGAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return STSTNGAvgAggregateOutputType(query);
  }

  STSTNGSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return STSTNGSumAggregateOutputType(query);
  }

  STSTNGMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return STSTNGMinAggregateOutputType(query);
  }

  STSTNGMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return STSTNGMaxAggregateOutputType(query);
  }
}

class AggregateSTUSERMST {
  const AggregateSTUSERMST(this.$query);

  final _i1.PrismaFluentQuery $query;

  STUSERMSTCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return STUSERMSTCountAggregateOutputType(query);
  }

  STUSERMSTMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return STUSERMSTMinAggregateOutputType(query);
  }

  STUSERMSTMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return STUSERMSTMaxAggregateOutputType(query);
  }
}

class AggregateWORKREPORTDETAILTBL {
  const AggregateWORKREPORTDETAILTBL(this.$query);

  final _i1.PrismaFluentQuery $query;

  WORKREPORTDETAILTBLCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return WORKREPORTDETAILTBLCountAggregateOutputType(query);
  }

  WORKREPORTDETAILTBLAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return WORKREPORTDETAILTBLAvgAggregateOutputType(query);
  }

  WORKREPORTDETAILTBLSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return WORKREPORTDETAILTBLSumAggregateOutputType(query);
  }

  WORKREPORTDETAILTBLMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return WORKREPORTDETAILTBLMinAggregateOutputType(query);
  }

  WORKREPORTDETAILTBLMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return WORKREPORTDETAILTBLMaxAggregateOutputType(query);
  }
}

class AggregateWORKREPORTHTMLTBL {
  const AggregateWORKREPORTHTMLTBL(this.$query);

  final _i1.PrismaFluentQuery $query;

  WORKREPORTHTMLTBLCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return WORKREPORTHTMLTBLCountAggregateOutputType(query);
  }

  WORKREPORTHTMLTBLMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return WORKREPORTHTMLTBLMinAggregateOutputType(query);
  }

  WORKREPORTHTMLTBLMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return WORKREPORTHTMLTBLMaxAggregateOutputType(query);
  }
}

class AggregateWORKREPORTHTMLTBLBACK {
  const AggregateWORKREPORTHTMLTBLBACK(this.$query);

  final _i1.PrismaFluentQuery $query;

  WORKREPORTHTMLTBLBACKCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return WORKREPORTHTMLTBLBACKCountAggregateOutputType(query);
  }

  WORKREPORTHTMLTBLBACKMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return WORKREPORTHTMLTBLBACKMinAggregateOutputType(query);
  }

  WORKREPORTHTMLTBLBACKMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return WORKREPORTHTMLTBLBACKMaxAggregateOutputType(query);
  }
}

class AggregateWORKREPORTMASTERTBL {
  const AggregateWORKREPORTMASTERTBL(this.$query);

  final _i1.PrismaFluentQuery $query;

  WORKREPORTMASTERTBLCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return WORKREPORTMASTERTBLCountAggregateOutputType(query);
  }

  WORKREPORTMASTERTBLMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return WORKREPORTMASTERTBLMinAggregateOutputType(query);
  }

  WORKREPORTMASTERTBLMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return WORKREPORTMASTERTBLMaxAggregateOutputType(query);
  }
}

class AggregateWORKREQUESTMST {
  const AggregateWORKREQUESTMST(this.$query);

  final _i1.PrismaFluentQuery $query;

  WORKREQUESTMSTCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return WORKREQUESTMSTCountAggregateOutputType(query);
  }

  WORKREQUESTMSTAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return WORKREQUESTMSTAvgAggregateOutputType(query);
  }

  WORKREQUESTMSTSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return WORKREQUESTMSTSumAggregateOutputType(query);
  }

  WORKREQUESTMSTMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return WORKREQUESTMSTMinAggregateOutputType(query);
  }

  WORKREQUESTMSTMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return WORKREQUESTMSTMaxAggregateOutputType(query);
  }
}

class AggregateWORKREQUESTREF {
  const AggregateWORKREQUESTREF(this.$query);

  final _i1.PrismaFluentQuery $query;

  WORKREQUESTREFCountAggregateOutputType $count() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_count',
          fields: fields,
        )
      ]),
      key: r'_count',
    );
    return WORKREQUESTREFCountAggregateOutputType(query);
  }

  WORKREQUESTREFAvgAggregateOutputType $avg() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_avg',
          fields: fields,
        )
      ]),
      key: r'_avg',
    );
    return WORKREQUESTREFAvgAggregateOutputType(query);
  }

  WORKREQUESTREFSumAggregateOutputType $sum() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_sum',
          fields: fields,
        )
      ]),
      key: r'_sum',
    );
    return WORKREQUESTREFSumAggregateOutputType(query);
  }

  WORKREQUESTREFMinAggregateOutputType $min() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_min',
          fields: fields,
        )
      ]),
      key: r'_min',
    );
    return WORKREQUESTREFMinAggregateOutputType(query);
  }

  WORKREQUESTREFMaxAggregateOutputType $max() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_max',
          fields: fields,
        )
      ]),
      key: r'_max',
    );
    return WORKREQUESTREFMaxAggregateOutputType(query);
  }
}

class ALLCODETBLCountAggregateOutputType {
  const ALLCODETBLCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> codeType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CODE_TYPE',
          fields: fields,
        )
      ]),
      key: r'CODE_TYPE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> codeName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CODE_NAME',
          fields: fields,
        )
      ]),
      key: r'CODE_NAME',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> unitType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UNIT_TYPE',
          fields: fields,
        )
      ]),
      key: r'UNIT_TYPE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> unitName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UNIT_NAME',
          fields: fields,
        )
      ]),
      key: r'UNIT_NAME',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class ALLCODETBLAvgAggregateOutputType {
  const ALLCODETBLAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class ALLCODETBLSumAggregateOutputType {
  const ALLCODETBLSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class ALLCODETBLMinAggregateOutputType {
  const ALLCODETBLMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> codeType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CODE_TYPE',
          fields: fields,
        )
      ]),
      key: r'CODE_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> codeName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CODE_NAME',
          fields: fields,
        )
      ]),
      key: r'CODE_NAME',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> unitType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UNIT_TYPE',
          fields: fields,
        )
      ]),
      key: r'UNIT_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> unitName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UNIT_NAME',
          fields: fields,
        )
      ]),
      key: r'UNIT_NAME',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }
}

class ALLCODETBLMaxAggregateOutputType {
  const ALLCODETBLMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> codeType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CODE_TYPE',
          fields: fields,
        )
      ]),
      key: r'CODE_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> codeName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CODE_NAME',
          fields: fields,
        )
      ]),
      key: r'CODE_NAME',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> unitType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UNIT_TYPE',
          fields: fields,
        )
      ]),
      key: r'UNIT_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> unitName() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UNIT_NAME',
          fields: fields,
        )
      ]),
      key: r'UNIT_NAME',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }
}

class APPROVALATTACHFILETBLCountAggregateOutputType {
  const APPROVALATTACHFILETBLCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> approvalId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_ID',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> oriFileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ORI_FILE_NM',
          fields: fields,
        )
      ]),
      key: r'ORI_FILE_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> saveFileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SAVE_FILE_NM',
          fields: fields,
        )
      ]),
      key: r'SAVE_FILE_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> fileSize() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_SIZE',
          fields: fields,
        )
      ]),
      key: r'FILE_SIZE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class APPROVALATTACHFILETBLAvgAggregateOutputType {
  const APPROVALATTACHFILETBLAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> fileSize() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_SIZE',
          fields: fields,
        )
      ]),
      key: r'FILE_SIZE',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class APPROVALATTACHFILETBLSumAggregateOutputType {
  const APPROVALATTACHFILETBLSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<int?> fileSize() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_SIZE',
          fields: fields,
        )
      ]),
      key: r'FILE_SIZE',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class APPROVALATTACHFILETBLMinAggregateOutputType {
  const APPROVALATTACHFILETBLMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> approvalId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_ID',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<double?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<String?> oriFileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ORI_FILE_NM',
          fields: fields,
        )
      ]),
      key: r'ORI_FILE_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> saveFileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SAVE_FILE_NM',
          fields: fields,
        )
      ]),
      key: r'SAVE_FILE_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> fileSize() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_SIZE',
          fields: fields,
        )
      ]),
      key: r'FILE_SIZE',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }
}

class APPROVALATTACHFILETBLMaxAggregateOutputType {
  const APPROVALATTACHFILETBLMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> approvalId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_ID',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<double?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<String?> oriFileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ORI_FILE_NM',
          fields: fields,
        )
      ]),
      key: r'ORI_FILE_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> saveFileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SAVE_FILE_NM',
          fields: fields,
        )
      ]),
      key: r'SAVE_FILE_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> fileSize() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_SIZE',
          fields: fields,
        )
      ]),
      key: r'FILE_SIZE',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }
}

class APPROVALDOCINFOTBLCountAggregateOutputType {
  const APPROVALDOCINFOTBLCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> docType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DOC_TYPE',
          fields: fields,
        )
      ]),
      key: r'DOC_TYPE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> docNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DOC_NM',
          fields: fields,
        )
      ]),
      key: r'DOC_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> title() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'TITLE',
          fields: fields,
        )
      ]),
      key: r'TITLE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> approvalLineType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_LINE_TYPE',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_LINE_TYPE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> approvalLineContent() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_LINE_CONTENT',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_LINE_CONTENT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> approvalLineContentBak() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_LINE_CONTENT_BAK',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_LINE_CONTENT_BAK',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> content() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CONTENT',
          fields: fields,
        )
      ]),
      key: r'CONTENT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> writerId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITER_ID',
          fields: fields,
        )
      ]),
      key: r'WRITER_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> userNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_NM',
          fields: fields,
        )
      ]),
      key: r'USER_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class APPROVALDOCINFOTBLAvgAggregateOutputType {
  const APPROVALDOCINFOTBLAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class APPROVALDOCINFOTBLSumAggregateOutputType {
  const APPROVALDOCINFOTBLSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class APPROVALDOCINFOTBLMinAggregateOutputType {
  const APPROVALDOCINFOTBLMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> docType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DOC_TYPE',
          fields: fields,
        )
      ]),
      key: r'DOC_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> docNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DOC_NM',
          fields: fields,
        )
      ]),
      key: r'DOC_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> title() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'TITLE',
          fields: fields,
        )
      ]),
      key: r'TITLE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> approvalLineType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_LINE_TYPE',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_LINE_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> approvalLineContent() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_LINE_CONTENT',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_LINE_CONTENT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> approvalLineContentBak() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_LINE_CONTENT_BAK',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_LINE_CONTENT_BAK',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> content() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CONTENT',
          fields: fields,
        )
      ]),
      key: r'CONTENT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> writerId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITER_ID',
          fields: fields,
        )
      ]),
      key: r'WRITER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> userNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_NM',
          fields: fields,
        )
      ]),
      key: r'USER_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<String?> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class APPROVALDOCINFOTBLMaxAggregateOutputType {
  const APPROVALDOCINFOTBLMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> docType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DOC_TYPE',
          fields: fields,
        )
      ]),
      key: r'DOC_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> docNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DOC_NM',
          fields: fields,
        )
      ]),
      key: r'DOC_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> title() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'TITLE',
          fields: fields,
        )
      ]),
      key: r'TITLE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> approvalLineType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_LINE_TYPE',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_LINE_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> approvalLineContent() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_LINE_CONTENT',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_LINE_CONTENT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> approvalLineContentBak() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_LINE_CONTENT_BAK',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_LINE_CONTENT_BAK',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> content() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CONTENT',
          fields: fields,
        )
      ]),
      key: r'CONTENT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> writerId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITER_ID',
          fields: fields,
        )
      ]),
      key: r'WRITER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> userNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_NM',
          fields: fields,
        )
      ]),
      key: r'USER_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<String?> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class APPROVALHISTORYTBLCountAggregateOutputType {
  const APPROVALHISTORYTBLCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> approvalId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_ID',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> writerId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITER_ID',
          fields: fields,
        )
      ]),
      key: r'WRITER_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> writerNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITER_NM',
          fields: fields,
        )
      ]),
      key: r'WRITER_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> docType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DOC_TYPE',
          fields: fields,
        )
      ]),
      key: r'DOC_TYPE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> keepPriod() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'KEEP_PRIOD',
          fields: fields,
        )
      ]),
      key: r'KEEP_PRIOD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> keepDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'KEEP_DATE',
          fields: fields,
        )
      ]),
      key: r'KEEP_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> grade() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'GRADE',
          fields: fields,
        )
      ]),
      key: r'GRADE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> status() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STATUS',
          fields: fields,
        )
      ]),
      key: r'STATUS',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> content() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CONTENT',
          fields: fields,
        )
      ]),
      key: r'CONTENT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class APPROVALHISTORYTBLAvgAggregateOutputType {
  const APPROVALHISTORYTBLAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> keepPriod() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'KEEP_PRIOD',
          fields: fields,
        )
      ]),
      key: r'KEEP_PRIOD',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class APPROVALHISTORYTBLSumAggregateOutputType {
  const APPROVALHISTORYTBLSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<int?> keepPriod() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'KEEP_PRIOD',
          fields: fields,
        )
      ]),
      key: r'KEEP_PRIOD',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class APPROVALHISTORYTBLMinAggregateOutputType {
  const APPROVALHISTORYTBLMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> approvalId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_ID',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> writerId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITER_ID',
          fields: fields,
        )
      ]),
      key: r'WRITER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> writerNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITER_NM',
          fields: fields,
        )
      ]),
      key: r'WRITER_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> docType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DOC_TYPE',
          fields: fields,
        )
      ]),
      key: r'DOC_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> keepPriod() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'KEEP_PRIOD',
          fields: fields,
        )
      ]),
      key: r'KEEP_PRIOD',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<DateTime?> keepDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'KEEP_DATE',
          fields: fields,
        )
      ]),
      key: r'KEEP_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<String?> grade() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'GRADE',
          fields: fields,
        )
      ]),
      key: r'GRADE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> status() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STATUS',
          fields: fields,
        )
      ]),
      key: r'STATUS',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> content() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CONTENT',
          fields: fields,
        )
      ]),
      key: r'CONTENT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class APPROVALHISTORYTBLMaxAggregateOutputType {
  const APPROVALHISTORYTBLMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> approvalId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_ID',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> writerId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITER_ID',
          fields: fields,
        )
      ]),
      key: r'WRITER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> writerNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITER_NM',
          fields: fields,
        )
      ]),
      key: r'WRITER_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> docType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DOC_TYPE',
          fields: fields,
        )
      ]),
      key: r'DOC_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> keepPriod() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'KEEP_PRIOD',
          fields: fields,
        )
      ]),
      key: r'KEEP_PRIOD',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<DateTime?> keepDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'KEEP_DATE',
          fields: fields,
        )
      ]),
      key: r'KEEP_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<String?> grade() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'GRADE',
          fields: fields,
        )
      ]),
      key: r'GRADE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> status() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STATUS',
          fields: fields,
        )
      ]),
      key: r'STATUS',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> content() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CONTENT',
          fields: fields,
        )
      ]),
      key: r'CONTENT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class APPROVALMASTERTBLCountAggregateOutputType {
  const APPROVALMASTERTBLCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> approvalId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_ID',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> writerId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITER_ID',
          fields: fields,
        )
      ]),
      key: r'WRITER_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> writerNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITER_NM',
          fields: fields,
        )
      ]),
      key: r'WRITER_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> docType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DOC_TYPE',
          fields: fields,
        )
      ]),
      key: r'DOC_TYPE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> keepPriod() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'KEEP_PRIOD',
          fields: fields,
        )
      ]),
      key: r'KEEP_PRIOD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> keepDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'KEEP_DATE',
          fields: fields,
        )
      ]),
      key: r'KEEP_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> grade() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'GRADE',
          fields: fields,
        )
      ]),
      key: r'GRADE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> status() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STATUS',
          fields: fields,
        )
      ]),
      key: r'STATUS',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> title() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'TITLE',
          fields: fields,
        )
      ]),
      key: r'TITLE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> header() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'HEADER',
          fields: fields,
        )
      ]),
      key: r'HEADER',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> content() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CONTENT',
          fields: fields,
        )
      ]),
      key: r'CONTENT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> m1() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M1',
          fields: fields,
        )
      ]),
      key: r'M1',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> m2() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M2',
          fields: fields,
        )
      ]),
      key: r'M2',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> m3() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M3',
          fields: fields,
        )
      ]),
      key: r'M3',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> m4() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M4',
          fields: fields,
        )
      ]),
      key: r'M4',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> m5() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M5',
          fields: fields,
        )
      ]),
      key: r'M5',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> m6() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M6',
          fields: fields,
        )
      ]),
      key: r'M6',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> m7() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M7',
          fields: fields,
        )
      ]),
      key: r'M7',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> m8() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M8',
          fields: fields,
        )
      ]),
      key: r'M8',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> m9() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M9',
          fields: fields,
        )
      ]),
      key: r'M9',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> m10() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M10',
          fields: fields,
        )
      ]),
      key: r'M10',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> m11() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M11',
          fields: fields,
        )
      ]),
      key: r'M11',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> m12() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M12',
          fields: fields,
        )
      ]),
      key: r'M12',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> completeDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'COMPLETE_DATE',
          fields: fields,
        )
      ]),
      key: r'COMPLETE_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class APPROVALMASTERTBLAvgAggregateOutputType {
  const APPROVALMASTERTBLAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> keepPriod() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'KEEP_PRIOD',
          fields: fields,
        )
      ]),
      key: r'KEEP_PRIOD',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m1() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M1',
          fields: fields,
        )
      ]),
      key: r'M1',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m2() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M2',
          fields: fields,
        )
      ]),
      key: r'M2',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m3() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M3',
          fields: fields,
        )
      ]),
      key: r'M3',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m4() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M4',
          fields: fields,
        )
      ]),
      key: r'M4',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m5() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M5',
          fields: fields,
        )
      ]),
      key: r'M5',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m6() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M6',
          fields: fields,
        )
      ]),
      key: r'M6',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m7() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M7',
          fields: fields,
        )
      ]),
      key: r'M7',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m8() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M8',
          fields: fields,
        )
      ]),
      key: r'M8',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m9() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M9',
          fields: fields,
        )
      ]),
      key: r'M9',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m10() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M10',
          fields: fields,
        )
      ]),
      key: r'M10',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m11() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M11',
          fields: fields,
        )
      ]),
      key: r'M11',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m12() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M12',
          fields: fields,
        )
      ]),
      key: r'M12',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class APPROVALMASTERTBLSumAggregateOutputType {
  const APPROVALMASTERTBLSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> keepPriod() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'KEEP_PRIOD',
          fields: fields,
        )
      ]),
      key: r'KEEP_PRIOD',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<double?> m1() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M1',
          fields: fields,
        )
      ]),
      key: r'M1',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m2() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M2',
          fields: fields,
        )
      ]),
      key: r'M2',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m3() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M3',
          fields: fields,
        )
      ]),
      key: r'M3',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m4() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M4',
          fields: fields,
        )
      ]),
      key: r'M4',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m5() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M5',
          fields: fields,
        )
      ]),
      key: r'M5',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m6() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M6',
          fields: fields,
        )
      ]),
      key: r'M6',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m7() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M7',
          fields: fields,
        )
      ]),
      key: r'M7',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m8() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M8',
          fields: fields,
        )
      ]),
      key: r'M8',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m9() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M9',
          fields: fields,
        )
      ]),
      key: r'M9',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m10() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M10',
          fields: fields,
        )
      ]),
      key: r'M10',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m11() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M11',
          fields: fields,
        )
      ]),
      key: r'M11',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m12() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M12',
          fields: fields,
        )
      ]),
      key: r'M12',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class APPROVALMASTERTBLMinAggregateOutputType {
  const APPROVALMASTERTBLMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> approvalId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_ID',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> writerId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITER_ID',
          fields: fields,
        )
      ]),
      key: r'WRITER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> writerNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITER_NM',
          fields: fields,
        )
      ]),
      key: r'WRITER_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> docType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DOC_TYPE',
          fields: fields,
        )
      ]),
      key: r'DOC_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> keepPriod() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'KEEP_PRIOD',
          fields: fields,
        )
      ]),
      key: r'KEEP_PRIOD',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<DateTime?> keepDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'KEEP_DATE',
          fields: fields,
        )
      ]),
      key: r'KEEP_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<String?> grade() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'GRADE',
          fields: fields,
        )
      ]),
      key: r'GRADE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> status() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STATUS',
          fields: fields,
        )
      ]),
      key: r'STATUS',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> title() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'TITLE',
          fields: fields,
        )
      ]),
      key: r'TITLE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> header() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'HEADER',
          fields: fields,
        )
      ]),
      key: r'HEADER',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> content() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CONTENT',
          fields: fields,
        )
      ]),
      key: r'CONTENT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<double?> m1() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M1',
          fields: fields,
        )
      ]),
      key: r'M1',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m2() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M2',
          fields: fields,
        )
      ]),
      key: r'M2',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m3() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M3',
          fields: fields,
        )
      ]),
      key: r'M3',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m4() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M4',
          fields: fields,
        )
      ]),
      key: r'M4',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m5() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M5',
          fields: fields,
        )
      ]),
      key: r'M5',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m6() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M6',
          fields: fields,
        )
      ]),
      key: r'M6',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m7() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M7',
          fields: fields,
        )
      ]),
      key: r'M7',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m8() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M8',
          fields: fields,
        )
      ]),
      key: r'M8',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m9() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M9',
          fields: fields,
        )
      ]),
      key: r'M9',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m10() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M10',
          fields: fields,
        )
      ]),
      key: r'M10',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m11() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M11',
          fields: fields,
        )
      ]),
      key: r'M11',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m12() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M12',
          fields: fields,
        )
      ]),
      key: r'M12',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> completeDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'COMPLETE_DATE',
          fields: fields,
        )
      ]),
      key: r'COMPLETE_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class APPROVALMASTERTBLMaxAggregateOutputType {
  const APPROVALMASTERTBLMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> approvalId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_ID',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> writerId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITER_ID',
          fields: fields,
        )
      ]),
      key: r'WRITER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> writerNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITER_NM',
          fields: fields,
        )
      ]),
      key: r'WRITER_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> docType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DOC_TYPE',
          fields: fields,
        )
      ]),
      key: r'DOC_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> keepPriod() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'KEEP_PRIOD',
          fields: fields,
        )
      ]),
      key: r'KEEP_PRIOD',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<DateTime?> keepDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'KEEP_DATE',
          fields: fields,
        )
      ]),
      key: r'KEEP_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<String?> grade() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'GRADE',
          fields: fields,
        )
      ]),
      key: r'GRADE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> status() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STATUS',
          fields: fields,
        )
      ]),
      key: r'STATUS',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> title() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'TITLE',
          fields: fields,
        )
      ]),
      key: r'TITLE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> header() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'HEADER',
          fields: fields,
        )
      ]),
      key: r'HEADER',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> content() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CONTENT',
          fields: fields,
        )
      ]),
      key: r'CONTENT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<double?> m1() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M1',
          fields: fields,
        )
      ]),
      key: r'M1',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m2() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M2',
          fields: fields,
        )
      ]),
      key: r'M2',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m3() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M3',
          fields: fields,
        )
      ]),
      key: r'M3',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m4() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M4',
          fields: fields,
        )
      ]),
      key: r'M4',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m5() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M5',
          fields: fields,
        )
      ]),
      key: r'M5',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m6() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M6',
          fields: fields,
        )
      ]),
      key: r'M6',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m7() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M7',
          fields: fields,
        )
      ]),
      key: r'M7',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m8() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M8',
          fields: fields,
        )
      ]),
      key: r'M8',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m9() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M9',
          fields: fields,
        )
      ]),
      key: r'M9',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m10() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M10',
          fields: fields,
        )
      ]),
      key: r'M10',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m11() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M11',
          fields: fields,
        )
      ]),
      key: r'M11',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m12() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M12',
          fields: fields,
        )
      ]),
      key: r'M12',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> completeDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'COMPLETE_DATE',
          fields: fields,
        )
      ]),
      key: r'COMPLETE_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class APPROVALMEMOTBLCountAggregateOutputType {
  const APPROVALMEMOTBLCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> approvalId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_ID',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> writerId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITER_ID',
          fields: fields,
        )
      ]),
      key: r'WRITER_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> writerNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITER_NM',
          fields: fields,
        )
      ]),
      key: r'WRITER_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> content() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CONTENT',
          fields: fields,
        )
      ]),
      key: r'CONTENT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class APPROVALMEMOTBLAvgAggregateOutputType {
  const APPROVALMEMOTBLAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class APPROVALMEMOTBLSumAggregateOutputType {
  const APPROVALMEMOTBLSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class APPROVALMEMOTBLMinAggregateOutputType {
  const APPROVALMEMOTBLMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> approvalId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_ID',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> writerId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITER_ID',
          fields: fields,
        )
      ]),
      key: r'WRITER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> writerNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITER_NM',
          fields: fields,
        )
      ]),
      key: r'WRITER_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> content() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CONTENT',
          fields: fields,
        )
      ]),
      key: r'CONTENT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class APPROVALMEMOTBLMaxAggregateOutputType {
  const APPROVALMEMOTBLMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> approvalId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_ID',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> writerId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITER_ID',
          fields: fields,
        )
      ]),
      key: r'WRITER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> writerNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITER_NM',
          fields: fields,
        )
      ]),
      key: r'WRITER_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> content() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CONTENT',
          fields: fields,
        )
      ]),
      key: r'CONTENT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class APPROVALTYPETBLCountAggregateOutputType {
  const APPROVALTYPETBLCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> type() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'TYPE',
          fields: fields,
        )
      ]),
      key: r'TYPE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> content() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CONTENT',
          fields: fields,
        )
      ]),
      key: r'CONTENT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> contentBak() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CONTENT_BAK',
          fields: fields,
        )
      ]),
      key: r'CONTENT_BAK',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class APPROVALTYPETBLMinAggregateOutputType {
  const APPROVALTYPETBLMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> type() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'TYPE',
          fields: fields,
        )
      ]),
      key: r'TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> content() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CONTENT',
          fields: fields,
        )
      ]),
      key: r'CONTENT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> contentBak() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CONTENT_BAK',
          fields: fields,
        )
      ]),
      key: r'CONTENT_BAK',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class APPROVALTYPETBLMaxAggregateOutputType {
  const APPROVALTYPETBLMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> type() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'TYPE',
          fields: fields,
        )
      ]),
      key: r'TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> content() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CONTENT',
          fields: fields,
        )
      ]),
      key: r'CONTENT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> contentBak() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CONTENT_BAK',
          fields: fields,
        )
      ]),
      key: r'CONTENT_BAK',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class APPROVALUSERTBLCountAggregateOutputType {
  const APPROVALUSERTBLCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> approvalId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_ID',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> approvalUsrId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_USR_ID',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_USR_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> approvalUsrGradeCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_USR_GRADE_CD',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_USR_GRADE_CD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> approvalUsrType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_USR_TYPE',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_USR_TYPE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> approvalUsrSort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_USR_SORT',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_USR_SORT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> approvalProcUserYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_PROC_USER_YN',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_PROC_USER_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> approvalProcYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_PROC_YN',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_PROC_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> approvalProcDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_PROC_DATE',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_PROC_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class APPROVALUSERTBLAvgAggregateOutputType {
  const APPROVALUSERTBLAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> approvalUsrSort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_USR_SORT',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_USR_SORT',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class APPROVALUSERTBLSumAggregateOutputType {
  const APPROVALUSERTBLSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> approvalUsrSort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_USR_SORT',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_USR_SORT',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class APPROVALUSERTBLMinAggregateOutputType {
  const APPROVALUSERTBLMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> approvalId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_ID',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> approvalUsrId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_USR_ID',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_USR_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> approvalUsrGradeCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_USR_GRADE_CD',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_USR_GRADE_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> approvalUsrType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_USR_TYPE',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_USR_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> approvalUsrSort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_USR_SORT',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_USR_SORT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> approvalProcUserYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_PROC_USER_YN',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_PROC_USER_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> approvalProcYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_PROC_YN',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_PROC_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> approvalProcDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_PROC_DATE',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_PROC_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class APPROVALUSERTBLMaxAggregateOutputType {
  const APPROVALUSERTBLMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> approvalId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_ID',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> approvalUsrId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_USR_ID',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_USR_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> approvalUsrGradeCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_USR_GRADE_CD',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_USR_GRADE_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> approvalUsrType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_USR_TYPE',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_USR_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> approvalUsrSort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_USR_SORT',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_USR_SORT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> approvalProcUserYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_PROC_USER_YN',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_PROC_USER_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> approvalProcYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_PROC_YN',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_PROC_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> approvalProcDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPROVAL_PROC_DATE',
          fields: fields,
        )
      ]),
      key: r'APPROVAL_PROC_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class BOOKASSETTBLCountAggregateOutputType {
  const BOOKASSETTBLCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> assetNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ASSET_NO',
          fields: fields,
        )
      ]),
      key: r'ASSET_NO',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> bookNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BOOK_NM',
          fields: fields,
        )
      ]),
      key: r'BOOK_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> cnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CNT',
          fields: fields,
        )
      ]),
      key: r'CNT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> publisher() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PUBLISHER',
          fields: fields,
        )
      ]),
      key: r'PUBLISHER',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> amount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'AMOUNT',
          fields: fields,
        )
      ]),
      key: r'AMOUNT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> buyDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BUY_DATE',
          fields: fields,
        )
      ]),
      key: r'BUY_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> mngDept() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MNG_DEPT',
          fields: fields,
        )
      ]),
      key: r'MNG_DEPT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> rentYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RENT_YN',
          fields: fields,
        )
      ]),
      key: r'RENT_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> rentUser() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RENT_USER',
          fields: fields,
        )
      ]),
      key: r'RENT_USER',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> remarks() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REMARKS',
          fields: fields,
        )
      ]),
      key: r'REMARKS',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class BOOKASSETTBLAvgAggregateOutputType {
  const BOOKASSETTBLAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> cnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CNT',
          fields: fields,
        )
      ]),
      key: r'CNT',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> amount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'AMOUNT',
          fields: fields,
        )
      ]),
      key: r'AMOUNT',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class BOOKASSETTBLSumAggregateOutputType {
  const BOOKASSETTBLSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<int?> cnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CNT',
          fields: fields,
        )
      ]),
      key: r'CNT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> amount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'AMOUNT',
          fields: fields,
        )
      ]),
      key: r'AMOUNT',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class BOOKASSETTBLMinAggregateOutputType {
  const BOOKASSETTBLMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> assetNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ASSET_NO',
          fields: fields,
        )
      ]),
      key: r'ASSET_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> bookNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BOOK_NM',
          fields: fields,
        )
      ]),
      key: r'BOOK_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> cnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CNT',
          fields: fields,
        )
      ]),
      key: r'CNT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> publisher() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PUBLISHER',
          fields: fields,
        )
      ]),
      key: r'PUBLISHER',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> amount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'AMOUNT',
          fields: fields,
        )
      ]),
      key: r'AMOUNT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> buyDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BUY_DATE',
          fields: fields,
        )
      ]),
      key: r'BUY_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> mngDept() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MNG_DEPT',
          fields: fields,
        )
      ]),
      key: r'MNG_DEPT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> rentYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RENT_YN',
          fields: fields,
        )
      ]),
      key: r'RENT_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> rentUser() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RENT_USER',
          fields: fields,
        )
      ]),
      key: r'RENT_USER',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> remarks() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REMARKS',
          fields: fields,
        )
      ]),
      key: r'REMARKS',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }
}

class BOOKASSETTBLMaxAggregateOutputType {
  const BOOKASSETTBLMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> assetNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ASSET_NO',
          fields: fields,
        )
      ]),
      key: r'ASSET_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> bookNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BOOK_NM',
          fields: fields,
        )
      ]),
      key: r'BOOK_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> cnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CNT',
          fields: fields,
        )
      ]),
      key: r'CNT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> publisher() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PUBLISHER',
          fields: fields,
        )
      ]),
      key: r'PUBLISHER',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> amount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'AMOUNT',
          fields: fields,
        )
      ]),
      key: r'AMOUNT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> buyDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BUY_DATE',
          fields: fields,
        )
      ]),
      key: r'BUY_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> mngDept() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MNG_DEPT',
          fields: fields,
        )
      ]),
      key: r'MNG_DEPT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> rentYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RENT_YN',
          fields: fields,
        )
      ]),
      key: r'RENT_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> rentUser() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RENT_USER',
          fields: fields,
        )
      ]),
      key: r'RENT_USER',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> remarks() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REMARKS',
          fields: fields,
        )
      ]),
      key: r'REMARKS',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }
}

class CARASSETINSURTBLCountAggregateOutputType {
  const CARASSETINSURTBLCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> mseq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSEQ',
          fields: fields,
        )
      ]),
      key: r'MSEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> guarantee() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'GUARANTEE',
          fields: fields,
        )
      ]),
      key: r'GUARANTEE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class CARASSETINSURTBLAvgAggregateOutputType {
  const CARASSETINSURTBLAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> mseq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSEQ',
          fields: fields,
        )
      ]),
      key: r'MSEQ',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class CARASSETINSURTBLSumAggregateOutputType {
  const CARASSETINSURTBLSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> mseq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSEQ',
          fields: fields,
        )
      ]),
      key: r'MSEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class CARASSETINSURTBLMinAggregateOutputType {
  const CARASSETINSURTBLMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> mseq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSEQ',
          fields: fields,
        )
      ]),
      key: r'MSEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> guarantee() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'GUARANTEE',
          fields: fields,
        )
      ]),
      key: r'GUARANTEE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class CARASSETINSURTBLMaxAggregateOutputType {
  const CARASSETINSURTBLMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> mseq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSEQ',
          fields: fields,
        )
      ]),
      key: r'MSEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> guarantee() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'GUARANTEE',
          fields: fields,
        )
      ]),
      key: r'GUARANTEE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class CARASSETTBLCountAggregateOutputType {
  const CARASSETTBLCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> assetNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ASSET_NO',
          fields: fields,
        )
      ]),
      key: r'ASSET_NO',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> modelNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MODEL_NO',
          fields: fields,
        )
      ]),
      key: r'MODEL_NO',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> carNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CAR_NO',
          fields: fields,
        )
      ]),
      key: r'CAR_NO',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> owner() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'OWNER',
          fields: fields,
        )
      ]),
      key: r'OWNER',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> ownerType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'OWNER_TYPE',
          fields: fields,
        )
      ]),
      key: r'OWNER_TYPE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> amount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'AMOUNT',
          fields: fields,
        )
      ]),
      key: r'AMOUNT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> buyDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BUY_DATE',
          fields: fields,
        )
      ]),
      key: r'BUY_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> seller() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SELLER',
          fields: fields,
        )
      ]),
      key: r'SELLER',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> remarks() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REMARKS',
          fields: fields,
        )
      ]),
      key: r'REMARKS',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> mngrNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MNGR_NM',
          fields: fields,
        )
      ]),
      key: r'MNGR_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> fuel() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FUEL',
          fields: fields,
        )
      ]),
      key: r'FUEL',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> manuDt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MANU_DT',
          fields: fields,
        )
      ]),
      key: r'MANU_DT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> effic() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EFFIC',
          fields: fields,
        )
      ]),
      key: r'EFFIC',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> insur() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'INSUR',
          fields: fields,
        )
      ]),
      key: r'INSUR',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> insurMngr() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'INSUR_MNGR',
          fields: fields,
        )
      ]),
      key: r'INSUR_MNGR',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> emgTel() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EMG_TEL',
          fields: fields,
        )
      ]),
      key: r'EMG_TEL',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> storeNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STORE_NM',
          fields: fields,
        )
      ]),
      key: r'STORE_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> storeTel() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STORE_TEL',
          fields: fields,
        )
      ]),
      key: r'STORE_TEL',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class CARASSETTBLAvgAggregateOutputType {
  const CARASSETTBLAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> amount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'AMOUNT',
          fields: fields,
        )
      ]),
      key: r'AMOUNT',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class CARASSETTBLSumAggregateOutputType {
  const CARASSETTBLSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<int?> amount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'AMOUNT',
          fields: fields,
        )
      ]),
      key: r'AMOUNT',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class CARASSETTBLMinAggregateOutputType {
  const CARASSETTBLMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> assetNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ASSET_NO',
          fields: fields,
        )
      ]),
      key: r'ASSET_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> modelNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MODEL_NO',
          fields: fields,
        )
      ]),
      key: r'MODEL_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> carNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CAR_NO',
          fields: fields,
        )
      ]),
      key: r'CAR_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> owner() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'OWNER',
          fields: fields,
        )
      ]),
      key: r'OWNER',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> ownerType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'OWNER_TYPE',
          fields: fields,
        )
      ]),
      key: r'OWNER_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> amount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'AMOUNT',
          fields: fields,
        )
      ]),
      key: r'AMOUNT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> buyDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BUY_DATE',
          fields: fields,
        )
      ]),
      key: r'BUY_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> seller() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SELLER',
          fields: fields,
        )
      ]),
      key: r'SELLER',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> remarks() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REMARKS',
          fields: fields,
        )
      ]),
      key: r'REMARKS',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> mngrNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MNGR_NM',
          fields: fields,
        )
      ]),
      key: r'MNGR_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> fuel() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FUEL',
          fields: fields,
        )
      ]),
      key: r'FUEL',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> manuDt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MANU_DT',
          fields: fields,
        )
      ]),
      key: r'MANU_DT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> effic() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EFFIC',
          fields: fields,
        )
      ]),
      key: r'EFFIC',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> insur() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'INSUR',
          fields: fields,
        )
      ]),
      key: r'INSUR',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> insurMngr() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'INSUR_MNGR',
          fields: fields,
        )
      ]),
      key: r'INSUR_MNGR',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> emgTel() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EMG_TEL',
          fields: fields,
        )
      ]),
      key: r'EMG_TEL',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> storeNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STORE_NM',
          fields: fields,
        )
      ]),
      key: r'STORE_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> storeTel() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STORE_TEL',
          fields: fields,
        )
      ]),
      key: r'STORE_TEL',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }
}

class CARASSETTBLMaxAggregateOutputType {
  const CARASSETTBLMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> assetNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ASSET_NO',
          fields: fields,
        )
      ]),
      key: r'ASSET_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> modelNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MODEL_NO',
          fields: fields,
        )
      ]),
      key: r'MODEL_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> carNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CAR_NO',
          fields: fields,
        )
      ]),
      key: r'CAR_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> owner() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'OWNER',
          fields: fields,
        )
      ]),
      key: r'OWNER',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> ownerType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'OWNER_TYPE',
          fields: fields,
        )
      ]),
      key: r'OWNER_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> amount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'AMOUNT',
          fields: fields,
        )
      ]),
      key: r'AMOUNT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> buyDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BUY_DATE',
          fields: fields,
        )
      ]),
      key: r'BUY_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> seller() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SELLER',
          fields: fields,
        )
      ]),
      key: r'SELLER',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> remarks() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REMARKS',
          fields: fields,
        )
      ]),
      key: r'REMARKS',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> mngrNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MNGR_NM',
          fields: fields,
        )
      ]),
      key: r'MNGR_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> fuel() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FUEL',
          fields: fields,
        )
      ]),
      key: r'FUEL',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> manuDt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MANU_DT',
          fields: fields,
        )
      ]),
      key: r'MANU_DT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> effic() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EFFIC',
          fields: fields,
        )
      ]),
      key: r'EFFIC',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> insur() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'INSUR',
          fields: fields,
        )
      ]),
      key: r'INSUR',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> insurMngr() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'INSUR_MNGR',
          fields: fields,
        )
      ]),
      key: r'INSUR_MNGR',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> emgTel() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EMG_TEL',
          fields: fields,
        )
      ]),
      key: r'EMG_TEL',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> storeNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STORE_NM',
          fields: fields,
        )
      ]),
      key: r'STORE_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> storeTel() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STORE_TEL',
          fields: fields,
        )
      ]),
      key: r'STORE_TEL',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }
}

class CARCHARGETBLCountAggregateOutputType {
  const CARCHARGETBLCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> item() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ITEM',
          fields: fields,
        )
      ]),
      key: r'ITEM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> charge() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CHARGE',
          fields: fields,
        )
      ]),
      key: r'CHARGE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> writerId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITER_ID',
          fields: fields,
        )
      ]),
      key: r'WRITER_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> memo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MEMO',
          fields: fields,
        )
      ]),
      key: r'MEMO',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class CARCHARGETBLAvgAggregateOutputType {
  const CARCHARGETBLAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> charge() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CHARGE',
          fields: fields,
        )
      ]),
      key: r'CHARGE',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class CARCHARGETBLSumAggregateOutputType {
  const CARCHARGETBLSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> charge() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CHARGE',
          fields: fields,
        )
      ]),
      key: r'CHARGE',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class CARCHARGETBLMinAggregateOutputType {
  const CARCHARGETBLMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> item() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ITEM',
          fields: fields,
        )
      ]),
      key: r'ITEM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<BigInt?> charge() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CHARGE',
          fields: fields,
        )
      ]),
      key: r'CHARGE',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> writerId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITER_ID',
          fields: fields,
        )
      ]),
      key: r'WRITER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> memo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MEMO',
          fields: fields,
        )
      ]),
      key: r'MEMO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class CARCHARGETBLMaxAggregateOutputType {
  const CARCHARGETBLMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> item() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ITEM',
          fields: fields,
        )
      ]),
      key: r'ITEM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<BigInt?> charge() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CHARGE',
          fields: fields,
        )
      ]),
      key: r'CHARGE',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> writerId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITER_ID',
          fields: fields,
        )
      ]),
      key: r'WRITER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> memo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MEMO',
          fields: fields,
        )
      ]),
      key: r'MEMO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class CARINFOTBLCountAggregateOutputType {
  const CARINFOTBLCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> carManageNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CAR_MANAGE_NO',
          fields: fields,
        )
      ]),
      key: r'CAR_MANAGE_NO',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> model() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MODEL',
          fields: fields,
        )
      ]),
      key: r'MODEL',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_ID',
          fields: fields,
        )
      ]),
      key: r'USER_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> disusedYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DISUSED_YN',
          fields: fields,
        )
      ]),
      key: r'DISUSED_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class CARINFOTBLAvgAggregateOutputType {
  const CARINFOTBLAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class CARINFOTBLSumAggregateOutputType {
  const CARINFOTBLSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class CARINFOTBLMinAggregateOutputType {
  const CARINFOTBLMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> carManageNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CAR_MANAGE_NO',
          fields: fields,
        )
      ]),
      key: r'CAR_MANAGE_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> model() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MODEL',
          fields: fields,
        )
      ]),
      key: r'MODEL',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_ID',
          fields: fields,
        )
      ]),
      key: r'USER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> disusedYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DISUSED_YN',
          fields: fields,
        )
      ]),
      key: r'DISUSED_YN',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class CARINFOTBLMaxAggregateOutputType {
  const CARINFOTBLMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> carManageNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CAR_MANAGE_NO',
          fields: fields,
        )
      ]),
      key: r'CAR_MANAGE_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> model() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MODEL',
          fields: fields,
        )
      ]),
      key: r'MODEL',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_ID',
          fields: fields,
        )
      ]),
      key: r'USER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> disusedYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DISUSED_YN',
          fields: fields,
        )
      ]),
      key: r'DISUSED_YN',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class CARMILEAGETBLCountAggregateOutputType {
  const CARMILEAGETBLCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> carManageNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CAR_MANAGE_NO',
          fields: fields,
        )
      ]),
      key: r'CAR_MANAGE_NO',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> forUse() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FOR_USE',
          fields: fields,
        )
      ]),
      key: r'FOR_USE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> stPoint() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ST_POINT',
          fields: fields,
        )
      ]),
      key: r'ST_POINT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> destination() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DESTINATION',
          fields: fields,
        )
      ]),
      key: r'DESTINATION',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> mileage() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MILEAGE',
          fields: fields,
        )
      ]),
      key: r'MILEAGE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> totalMileage() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'TOTAL_MILEAGE',
          fields: fields,
        )
      ]),
      key: r'TOTAL_MILEAGE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> recordDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RECORD_DATE',
          fields: fields,
        )
      ]),
      key: r'RECORD_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> writerId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITER_ID',
          fields: fields,
        )
      ]),
      key: r'WRITER_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editorId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDITOR_ID',
          fields: fields,
        )
      ]),
      key: r'EDITOR_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> apprYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPR_YN',
          fields: fields,
        )
      ]),
      key: r'APPR_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class CARMILEAGETBLAvgAggregateOutputType {
  const CARMILEAGETBLAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> mileage() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MILEAGE',
          fields: fields,
        )
      ]),
      key: r'MILEAGE',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> totalMileage() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'TOTAL_MILEAGE',
          fields: fields,
        )
      ]),
      key: r'TOTAL_MILEAGE',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class CARMILEAGETBLSumAggregateOutputType {
  const CARMILEAGETBLSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> mileage() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MILEAGE',
          fields: fields,
        )
      ]),
      key: r'MILEAGE',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> totalMileage() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'TOTAL_MILEAGE',
          fields: fields,
        )
      ]),
      key: r'TOTAL_MILEAGE',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class CARMILEAGETBLMinAggregateOutputType {
  const CARMILEAGETBLMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> carManageNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CAR_MANAGE_NO',
          fields: fields,
        )
      ]),
      key: r'CAR_MANAGE_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> forUse() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FOR_USE',
          fields: fields,
        )
      ]),
      key: r'FOR_USE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> stPoint() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ST_POINT',
          fields: fields,
        )
      ]),
      key: r'ST_POINT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> destination() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DESTINATION',
          fields: fields,
        )
      ]),
      key: r'DESTINATION',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<BigInt?> mileage() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MILEAGE',
          fields: fields,
        )
      ]),
      key: r'MILEAGE',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> totalMileage() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'TOTAL_MILEAGE',
          fields: fields,
        )
      ]),
      key: r'TOTAL_MILEAGE',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> recordDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RECORD_DATE',
          fields: fields,
        )
      ]),
      key: r'RECORD_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> writerId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITER_ID',
          fields: fields,
        )
      ]),
      key: r'WRITER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editorId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDITOR_ID',
          fields: fields,
        )
      ]),
      key: r'EDITOR_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> apprYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPR_YN',
          fields: fields,
        )
      ]),
      key: r'APPR_YN',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class CARMILEAGETBLMaxAggregateOutputType {
  const CARMILEAGETBLMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> carManageNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CAR_MANAGE_NO',
          fields: fields,
        )
      ]),
      key: r'CAR_MANAGE_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> forUse() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FOR_USE',
          fields: fields,
        )
      ]),
      key: r'FOR_USE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> stPoint() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ST_POINT',
          fields: fields,
        )
      ]),
      key: r'ST_POINT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> destination() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DESTINATION',
          fields: fields,
        )
      ]),
      key: r'DESTINATION',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<BigInt?> mileage() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MILEAGE',
          fields: fields,
        )
      ]),
      key: r'MILEAGE',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> totalMileage() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'TOTAL_MILEAGE',
          fields: fields,
        )
      ]),
      key: r'TOTAL_MILEAGE',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> recordDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RECORD_DATE',
          fields: fields,
        )
      ]),
      key: r'RECORD_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> writerId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITER_ID',
          fields: fields,
        )
      ]),
      key: r'WRITER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editorId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDITOR_ID',
          fields: fields,
        )
      ]),
      key: r'EDITOR_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> apprYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'APPR_YN',
          fields: fields,
        )
      ]),
      key: r'APPR_YN',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class CARPARTREPLACETBLCountAggregateOutputType {
  const CARPARTREPLACETBLCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> partNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PART_NM',
          fields: fields,
        )
      ]),
      key: r'PART_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> replacePeriod() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPLACE_PERIOD',
          fields: fields,
        )
      ]),
      key: r'REPLACE_PERIOD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> reTotalMileage() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RE_TOTAL_MILEAGE',
          fields: fields,
        )
      ]),
      key: r'RE_TOTAL_MILEAGE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> nowTotalMileage() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'NOW_TOTAL_MILEAGE',
          fields: fields,
        )
      ]),
      key: r'NOW_TOTAL_MILEAGE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> remainMileage() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REMAIN_MILEAGE',
          fields: fields,
        )
      ]),
      key: r'REMAIN_MILEAGE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> replaceCount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPLACE_COUNT',
          fields: fields,
        )
      ]),
      key: r'REPLACE_COUNT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> partReDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PART_RE_DATE',
          fields: fields,
        )
      ]),
      key: r'PART_RE_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> writerId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITER_ID',
          fields: fields,
        )
      ]),
      key: r'WRITER_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class CARPARTREPLACETBLAvgAggregateOutputType {
  const CARPARTREPLACETBLAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> replacePeriod() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPLACE_PERIOD',
          fields: fields,
        )
      ]),
      key: r'REPLACE_PERIOD',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> reTotalMileage() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RE_TOTAL_MILEAGE',
          fields: fields,
        )
      ]),
      key: r'RE_TOTAL_MILEAGE',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> nowTotalMileage() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'NOW_TOTAL_MILEAGE',
          fields: fields,
        )
      ]),
      key: r'NOW_TOTAL_MILEAGE',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> remainMileage() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REMAIN_MILEAGE',
          fields: fields,
        )
      ]),
      key: r'REMAIN_MILEAGE',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> replaceCount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPLACE_COUNT',
          fields: fields,
        )
      ]),
      key: r'REPLACE_COUNT',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class CARPARTREPLACETBLSumAggregateOutputType {
  const CARPARTREPLACETBLSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> replacePeriod() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPLACE_PERIOD',
          fields: fields,
        )
      ]),
      key: r'REPLACE_PERIOD',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> reTotalMileage() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RE_TOTAL_MILEAGE',
          fields: fields,
        )
      ]),
      key: r'RE_TOTAL_MILEAGE',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> nowTotalMileage() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'NOW_TOTAL_MILEAGE',
          fields: fields,
        )
      ]),
      key: r'NOW_TOTAL_MILEAGE',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> remainMileage() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REMAIN_MILEAGE',
          fields: fields,
        )
      ]),
      key: r'REMAIN_MILEAGE',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> replaceCount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPLACE_COUNT',
          fields: fields,
        )
      ]),
      key: r'REPLACE_COUNT',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class CARPARTREPLACETBLMinAggregateOutputType {
  const CARPARTREPLACETBLMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> partNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PART_NM',
          fields: fields,
        )
      ]),
      key: r'PART_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<BigInt?> replacePeriod() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPLACE_PERIOD',
          fields: fields,
        )
      ]),
      key: r'REPLACE_PERIOD',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> reTotalMileage() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RE_TOTAL_MILEAGE',
          fields: fields,
        )
      ]),
      key: r'RE_TOTAL_MILEAGE',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> nowTotalMileage() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'NOW_TOTAL_MILEAGE',
          fields: fields,
        )
      ]),
      key: r'NOW_TOTAL_MILEAGE',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> remainMileage() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REMAIN_MILEAGE',
          fields: fields,
        )
      ]),
      key: r'REMAIN_MILEAGE',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> replaceCount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPLACE_COUNT',
          fields: fields,
        )
      ]),
      key: r'REPLACE_COUNT',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> partReDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PART_RE_DATE',
          fields: fields,
        )
      ]),
      key: r'PART_RE_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> writerId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITER_ID',
          fields: fields,
        )
      ]),
      key: r'WRITER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class CARPARTREPLACETBLMaxAggregateOutputType {
  const CARPARTREPLACETBLMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> partNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PART_NM',
          fields: fields,
        )
      ]),
      key: r'PART_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<BigInt?> replacePeriod() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPLACE_PERIOD',
          fields: fields,
        )
      ]),
      key: r'REPLACE_PERIOD',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> reTotalMileage() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RE_TOTAL_MILEAGE',
          fields: fields,
        )
      ]),
      key: r'RE_TOTAL_MILEAGE',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> nowTotalMileage() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'NOW_TOTAL_MILEAGE',
          fields: fields,
        )
      ]),
      key: r'NOW_TOTAL_MILEAGE',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> remainMileage() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REMAIN_MILEAGE',
          fields: fields,
        )
      ]),
      key: r'REMAIN_MILEAGE',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> replaceCount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPLACE_COUNT',
          fields: fields,
        )
      ]),
      key: r'REPLACE_COUNT',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> partReDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PART_RE_DATE',
          fields: fields,
        )
      ]),
      key: r'PART_RE_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> writerId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITER_ID',
          fields: fields,
        )
      ]),
      key: r'WRITER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class CARREPAIRLOGCountAggregateOutputType {
  const CARREPAIRLOGCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> mseq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSEQ',
          fields: fields,
        )
      ]),
      key: r'MSEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> assetNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ASSET_NO',
          fields: fields,
        )
      ]),
      key: r'ASSET_NO',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> repairDe() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPAIR_DE',
          fields: fields,
        )
      ]),
      key: r'REPAIR_DE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> repairAmount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPAIR_AMOUNT',
          fields: fields,
        )
      ]),
      key: r'REPAIR_AMOUNT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> repairStore() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPAIR_STORE',
          fields: fields,
        )
      ]),
      key: r'REPAIR_STORE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> repairLog() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPAIR_LOG',
          fields: fields,
        )
      ]),
      key: r'REPAIR_LOG',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> repairOwner() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPAIR_OWNER',
          fields: fields,
        )
      ]),
      key: r'REPAIR_OWNER',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> fileTp() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_TP',
          fields: fields,
        )
      ]),
      key: r'FILE_TP',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> flpth() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FLPTH',
          fields: fields,
        )
      ]),
      key: r'FLPTH',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> orginalFileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ORGINAL_FILE_NM',
          fields: fields,
        )
      ]),
      key: r'ORGINAL_FILE_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> streFileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STRE_FILE_NM',
          fields: fields,
        )
      ]),
      key: r'STRE_FILE_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class CARREPAIRLOGAvgAggregateOutputType {
  const CARREPAIRLOGAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> mseq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSEQ',
          fields: fields,
        )
      ]),
      key: r'MSEQ',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class CARREPAIRLOGSumAggregateOutputType {
  const CARREPAIRLOGSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> mseq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSEQ',
          fields: fields,
        )
      ]),
      key: r'MSEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class CARREPAIRLOGMinAggregateOutputType {
  const CARREPAIRLOGMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> mseq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSEQ',
          fields: fields,
        )
      ]),
      key: r'MSEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> assetNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ASSET_NO',
          fields: fields,
        )
      ]),
      key: r'ASSET_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> repairDe() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPAIR_DE',
          fields: fields,
        )
      ]),
      key: r'REPAIR_DE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> repairAmount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPAIR_AMOUNT',
          fields: fields,
        )
      ]),
      key: r'REPAIR_AMOUNT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> repairStore() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPAIR_STORE',
          fields: fields,
        )
      ]),
      key: r'REPAIR_STORE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> repairLog() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPAIR_LOG',
          fields: fields,
        )
      ]),
      key: r'REPAIR_LOG',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> repairOwner() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPAIR_OWNER',
          fields: fields,
        )
      ]),
      key: r'REPAIR_OWNER',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> fileTp() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_TP',
          fields: fields,
        )
      ]),
      key: r'FILE_TP',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> flpth() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FLPTH',
          fields: fields,
        )
      ]),
      key: r'FLPTH',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> orginalFileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ORGINAL_FILE_NM',
          fields: fields,
        )
      ]),
      key: r'ORGINAL_FILE_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> streFileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STRE_FILE_NM',
          fields: fields,
        )
      ]),
      key: r'STRE_FILE_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class CARREPAIRLOGMaxAggregateOutputType {
  const CARREPAIRLOGMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<BigInt?> mseq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSEQ',
          fields: fields,
        )
      ]),
      key: r'MSEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> assetNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ASSET_NO',
          fields: fields,
        )
      ]),
      key: r'ASSET_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> repairDe() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPAIR_DE',
          fields: fields,
        )
      ]),
      key: r'REPAIR_DE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> repairAmount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPAIR_AMOUNT',
          fields: fields,
        )
      ]),
      key: r'REPAIR_AMOUNT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> repairStore() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPAIR_STORE',
          fields: fields,
        )
      ]),
      key: r'REPAIR_STORE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> repairLog() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPAIR_LOG',
          fields: fields,
        )
      ]),
      key: r'REPAIR_LOG',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> repairOwner() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPAIR_OWNER',
          fields: fields,
        )
      ]),
      key: r'REPAIR_OWNER',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> fileTp() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_TP',
          fields: fields,
        )
      ]),
      key: r'FILE_TP',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> flpth() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FLPTH',
          fields: fields,
        )
      ]),
      key: r'FLPTH',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> orginalFileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ORGINAL_FILE_NM',
          fields: fields,
        )
      ]),
      key: r'ORGINAL_FILE_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> streFileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STRE_FILE_NM',
          fields: fields,
        )
      ]),
      key: r'STRE_FILE_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class CARUSEMANAGETBLCountAggregateOutputType {
  const CARUSEMANAGETBLCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> carNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CAR_NO',
          fields: fields,
        )
      ]),
      key: r'CAR_NO',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> carType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CAR_TYPE',
          fields: fields,
        )
      ]),
      key: r'CAR_TYPE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> destination() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DESTINATION',
          fields: fields,
        )
      ]),
      key: r'DESTINATION',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> purpose() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PURPOSE',
          fields: fields,
        )
      ]),
      key: r'PURPOSE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> users() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USERS',
          fields: fields,
        )
      ]),
      key: r'USERS',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> useStartDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_START_DATE',
          fields: fields,
        )
      ]),
      key: r'USE_START_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> useEndDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_END_DATE',
          fields: fields,
        )
      ]),
      key: r'USE_END_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> useBeforeDistance() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_BEFORE_DISTANCE',
          fields: fields,
        )
      ]),
      key: r'USE_BEFORE_DISTANCE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> useAfterDistance() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_AFTER_DISTANCE',
          fields: fields,
        )
      ]),
      key: r'USE_AFTER_DISTANCE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> remarks() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REMARKS',
          fields: fields,
        )
      ]),
      key: r'REMARKS',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> acceptYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ACCEPT_YN',
          fields: fields,
        )
      ]),
      key: r'ACCEPT_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regUser() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_USER',
          fields: fields,
        )
      ]),
      key: r'REG_USER',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> useStartHour() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_START_HOUR',
          fields: fields,
        )
      ]),
      key: r'USE_START_HOUR',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> useEndHour() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_END_HOUR',
          fields: fields,
        )
      ]),
      key: r'USE_END_HOUR',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> cardApply() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CARD_APPLY',
          fields: fields,
        )
      ]),
      key: r'CARD_APPLY',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class CARUSEMANAGETBLAvgAggregateOutputType {
  const CARUSEMANAGETBLAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> useBeforeDistance() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_BEFORE_DISTANCE',
          fields: fields,
        )
      ]),
      key: r'USE_BEFORE_DISTANCE',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> useAfterDistance() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_AFTER_DISTANCE',
          fields: fields,
        )
      ]),
      key: r'USE_AFTER_DISTANCE',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class CARUSEMANAGETBLSumAggregateOutputType {
  const CARUSEMANAGETBLSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<double?> useBeforeDistance() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_BEFORE_DISTANCE',
          fields: fields,
        )
      ]),
      key: r'USE_BEFORE_DISTANCE',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> useAfterDistance() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_AFTER_DISTANCE',
          fields: fields,
        )
      ]),
      key: r'USE_AFTER_DISTANCE',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class CARUSEMANAGETBLMinAggregateOutputType {
  const CARUSEMANAGETBLMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> carNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CAR_NO',
          fields: fields,
        )
      ]),
      key: r'CAR_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> carType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CAR_TYPE',
          fields: fields,
        )
      ]),
      key: r'CAR_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> destination() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DESTINATION',
          fields: fields,
        )
      ]),
      key: r'DESTINATION',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> purpose() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PURPOSE',
          fields: fields,
        )
      ]),
      key: r'PURPOSE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> users() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USERS',
          fields: fields,
        )
      ]),
      key: r'USERS',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> useStartDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_START_DATE',
          fields: fields,
        )
      ]),
      key: r'USE_START_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> useEndDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_END_DATE',
          fields: fields,
        )
      ]),
      key: r'USE_END_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<double?> useBeforeDistance() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_BEFORE_DISTANCE',
          fields: fields,
        )
      ]),
      key: r'USE_BEFORE_DISTANCE',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> useAfterDistance() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_AFTER_DISTANCE',
          fields: fields,
        )
      ]),
      key: r'USE_AFTER_DISTANCE',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<String?> remarks() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REMARKS',
          fields: fields,
        )
      ]),
      key: r'REMARKS',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> acceptYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ACCEPT_YN',
          fields: fields,
        )
      ]),
      key: r'ACCEPT_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regUser() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_USER',
          fields: fields,
        )
      ]),
      key: r'REG_USER',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<String?> useStartHour() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_START_HOUR',
          fields: fields,
        )
      ]),
      key: r'USE_START_HOUR',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> useEndHour() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_END_HOUR',
          fields: fields,
        )
      ]),
      key: r'USE_END_HOUR',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> cardApply() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CARD_APPLY',
          fields: fields,
        )
      ]),
      key: r'CARD_APPLY',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class CARUSEMANAGETBLMaxAggregateOutputType {
  const CARUSEMANAGETBLMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> carNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CAR_NO',
          fields: fields,
        )
      ]),
      key: r'CAR_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> carType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CAR_TYPE',
          fields: fields,
        )
      ]),
      key: r'CAR_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> destination() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DESTINATION',
          fields: fields,
        )
      ]),
      key: r'DESTINATION',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> purpose() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PURPOSE',
          fields: fields,
        )
      ]),
      key: r'PURPOSE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> users() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USERS',
          fields: fields,
        )
      ]),
      key: r'USERS',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> useStartDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_START_DATE',
          fields: fields,
        )
      ]),
      key: r'USE_START_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> useEndDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_END_DATE',
          fields: fields,
        )
      ]),
      key: r'USE_END_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<double?> useBeforeDistance() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_BEFORE_DISTANCE',
          fields: fields,
        )
      ]),
      key: r'USE_BEFORE_DISTANCE',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> useAfterDistance() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_AFTER_DISTANCE',
          fields: fields,
        )
      ]),
      key: r'USE_AFTER_DISTANCE',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<String?> remarks() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REMARKS',
          fields: fields,
        )
      ]),
      key: r'REMARKS',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> acceptYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ACCEPT_YN',
          fields: fields,
        )
      ]),
      key: r'ACCEPT_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regUser() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_USER',
          fields: fields,
        )
      ]),
      key: r'REG_USER',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<String?> useStartHour() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_START_HOUR',
          fields: fields,
        )
      ]),
      key: r'USE_START_HOUR',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> useEndHour() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_END_HOUR',
          fields: fields,
        )
      ]),
      key: r'USE_END_HOUR',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> cardApply() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CARD_APPLY',
          fields: fields,
        )
      ]),
      key: r'CARD_APPLY',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class HOLIDAYTBLCountAggregateOutputType {
  const HOLIDAYTBLCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_ID',
          fields: fields,
        )
      ]),
      key: r'USER_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> stdYear() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STD_YEAR',
          fields: fields,
        )
      ]),
      key: r'STD_YEAR',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> m1() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M1',
          fields: fields,
        )
      ]),
      key: r'M1',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> m2() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M2',
          fields: fields,
        )
      ]),
      key: r'M2',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> m3() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M3',
          fields: fields,
        )
      ]),
      key: r'M3',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> m4() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M4',
          fields: fields,
        )
      ]),
      key: r'M4',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> m5() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M5',
          fields: fields,
        )
      ]),
      key: r'M5',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> m6() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M6',
          fields: fields,
        )
      ]),
      key: r'M6',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> m7() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M7',
          fields: fields,
        )
      ]),
      key: r'M7',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> m8() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M8',
          fields: fields,
        )
      ]),
      key: r'M8',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> m9() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M9',
          fields: fields,
        )
      ]),
      key: r'M9',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> m10() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M10',
          fields: fields,
        )
      ]),
      key: r'M10',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> m11() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M11',
          fields: fields,
        )
      ]),
      key: r'M11',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> m12() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M12',
          fields: fields,
        )
      ]),
      key: r'M12',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class HOLIDAYTBLAvgAggregateOutputType {
  const HOLIDAYTBLAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> m1() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M1',
          fields: fields,
        )
      ]),
      key: r'M1',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m2() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M2',
          fields: fields,
        )
      ]),
      key: r'M2',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m3() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M3',
          fields: fields,
        )
      ]),
      key: r'M3',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m4() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M4',
          fields: fields,
        )
      ]),
      key: r'M4',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m5() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M5',
          fields: fields,
        )
      ]),
      key: r'M5',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m6() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M6',
          fields: fields,
        )
      ]),
      key: r'M6',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m7() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M7',
          fields: fields,
        )
      ]),
      key: r'M7',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m8() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M8',
          fields: fields,
        )
      ]),
      key: r'M8',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m9() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M9',
          fields: fields,
        )
      ]),
      key: r'M9',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m10() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M10',
          fields: fields,
        )
      ]),
      key: r'M10',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m11() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M11',
          fields: fields,
        )
      ]),
      key: r'M11',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m12() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M12',
          fields: fields,
        )
      ]),
      key: r'M12',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class HOLIDAYTBLSumAggregateOutputType {
  const HOLIDAYTBLSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> m1() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M1',
          fields: fields,
        )
      ]),
      key: r'M1',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m2() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M2',
          fields: fields,
        )
      ]),
      key: r'M2',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m3() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M3',
          fields: fields,
        )
      ]),
      key: r'M3',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m4() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M4',
          fields: fields,
        )
      ]),
      key: r'M4',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m5() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M5',
          fields: fields,
        )
      ]),
      key: r'M5',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m6() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M6',
          fields: fields,
        )
      ]),
      key: r'M6',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m7() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M7',
          fields: fields,
        )
      ]),
      key: r'M7',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m8() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M8',
          fields: fields,
        )
      ]),
      key: r'M8',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m9() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M9',
          fields: fields,
        )
      ]),
      key: r'M9',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m10() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M10',
          fields: fields,
        )
      ]),
      key: r'M10',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m11() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M11',
          fields: fields,
        )
      ]),
      key: r'M11',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m12() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M12',
          fields: fields,
        )
      ]),
      key: r'M12',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class HOLIDAYTBLMinAggregateOutputType {
  const HOLIDAYTBLMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_ID',
          fields: fields,
        )
      ]),
      key: r'USER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> stdYear() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STD_YEAR',
          fields: fields,
        )
      ]),
      key: r'STD_YEAR',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<double?> m1() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M1',
          fields: fields,
        )
      ]),
      key: r'M1',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m2() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M2',
          fields: fields,
        )
      ]),
      key: r'M2',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m3() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M3',
          fields: fields,
        )
      ]),
      key: r'M3',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m4() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M4',
          fields: fields,
        )
      ]),
      key: r'M4',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m5() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M5',
          fields: fields,
        )
      ]),
      key: r'M5',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m6() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M6',
          fields: fields,
        )
      ]),
      key: r'M6',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m7() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M7',
          fields: fields,
        )
      ]),
      key: r'M7',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m8() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M8',
          fields: fields,
        )
      ]),
      key: r'M8',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m9() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M9',
          fields: fields,
        )
      ]),
      key: r'M9',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m10() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M10',
          fields: fields,
        )
      ]),
      key: r'M10',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m11() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M11',
          fields: fields,
        )
      ]),
      key: r'M11',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m12() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M12',
          fields: fields,
        )
      ]),
      key: r'M12',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<String?> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }
}

class HOLIDAYTBLMaxAggregateOutputType {
  const HOLIDAYTBLMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_ID',
          fields: fields,
        )
      ]),
      key: r'USER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> stdYear() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STD_YEAR',
          fields: fields,
        )
      ]),
      key: r'STD_YEAR',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<double?> m1() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M1',
          fields: fields,
        )
      ]),
      key: r'M1',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m2() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M2',
          fields: fields,
        )
      ]),
      key: r'M2',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m3() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M3',
          fields: fields,
        )
      ]),
      key: r'M3',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m4() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M4',
          fields: fields,
        )
      ]),
      key: r'M4',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m5() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M5',
          fields: fields,
        )
      ]),
      key: r'M5',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m6() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M6',
          fields: fields,
        )
      ]),
      key: r'M6',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m7() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M7',
          fields: fields,
        )
      ]),
      key: r'M7',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m8() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M8',
          fields: fields,
        )
      ]),
      key: r'M8',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m9() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M9',
          fields: fields,
        )
      ]),
      key: r'M9',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m10() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M10',
          fields: fields,
        )
      ]),
      key: r'M10',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m11() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M11',
          fields: fields,
        )
      ]),
      key: r'M11',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> m12() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'M12',
          fields: fields,
        )
      ]),
      key: r'M12',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<String?> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }
}

class MEMBERTBLCountOutputType {
  const MEMBERTBLCountOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> menuTbl({MENUTBLWhereInput? where}) {
    final args = [
      _i2.GraphQLArg(
        r'where',
        where,
      )
    ];
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_TBL',
          fields: fields,
          args: args,
        )
      ]),
      key: r'MENU_TBL',
    );
    return query(const []).then((value) => (value as int));
  }
}

class MEMBERTBLCountAggregateOutputType {
  const MEMBERTBLCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_ID',
          fields: fields,
        )
      ]),
      key: r'USER_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> passwd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PASSWD',
          fields: fields,
        )
      ]),
      key: r'PASSWD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> userNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_NM',
          fields: fields,
        )
      ]),
      key: r'USER_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> dept() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPT',
          fields: fields,
        )
      ]),
      key: r'DEPT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> grade() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'GRADE',
          fields: fields,
        )
      ]),
      key: r'GRADE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> joinDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'JOIN_DATE',
          fields: fields,
        )
      ]),
      key: r'JOIN_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> retireDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RETIRE_DATE',
          fields: fields,
        )
      ]),
      key: r'RETIRE_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> pwdChgDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PWD_CHG_DATE',
          fields: fields,
        )
      ]),
      key: r'PWD_CHG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> pwdWrongCnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PWD_WRONG_CNT',
          fields: fields,
        )
      ]),
      key: r'PWD_WRONG_CNT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> lastLoginDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LAST_LOGIN_DATE',
          fields: fields,
        )
      ]),
      key: r'LAST_LOGIN_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> memo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MEMO',
          fields: fields,
        )
      ]),
      key: r'MEMO',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class MEMBERTBLAvgAggregateOutputType {
  const MEMBERTBLAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> pwdWrongCnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PWD_WRONG_CNT',
          fields: fields,
        )
      ]),
      key: r'PWD_WRONG_CNT',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class MEMBERTBLSumAggregateOutputType {
  const MEMBERTBLSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> pwdWrongCnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PWD_WRONG_CNT',
          fields: fields,
        )
      ]),
      key: r'PWD_WRONG_CNT',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class MEMBERTBLMinAggregateOutputType {
  const MEMBERTBLMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_ID',
          fields: fields,
        )
      ]),
      key: r'USER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> passwd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PASSWD',
          fields: fields,
        )
      ]),
      key: r'PASSWD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> userNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_NM',
          fields: fields,
        )
      ]),
      key: r'USER_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> dept() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPT',
          fields: fields,
        )
      ]),
      key: r'DEPT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> grade() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'GRADE',
          fields: fields,
        )
      ]),
      key: r'GRADE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> joinDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'JOIN_DATE',
          fields: fields,
        )
      ]),
      key: r'JOIN_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> retireDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RETIRE_DATE',
          fields: fields,
        )
      ]),
      key: r'RETIRE_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> pwdChgDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PWD_CHG_DATE',
          fields: fields,
        )
      ]),
      key: r'PWD_CHG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<int?> pwdWrongCnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PWD_WRONG_CNT',
          fields: fields,
        )
      ]),
      key: r'PWD_WRONG_CNT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> lastLoginDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LAST_LOGIN_DATE',
          fields: fields,
        )
      ]),
      key: r'LAST_LOGIN_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<String?> memo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MEMO',
          fields: fields,
        )
      ]),
      key: r'MEMO',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class MEMBERTBLMaxAggregateOutputType {
  const MEMBERTBLMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_ID',
          fields: fields,
        )
      ]),
      key: r'USER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> passwd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PASSWD',
          fields: fields,
        )
      ]),
      key: r'PASSWD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> userNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_NM',
          fields: fields,
        )
      ]),
      key: r'USER_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> dept() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPT',
          fields: fields,
        )
      ]),
      key: r'DEPT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> grade() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'GRADE',
          fields: fields,
        )
      ]),
      key: r'GRADE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> joinDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'JOIN_DATE',
          fields: fields,
        )
      ]),
      key: r'JOIN_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> retireDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RETIRE_DATE',
          fields: fields,
        )
      ]),
      key: r'RETIRE_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> pwdChgDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PWD_CHG_DATE',
          fields: fields,
        )
      ]),
      key: r'PWD_CHG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<int?> pwdWrongCnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PWD_WRONG_CNT',
          fields: fields,
        )
      ]),
      key: r'PWD_WRONG_CNT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> lastLoginDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LAST_LOGIN_DATE',
          fields: fields,
        )
      ]),
      key: r'LAST_LOGIN_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<String?> memo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MEMO',
          fields: fields,
        )
      ]),
      key: r'MEMO',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class MENUAUTHTBLCountAggregateOutputType {
  const MENUAUTHTBLCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_ID',
          fields: fields,
        )
      ]),
      key: r'USER_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> menuId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_ID',
          fields: fields,
        )
      ]),
      key: r'MENU_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> readYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'READ_YN',
          fields: fields,
        )
      ]),
      key: r'READ_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> writeYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITE_YN',
          fields: fields,
        )
      ]),
      key: r'WRITE_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> updId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_ID',
          fields: fields,
        )
      ]),
      key: r'UPD_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class MENUAUTHTBLMinAggregateOutputType {
  const MENUAUTHTBLMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_ID',
          fields: fields,
        )
      ]),
      key: r'USER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> menuId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_ID',
          fields: fields,
        )
      ]),
      key: r'MENU_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> readYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'READ_YN',
          fields: fields,
        )
      ]),
      key: r'READ_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> writeYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITE_YN',
          fields: fields,
        )
      ]),
      key: r'WRITE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> updId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_ID',
          fields: fields,
        )
      ]),
      key: r'UPD_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }
}

class MENUAUTHTBLMaxAggregateOutputType {
  const MENUAUTHTBLMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_ID',
          fields: fields,
        )
      ]),
      key: r'USER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> menuId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_ID',
          fields: fields,
        )
      ]),
      key: r'MENU_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> readYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'READ_YN',
          fields: fields,
        )
      ]),
      key: r'READ_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> writeYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITE_YN',
          fields: fields,
        )
      ]),
      key: r'WRITE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> updId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_ID',
          fields: fields,
        )
      ]),
      key: r'UPD_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }
}

class MENUTBLCountAggregateOutputType {
  const MENUTBLCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> menuId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_ID',
          fields: fields,
        )
      ]),
      key: r'MENU_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> menuNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_NM',
          fields: fields,
        )
      ]),
      key: r'MENU_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> depth() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPTH',
          fields: fields,
        )
      ]),
      key: r'DEPTH',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> ownerId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'OWNER_ID',
          fields: fields,
        )
      ]),
      key: r'OWNER_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> url() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'URL',
          fields: fields,
        )
      ]),
      key: r'URL',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> writerId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITER_ID',
          fields: fields,
        )
      ]),
      key: r'WRITER_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> dispYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DISP_YN',
          fields: fields,
        )
      ]),
      key: r'DISP_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> menuIcon() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_ICON',
          fields: fields,
        )
      ]),
      key: r'MENU_ICON',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class MENUTBLAvgAggregateOutputType {
  const MENUTBLAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> depth() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPTH',
          fields: fields,
        )
      ]),
      key: r'DEPTH',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class MENUTBLSumAggregateOutputType {
  const MENUTBLSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> depth() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPTH',
          fields: fields,
        )
      ]),
      key: r'DEPTH',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class MENUTBLMinAggregateOutputType {
  const MENUTBLMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> menuId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_ID',
          fields: fields,
        )
      ]),
      key: r'MENU_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> menuNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_NM',
          fields: fields,
        )
      ]),
      key: r'MENU_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> depth() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPTH',
          fields: fields,
        )
      ]),
      key: r'DEPTH',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> ownerId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'OWNER_ID',
          fields: fields,
        )
      ]),
      key: r'OWNER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> url() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'URL',
          fields: fields,
        )
      ]),
      key: r'URL',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> writerId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITER_ID',
          fields: fields,
        )
      ]),
      key: r'WRITER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<String?> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> dispYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DISP_YN',
          fields: fields,
        )
      ]),
      key: r'DISP_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> menuIcon() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_ICON',
          fields: fields,
        )
      ]),
      key: r'MENU_ICON',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class MENUTBLMaxAggregateOutputType {
  const MENUTBLMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> menuId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_ID',
          fields: fields,
        )
      ]),
      key: r'MENU_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> menuNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_NM',
          fields: fields,
        )
      ]),
      key: r'MENU_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> depth() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPTH',
          fields: fields,
        )
      ]),
      key: r'DEPTH',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> ownerId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'OWNER_ID',
          fields: fields,
        )
      ]),
      key: r'OWNER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> url() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'URL',
          fields: fields,
        )
      ]),
      key: r'URL',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> writerId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITER_ID',
          fields: fields,
        )
      ]),
      key: r'WRITER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<String?> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> dispYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DISP_YN',
          fields: fields,
        )
      ]),
      key: r'DISP_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> menuIcon() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_ICON',
          fields: fields,
        )
      ]),
      key: r'MENU_ICON',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class OFFICEASSETTBLCountAggregateOutputType {
  const OFFICEASSETTBLCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> assetNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ASSET_NO',
          fields: fields,
        )
      ]),
      key: r'ASSET_NO',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> assetType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ASSET_TYPE',
          fields: fields,
        )
      ]),
      key: r'ASSET_TYPE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> seller() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SELLER',
          fields: fields,
        )
      ]),
      key: r'SELLER',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> buyDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BUY_DATE',
          fields: fields,
        )
      ]),
      key: r'BUY_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> modelNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MODEL_NO',
          fields: fields,
        )
      ]),
      key: r'MODEL_NO',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> serialNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SERIAL_NO',
          fields: fields,
        )
      ]),
      key: r'SERIAL_NO',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> amount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'AMOUNT',
          fields: fields,
        )
      ]),
      key: r'AMOUNT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> keepYear() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'KEEP_YEAR',
          fields: fields,
        )
      ]),
      key: r'KEEP_YEAR',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> mngDept() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MNG_DEPT',
          fields: fields,
        )
      ]),
      key: r'MNG_DEPT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> assetAccount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ASSET_ACCOUNT',
          fields: fields,
        )
      ]),
      key: r'ASSET_ACCOUNT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> remarks() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REMARKS',
          fields: fields,
        )
      ]),
      key: r'REMARKS',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> carryOut() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CARRY_OUT',
          fields: fields,
        )
      ]),
      key: r'CARRY_OUT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class OFFICEASSETTBLAvgAggregateOutputType {
  const OFFICEASSETTBLAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> amount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'AMOUNT',
          fields: fields,
        )
      ]),
      key: r'AMOUNT',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> keepYear() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'KEEP_YEAR',
          fields: fields,
        )
      ]),
      key: r'KEEP_YEAR',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class OFFICEASSETTBLSumAggregateOutputType {
  const OFFICEASSETTBLSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<int?> amount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'AMOUNT',
          fields: fields,
        )
      ]),
      key: r'AMOUNT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<double?> keepYear() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'KEEP_YEAR',
          fields: fields,
        )
      ]),
      key: r'KEEP_YEAR',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class OFFICEASSETTBLMinAggregateOutputType {
  const OFFICEASSETTBLMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> assetNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ASSET_NO',
          fields: fields,
        )
      ]),
      key: r'ASSET_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> assetType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ASSET_TYPE',
          fields: fields,
        )
      ]),
      key: r'ASSET_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> seller() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SELLER',
          fields: fields,
        )
      ]),
      key: r'SELLER',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> buyDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BUY_DATE',
          fields: fields,
        )
      ]),
      key: r'BUY_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> modelNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MODEL_NO',
          fields: fields,
        )
      ]),
      key: r'MODEL_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> serialNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SERIAL_NO',
          fields: fields,
        )
      ]),
      key: r'SERIAL_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> amount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'AMOUNT',
          fields: fields,
        )
      ]),
      key: r'AMOUNT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<double?> keepYear() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'KEEP_YEAR',
          fields: fields,
        )
      ]),
      key: r'KEEP_YEAR',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<String?> mngDept() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MNG_DEPT',
          fields: fields,
        )
      ]),
      key: r'MNG_DEPT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> assetAccount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ASSET_ACCOUNT',
          fields: fields,
        )
      ]),
      key: r'ASSET_ACCOUNT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> remarks() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REMARKS',
          fields: fields,
        )
      ]),
      key: r'REMARKS',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> carryOut() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CARRY_OUT',
          fields: fields,
        )
      ]),
      key: r'CARRY_OUT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }
}

class OFFICEASSETTBLMaxAggregateOutputType {
  const OFFICEASSETTBLMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> assetNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ASSET_NO',
          fields: fields,
        )
      ]),
      key: r'ASSET_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> assetType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ASSET_TYPE',
          fields: fields,
        )
      ]),
      key: r'ASSET_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> seller() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SELLER',
          fields: fields,
        )
      ]),
      key: r'SELLER',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> buyDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BUY_DATE',
          fields: fields,
        )
      ]),
      key: r'BUY_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> modelNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MODEL_NO',
          fields: fields,
        )
      ]),
      key: r'MODEL_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> serialNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SERIAL_NO',
          fields: fields,
        )
      ]),
      key: r'SERIAL_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> amount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'AMOUNT',
          fields: fields,
        )
      ]),
      key: r'AMOUNT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<double?> keepYear() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'KEEP_YEAR',
          fields: fields,
        )
      ]),
      key: r'KEEP_YEAR',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<String?> mngDept() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MNG_DEPT',
          fields: fields,
        )
      ]),
      key: r'MNG_DEPT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> assetAccount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ASSET_ACCOUNT',
          fields: fields,
        )
      ]),
      key: r'ASSET_ACCOUNT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> remarks() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REMARKS',
          fields: fields,
        )
      ]),
      key: r'REMARKS',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> carryOut() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CARRY_OUT',
          fields: fields,
        )
      ]),
      key: r'CARRY_OUT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }
}

class SERVERASSETTBLCountAggregateOutputType {
  const SERVERASSETTBLCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> assetNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ASSET_NO',
          fields: fields,
        )
      ]),
      key: r'ASSET_NO',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> assetType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ASSET_TYPE',
          fields: fields,
        )
      ]),
      key: r'ASSET_TYPE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> maker() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MAKER',
          fields: fields,
        )
      ]),
      key: r'MAKER',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> cnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CNT',
          fields: fields,
        )
      ]),
      key: r'CNT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> amount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'AMOUNT',
          fields: fields,
        )
      ]),
      key: r'AMOUNT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> buyDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BUY_DATE',
          fields: fields,
        )
      ]),
      key: r'BUY_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> seller() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SELLER',
          fields: fields,
        )
      ]),
      key: r'SELLER',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> modelNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MODEL_NO',
          fields: fields,
        )
      ]),
      key: r'MODEL_NO',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> serialNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SERIAL_NO',
          fields: fields,
        )
      ]),
      key: r'SERIAL_NO',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> hostname() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'HOSTNAME',
          fields: fields,
        )
      ]),
      key: r'HOSTNAME',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> builtLoc() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BUILT_LOC',
          fields: fields,
        )
      ]),
      key: r'BUILT_LOC',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> useDesc() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_DESC',
          fields: fields,
        )
      ]),
      key: r'USE_DESC',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> osInfo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'OS_INFO',
          fields: fields,
        )
      ]),
      key: r'OS_INFO',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> cpuInfo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CPU_INFO',
          fields: fields,
        )
      ]),
      key: r'CPU_INFO',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> ramInfo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RAM_INFO',
          fields: fields,
        )
      ]),
      key: r'RAM_INFO',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> hddInfo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'HDD_INFO',
          fields: fields,
        )
      ]),
      key: r'HDD_INFO',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> ssdInfo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SSD_INFO',
          fields: fields,
        )
      ]),
      key: r'SSD_INFO',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> odd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ODD',
          fields: fields,
        )
      ]),
      key: r'ODD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> remarks() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REMARKS',
          fields: fields,
        )
      ]),
      key: r'REMARKS',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> carryOut() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CARRY_OUT',
          fields: fields,
        )
      ]),
      key: r'CARRY_OUT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class SERVERASSETTBLAvgAggregateOutputType {
  const SERVERASSETTBLAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> cnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CNT',
          fields: fields,
        )
      ]),
      key: r'CNT',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> amount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'AMOUNT',
          fields: fields,
        )
      ]),
      key: r'AMOUNT',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class SERVERASSETTBLSumAggregateOutputType {
  const SERVERASSETTBLSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<double?> cnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CNT',
          fields: fields,
        )
      ]),
      key: r'CNT',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<int?> amount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'AMOUNT',
          fields: fields,
        )
      ]),
      key: r'AMOUNT',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class SERVERASSETTBLMinAggregateOutputType {
  const SERVERASSETTBLMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> assetNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ASSET_NO',
          fields: fields,
        )
      ]),
      key: r'ASSET_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> assetType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ASSET_TYPE',
          fields: fields,
        )
      ]),
      key: r'ASSET_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> maker() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MAKER',
          fields: fields,
        )
      ]),
      key: r'MAKER',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<double?> cnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CNT',
          fields: fields,
        )
      ]),
      key: r'CNT',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<int?> amount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'AMOUNT',
          fields: fields,
        )
      ]),
      key: r'AMOUNT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> buyDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BUY_DATE',
          fields: fields,
        )
      ]),
      key: r'BUY_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> seller() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SELLER',
          fields: fields,
        )
      ]),
      key: r'SELLER',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> modelNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MODEL_NO',
          fields: fields,
        )
      ]),
      key: r'MODEL_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> serialNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SERIAL_NO',
          fields: fields,
        )
      ]),
      key: r'SERIAL_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> hostname() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'HOSTNAME',
          fields: fields,
        )
      ]),
      key: r'HOSTNAME',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> builtLoc() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BUILT_LOC',
          fields: fields,
        )
      ]),
      key: r'BUILT_LOC',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> useDesc() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_DESC',
          fields: fields,
        )
      ]),
      key: r'USE_DESC',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> osInfo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'OS_INFO',
          fields: fields,
        )
      ]),
      key: r'OS_INFO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> cpuInfo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CPU_INFO',
          fields: fields,
        )
      ]),
      key: r'CPU_INFO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> ramInfo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RAM_INFO',
          fields: fields,
        )
      ]),
      key: r'RAM_INFO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> hddInfo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'HDD_INFO',
          fields: fields,
        )
      ]),
      key: r'HDD_INFO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> ssdInfo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SSD_INFO',
          fields: fields,
        )
      ]),
      key: r'SSD_INFO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> odd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ODD',
          fields: fields,
        )
      ]),
      key: r'ODD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> remarks() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REMARKS',
          fields: fields,
        )
      ]),
      key: r'REMARKS',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> carryOut() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CARRY_OUT',
          fields: fields,
        )
      ]),
      key: r'CARRY_OUT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }
}

class SERVERASSETTBLMaxAggregateOutputType {
  const SERVERASSETTBLMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> assetNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ASSET_NO',
          fields: fields,
        )
      ]),
      key: r'ASSET_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> assetType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ASSET_TYPE',
          fields: fields,
        )
      ]),
      key: r'ASSET_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> maker() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MAKER',
          fields: fields,
        )
      ]),
      key: r'MAKER',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<double?> cnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CNT',
          fields: fields,
        )
      ]),
      key: r'CNT',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<int?> amount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'AMOUNT',
          fields: fields,
        )
      ]),
      key: r'AMOUNT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> buyDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BUY_DATE',
          fields: fields,
        )
      ]),
      key: r'BUY_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> seller() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SELLER',
          fields: fields,
        )
      ]),
      key: r'SELLER',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> modelNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MODEL_NO',
          fields: fields,
        )
      ]),
      key: r'MODEL_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> serialNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SERIAL_NO',
          fields: fields,
        )
      ]),
      key: r'SERIAL_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> hostname() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'HOSTNAME',
          fields: fields,
        )
      ]),
      key: r'HOSTNAME',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> builtLoc() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BUILT_LOC',
          fields: fields,
        )
      ]),
      key: r'BUILT_LOC',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> useDesc() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_DESC',
          fields: fields,
        )
      ]),
      key: r'USE_DESC',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> osInfo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'OS_INFO',
          fields: fields,
        )
      ]),
      key: r'OS_INFO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> cpuInfo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CPU_INFO',
          fields: fields,
        )
      ]),
      key: r'CPU_INFO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> ramInfo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RAM_INFO',
          fields: fields,
        )
      ]),
      key: r'RAM_INFO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> hddInfo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'HDD_INFO',
          fields: fields,
        )
      ]),
      key: r'HDD_INFO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> ssdInfo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SSD_INFO',
          fields: fields,
        )
      ]),
      key: r'SSD_INFO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> odd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ODD',
          fields: fields,
        )
      ]),
      key: r'ODD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> remarks() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REMARKS',
          fields: fields,
        )
      ]),
      key: r'REMARKS',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> carryOut() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CARRY_OUT',
          fields: fields,
        )
      ]),
      key: r'CARRY_OUT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }
}

class SOFTWAREASSETTBLCountAggregateOutputType {
  const SOFTWAREASSETTBLCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> assetNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ASSET_NO',
          fields: fields,
        )
      ]),
      key: r'ASSET_NO',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> softwareNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SOFTWARE_NM',
          fields: fields,
        )
      ]),
      key: r'SOFTWARE_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> versionNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'VERSION_NM',
          fields: fields,
        )
      ]),
      key: r'VERSION_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> cnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CNT',
          fields: fields,
        )
      ]),
      key: r'CNT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> amount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'AMOUNT',
          fields: fields,
        )
      ]),
      key: r'AMOUNT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> buyDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BUY_DATE',
          fields: fields,
        )
      ]),
      key: r'BUY_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> serialNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SERIAL_NO',
          fields: fields,
        )
      ]),
      key: r'SERIAL_NO',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> licenseNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LICENSE_NO',
          fields: fields,
        )
      ]),
      key: r'LICENSE_NO',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> userNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_NM',
          fields: fields,
        )
      ]),
      key: r'USER_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> remarks() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REMARKS',
          fields: fields,
        )
      ]),
      key: r'REMARKS',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class SOFTWAREASSETTBLAvgAggregateOutputType {
  const SOFTWAREASSETTBLAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> cnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CNT',
          fields: fields,
        )
      ]),
      key: r'CNT',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> amount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'AMOUNT',
          fields: fields,
        )
      ]),
      key: r'AMOUNT',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class SOFTWAREASSETTBLSumAggregateOutputType {
  const SOFTWAREASSETTBLSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<double?> cnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CNT',
          fields: fields,
        )
      ]),
      key: r'CNT',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<int?> amount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'AMOUNT',
          fields: fields,
        )
      ]),
      key: r'AMOUNT',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class SOFTWAREASSETTBLMinAggregateOutputType {
  const SOFTWAREASSETTBLMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> assetNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ASSET_NO',
          fields: fields,
        )
      ]),
      key: r'ASSET_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> softwareNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SOFTWARE_NM',
          fields: fields,
        )
      ]),
      key: r'SOFTWARE_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> versionNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'VERSION_NM',
          fields: fields,
        )
      ]),
      key: r'VERSION_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<double?> cnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CNT',
          fields: fields,
        )
      ]),
      key: r'CNT',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<int?> amount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'AMOUNT',
          fields: fields,
        )
      ]),
      key: r'AMOUNT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> buyDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BUY_DATE',
          fields: fields,
        )
      ]),
      key: r'BUY_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> serialNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SERIAL_NO',
          fields: fields,
        )
      ]),
      key: r'SERIAL_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> licenseNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LICENSE_NO',
          fields: fields,
        )
      ]),
      key: r'LICENSE_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> userNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_NM',
          fields: fields,
        )
      ]),
      key: r'USER_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> remarks() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REMARKS',
          fields: fields,
        )
      ]),
      key: r'REMARKS',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }
}

class SOFTWAREASSETTBLMaxAggregateOutputType {
  const SOFTWAREASSETTBLMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> assetNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ASSET_NO',
          fields: fields,
        )
      ]),
      key: r'ASSET_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> softwareNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SOFTWARE_NM',
          fields: fields,
        )
      ]),
      key: r'SOFTWARE_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> versionNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'VERSION_NM',
          fields: fields,
        )
      ]),
      key: r'VERSION_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<double?> cnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CNT',
          fields: fields,
        )
      ]),
      key: r'CNT',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<int?> amount() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'AMOUNT',
          fields: fields,
        )
      ]),
      key: r'AMOUNT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> buyDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BUY_DATE',
          fields: fields,
        )
      ]),
      key: r'BUY_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> serialNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SERIAL_NO',
          fields: fields,
        )
      ]),
      key: r'SERIAL_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> licenseNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LICENSE_NO',
          fields: fields,
        )
      ]),
      key: r'LICENSE_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> userNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_NM',
          fields: fields,
        )
      ]),
      key: r'USER_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> remarks() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REMARKS',
          fields: fields,
        )
      ]),
      key: r'REMARKS',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }
}

class STADMINMENUCountAggregateOutputType {
  const STADMINMENUCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> menuCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_CD',
          fields: fields,
        )
      ]),
      key: r'MENU_CD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> menuNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_NM',
          fields: fields,
        )
      ]),
      key: r'MENU_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> menuPath() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_PATH',
          fields: fields,
        )
      ]),
      key: r'MENU_PATH',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> menuSrt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_SRT',
          fields: fields,
        )
      ]),
      key: r'MENU_SRT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> menuDeps() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_DEPS',
          fields: fields,
        )
      ]),
      key: r'MENU_DEPS',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> menuIcon() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_ICON',
          fields: fields,
        )
      ]),
      key: r'MENU_ICON',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> menuTp() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_TP',
          fields: fields,
        )
      ]),
      key: r'MENU_TP',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class STADMINMENUAvgAggregateOutputType {
  const STADMINMENUAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> menuSrt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_SRT',
          fields: fields,
        )
      ]),
      key: r'MENU_SRT',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> menuDeps() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_DEPS',
          fields: fields,
        )
      ]),
      key: r'MENU_DEPS',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class STADMINMENUSumAggregateOutputType {
  const STADMINMENUSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> menuSrt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_SRT',
          fields: fields,
        )
      ]),
      key: r'MENU_SRT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> menuDeps() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_DEPS',
          fields: fields,
        )
      ]),
      key: r'MENU_DEPS',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class STADMINMENUMinAggregateOutputType {
  const STADMINMENUMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> menuCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_CD',
          fields: fields,
        )
      ]),
      key: r'MENU_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> menuNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_NM',
          fields: fields,
        )
      ]),
      key: r'MENU_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> menuPath() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_PATH',
          fields: fields,
        )
      ]),
      key: r'MENU_PATH',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> menuSrt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_SRT',
          fields: fields,
        )
      ]),
      key: r'MENU_SRT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> menuDeps() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_DEPS',
          fields: fields,
        )
      ]),
      key: r'MENU_DEPS',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> menuIcon() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_ICON',
          fields: fields,
        )
      ]),
      key: r'MENU_ICON',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> menuTp() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_TP',
          fields: fields,
        )
      ]),
      key: r'MENU_TP',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STADMINMENUMaxAggregateOutputType {
  const STADMINMENUMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> menuCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_CD',
          fields: fields,
        )
      ]),
      key: r'MENU_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> menuNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_NM',
          fields: fields,
        )
      ]),
      key: r'MENU_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> menuPath() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_PATH',
          fields: fields,
        )
      ]),
      key: r'MENU_PATH',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> menuSrt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_SRT',
          fields: fields,
        )
      ]),
      key: r'MENU_SRT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> menuDeps() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_DEPS',
          fields: fields,
        )
      ]),
      key: r'MENU_DEPS',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> menuIcon() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_ICON',
          fields: fields,
        )
      ]),
      key: r'MENU_ICON',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> menuTp() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_TP',
          fields: fields,
        )
      ]),
      key: r'MENU_TP',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STALARMCountAggregateOutputType {
  const STALARMCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> msgCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSG_CD',
          fields: fields,
        )
      ]),
      key: r'MSG_CD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> msgCnts() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSG_CNTS',
          fields: fields,
        )
      ]),
      key: r'MSG_CNTS',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> sendDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEND_DATE',
          fields: fields,
        )
      ]),
      key: r'SEND_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> sendDiv() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEND_DIV',
          fields: fields,
        )
      ]),
      key: r'SEND_DIV',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> sendDeptCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEND_DEPT_CD',
          fields: fields,
        )
      ]),
      key: r'SEND_DEPT_CD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> sendId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEND_ID',
          fields: fields,
        )
      ]),
      key: r'SEND_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> recvId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RECV_ID',
          fields: fields,
        )
      ]),
      key: r'RECV_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> popYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'POP_YN',
          fields: fields,
        )
      ]),
      key: r'POP_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class STALARMAvgAggregateOutputType {
  const STALARMAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class STALARMSumAggregateOutputType {
  const STALARMSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class STALARMMinAggregateOutputType {
  const STALARMMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> msgCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSG_CD',
          fields: fields,
        )
      ]),
      key: r'MSG_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> msgCnts() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSG_CNTS',
          fields: fields,
        )
      ]),
      key: r'MSG_CNTS',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> sendDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEND_DATE',
          fields: fields,
        )
      ]),
      key: r'SEND_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> sendDiv() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEND_DIV',
          fields: fields,
        )
      ]),
      key: r'SEND_DIV',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> sendDeptCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEND_DEPT_CD',
          fields: fields,
        )
      ]),
      key: r'SEND_DEPT_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> sendId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEND_ID',
          fields: fields,
        )
      ]),
      key: r'SEND_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> recvId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RECV_ID',
          fields: fields,
        )
      ]),
      key: r'RECV_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> popYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'POP_YN',
          fields: fields,
        )
      ]),
      key: r'POP_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STALARMMaxAggregateOutputType {
  const STALARMMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> msgCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSG_CD',
          fields: fields,
        )
      ]),
      key: r'MSG_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> msgCnts() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSG_CNTS',
          fields: fields,
        )
      ]),
      key: r'MSG_CNTS',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> sendDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEND_DATE',
          fields: fields,
        )
      ]),
      key: r'SEND_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> sendDiv() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEND_DIV',
          fields: fields,
        )
      ]),
      key: r'SEND_DIV',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> sendDeptCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEND_DEPT_CD',
          fields: fields,
        )
      ]),
      key: r'SEND_DEPT_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> sendId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEND_ID',
          fields: fields,
        )
      ]),
      key: r'SEND_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> recvId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RECV_ID',
          fields: fields,
        )
      ]),
      key: r'RECV_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> popYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'POP_YN',
          fields: fields,
        )
      ]),
      key: r'POP_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STAUDITLOGCountAggregateOutputType {
  const STAUDITLOGCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> logCode() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LOG_CODE',
          fields: fields,
        )
      ]),
      key: r'LOG_CODE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> logCnts() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LOG_CNTS',
          fields: fields,
        )
      ]),
      key: r'LOG_CNTS',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> errCode() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ERR_CODE',
          fields: fields,
        )
      ]),
      key: r'ERR_CODE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class STAUDITLOGAvgAggregateOutputType {
  const STAUDITLOGAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class STAUDITLOGSumAggregateOutputType {
  const STAUDITLOGSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class STAUDITLOGMinAggregateOutputType {
  const STAUDITLOGMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> logCode() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LOG_CODE',
          fields: fields,
        )
      ]),
      key: r'LOG_CODE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> logCnts() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LOG_CNTS',
          fields: fields,
        )
      ]),
      key: r'LOG_CNTS',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> errCode() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ERR_CODE',
          fields: fields,
        )
      ]),
      key: r'ERR_CODE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STAUDITLOGMaxAggregateOutputType {
  const STAUDITLOGMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> logCode() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LOG_CODE',
          fields: fields,
        )
      ]),
      key: r'LOG_CODE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> logCnts() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LOG_CNTS',
          fields: fields,
        )
      ]),
      key: r'LOG_CNTS',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> errCode() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ERR_CODE',
          fields: fields,
        )
      ]),
      key: r'ERR_CODE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STBANNERCountAggregateOutputType {
  const STBANNERCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> bannerCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BANNER_CD',
          fields: fields,
        )
      ]),
      key: r'BANNER_CD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> lkUrl() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LK_URL',
          fields: fields,
        )
      ]),
      key: r'LK_URL',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> lkTarget() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LK_TARGET',
          fields: fields,
        )
      ]),
      key: r'LK_TARGET',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> flpth() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FLPTH',
          fields: fields,
        )
      ]),
      key: r'FLPTH',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> fileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_NM',
          fields: fields,
        )
      ]),
      key: r'FILE_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class STBANNERMinAggregateOutputType {
  const STBANNERMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> bannerCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BANNER_CD',
          fields: fields,
        )
      ]),
      key: r'BANNER_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> lkUrl() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LK_URL',
          fields: fields,
        )
      ]),
      key: r'LK_URL',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> lkTarget() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LK_TARGET',
          fields: fields,
        )
      ]),
      key: r'LK_TARGET',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> flpth() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FLPTH',
          fields: fields,
        )
      ]),
      key: r'FLPTH',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> fileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_NM',
          fields: fields,
        )
      ]),
      key: r'FILE_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STBANNERMaxAggregateOutputType {
  const STBANNERMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> bannerCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BANNER_CD',
          fields: fields,
        )
      ]),
      key: r'BANNER_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> lkUrl() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LK_URL',
          fields: fields,
        )
      ]),
      key: r'LK_URL',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> lkTarget() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LK_TARGET',
          fields: fields,
        )
      ]),
      key: r'LK_TARGET',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> flpth() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FLPTH',
          fields: fields,
        )
      ]),
      key: r'FLPTH',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> fileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_NM',
          fields: fields,
        )
      ]),
      key: r'FILE_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STBOARDCOLUMNCountAggregateOutputType {
  const STBOARDCOLUMNCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> boardCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BOARD_CD',
          fields: fields,
        )
      ]),
      key: r'BOARD_CD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> colCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'COL_CD',
          fields: fields,
        )
      ]),
      key: r'COL_CD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> colNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'COL_NM',
          fields: fields,
        )
      ]),
      key: r'COL_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class STBOARDCOLUMNAvgAggregateOutputType {
  const STBOARDCOLUMNAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class STBOARDCOLUMNSumAggregateOutputType {
  const STBOARDCOLUMNSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class STBOARDCOLUMNMinAggregateOutputType {
  const STBOARDCOLUMNMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> boardCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BOARD_CD',
          fields: fields,
        )
      ]),
      key: r'BOARD_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> colCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'COL_CD',
          fields: fields,
        )
      ]),
      key: r'COL_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> colNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'COL_NM',
          fields: fields,
        )
      ]),
      key: r'COL_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STBOARDCOLUMNMaxAggregateOutputType {
  const STBOARDCOLUMNMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> boardCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BOARD_CD',
          fields: fields,
        )
      ]),
      key: r'BOARD_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> colCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'COL_CD',
          fields: fields,
        )
      ]),
      key: r'COL_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> colNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'COL_NM',
          fields: fields,
        )
      ]),
      key: r'COL_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STBOARDCOLUMNDFTCountAggregateOutputType {
  const STBOARDCOLUMNDFTCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> boardTy() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BOARD_TY',
          fields: fields,
        )
      ]),
      key: r'BOARD_TY',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> colCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'COL_CD',
          fields: fields,
        )
      ]),
      key: r'COL_CD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> colNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'COL_NM',
          fields: fields,
        )
      ]),
      key: r'COL_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class STBOARDCOLUMNDFTAvgAggregateOutputType {
  const STBOARDCOLUMNDFTAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class STBOARDCOLUMNDFTSumAggregateOutputType {
  const STBOARDCOLUMNDFTSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class STBOARDCOLUMNDFTMinAggregateOutputType {
  const STBOARDCOLUMNDFTMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> boardTy() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BOARD_TY',
          fields: fields,
        )
      ]),
      key: r'BOARD_TY',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> colCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'COL_CD',
          fields: fields,
        )
      ]),
      key: r'COL_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> colNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'COL_NM',
          fields: fields,
        )
      ]),
      key: r'COL_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STBOARDCOLUMNDFTMaxAggregateOutputType {
  const STBOARDCOLUMNDFTMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> boardTy() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BOARD_TY',
          fields: fields,
        )
      ]),
      key: r'BOARD_TY',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> colCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'COL_CD',
          fields: fields,
        )
      ]),
      key: r'COL_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> colNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'COL_NM',
          fields: fields,
        )
      ]),
      key: r'COL_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STBOARDCOMMENTCountAggregateOutputType {
  const STBOARDCOMMENTCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> mseq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSEQ',
          fields: fields,
        )
      ]),
      key: r'MSEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> boardCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BOARD_CD',
          fields: fields,
        )
      ]),
      key: r'BOARD_CD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> cnts() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CNTS',
          fields: fields,
        )
      ]),
      key: r'CNTS',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> upperSeq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPPER_SEQ',
          fields: fields,
        )
      ]),
      key: r'UPPER_SEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> replyYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPLY_YN',
          fields: fields,
        )
      ]),
      key: r'REPLY_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regAdminYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ADMIN_YN',
          fields: fields,
        )
      ]),
      key: r'REG_ADMIN_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class STBOARDCOMMENTAvgAggregateOutputType {
  const STBOARDCOMMENTAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> mseq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSEQ',
          fields: fields,
        )
      ]),
      key: r'MSEQ',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> upperSeq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPPER_SEQ',
          fields: fields,
        )
      ]),
      key: r'UPPER_SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class STBOARDCOMMENTSumAggregateOutputType {
  const STBOARDCOMMENTSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> mseq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSEQ',
          fields: fields,
        )
      ]),
      key: r'MSEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> upperSeq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPPER_SEQ',
          fields: fields,
        )
      ]),
      key: r'UPPER_SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class STBOARDCOMMENTMinAggregateOutputType {
  const STBOARDCOMMENTMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> mseq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSEQ',
          fields: fields,
        )
      ]),
      key: r'MSEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> boardCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BOARD_CD',
          fields: fields,
        )
      ]),
      key: r'BOARD_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> cnts() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CNTS',
          fields: fields,
        )
      ]),
      key: r'CNTS',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> upperSeq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPPER_SEQ',
          fields: fields,
        )
      ]),
      key: r'UPPER_SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> replyYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPLY_YN',
          fields: fields,
        )
      ]),
      key: r'REPLY_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regAdminYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ADMIN_YN',
          fields: fields,
        )
      ]),
      key: r'REG_ADMIN_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STBOARDCOMMENTMaxAggregateOutputType {
  const STBOARDCOMMENTMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> mseq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSEQ',
          fields: fields,
        )
      ]),
      key: r'MSEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> boardCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BOARD_CD',
          fields: fields,
        )
      ]),
      key: r'BOARD_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> cnts() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CNTS',
          fields: fields,
        )
      ]),
      key: r'CNTS',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> upperSeq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPPER_SEQ',
          fields: fields,
        )
      ]),
      key: r'UPPER_SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> replyYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPLY_YN',
          fields: fields,
        )
      ]),
      key: r'REPLY_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regAdminYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ADMIN_YN',
          fields: fields,
        )
      ]),
      key: r'REG_ADMIN_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STBOARDFILECountAggregateOutputType {
  const STBOARDFILECountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> mseq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSEQ',
          fields: fields,
        )
      ]),
      key: r'MSEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> boardCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BOARD_CD',
          fields: fields,
        )
      ]),
      key: r'BOARD_CD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> fileTp() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_TP',
          fields: fields,
        )
      ]),
      key: r'FILE_TP',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> flpth() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FLPTH',
          fields: fields,
        )
      ]),
      key: r'FLPTH',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> orginalFileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ORGINAL_FILE_NM',
          fields: fields,
        )
      ]),
      key: r'ORGINAL_FILE_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> streFileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STRE_FILE_NM',
          fields: fields,
        )
      ]),
      key: r'STRE_FILE_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> fileSize() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_SIZE',
          fields: fields,
        )
      ]),
      key: r'FILE_SIZE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> repreYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPRE_YN',
          fields: fields,
        )
      ]),
      key: r'REPRE_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> dwldCo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DWLD_CO',
          fields: fields,
        )
      ]),
      key: r'DWLD_CO',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class STBOARDFILEAvgAggregateOutputType {
  const STBOARDFILEAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> mseq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSEQ',
          fields: fields,
        )
      ]),
      key: r'MSEQ',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> fileSize() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_SIZE',
          fields: fields,
        )
      ]),
      key: r'FILE_SIZE',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> dwldCo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DWLD_CO',
          fields: fields,
        )
      ]),
      key: r'DWLD_CO',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class STBOARDFILESumAggregateOutputType {
  const STBOARDFILESumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> mseq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSEQ',
          fields: fields,
        )
      ]),
      key: r'MSEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> fileSize() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_SIZE',
          fields: fields,
        )
      ]),
      key: r'FILE_SIZE',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> dwldCo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DWLD_CO',
          fields: fields,
        )
      ]),
      key: r'DWLD_CO',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class STBOARDFILEMinAggregateOutputType {
  const STBOARDFILEMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> mseq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSEQ',
          fields: fields,
        )
      ]),
      key: r'MSEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> boardCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BOARD_CD',
          fields: fields,
        )
      ]),
      key: r'BOARD_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> fileTp() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_TP',
          fields: fields,
        )
      ]),
      key: r'FILE_TP',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> flpth() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FLPTH',
          fields: fields,
        )
      ]),
      key: r'FLPTH',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> orginalFileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ORGINAL_FILE_NM',
          fields: fields,
        )
      ]),
      key: r'ORGINAL_FILE_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> streFileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STRE_FILE_NM',
          fields: fields,
        )
      ]),
      key: r'STRE_FILE_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> fileSize() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_SIZE',
          fields: fields,
        )
      ]),
      key: r'FILE_SIZE',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> repreYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPRE_YN',
          fields: fields,
        )
      ]),
      key: r'REPRE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> dwldCo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DWLD_CO',
          fields: fields,
        )
      ]),
      key: r'DWLD_CO',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class STBOARDFILEMaxAggregateOutputType {
  const STBOARDFILEMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> mseq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSEQ',
          fields: fields,
        )
      ]),
      key: r'MSEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> boardCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BOARD_CD',
          fields: fields,
        )
      ]),
      key: r'BOARD_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> fileTp() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_TP',
          fields: fields,
        )
      ]),
      key: r'FILE_TP',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> flpth() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FLPTH',
          fields: fields,
        )
      ]),
      key: r'FLPTH',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> orginalFileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ORGINAL_FILE_NM',
          fields: fields,
        )
      ]),
      key: r'ORGINAL_FILE_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> streFileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STRE_FILE_NM',
          fields: fields,
        )
      ]),
      key: r'STRE_FILE_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> fileSize() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_SIZE',
          fields: fields,
        )
      ]),
      key: r'FILE_SIZE',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> repreYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPRE_YN',
          fields: fields,
        )
      ]),
      key: r'REPRE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> dwldCo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DWLD_CO',
          fields: fields,
        )
      ]),
      key: r'DWLD_CO',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class STBOARDMSTCountAggregateOutputType {
  const STBOARDMSTCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> boardCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BOARD_CD',
          fields: fields,
        )
      ]),
      key: r'BOARD_CD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> clsCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CLS_CD',
          fields: fields,
        )
      ]),
      key: r'CLS_CD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> ttl() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'TTL',
          fields: fields,
        )
      ]),
      key: r'TTL',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> cnts() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CNTS',
          fields: fields,
        )
      ]),
      key: r'CNTS',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> fileYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_YN',
          fields: fields,
        )
      ]),
      key: r'FILE_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> imageYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'IMAGE_YN',
          fields: fields,
        )
      ]),
      key: r'IMAGE_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> noticeYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'NOTICE_YN',
          fields: fields,
        )
      ]),
      key: r'NOTICE_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> lkUrl() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LK_URL',
          fields: fields,
        )
      ]),
      key: r'LK_URL',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> lkTarget() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LK_TARGET',
          fields: fields,
        )
      ]),
      key: r'LK_TARGET',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> readCnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'READ_CNT',
          fields: fields,
        )
      ]),
      key: r'READ_CNT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regAdminYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ADMIN_YN',
          fields: fields,
        )
      ]),
      key: r'REG_ADMIN_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> replyYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPLY_YN',
          fields: fields,
        )
      ]),
      key: r'REPLY_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> upperSeq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPPER_SEQ',
          fields: fields,
        )
      ]),
      key: r'UPPER_SEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class STBOARDMSTAvgAggregateOutputType {
  const STBOARDMSTAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> readCnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'READ_CNT',
          fields: fields,
        )
      ]),
      key: r'READ_CNT',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> upperSeq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPPER_SEQ',
          fields: fields,
        )
      ]),
      key: r'UPPER_SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class STBOARDMSTSumAggregateOutputType {
  const STBOARDMSTSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> readCnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'READ_CNT',
          fields: fields,
        )
      ]),
      key: r'READ_CNT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> upperSeq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPPER_SEQ',
          fields: fields,
        )
      ]),
      key: r'UPPER_SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class STBOARDMSTMinAggregateOutputType {
  const STBOARDMSTMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> boardCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BOARD_CD',
          fields: fields,
        )
      ]),
      key: r'BOARD_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> clsCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CLS_CD',
          fields: fields,
        )
      ]),
      key: r'CLS_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> ttl() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'TTL',
          fields: fields,
        )
      ]),
      key: r'TTL',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> cnts() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CNTS',
          fields: fields,
        )
      ]),
      key: r'CNTS',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> fileYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_YN',
          fields: fields,
        )
      ]),
      key: r'FILE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> imageYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'IMAGE_YN',
          fields: fields,
        )
      ]),
      key: r'IMAGE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> noticeYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'NOTICE_YN',
          fields: fields,
        )
      ]),
      key: r'NOTICE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> lkUrl() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LK_URL',
          fields: fields,
        )
      ]),
      key: r'LK_URL',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> lkTarget() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LK_TARGET',
          fields: fields,
        )
      ]),
      key: r'LK_TARGET',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> readCnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'READ_CNT',
          fields: fields,
        )
      ]),
      key: r'READ_CNT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> regAdminYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ADMIN_YN',
          fields: fields,
        )
      ]),
      key: r'REG_ADMIN_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> replyYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPLY_YN',
          fields: fields,
        )
      ]),
      key: r'REPLY_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> upperSeq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPPER_SEQ',
          fields: fields,
        )
      ]),
      key: r'UPPER_SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STBOARDMSTMaxAggregateOutputType {
  const STBOARDMSTMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> boardCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BOARD_CD',
          fields: fields,
        )
      ]),
      key: r'BOARD_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> clsCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CLS_CD',
          fields: fields,
        )
      ]),
      key: r'CLS_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> ttl() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'TTL',
          fields: fields,
        )
      ]),
      key: r'TTL',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> cnts() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CNTS',
          fields: fields,
        )
      ]),
      key: r'CNTS',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> fileYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_YN',
          fields: fields,
        )
      ]),
      key: r'FILE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> imageYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'IMAGE_YN',
          fields: fields,
        )
      ]),
      key: r'IMAGE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> noticeYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'NOTICE_YN',
          fields: fields,
        )
      ]),
      key: r'NOTICE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> lkUrl() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LK_URL',
          fields: fields,
        )
      ]),
      key: r'LK_URL',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> lkTarget() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LK_TARGET',
          fields: fields,
        )
      ]),
      key: r'LK_TARGET',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> readCnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'READ_CNT',
          fields: fields,
        )
      ]),
      key: r'READ_CNT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> regAdminYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ADMIN_YN',
          fields: fields,
        )
      ]),
      key: r'REG_ADMIN_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> replyYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPLY_YN',
          fields: fields,
        )
      ]),
      key: r'REPLY_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> upperSeq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPPER_SEQ',
          fields: fields,
        )
      ]),
      key: r'UPPER_SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STBOARDSTNGCountAggregateOutputType {
  const STBOARDSTNGCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> boardCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BOARD_CD',
          fields: fields,
        )
      ]),
      key: r'BOARD_CD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> boardNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BOARD_NM',
          fields: fields,
        )
      ]),
      key: r'BOARD_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> boardTy() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BOARD_TY',
          fields: fields,
        )
      ]),
      key: r'BOARD_TY',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editorYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDITOR_YN',
          fields: fields,
        )
      ]),
      key: r'EDITOR_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> rlsYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RLS_YN',
          fields: fields,
        )
      ]),
      key: r'RLS_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> cclSeq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CCL_SEQ',
          fields: fields,
        )
      ]),
      key: r'CCL_SEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> listCnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LIST_CNT',
          fields: fields,
        )
      ]),
      key: r'LIST_CNT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> writeYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITE_YN',
          fields: fields,
        )
      ]),
      key: r'WRITE_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> commentYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'COMMENT_YN',
          fields: fields,
        )
      ]),
      key: r'COMMENT_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> replyYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPLY_YN',
          fields: fields,
        )
      ]),
      key: r'REPLY_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> attachYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ATTACH_YN',
          fields: fields,
        )
      ]),
      key: r'ATTACH_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> attachSize() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ATTACH_SIZE',
          fields: fields,
        )
      ]),
      key: r'ATTACH_SIZE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> attachCnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ATTACH_CNT',
          fields: fields,
        )
      ]),
      key: r'ATTACH_CNT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> attachExt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ATTACH_EXT',
          fields: fields,
        )
      ]),
      key: r'ATTACH_EXT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class STBOARDSTNGAvgAggregateOutputType {
  const STBOARDSTNGAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> cclSeq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CCL_SEQ',
          fields: fields,
        )
      ]),
      key: r'CCL_SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> listCnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LIST_CNT',
          fields: fields,
        )
      ]),
      key: r'LIST_CNT',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class STBOARDSTNGSumAggregateOutputType {
  const STBOARDSTNGSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> cclSeq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CCL_SEQ',
          fields: fields,
        )
      ]),
      key: r'CCL_SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> listCnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LIST_CNT',
          fields: fields,
        )
      ]),
      key: r'LIST_CNT',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class STBOARDSTNGMinAggregateOutputType {
  const STBOARDSTNGMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> boardCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BOARD_CD',
          fields: fields,
        )
      ]),
      key: r'BOARD_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> boardNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BOARD_NM',
          fields: fields,
        )
      ]),
      key: r'BOARD_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> boardTy() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BOARD_TY',
          fields: fields,
        )
      ]),
      key: r'BOARD_TY',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editorYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDITOR_YN',
          fields: fields,
        )
      ]),
      key: r'EDITOR_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> rlsYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RLS_YN',
          fields: fields,
        )
      ]),
      key: r'RLS_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> cclSeq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CCL_SEQ',
          fields: fields,
        )
      ]),
      key: r'CCL_SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> listCnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LIST_CNT',
          fields: fields,
        )
      ]),
      key: r'LIST_CNT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> writeYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITE_YN',
          fields: fields,
        )
      ]),
      key: r'WRITE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> commentYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'COMMENT_YN',
          fields: fields,
        )
      ]),
      key: r'COMMENT_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> replyYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPLY_YN',
          fields: fields,
        )
      ]),
      key: r'REPLY_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> attachYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ATTACH_YN',
          fields: fields,
        )
      ]),
      key: r'ATTACH_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> attachSize() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ATTACH_SIZE',
          fields: fields,
        )
      ]),
      key: r'ATTACH_SIZE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> attachCnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ATTACH_CNT',
          fields: fields,
        )
      ]),
      key: r'ATTACH_CNT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> attachExt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ATTACH_EXT',
          fields: fields,
        )
      ]),
      key: r'ATTACH_EXT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STBOARDSTNGMaxAggregateOutputType {
  const STBOARDSTNGMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> boardCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BOARD_CD',
          fields: fields,
        )
      ]),
      key: r'BOARD_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> boardNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BOARD_NM',
          fields: fields,
        )
      ]),
      key: r'BOARD_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> boardTy() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BOARD_TY',
          fields: fields,
        )
      ]),
      key: r'BOARD_TY',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editorYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDITOR_YN',
          fields: fields,
        )
      ]),
      key: r'EDITOR_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> rlsYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RLS_YN',
          fields: fields,
        )
      ]),
      key: r'RLS_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> cclSeq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CCL_SEQ',
          fields: fields,
        )
      ]),
      key: r'CCL_SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> listCnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LIST_CNT',
          fields: fields,
        )
      ]),
      key: r'LIST_CNT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> writeYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WRITE_YN',
          fields: fields,
        )
      ]),
      key: r'WRITE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> commentYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'COMMENT_YN',
          fields: fields,
        )
      ]),
      key: r'COMMENT_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> replyYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPLY_YN',
          fields: fields,
        )
      ]),
      key: r'REPLY_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> attachYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ATTACH_YN',
          fields: fields,
        )
      ]),
      key: r'ATTACH_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> attachSize() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ATTACH_SIZE',
          fields: fields,
        )
      ]),
      key: r'ATTACH_SIZE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> attachCnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ATTACH_CNT',
          fields: fields,
        )
      ]),
      key: r'ATTACH_CNT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> attachExt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ATTACH_EXT',
          fields: fields,
        )
      ]),
      key: r'ATTACH_EXT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STCCLCountAggregateOutputType {
  const STCCLCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> cclType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CCL_TYPE',
          fields: fields,
        )
      ]),
      key: r'CCL_TYPE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> cclNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CCL_NM',
          fields: fields,
        )
      ]),
      key: r'CCL_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> flpth() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FLPTH',
          fields: fields,
        )
      ]),
      key: r'FLPTH',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> orginalFileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ORGINAL_FILE_NM',
          fields: fields,
        )
      ]),
      key: r'ORGINAL_FILE_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> streFileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STRE_FILE_NM',
          fields: fields,
        )
      ]),
      key: r'STRE_FILE_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> fileExtsn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_EXTSN',
          fields: fields,
        )
      ]),
      key: r'FILE_EXTSN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> fileSize() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_SIZE',
          fields: fields,
        )
      ]),
      key: r'FILE_SIZE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class STCCLAvgAggregateOutputType {
  const STCCLAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> fileSize() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_SIZE',
          fields: fields,
        )
      ]),
      key: r'FILE_SIZE',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class STCCLSumAggregateOutputType {
  const STCCLSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> fileSize() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_SIZE',
          fields: fields,
        )
      ]),
      key: r'FILE_SIZE',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class STCCLMinAggregateOutputType {
  const STCCLMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> cclType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CCL_TYPE',
          fields: fields,
        )
      ]),
      key: r'CCL_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> cclNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CCL_NM',
          fields: fields,
        )
      ]),
      key: r'CCL_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> flpth() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FLPTH',
          fields: fields,
        )
      ]),
      key: r'FLPTH',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> orginalFileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ORGINAL_FILE_NM',
          fields: fields,
        )
      ]),
      key: r'ORGINAL_FILE_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> streFileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STRE_FILE_NM',
          fields: fields,
        )
      ]),
      key: r'STRE_FILE_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> fileExtsn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_EXTSN',
          fields: fields,
        )
      ]),
      key: r'FILE_EXTSN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> fileSize() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_SIZE',
          fields: fields,
        )
      ]),
      key: r'FILE_SIZE',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STCCLMaxAggregateOutputType {
  const STCCLMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> cclType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CCL_TYPE',
          fields: fields,
        )
      ]),
      key: r'CCL_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> cclNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CCL_NM',
          fields: fields,
        )
      ]),
      key: r'CCL_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> flpth() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FLPTH',
          fields: fields,
        )
      ]),
      key: r'FLPTH',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> orginalFileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ORGINAL_FILE_NM',
          fields: fields,
        )
      ]),
      key: r'ORGINAL_FILE_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> streFileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STRE_FILE_NM',
          fields: fields,
        )
      ]),
      key: r'STRE_FILE_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> fileExtsn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_EXTSN',
          fields: fields,
        )
      ]),
      key: r'FILE_EXTSN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> fileSize() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_SIZE',
          fields: fields,
        )
      ]),
      key: r'FILE_SIZE',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STCODEMSTCountAggregateOutputType {
  const STCODEMSTCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> cdGrp() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CD_GRP',
          fields: fields,
        )
      ]),
      key: r'CD_GRP',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> cdKey() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CD_KEY',
          fields: fields,
        )
      ]),
      key: r'CD_KEY',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> cdVal() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CD_VAL',
          fields: fields,
        )
      ]),
      key: r'CD_VAL',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> cdDesc() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CD_DESC',
          fields: fields,
        )
      ]),
      key: r'CD_DESC',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> cdSrt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CD_SRT',
          fields: fields,
        )
      ]),
      key: r'CD_SRT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> depth() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPTH',
          fields: fields,
        )
      ]),
      key: r'DEPTH',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class STCODEMSTAvgAggregateOutputType {
  const STCODEMSTAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> cdSrt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CD_SRT',
          fields: fields,
        )
      ]),
      key: r'CD_SRT',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> depth() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPTH',
          fields: fields,
        )
      ]),
      key: r'DEPTH',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class STCODEMSTSumAggregateOutputType {
  const STCODEMSTSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> cdSrt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CD_SRT',
          fields: fields,
        )
      ]),
      key: r'CD_SRT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> depth() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPTH',
          fields: fields,
        )
      ]),
      key: r'DEPTH',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class STCODEMSTMinAggregateOutputType {
  const STCODEMSTMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> cdGrp() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CD_GRP',
          fields: fields,
        )
      ]),
      key: r'CD_GRP',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> cdKey() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CD_KEY',
          fields: fields,
        )
      ]),
      key: r'CD_KEY',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> cdVal() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CD_VAL',
          fields: fields,
        )
      ]),
      key: r'CD_VAL',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> cdDesc() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CD_DESC',
          fields: fields,
        )
      ]),
      key: r'CD_DESC',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> cdSrt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CD_SRT',
          fields: fields,
        )
      ]),
      key: r'CD_SRT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> depth() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPTH',
          fields: fields,
        )
      ]),
      key: r'DEPTH',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STCODEMSTMaxAggregateOutputType {
  const STCODEMSTMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> cdGrp() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CD_GRP',
          fields: fields,
        )
      ]),
      key: r'CD_GRP',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> cdKey() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CD_KEY',
          fields: fields,
        )
      ]),
      key: r'CD_KEY',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> cdVal() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CD_VAL',
          fields: fields,
        )
      ]),
      key: r'CD_VAL',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> cdDesc() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CD_DESC',
          fields: fields,
        )
      ]),
      key: r'CD_DESC',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> cdSrt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CD_SRT',
          fields: fields,
        )
      ]),
      key: r'CD_SRT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> depth() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPTH',
          fields: fields,
        )
      ]),
      key: r'DEPTH',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STCONNECTLOGCountAggregateOutputType {
  const STCONNECTLOGCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_ID',
          fields: fields,
        )
      ]),
      key: r'USER_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> connType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CONN_TYPE',
          fields: fields,
        )
      ]),
      key: r'CONN_TYPE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> osType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'OS_TYPE',
          fields: fields,
        )
      ]),
      key: r'OS_TYPE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> browserType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BROWSER_TYPE',
          fields: fields,
        )
      ]),
      key: r'BROWSER_TYPE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> conneIp() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CONNE_IP',
          fields: fields,
        )
      ]),
      key: r'CONNE_IP',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class STCONNECTLOGAvgAggregateOutputType {
  const STCONNECTLOGAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class STCONNECTLOGSumAggregateOutputType {
  const STCONNECTLOGSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class STCONNECTLOGMinAggregateOutputType {
  const STCONNECTLOGMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_ID',
          fields: fields,
        )
      ]),
      key: r'USER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> connType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CONN_TYPE',
          fields: fields,
        )
      ]),
      key: r'CONN_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> osType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'OS_TYPE',
          fields: fields,
        )
      ]),
      key: r'OS_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> browserType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BROWSER_TYPE',
          fields: fields,
        )
      ]),
      key: r'BROWSER_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> conneIp() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CONNE_IP',
          fields: fields,
        )
      ]),
      key: r'CONNE_IP',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STCONNECTLOGMaxAggregateOutputType {
  const STCONNECTLOGMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_ID',
          fields: fields,
        )
      ]),
      key: r'USER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> connType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CONN_TYPE',
          fields: fields,
        )
      ]),
      key: r'CONN_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> osType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'OS_TYPE',
          fields: fields,
        )
      ]),
      key: r'OS_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> browserType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BROWSER_TYPE',
          fields: fields,
        )
      ]),
      key: r'BROWSER_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> conneIp() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CONNE_IP',
          fields: fields,
        )
      ]),
      key: r'CONNE_IP',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STCONTENTSFILECountAggregateOutputType {
  const STCONTENTSFILECountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> mseq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSEQ',
          fields: fields,
        )
      ]),
      key: r'MSEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> fileTp() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_TP',
          fields: fields,
        )
      ]),
      key: r'FILE_TP',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> flpth() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FLPTH',
          fields: fields,
        )
      ]),
      key: r'FLPTH',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> orginalFileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ORGINAL_FILE_NM',
          fields: fields,
        )
      ]),
      key: r'ORGINAL_FILE_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> streFileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STRE_FILE_NM',
          fields: fields,
        )
      ]),
      key: r'STRE_FILE_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> fileSize() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_SIZE',
          fields: fields,
        )
      ]),
      key: r'FILE_SIZE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class STCONTENTSFILEAvgAggregateOutputType {
  const STCONTENTSFILEAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> fileSize() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_SIZE',
          fields: fields,
        )
      ]),
      key: r'FILE_SIZE',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class STCONTENTSFILESumAggregateOutputType {
  const STCONTENTSFILESumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> fileSize() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_SIZE',
          fields: fields,
        )
      ]),
      key: r'FILE_SIZE',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class STCONTENTSFILEMinAggregateOutputType {
  const STCONTENTSFILEMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> mseq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSEQ',
          fields: fields,
        )
      ]),
      key: r'MSEQ',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> fileTp() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_TP',
          fields: fields,
        )
      ]),
      key: r'FILE_TP',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> flpth() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FLPTH',
          fields: fields,
        )
      ]),
      key: r'FLPTH',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> orginalFileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ORGINAL_FILE_NM',
          fields: fields,
        )
      ]),
      key: r'ORGINAL_FILE_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> streFileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STRE_FILE_NM',
          fields: fields,
        )
      ]),
      key: r'STRE_FILE_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> fileSize() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_SIZE',
          fields: fields,
        )
      ]),
      key: r'FILE_SIZE',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class STCONTENTSFILEMaxAggregateOutputType {
  const STCONTENTSFILEMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> mseq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSEQ',
          fields: fields,
        )
      ]),
      key: r'MSEQ',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> fileTp() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_TP',
          fields: fields,
        )
      ]),
      key: r'FILE_TP',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> flpth() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FLPTH',
          fields: fields,
        )
      ]),
      key: r'FLPTH',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> orginalFileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ORGINAL_FILE_NM',
          fields: fields,
        )
      ]),
      key: r'ORGINAL_FILE_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> streFileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STRE_FILE_NM',
          fields: fields,
        )
      ]),
      key: r'STRE_FILE_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> fileSize() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_SIZE',
          fields: fields,
        )
      ]),
      key: r'FILE_SIZE',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class STCONTENTSMSTCountAggregateOutputType {
  const STCONTENTSMSTCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> cntsNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CNTS_NM',
          fields: fields,
        )
      ]),
      key: r'CNTS_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> pubDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PUB_DATE',
          fields: fields,
        )
      ]),
      key: r'PUB_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> pubState() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PUB_STATE',
          fields: fields,
        )
      ]),
      key: r'PUB_STATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> cn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CN',
          fields: fields,
        )
      ]),
      key: r'CN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> srchYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SRCH_YN',
          fields: fields,
        )
      ]),
      key: r'SRCH_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> fileYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_YN',
          fields: fields,
        )
      ]),
      key: r'FILE_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> imageYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'IMAGE_YN',
          fields: fields,
        )
      ]),
      key: r'IMAGE_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class STCONTENTSMSTAvgAggregateOutputType {
  const STCONTENTSMSTAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class STCONTENTSMSTSumAggregateOutputType {
  const STCONTENTSMSTSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class STCONTENTSMSTMinAggregateOutputType {
  const STCONTENTSMSTMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> cntsNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CNTS_NM',
          fields: fields,
        )
      ]),
      key: r'CNTS_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> pubDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PUB_DATE',
          fields: fields,
        )
      ]),
      key: r'PUB_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> pubState() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PUB_STATE',
          fields: fields,
        )
      ]),
      key: r'PUB_STATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> cn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CN',
          fields: fields,
        )
      ]),
      key: r'CN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> srchYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SRCH_YN',
          fields: fields,
        )
      ]),
      key: r'SRCH_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> fileYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_YN',
          fields: fields,
        )
      ]),
      key: r'FILE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> imageYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'IMAGE_YN',
          fields: fields,
        )
      ]),
      key: r'IMAGE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STCONTENTSMSTMaxAggregateOutputType {
  const STCONTENTSMSTMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> cntsNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CNTS_NM',
          fields: fields,
        )
      ]),
      key: r'CNTS_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> pubDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PUB_DATE',
          fields: fields,
        )
      ]),
      key: r'PUB_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> pubState() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PUB_STATE',
          fields: fields,
        )
      ]),
      key: r'PUB_STATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> cn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CN',
          fields: fields,
        )
      ]),
      key: r'CN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> srchYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SRCH_YN',
          fields: fields,
        )
      ]),
      key: r'SRCH_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> fileYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_YN',
          fields: fields,
        )
      ]),
      key: r'FILE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> imageYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'IMAGE_YN',
          fields: fields,
        )
      ]),
      key: r'IMAGE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STDEPTCountAggregateOutputType {
  const STDEPTCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> deptCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPT_CD',
          fields: fields,
        )
      ]),
      key: r'DEPT_CD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> deptNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPT_NM',
          fields: fields,
        )
      ]),
      key: r'DEPT_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> upperDeptCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPPER_DEPT_CD',
          fields: fields,
        )
      ]),
      key: r'UPPER_DEPT_CD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> upperDeptNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPPER_DEPT_NM',
          fields: fields,
        )
      ]),
      key: r'UPPER_DEPT_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> mainYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MAIN_YN',
          fields: fields,
        )
      ]),
      key: r'MAIN_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> deptDesc() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPT_DESC',
          fields: fields,
        )
      ]),
      key: r'DEPT_DESC',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class STDEPTAvgAggregateOutputType {
  const STDEPTAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class STDEPTSumAggregateOutputType {
  const STDEPTSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class STDEPTMinAggregateOutputType {
  const STDEPTMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> deptCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPT_CD',
          fields: fields,
        )
      ]),
      key: r'DEPT_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> deptNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPT_NM',
          fields: fields,
        )
      ]),
      key: r'DEPT_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> upperDeptCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPPER_DEPT_CD',
          fields: fields,
        )
      ]),
      key: r'UPPER_DEPT_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> upperDeptNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPPER_DEPT_NM',
          fields: fields,
        )
      ]),
      key: r'UPPER_DEPT_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> mainYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MAIN_YN',
          fields: fields,
        )
      ]),
      key: r'MAIN_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> deptDesc() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPT_DESC',
          fields: fields,
        )
      ]),
      key: r'DEPT_DESC',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STDEPTMaxAggregateOutputType {
  const STDEPTMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> deptCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPT_CD',
          fields: fields,
        )
      ]),
      key: r'DEPT_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> deptNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPT_NM',
          fields: fields,
        )
      ]),
      key: r'DEPT_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> upperDeptCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPPER_DEPT_CD',
          fields: fields,
        )
      ]),
      key: r'UPPER_DEPT_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> upperDeptNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPPER_DEPT_NM',
          fields: fields,
        )
      ]),
      key: r'UPPER_DEPT_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> mainYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MAIN_YN',
          fields: fields,
        )
      ]),
      key: r'MAIN_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> deptDesc() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPT_DESC',
          fields: fields,
        )
      ]),
      key: r'DEPT_DESC',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STDEPTEMPCountAggregateOutputType {
  const STDEPTEMPCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> empNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EMP_NO',
          fields: fields,
        )
      ]),
      key: r'EMP_NO',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> empNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EMP_NM',
          fields: fields,
        )
      ]),
      key: r'EMP_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> deptCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPT_CD',
          fields: fields,
        )
      ]),
      key: r'DEPT_CD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> deptNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPT_NM',
          fields: fields,
        )
      ]),
      key: r'DEPT_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> fctnCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FCTN_CD',
          fields: fields,
        )
      ]),
      key: r'FCTN_CD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> fctnNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FCTN_NM',
          fields: fields,
        )
      ]),
      key: r'FCTN_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> ofcpCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'OFCP_CD',
          fields: fields,
        )
      ]),
      key: r'OFCP_CD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> ofcpNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'OFCP_NM',
          fields: fields,
        )
      ]),
      key: r'OFCP_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> emailAddr() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EMAIL_ADDR',
          fields: fields,
        )
      ]),
      key: r'EMAIL_ADDR',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> offmTelno() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'OFFM_TELNO',
          fields: fields,
        )
      ]),
      key: r'OFFM_TELNO',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> htelTelno() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'HTEL_TELNO',
          fields: fields,
        )
      ]),
      key: r'HTEL_TELNO',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> deptYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPT_YN',
          fields: fields,
        )
      ]),
      key: r'DEPT_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class STDEPTEMPMinAggregateOutputType {
  const STDEPTEMPMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> empNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EMP_NO',
          fields: fields,
        )
      ]),
      key: r'EMP_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> empNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EMP_NM',
          fields: fields,
        )
      ]),
      key: r'EMP_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> deptCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPT_CD',
          fields: fields,
        )
      ]),
      key: r'DEPT_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> deptNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPT_NM',
          fields: fields,
        )
      ]),
      key: r'DEPT_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> fctnCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FCTN_CD',
          fields: fields,
        )
      ]),
      key: r'FCTN_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> fctnNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FCTN_NM',
          fields: fields,
        )
      ]),
      key: r'FCTN_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> ofcpCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'OFCP_CD',
          fields: fields,
        )
      ]),
      key: r'OFCP_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> ofcpNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'OFCP_NM',
          fields: fields,
        )
      ]),
      key: r'OFCP_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> emailAddr() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EMAIL_ADDR',
          fields: fields,
        )
      ]),
      key: r'EMAIL_ADDR',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> offmTelno() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'OFFM_TELNO',
          fields: fields,
        )
      ]),
      key: r'OFFM_TELNO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> htelTelno() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'HTEL_TELNO',
          fields: fields,
        )
      ]),
      key: r'HTEL_TELNO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> deptYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPT_YN',
          fields: fields,
        )
      ]),
      key: r'DEPT_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STDEPTEMPMaxAggregateOutputType {
  const STDEPTEMPMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> empNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EMP_NO',
          fields: fields,
        )
      ]),
      key: r'EMP_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> empNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EMP_NM',
          fields: fields,
        )
      ]),
      key: r'EMP_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> deptCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPT_CD',
          fields: fields,
        )
      ]),
      key: r'DEPT_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> deptNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPT_NM',
          fields: fields,
        )
      ]),
      key: r'DEPT_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> fctnCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FCTN_CD',
          fields: fields,
        )
      ]),
      key: r'FCTN_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> fctnNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FCTN_NM',
          fields: fields,
        )
      ]),
      key: r'FCTN_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> ofcpCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'OFCP_CD',
          fields: fields,
        )
      ]),
      key: r'OFCP_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> ofcpNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'OFCP_NM',
          fields: fields,
        )
      ]),
      key: r'OFCP_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> emailAddr() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EMAIL_ADDR',
          fields: fields,
        )
      ]),
      key: r'EMAIL_ADDR',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> offmTelno() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'OFFM_TELNO',
          fields: fields,
        )
      ]),
      key: r'OFFM_TELNO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> htelTelno() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'HTEL_TELNO',
          fields: fields,
        )
      ]),
      key: r'HTEL_TELNO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> deptYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPT_YN',
          fields: fields,
        )
      ]),
      key: r'DEPT_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STMENUCountAggregateOutputType {
  const STMENUCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> menuCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_CD',
          fields: fields,
        )
      ]),
      key: r'MENU_CD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> menuNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_NM',
          fields: fields,
        )
      ]),
      key: r'MENU_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> menuPath() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_PATH',
          fields: fields,
        )
      ]),
      key: r'MENU_PATH',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> menuMapping() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_MAPPING',
          fields: fields,
        )
      ]),
      key: r'MENU_MAPPING',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> menuSrt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_SRT',
          fields: fields,
        )
      ]),
      key: r'MENU_SRT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> menuDeps() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_DEPS',
          fields: fields,
        )
      ]),
      key: r'MENU_DEPS',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> menuIcon() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_ICON',
          fields: fields,
        )
      ]),
      key: r'MENU_ICON',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> menuTp() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_TP',
          fields: fields,
        )
      ]),
      key: r'MENU_TP',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> mainExpsrYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MAIN_EXPSR_YN',
          fields: fields,
        )
      ]),
      key: r'MAIN_EXPSR_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> subExpsrYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SUB_EXPSR_YN',
          fields: fields,
        )
      ]),
      key: r'SUB_EXPSR_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> upendClas() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPEND_CLAS',
          fields: fields,
        )
      ]),
      key: r'UPEND_CLAS',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> upendCn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPEND_CN',
          fields: fields,
        )
      ]),
      key: r'UPEND_CN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> cclType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CCL_TYPE',
          fields: fields,
        )
      ]),
      key: r'CCL_TYPE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class STMENUAvgAggregateOutputType {
  const STMENUAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> menuSrt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_SRT',
          fields: fields,
        )
      ]),
      key: r'MENU_SRT',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> menuDeps() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_DEPS',
          fields: fields,
        )
      ]),
      key: r'MENU_DEPS',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class STMENUSumAggregateOutputType {
  const STMENUSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> menuSrt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_SRT',
          fields: fields,
        )
      ]),
      key: r'MENU_SRT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> menuDeps() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_DEPS',
          fields: fields,
        )
      ]),
      key: r'MENU_DEPS',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class STMENUMinAggregateOutputType {
  const STMENUMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> menuCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_CD',
          fields: fields,
        )
      ]),
      key: r'MENU_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> menuNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_NM',
          fields: fields,
        )
      ]),
      key: r'MENU_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> menuPath() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_PATH',
          fields: fields,
        )
      ]),
      key: r'MENU_PATH',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> menuMapping() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_MAPPING',
          fields: fields,
        )
      ]),
      key: r'MENU_MAPPING',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> menuSrt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_SRT',
          fields: fields,
        )
      ]),
      key: r'MENU_SRT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> menuDeps() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_DEPS',
          fields: fields,
        )
      ]),
      key: r'MENU_DEPS',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> menuIcon() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_ICON',
          fields: fields,
        )
      ]),
      key: r'MENU_ICON',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> menuTp() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_TP',
          fields: fields,
        )
      ]),
      key: r'MENU_TP',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> mainExpsrYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MAIN_EXPSR_YN',
          fields: fields,
        )
      ]),
      key: r'MAIN_EXPSR_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> subExpsrYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SUB_EXPSR_YN',
          fields: fields,
        )
      ]),
      key: r'SUB_EXPSR_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> upendClas() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPEND_CLAS',
          fields: fields,
        )
      ]),
      key: r'UPEND_CLAS',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> upendCn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPEND_CN',
          fields: fields,
        )
      ]),
      key: r'UPEND_CN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> cclType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CCL_TYPE',
          fields: fields,
        )
      ]),
      key: r'CCL_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STMENUMaxAggregateOutputType {
  const STMENUMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> menuCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_CD',
          fields: fields,
        )
      ]),
      key: r'MENU_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> menuNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_NM',
          fields: fields,
        )
      ]),
      key: r'MENU_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> menuPath() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_PATH',
          fields: fields,
        )
      ]),
      key: r'MENU_PATH',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> menuMapping() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_MAPPING',
          fields: fields,
        )
      ]),
      key: r'MENU_MAPPING',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> menuSrt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_SRT',
          fields: fields,
        )
      ]),
      key: r'MENU_SRT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> menuDeps() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_DEPS',
          fields: fields,
        )
      ]),
      key: r'MENU_DEPS',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> menuIcon() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_ICON',
          fields: fields,
        )
      ]),
      key: r'MENU_ICON',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> menuTp() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_TP',
          fields: fields,
        )
      ]),
      key: r'MENU_TP',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> mainExpsrYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MAIN_EXPSR_YN',
          fields: fields,
        )
      ]),
      key: r'MAIN_EXPSR_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> subExpsrYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SUB_EXPSR_YN',
          fields: fields,
        )
      ]),
      key: r'SUB_EXPSR_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> upendClas() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPEND_CLAS',
          fields: fields,
        )
      ]),
      key: r'UPEND_CLAS',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> upendCn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPEND_CN',
          fields: fields,
        )
      ]),
      key: r'UPEND_CN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> cclType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CCL_TYPE',
          fields: fields,
        )
      ]),
      key: r'CCL_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STMESSAGETMPLATCountAggregateOutputType {
  const STMESSAGETMPLATCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> msgDivCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSG_DIV_CD',
          fields: fields,
        )
      ]),
      key: r'MSG_DIV_CD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> msgCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSG_CD',
          fields: fields,
        )
      ]),
      key: r'MSG_CD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> msgNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSG_NM',
          fields: fields,
        )
      ]),
      key: r'MSG_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> msgTmplat() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSG_TMPLAT',
          fields: fields,
        )
      ]),
      key: r'MSG_TMPLAT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class STMESSAGETMPLATMinAggregateOutputType {
  const STMESSAGETMPLATMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> msgDivCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSG_DIV_CD',
          fields: fields,
        )
      ]),
      key: r'MSG_DIV_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> msgCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSG_CD',
          fields: fields,
        )
      ]),
      key: r'MSG_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> msgNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSG_NM',
          fields: fields,
        )
      ]),
      key: r'MSG_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> msgTmplat() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSG_TMPLAT',
          fields: fields,
        )
      ]),
      key: r'MSG_TMPLAT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STMESSAGETMPLATMaxAggregateOutputType {
  const STMESSAGETMPLATMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> msgDivCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSG_DIV_CD',
          fields: fields,
        )
      ]),
      key: r'MSG_DIV_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> msgCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSG_CD',
          fields: fields,
        )
      ]),
      key: r'MSG_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> msgNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSG_NM',
          fields: fields,
        )
      ]),
      key: r'MSG_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> msgTmplat() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSG_TMPLAT',
          fields: fields,
        )
      ]),
      key: r'MSG_TMPLAT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STMIMETYPECountAggregateOutputType {
  const STMIMETYPECountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> extnNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EXTN_NM',
          fields: fields,
        )
      ]),
      key: r'EXTN_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> fileMt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_MT',
          fields: fields,
        )
      ]),
      key: r'FILE_MT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class STMIMETYPEAvgAggregateOutputType {
  const STMIMETYPEAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class STMIMETYPESumAggregateOutputType {
  const STMIMETYPESumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class STMIMETYPEMinAggregateOutputType {
  const STMIMETYPEMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> extnNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EXTN_NM',
          fields: fields,
        )
      ]),
      key: r'EXTN_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> fileMt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_MT',
          fields: fields,
        )
      ]),
      key: r'FILE_MT',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STMIMETYPEMaxAggregateOutputType {
  const STMIMETYPEMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> extnNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EXTN_NM',
          fields: fields,
        )
      ]),
      key: r'EXTN_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> fileMt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_MT',
          fields: fields,
        )
      ]),
      key: r'FILE_MT',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STMNGRGRPCountAggregateOutputType {
  const STMNGRGRPCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> grpCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'GRP_CD',
          fields: fields,
        )
      ]),
      key: r'GRP_CD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> grpNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'GRP_NM',
          fields: fields,
        )
      ]),
      key: r'GRP_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> grpDesc() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'GRP_DESC',
          fields: fields,
        )
      ]),
      key: r'GRP_DESC',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class STMNGRGRPAvgAggregateOutputType {
  const STMNGRGRPAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class STMNGRGRPSumAggregateOutputType {
  const STMNGRGRPSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class STMNGRGRPMinAggregateOutputType {
  const STMNGRGRPMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> grpCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'GRP_CD',
          fields: fields,
        )
      ]),
      key: r'GRP_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> grpNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'GRP_NM',
          fields: fields,
        )
      ]),
      key: r'GRP_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> grpDesc() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'GRP_DESC',
          fields: fields,
        )
      ]),
      key: r'GRP_DESC',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STMNGRGRPMaxAggregateOutputType {
  const STMNGRGRPMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> grpCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'GRP_CD',
          fields: fields,
        )
      ]),
      key: r'GRP_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> grpNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'GRP_NM',
          fields: fields,
        )
      ]),
      key: r'GRP_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> grpDesc() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'GRP_DESC',
          fields: fields,
        )
      ]),
      key: r'GRP_DESC',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STMNGRMSTCountAggregateOutputType {
  const STMNGRMSTCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> mngrId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MNGR_ID',
          fields: fields,
        )
      ]),
      key: r'MNGR_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> mngrNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MNGR_NM',
          fields: fields,
        )
      ]),
      key: r'MNGR_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> mngrPw() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MNGR_PW',
          fields: fields,
        )
      ]),
      key: r'MNGR_PW',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> grpCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'GRP_CD',
          fields: fields,
        )
      ]),
      key: r'GRP_CD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> grade() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'GRADE',
          fields: fields,
        )
      ]),
      key: r'GRADE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> permCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PERM_CD',
          fields: fields,
        )
      ]),
      key: r'PERM_CD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> acsYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ACS_YN',
          fields: fields,
        )
      ]),
      key: r'ACS_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> clph() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CLPH',
          fields: fields,
        )
      ]),
      key: r'CLPH',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> empNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EMP_NO',
          fields: fields,
        )
      ]),
      key: r'EMP_NO',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> joinDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'JOIN_DATE',
          fields: fields,
        )
      ]),
      key: r'JOIN_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> retireDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RETIRE_DATE',
          fields: fields,
        )
      ]),
      key: r'RETIRE_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> pwdChgDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PWD_CHG_DATE',
          fields: fields,
        )
      ]),
      key: r'PWD_CHG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> pwdWrongCnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PWD_WRONG_CNT',
          fields: fields,
        )
      ]),
      key: r'PWD_WRONG_CNT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> pwdWrongDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PWD_WRONG_DATE',
          fields: fields,
        )
      ]),
      key: r'PWD_WRONG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> lstLoginDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LST_LOGIN_DATE',
          fields: fields,
        )
      ]),
      key: r'LST_LOGIN_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> flpth() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FLPTH',
          fields: fields,
        )
      ]),
      key: r'FLPTH',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> fileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_NM',
          fields: fields,
        )
      ]),
      key: r'FILE_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class STMNGRMSTAvgAggregateOutputType {
  const STMNGRMSTAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> pwdWrongCnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PWD_WRONG_CNT',
          fields: fields,
        )
      ]),
      key: r'PWD_WRONG_CNT',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class STMNGRMSTSumAggregateOutputType {
  const STMNGRMSTSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> pwdWrongCnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PWD_WRONG_CNT',
          fields: fields,
        )
      ]),
      key: r'PWD_WRONG_CNT',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class STMNGRMSTMinAggregateOutputType {
  const STMNGRMSTMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> mngrId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MNGR_ID',
          fields: fields,
        )
      ]),
      key: r'MNGR_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> mngrNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MNGR_NM',
          fields: fields,
        )
      ]),
      key: r'MNGR_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> mngrPw() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MNGR_PW',
          fields: fields,
        )
      ]),
      key: r'MNGR_PW',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> grpCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'GRP_CD',
          fields: fields,
        )
      ]),
      key: r'GRP_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> grade() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'GRADE',
          fields: fields,
        )
      ]),
      key: r'GRADE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> permCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PERM_CD',
          fields: fields,
        )
      ]),
      key: r'PERM_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> acsYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ACS_YN',
          fields: fields,
        )
      ]),
      key: r'ACS_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> clph() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CLPH',
          fields: fields,
        )
      ]),
      key: r'CLPH',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> empNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EMP_NO',
          fields: fields,
        )
      ]),
      key: r'EMP_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> joinDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'JOIN_DATE',
          fields: fields,
        )
      ]),
      key: r'JOIN_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> retireDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RETIRE_DATE',
          fields: fields,
        )
      ]),
      key: r'RETIRE_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> pwdChgDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PWD_CHG_DATE',
          fields: fields,
        )
      ]),
      key: r'PWD_CHG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<int?> pwdWrongCnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PWD_WRONG_CNT',
          fields: fields,
        )
      ]),
      key: r'PWD_WRONG_CNT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> pwdWrongDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PWD_WRONG_DATE',
          fields: fields,
        )
      ]),
      key: r'PWD_WRONG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> lstLoginDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LST_LOGIN_DATE',
          fields: fields,
        )
      ]),
      key: r'LST_LOGIN_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> flpth() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FLPTH',
          fields: fields,
        )
      ]),
      key: r'FLPTH',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> fileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_NM',
          fields: fields,
        )
      ]),
      key: r'FILE_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STMNGRMSTMaxAggregateOutputType {
  const STMNGRMSTMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> mngrId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MNGR_ID',
          fields: fields,
        )
      ]),
      key: r'MNGR_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> mngrNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MNGR_NM',
          fields: fields,
        )
      ]),
      key: r'MNGR_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> mngrPw() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MNGR_PW',
          fields: fields,
        )
      ]),
      key: r'MNGR_PW',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> grpCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'GRP_CD',
          fields: fields,
        )
      ]),
      key: r'GRP_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> grade() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'GRADE',
          fields: fields,
        )
      ]),
      key: r'GRADE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> permCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PERM_CD',
          fields: fields,
        )
      ]),
      key: r'PERM_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> acsYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ACS_YN',
          fields: fields,
        )
      ]),
      key: r'ACS_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> clph() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CLPH',
          fields: fields,
        )
      ]),
      key: r'CLPH',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> empNo() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EMP_NO',
          fields: fields,
        )
      ]),
      key: r'EMP_NO',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> joinDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'JOIN_DATE',
          fields: fields,
        )
      ]),
      key: r'JOIN_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> retireDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RETIRE_DATE',
          fields: fields,
        )
      ]),
      key: r'RETIRE_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> pwdChgDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PWD_CHG_DATE',
          fields: fields,
        )
      ]),
      key: r'PWD_CHG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<int?> pwdWrongCnt() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PWD_WRONG_CNT',
          fields: fields,
        )
      ]),
      key: r'PWD_WRONG_CNT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> pwdWrongDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PWD_WRONG_DATE',
          fields: fields,
        )
      ]),
      key: r'PWD_WRONG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> lstLoginDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LST_LOGIN_DATE',
          fields: fields,
        )
      ]),
      key: r'LST_LOGIN_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> flpth() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FLPTH',
          fields: fields,
        )
      ]),
      key: r'FLPTH',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> fileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_NM',
          fields: fields,
        )
      ]),
      key: r'FILE_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STMYSTNGCountAggregateOutputType {
  const STMYSTNGCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_ID',
          fields: fields,
        )
      ]),
      key: r'USER_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> stngCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STNG_CD',
          fields: fields,
        )
      ]),
      key: r'STNG_CD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> userDiv() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_DIV',
          fields: fields,
        )
      ]),
      key: r'USER_DIV',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> stngData() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STNG_DATA',
          fields: fields,
        )
      ]),
      key: r'STNG_DATA',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class STMYSTNGMinAggregateOutputType {
  const STMYSTNGMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_ID',
          fields: fields,
        )
      ]),
      key: r'USER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> stngCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STNG_CD',
          fields: fields,
        )
      ]),
      key: r'STNG_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> userDiv() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_DIV',
          fields: fields,
        )
      ]),
      key: r'USER_DIV',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> stngData() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STNG_DATA',
          fields: fields,
        )
      ]),
      key: r'STNG_DATA',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STMYSTNGMaxAggregateOutputType {
  const STMYSTNGMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_ID',
          fields: fields,
        )
      ]),
      key: r'USER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> stngCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STNG_CD',
          fields: fields,
        )
      ]),
      key: r'STNG_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> userDiv() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_DIV',
          fields: fields,
        )
      ]),
      key: r'USER_DIV',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> stngData() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STNG_DATA',
          fields: fields,
        )
      ]),
      key: r'STNG_DATA',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STPERMDTLCountAggregateOutputType {
  const STPERMDTLCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> permCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PERM_CD',
          fields: fields,
        )
      ]),
      key: r'PERM_CD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> menuCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_CD',
          fields: fields,
        )
      ]),
      key: r'MENU_CD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> readYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'READ_YN',
          fields: fields,
        )
      ]),
      key: r'READ_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_YN',
          fields: fields,
        )
      ]),
      key: r'REG_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> mdfcnYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MDFCN_YN',
          fields: fields,
        )
      ]),
      key: r'MDFCN_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> manageYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MANAGE_YN',
          fields: fields,
        )
      ]),
      key: r'MANAGE_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class STPERMDTLMinAggregateOutputType {
  const STPERMDTLMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> permCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PERM_CD',
          fields: fields,
        )
      ]),
      key: r'PERM_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> menuCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_CD',
          fields: fields,
        )
      ]),
      key: r'MENU_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> readYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'READ_YN',
          fields: fields,
        )
      ]),
      key: r'READ_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_YN',
          fields: fields,
        )
      ]),
      key: r'REG_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> mdfcnYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MDFCN_YN',
          fields: fields,
        )
      ]),
      key: r'MDFCN_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> manageYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MANAGE_YN',
          fields: fields,
        )
      ]),
      key: r'MANAGE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STPERMDTLMaxAggregateOutputType {
  const STPERMDTLMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> permCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PERM_CD',
          fields: fields,
        )
      ]),
      key: r'PERM_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> menuCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MENU_CD',
          fields: fields,
        )
      ]),
      key: r'MENU_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> readYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'READ_YN',
          fields: fields,
        )
      ]),
      key: r'READ_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_YN',
          fields: fields,
        )
      ]),
      key: r'REG_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> mdfcnYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MDFCN_YN',
          fields: fields,
        )
      ]),
      key: r'MDFCN_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> manageYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MANAGE_YN',
          fields: fields,
        )
      ]),
      key: r'MANAGE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STPERMMSTCountAggregateOutputType {
  const STPERMMSTCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> permCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PERM_CD',
          fields: fields,
        )
      ]),
      key: r'PERM_CD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> permNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PERM_NM',
          fields: fields,
        )
      ]),
      key: r'PERM_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class STPERMMSTMinAggregateOutputType {
  const STPERMMSTMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> permCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PERM_CD',
          fields: fields,
        )
      ]),
      key: r'PERM_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> permNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PERM_NM',
          fields: fields,
        )
      ]),
      key: r'PERM_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STPERMMSTMaxAggregateOutputType {
  const STPERMMSTMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> permCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PERM_CD',
          fields: fields,
        )
      ]),
      key: r'PERM_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> permNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PERM_NM',
          fields: fields,
        )
      ]),
      key: r'PERM_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STPOPUPCountAggregateOutputType {
  const STPOPUPCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> popCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'POP_CD',
          fields: fields,
        )
      ]),
      key: r'POP_CD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> popNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'POP_NM',
          fields: fields,
        )
      ]),
      key: r'POP_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> popTy() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'POP_TY',
          fields: fields,
        )
      ]),
      key: r'POP_TY',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> imgText() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'IMG_TEXT',
          fields: fields,
        )
      ]),
      key: r'IMG_TEXT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> lkUrl() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LK_URL',
          fields: fields,
        )
      ]),
      key: r'LK_URL',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> lkTarget() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LK_TARGET',
          fields: fields,
        )
      ]),
      key: r'LK_TARGET',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> bgngDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BGNG_DATE',
          fields: fields,
        )
      ]),
      key: r'BGNG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> endDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'END_DATE',
          fields: fields,
        )
      ]),
      key: r'END_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> spwgPred() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SPWG_PRED',
          fields: fields,
        )
      ]),
      key: r'SPWG_PRED',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> flpth() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FLPTH',
          fields: fields,
        )
      ]),
      key: r'FLPTH',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> fileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_NM',
          fields: fields,
        )
      ]),
      key: r'FILE_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> beforeCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BEFORE_CD',
          fields: fields,
        )
      ]),
      key: r'BEFORE_CD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class STPOPUPMinAggregateOutputType {
  const STPOPUPMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> popCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'POP_CD',
          fields: fields,
        )
      ]),
      key: r'POP_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> popNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'POP_NM',
          fields: fields,
        )
      ]),
      key: r'POP_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> popTy() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'POP_TY',
          fields: fields,
        )
      ]),
      key: r'POP_TY',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> imgText() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'IMG_TEXT',
          fields: fields,
        )
      ]),
      key: r'IMG_TEXT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> lkUrl() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LK_URL',
          fields: fields,
        )
      ]),
      key: r'LK_URL',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> lkTarget() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LK_TARGET',
          fields: fields,
        )
      ]),
      key: r'LK_TARGET',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> bgngDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BGNG_DATE',
          fields: fields,
        )
      ]),
      key: r'BGNG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> endDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'END_DATE',
          fields: fields,
        )
      ]),
      key: r'END_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> spwgPred() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SPWG_PRED',
          fields: fields,
        )
      ]),
      key: r'SPWG_PRED',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> flpth() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FLPTH',
          fields: fields,
        )
      ]),
      key: r'FLPTH',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> fileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_NM',
          fields: fields,
        )
      ]),
      key: r'FILE_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> beforeCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BEFORE_CD',
          fields: fields,
        )
      ]),
      key: r'BEFORE_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STPOPUPMaxAggregateOutputType {
  const STPOPUPMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> popCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'POP_CD',
          fields: fields,
        )
      ]),
      key: r'POP_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> popNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'POP_NM',
          fields: fields,
        )
      ]),
      key: r'POP_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> popTy() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'POP_TY',
          fields: fields,
        )
      ]),
      key: r'POP_TY',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> imgText() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'IMG_TEXT',
          fields: fields,
        )
      ]),
      key: r'IMG_TEXT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> lkUrl() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LK_URL',
          fields: fields,
        )
      ]),
      key: r'LK_URL',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> lkTarget() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LK_TARGET',
          fields: fields,
        )
      ]),
      key: r'LK_TARGET',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> bgngDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BGNG_DATE',
          fields: fields,
        )
      ]),
      key: r'BGNG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> endDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'END_DATE',
          fields: fields,
        )
      ]),
      key: r'END_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> spwgPred() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SPWG_PRED',
          fields: fields,
        )
      ]),
      key: r'SPWG_PRED',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> flpth() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FLPTH',
          fields: fields,
        )
      ]),
      key: r'FLPTH',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> fileNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'FILE_NM',
          fields: fields,
        )
      ]),
      key: r'FILE_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> useYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USE_YN',
          fields: fields,
        )
      ]),
      key: r'USE_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> beforeCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'BEFORE_CD',
          fields: fields,
        )
      ]),
      key: r'BEFORE_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STSTNGCountAggregateOutputType {
  const STSTNGCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> stngCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STNG_CD',
          fields: fields,
        )
      ]),
      key: r'STNG_CD',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> stngData() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STNG_DATA',
          fields: fields,
        )
      ]),
      key: r'STNG_DATA',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> title() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'TITLE',
          fields: fields,
        )
      ]),
      key: r'TITLE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> descCn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DESC_CN',
          fields: fields,
        )
      ]),
      key: r'DESC_CN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class STSTNGAvgAggregateOutputType {
  const STSTNGAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class STSTNGSumAggregateOutputType {
  const STSTNGSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class STSTNGMinAggregateOutputType {
  const STSTNGMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> stngCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STNG_CD',
          fields: fields,
        )
      ]),
      key: r'STNG_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> stngData() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STNG_DATA',
          fields: fields,
        )
      ]),
      key: r'STNG_DATA',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> title() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'TITLE',
          fields: fields,
        )
      ]),
      key: r'TITLE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> descCn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DESC_CN',
          fields: fields,
        )
      ]),
      key: r'DESC_CN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STSTNGMaxAggregateOutputType {
  const STSTNGMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> stngCd() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STNG_CD',
          fields: fields,
        )
      ]),
      key: r'STNG_CD',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> stngData() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STNG_DATA',
          fields: fields,
        )
      ]),
      key: r'STNG_DATA',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> title() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'TITLE',
          fields: fields,
        )
      ]),
      key: r'TITLE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> descCn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DESC_CN',
          fields: fields,
        )
      ]),
      key: r'DESC_CN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<int?> sort() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SORT',
          fields: fields,
        )
      ]),
      key: r'SORT',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STUSERMSTCountAggregateOutputType {
  const STUSERMSTCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_ID',
          fields: fields,
        )
      ]),
      key: r'USER_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> userNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_NM',
          fields: fields,
        )
      ]),
      key: r'USER_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> userPw() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_PW',
          fields: fields,
        )
      ]),
      key: r'USER_PW',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> userDiv() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_DIV',
          fields: fields,
        )
      ]),
      key: r'USER_DIV',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> status() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STATUS',
          fields: fields,
        )
      ]),
      key: r'STATUS',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> prevLoginYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PREV_LOGIN_YN',
          fields: fields,
        )
      ]),
      key: r'PREV_LOGIN_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> withdrawnYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WITHDRAWN_YN',
          fields: fields,
        )
      ]),
      key: r'WITHDRAWN_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> clph() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CLPH',
          fields: fields,
        )
      ]),
      key: r'CLPH',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> email() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EMAIL',
          fields: fields,
        )
      ]),
      key: r'EMAIL',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> lstLoginDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LST_LOGIN_DATE',
          fields: fields,
        )
      ]),
      key: r'LST_LOGIN_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class STUSERMSTMinAggregateOutputType {
  const STUSERMSTMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_ID',
          fields: fields,
        )
      ]),
      key: r'USER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> userNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_NM',
          fields: fields,
        )
      ]),
      key: r'USER_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> userPw() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_PW',
          fields: fields,
        )
      ]),
      key: r'USER_PW',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> userDiv() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_DIV',
          fields: fields,
        )
      ]),
      key: r'USER_DIV',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> status() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STATUS',
          fields: fields,
        )
      ]),
      key: r'STATUS',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> prevLoginYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PREV_LOGIN_YN',
          fields: fields,
        )
      ]),
      key: r'PREV_LOGIN_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> withdrawnYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WITHDRAWN_YN',
          fields: fields,
        )
      ]),
      key: r'WITHDRAWN_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> clph() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CLPH',
          fields: fields,
        )
      ]),
      key: r'CLPH',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> email() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EMAIL',
          fields: fields,
        )
      ]),
      key: r'EMAIL',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> lstLoginDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LST_LOGIN_DATE',
          fields: fields,
        )
      ]),
      key: r'LST_LOGIN_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class STUSERMSTMaxAggregateOutputType {
  const STUSERMSTMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_ID',
          fields: fields,
        )
      ]),
      key: r'USER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> userNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_NM',
          fields: fields,
        )
      ]),
      key: r'USER_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> userPw() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_PW',
          fields: fields,
        )
      ]),
      key: r'USER_PW',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> userDiv() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_DIV',
          fields: fields,
        )
      ]),
      key: r'USER_DIV',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> status() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'STATUS',
          fields: fields,
        )
      ]),
      key: r'STATUS',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> prevLoginYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PREV_LOGIN_YN',
          fields: fields,
        )
      ]),
      key: r'PREV_LOGIN_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> withdrawnYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WITHDRAWN_YN',
          fields: fields,
        )
      ]),
      key: r'WITHDRAWN_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> clph() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CLPH',
          fields: fields,
        )
      ]),
      key: r'CLPH',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> email() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EMAIL',
          fields: fields,
        )
      ]),
      key: r'EMAIL',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> lstLoginDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'LST_LOGIN_DATE',
          fields: fields,
        )
      ]),
      key: r'LST_LOGIN_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class WORKREPORTDETAILTBLCountAggregateOutputType {
  const WORKREPORTDETAILTBLCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> reportId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPORT_ID',
          fields: fields,
        )
      ]),
      key: r'REPORT_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> projectNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PROJECT_NM',
          fields: fields,
        )
      ]),
      key: r'PROJECT_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> projectSubNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PROJECT_SUB_NM',
          fields: fields,
        )
      ]),
      key: r'PROJECT_SUB_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> detailContent() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DETAIL_CONTENT',
          fields: fields,
        )
      ]),
      key: r'DETAIL_CONTENT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> worker() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WORKER',
          fields: fields,
        )
      ]),
      key: r'WORKER',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> grade() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'GRADE',
          fields: fields,
        )
      ]),
      key: r'GRADE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> processRate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PROCESS_RATE',
          fields: fields,
        )
      ]),
      key: r'PROCESS_RATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> workDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WORK_DATE',
          fields: fields,
        )
      ]),
      key: r'WORK_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> processType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PROCESS_TYPE',
          fields: fields,
        )
      ]),
      key: r'PROCESS_TYPE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> subjectYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SUBJECT_YN',
          fields: fields,
        )
      ]),
      key: r'SUBJECT_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regUser() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_USER',
          fields: fields,
        )
      ]),
      key: r'REG_USER',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> completeDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'COMPLETE_DATE',
          fields: fields,
        )
      ]),
      key: r'COMPLETE_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class WORKREPORTDETAILTBLAvgAggregateOutputType {
  const WORKREPORTDETAILTBLAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class WORKREPORTDETAILTBLSumAggregateOutputType {
  const WORKREPORTDETAILTBLSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }
}

class WORKREPORTDETAILTBLMinAggregateOutputType {
  const WORKREPORTDETAILTBLMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> reportId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPORT_ID',
          fields: fields,
        )
      ]),
      key: r'REPORT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> projectNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PROJECT_NM',
          fields: fields,
        )
      ]),
      key: r'PROJECT_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> projectSubNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PROJECT_SUB_NM',
          fields: fields,
        )
      ]),
      key: r'PROJECT_SUB_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> detailContent() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DETAIL_CONTENT',
          fields: fields,
        )
      ]),
      key: r'DETAIL_CONTENT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> worker() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WORKER',
          fields: fields,
        )
      ]),
      key: r'WORKER',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> grade() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'GRADE',
          fields: fields,
        )
      ]),
      key: r'GRADE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> processRate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PROCESS_RATE',
          fields: fields,
        )
      ]),
      key: r'PROCESS_RATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> workDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WORK_DATE',
          fields: fields,
        )
      ]),
      key: r'WORK_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> processType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PROCESS_TYPE',
          fields: fields,
        )
      ]),
      key: r'PROCESS_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> subjectYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SUBJECT_YN',
          fields: fields,
        )
      ]),
      key: r'SUBJECT_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regUser() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_USER',
          fields: fields,
        )
      ]),
      key: r'REG_USER',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<String?> completeDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'COMPLETE_DATE',
          fields: fields,
        )
      ]),
      key: r'COMPLETE_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class WORKREPORTDETAILTBLMaxAggregateOutputType {
  const WORKREPORTDETAILTBLMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> reportId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPORT_ID',
          fields: fields,
        )
      ]),
      key: r'REPORT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<BigInt?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as BigInt?));
  }

  Future<String?> projectNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PROJECT_NM',
          fields: fields,
        )
      ]),
      key: r'PROJECT_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> projectSubNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PROJECT_SUB_NM',
          fields: fields,
        )
      ]),
      key: r'PROJECT_SUB_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> detailContent() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DETAIL_CONTENT',
          fields: fields,
        )
      ]),
      key: r'DETAIL_CONTENT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> worker() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WORKER',
          fields: fields,
        )
      ]),
      key: r'WORKER',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> grade() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'GRADE',
          fields: fields,
        )
      ]),
      key: r'GRADE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> processRate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PROCESS_RATE',
          fields: fields,
        )
      ]),
      key: r'PROCESS_RATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> workDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'WORK_DATE',
          fields: fields,
        )
      ]),
      key: r'WORK_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> processType() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'PROCESS_TYPE',
          fields: fields,
        )
      ]),
      key: r'PROCESS_TYPE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> subjectYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SUBJECT_YN',
          fields: fields,
        )
      ]),
      key: r'SUBJECT_YN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regUser() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_USER',
          fields: fields,
        )
      ]),
      key: r'REG_USER',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<String?> completeDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'COMPLETE_DATE',
          fields: fields,
        )
      ]),
      key: r'COMPLETE_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class WORKREPORTHTMLTBLCountAggregateOutputType {
  const WORKREPORTHTMLTBLCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> reportId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPORT_ID',
          fields: fields,
        )
      ]),
      key: r'REPORT_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_ID',
          fields: fields,
        )
      ]),
      key: r'USER_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> title() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'TITLE',
          fields: fields,
        )
      ]),
      key: r'TITLE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> htmlContent() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'HTML_CONTENT',
          fields: fields,
        )
      ]),
      key: r'HTML_CONTENT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class WORKREPORTHTMLTBLMinAggregateOutputType {
  const WORKREPORTHTMLTBLMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> reportId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPORT_ID',
          fields: fields,
        )
      ]),
      key: r'REPORT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_ID',
          fields: fields,
        )
      ]),
      key: r'USER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> title() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'TITLE',
          fields: fields,
        )
      ]),
      key: r'TITLE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> htmlContent() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'HTML_CONTENT',
          fields: fields,
        )
      ]),
      key: r'HTML_CONTENT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class WORKREPORTHTMLTBLMaxAggregateOutputType {
  const WORKREPORTHTMLTBLMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> reportId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPORT_ID',
          fields: fields,
        )
      ]),
      key: r'REPORT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_ID',
          fields: fields,
        )
      ]),
      key: r'USER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> title() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'TITLE',
          fields: fields,
        )
      ]),
      key: r'TITLE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> htmlContent() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'HTML_CONTENT',
          fields: fields,
        )
      ]),
      key: r'HTML_CONTENT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class WORKREPORTHTMLTBLBACKCountAggregateOutputType {
  const WORKREPORTHTMLTBLBACKCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> reportId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPORT_ID',
          fields: fields,
        )
      ]),
      key: r'REPORT_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_ID',
          fields: fields,
        )
      ]),
      key: r'USER_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> title() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'TITLE',
          fields: fields,
        )
      ]),
      key: r'TITLE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> htmlContent() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'HTML_CONTENT',
          fields: fields,
        )
      ]),
      key: r'HTML_CONTENT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class WORKREPORTHTMLTBLBACKMinAggregateOutputType {
  const WORKREPORTHTMLTBLBACKMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> reportId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPORT_ID',
          fields: fields,
        )
      ]),
      key: r'REPORT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_ID',
          fields: fields,
        )
      ]),
      key: r'USER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> title() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'TITLE',
          fields: fields,
        )
      ]),
      key: r'TITLE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> htmlContent() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'HTML_CONTENT',
          fields: fields,
        )
      ]),
      key: r'HTML_CONTENT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class WORKREPORTHTMLTBLBACKMaxAggregateOutputType {
  const WORKREPORTHTMLTBLBACKMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> reportId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPORT_ID',
          fields: fields,
        )
      ]),
      key: r'REPORT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> userId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'USER_ID',
          fields: fields,
        )
      ]),
      key: r'USER_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> title() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'TITLE',
          fields: fields,
        )
      ]),
      key: r'TITLE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> htmlContent() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'HTML_CONTENT',
          fields: fields,
        )
      ]),
      key: r'HTML_CONTENT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class WORKREPORTMASTERTBLCountAggregateOutputType {
  const WORKREPORTMASTERTBLCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> reportId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPORT_ID',
          fields: fields,
        )
      ]),
      key: r'REPORT_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> title() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'TITLE',
          fields: fields,
        )
      ]),
      key: r'TITLE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> dept() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPT',
          fields: fields,
        )
      ]),
      key: r'DEPT',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class WORKREPORTMASTERTBLMinAggregateOutputType {
  const WORKREPORTMASTERTBLMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> reportId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPORT_ID',
          fields: fields,
        )
      ]),
      key: r'REPORT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> title() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'TITLE',
          fields: fields,
        )
      ]),
      key: r'TITLE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> dept() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPT',
          fields: fields,
        )
      ]),
      key: r'DEPT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class WORKREPORTMASTERTBLMaxAggregateOutputType {
  const WORKREPORTMASTERTBLMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<String?> reportId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REPORT_ID',
          fields: fields,
        )
      ]),
      key: r'REPORT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> title() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'TITLE',
          fields: fields,
        )
      ]),
      key: r'TITLE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> dept() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEPT',
          fields: fields,
        )
      ]),
      key: r'DEPT',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<DateTime?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<DateTime?> updDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'UPD_DATE',
          fields: fields,
        )
      ]),
      key: r'UPD_DATE',
    );
    return query(const [])
        .then((value) => value is String ? DateTime.parse(value) : null);
  }

  Future<String?> delYn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_YN',
          fields: fields,
        )
      ]),
      key: r'DEL_YN',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class WORKREQUESTMSTCountAggregateOutputType {
  const WORKREQUESTMSTCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> rqstrDpnm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RQSTR_DPNM',
          fields: fields,
        )
      ]),
      key: r'RQSTR_DPNM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> rqstrNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RQSTR_NM',
          fields: fields,
        )
      ]),
      key: r'RQSTR_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> rqstrId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RQSTR_ID',
          fields: fields,
        )
      ]),
      key: r'RQSTR_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> rqstrDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RQSTR_DATE',
          fields: fields,
        )
      ]),
      key: r'RQSTR_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> hopeDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'HOPE_DATE',
          fields: fields,
        )
      ]),
      key: r'HOPE_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> chrDprNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CHR_DPR_NM',
          fields: fields,
        )
      ]),
      key: r'CHR_DPR_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> chrNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CHR_NM',
          fields: fields,
        )
      ]),
      key: r'CHR_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> chrId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CHR_ID',
          fields: fields,
        )
      ]),
      key: r'CHR_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> chrChk() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CHR_CHK',
          fields: fields,
        )
      ]),
      key: r'CHR_CHK',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> title() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'TITLE',
          fields: fields,
        )
      ]),
      key: r'TITLE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> cn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CN',
          fields: fields,
        )
      ]),
      key: r'CN',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> etc() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ETC',
          fields: fields,
        )
      ]),
      key: r'ETC',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> doc() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DOC',
          fields: fields,
        )
      ]),
      key: r'DOC',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class WORKREQUESTMSTAvgAggregateOutputType {
  const WORKREQUESTMSTAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class WORKREQUESTMSTSumAggregateOutputType {
  const WORKREQUESTMSTSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class WORKREQUESTMSTMinAggregateOutputType {
  const WORKREQUESTMSTMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> rqstrDpnm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RQSTR_DPNM',
          fields: fields,
        )
      ]),
      key: r'RQSTR_DPNM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> rqstrNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RQSTR_NM',
          fields: fields,
        )
      ]),
      key: r'RQSTR_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> rqstrId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RQSTR_ID',
          fields: fields,
        )
      ]),
      key: r'RQSTR_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> rqstrDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RQSTR_DATE',
          fields: fields,
        )
      ]),
      key: r'RQSTR_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> hopeDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'HOPE_DATE',
          fields: fields,
        )
      ]),
      key: r'HOPE_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> chrDprNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CHR_DPR_NM',
          fields: fields,
        )
      ]),
      key: r'CHR_DPR_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> chrNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CHR_NM',
          fields: fields,
        )
      ]),
      key: r'CHR_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> chrId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CHR_ID',
          fields: fields,
        )
      ]),
      key: r'CHR_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> chrChk() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CHR_CHK',
          fields: fields,
        )
      ]),
      key: r'CHR_CHK',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> title() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'TITLE',
          fields: fields,
        )
      ]),
      key: r'TITLE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> cn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CN',
          fields: fields,
        )
      ]),
      key: r'CN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> etc() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ETC',
          fields: fields,
        )
      ]),
      key: r'ETC',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> doc() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DOC',
          fields: fields,
        )
      ]),
      key: r'DOC',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class WORKREQUESTMSTMaxAggregateOutputType {
  const WORKREQUESTMSTMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> rqstrDpnm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RQSTR_DPNM',
          fields: fields,
        )
      ]),
      key: r'RQSTR_DPNM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> rqstrNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RQSTR_NM',
          fields: fields,
        )
      ]),
      key: r'RQSTR_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> rqstrId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RQSTR_ID',
          fields: fields,
        )
      ]),
      key: r'RQSTR_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> rqstrDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'RQSTR_DATE',
          fields: fields,
        )
      ]),
      key: r'RQSTR_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> hopeDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'HOPE_DATE',
          fields: fields,
        )
      ]),
      key: r'HOPE_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> chrDprNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CHR_DPR_NM',
          fields: fields,
        )
      ]),
      key: r'CHR_DPR_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> chrNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CHR_NM',
          fields: fields,
        )
      ]),
      key: r'CHR_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> chrId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CHR_ID',
          fields: fields,
        )
      ]),
      key: r'CHR_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> chrChk() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CHR_CHK',
          fields: fields,
        )
      ]),
      key: r'CHR_CHK',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> title() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'TITLE',
          fields: fields,
        )
      ]),
      key: r'TITLE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> cn() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'CN',
          fields: fields,
        )
      ]),
      key: r'CN',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> etc() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'ETC',
          fields: fields,
        )
      ]),
      key: r'ETC',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> doc() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DOC',
          fields: fields,
        )
      ]),
      key: r'DOC',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class WORKREQUESTREFCountAggregateOutputType {
  const WORKREQUESTREFCountAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> mseq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSEQ',
          fields: fields,
        )
      ]),
      key: r'MSEQ',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> refId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REF_ID',
          fields: fields,
        )
      ]),
      key: r'REF_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> refNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REF_NM',
          fields: fields,
        )
      ]),
      key: r'REF_NM',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> refDep() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REF_DEP',
          fields: fields,
        )
      ]),
      key: r'REF_DEP',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> refGrade() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REF_GRADE',
          fields: fields,
        )
      ]),
      key: r'REF_GRADE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as int));
  }

  Future<int> $all() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'_all',
          fields: fields,
        )
      ]),
      key: r'_all',
    );
    return query(const []).then((value) => (value as int));
  }
}

class WORKREQUESTREFAvgAggregateOutputType {
  const WORKREQUESTREFAvgAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<double?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as double?));
  }

  Future<double?> mseq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSEQ',
          fields: fields,
        )
      ]),
      key: r'MSEQ',
    );
    return query(const []).then((value) => (value as double?));
  }
}

class WORKREQUESTREFSumAggregateOutputType {
  const WORKREQUESTREFSumAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> mseq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSEQ',
          fields: fields,
        )
      ]),
      key: r'MSEQ',
    );
    return query(const []).then((value) => (value as int?));
  }
}

class WORKREQUESTREFMinAggregateOutputType {
  const WORKREQUESTREFMinAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> mseq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSEQ',
          fields: fields,
        )
      ]),
      key: r'MSEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> refId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REF_ID',
          fields: fields,
        )
      ]),
      key: r'REF_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> refNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REF_NM',
          fields: fields,
        )
      ]),
      key: r'REF_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> refDep() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REF_DEP',
          fields: fields,
        )
      ]),
      key: r'REF_DEP',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> refGrade() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REF_GRADE',
          fields: fields,
        )
      ]),
      key: r'REF_GRADE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

class WORKREQUESTREFMaxAggregateOutputType {
  const WORKREQUESTREFMaxAggregateOutputType(this.$query);

  final _i1.PrismaFluentQuery $query;

  Future<int?> seq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'SEQ',
          fields: fields,
        )
      ]),
      key: r'SEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<int?> mseq() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'MSEQ',
          fields: fields,
        )
      ]),
      key: r'MSEQ',
    );
    return query(const []).then((value) => (value as int?));
  }

  Future<String?> refId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REF_ID',
          fields: fields,
        )
      ]),
      key: r'REF_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> refNm() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REF_NM',
          fields: fields,
        )
      ]),
      key: r'REF_NM',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> refDep() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REF_DEP',
          fields: fields,
        )
      ]),
      key: r'REF_DEP',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> refGrade() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REF_GRADE',
          fields: fields,
        )
      ]),
      key: r'REF_GRADE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_ID',
          fields: fields,
        )
      ]),
      key: r'REG_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> regDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'REG_DATE',
          fields: fields,
        )
      ]),
      key: r'REG_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_ID',
          fields: fields,
        )
      ]),
      key: r'EDIT_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> editDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'EDIT_DATE',
          fields: fields,
        )
      ]),
      key: r'EDIT_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delId() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_ID',
          fields: fields,
        )
      ]),
      key: r'DEL_ID',
    );
    return query(const []).then((value) => (value as String?));
  }

  Future<String?> delDate() {
    final query = _i1.PrismaFluent.queryBuilder(
      query: (fields) => $query([
        _i2.GraphQLField(
          r'DEL_DATE',
          fields: fields,
        )
      ]),
      key: r'DEL_DATE',
    );
    return query(const []).then((value) => (value as String?));
  }
}

@JsonSerializable(
  createFactory: false,
  createToJson: true,
  includeIfNull: false,
)
class Datasources implements _i1.JsonSerializable {
  const Datasources({this.db});

  final String? db;

  @override
  Map<String, dynamic> toJson() => _$DatasourcesToJson(this);
}

class PrismaClient extends _i1.BasePrismaClient<PrismaClient> {
  PrismaClient._internal(
    _i3.Engine engine, {
    _i3.QueryEngineRequestHeaders? headers,
    _i3.TransactionInfo? transaction,
  })  : _engine = engine,
        _headers = headers,
        _transaction = transaction,
        super(
          engine,
          headers: headers,
          transaction: transaction,
        );

  factory PrismaClient({
    Datasources? datasources,
    Iterable<_i4.Event>? stdout,
    Iterable<_i4.Event>? event,
  }) {
    final logger = _i4.Logger(
      stdout: stdout,
      event: event,
    );
    final engine = _i5.BinaryEngine(
      logger: logger,
      schema:
          r'Z2VuZXJhdG9yIGNsaWVudCB7CiAgcHJvdmlkZXIgPSAiZGFydCBydW4gb3JtIgp9CgpkYXRhc291cmNlIGRiIHsKICBwcm92aWRlciA9ICJteXNxbCIKICB1cmwgICAgICA9IGVudigiREFUQUJBU0VfVVJMIikKfQoKLy8vIFRoaXMgbW9kZWwgb3IgYXQgbGVhc3Qgb25lIG9mIGl0cyBmaWVsZHMgaGFzIGNvbW1lbnRzIGluIHRoZSBkYXRhYmFzZSwgYW5kIHJlcXVpcmVzIGFuIGFkZGl0aW9uYWwgc2V0dXAgZm9yIG1pZ3JhdGlvbnM6IFJlYWQgbW9yZTogaHR0cHM6Ly9wcmlzLmx5L2QvZGF0YWJhc2UtY29tbWVudHMKbW9kZWwgQUxMX0NPREVfVEJMIHsKICBDT0RFX1RZUEUgU3RyaW5nICAgQGRiLlZhckNoYXIoNCkKICBDT0RFX05BTUUgU3RyaW5nPyAgQGRiLlZhckNoYXIoMTUpCiAgVU5JVF9UWVBFIFN0cmluZyAgIEBkYi5WYXJDaGFyKDUpCiAgVU5JVF9OQU1FIFN0cmluZz8gIEBkYi5WYXJDaGFyKDMwKQogIFNPUlQgICAgICBJbnQ/CiAgVVNFX1lOICAgIFN0cmluZz8gIEBkZWZhdWx0KCJZIikgQGRiLkNoYXIoMSkKICBERUxfWU4gICAgU3RyaW5nPyAgQGRlZmF1bHQoIk4iKSBAZGIuQ2hhcigxKQogIFJFR19EQVRFICBEYXRlVGltZSBAZGVmYXVsdChub3coKSkgQGRiLlRpbWVzdGFtcCgwKQogIFVQRF9EQVRFICBEYXRlVGltZSBAZGVmYXVsdChkYmdlbmVyYXRlZCgiKCcwMDAwLTAwLTAwIDAwOjAwOjAwJykiKSkgQGRiLlRpbWVzdGFtcCgwKQoKICBAQGlkKFtDT0RFX1RZUEUsIFVOSVRfVFlQRV0pCn0KCi8vLyBUaGlzIG1vZGVsIG9yIGF0IGxlYXN0IG9uZSBvZiBpdHMgZmllbGRzIGhhcyBjb21tZW50cyBpbiB0aGUgZGF0YWJhc2UsIGFuZCByZXF1aXJlcyBhbiBhZGRpdGlvbmFsIHNldHVwIGZvciBtaWdyYXRpb25zOiBSZWFkIG1vcmU6IGh0dHBzOi8vcHJpcy5seS9kL2RhdGFiYXNlLWNvbW1lbnRzCm1vZGVsIEFQUFJPVkFMX0FUVEFDSEZJTEVfVEJMIHsKICBBUFBST1ZBTF9JRCAgU3RyaW5nICAgQGRiLlZhckNoYXIoMjU1KQogIFNFUSAgICAgICAgICBEZWNpbWFsICBAZGIuRGVjaW1hbCgyLCAwKQogIE9SSV9GSUxFX05NICBTdHJpbmc/ICBAZGIuVmFyQ2hhcigyNTYpCiAgU0FWRV9GSUxFX05NIFN0cmluZz8gIEBkYi5WYXJDaGFyKDUxMikKICBGSUxFX1NJWkUgICAgSW50PwogIFJFR19EQVRFICAgICBEYXRlVGltZSBAZGVmYXVsdChub3coKSkgQGRiLlRpbWVzdGFtcCgwKQoKICBAQGlkKFtBUFBST1ZBTF9JRCwgU0VRXSkKfQoKLy8vIFRoaXMgbW9kZWwgb3IgYXQgbGVhc3Qgb25lIG9mIGl0cyBmaWVsZHMgaGFzIGNvbW1lbnRzIGluIHRoZSBkYXRhYmFzZSwgYW5kIHJlcXVpcmVzIGFuIGFkZGl0aW9uYWwgc2V0dXAgZm9yIG1pZ3JhdGlvbnM6IFJlYWQgbW9yZTogaHR0cHM6Ly9wcmlzLmx5L2QvZGF0YWJhc2UtY29tbWVudHMKbW9kZWwgQVBQUk9WQUxfRE9DX0lORk9fVEJMIHsKICBTRVEgICAgICAgICAgICAgICAgICAgICAgIEJpZ0ludCAgICBAaWQgQGRlZmF1bHQoYXV0b2luY3JlbWVudCgpKQogIERPQ19UWVBFICAgICAgICAgICAgICAgICAgU3RyaW5nPyAgIEBkYi5WYXJDaGFyKDMpCiAgRE9DX05NICAgICAgICAgICAgICAgICAgICBTdHJpbmc/ICAgQGRiLlZhckNoYXIoMTAwKQogIFRJVExFICAgICAgICAgICAgICAgICAgICAgU3RyaW5nICAgIEBkYi5WYXJDaGFyKDEyMCkKICBBUFBST1ZBTF9MSU5FX1RZUEUgICAgICAgIFN0cmluZz8gICBAZGIuVmFyQ2hhcigzKQogIEFQUFJPVkFMX0xJTkVfQ09OVEVOVCAgICAgU3RyaW5nPyAgIEBkYi5Mb25nVGV4dAogIEFQUFJPVkFMX0xJTkVfQ09OVEVOVF9CQUsgU3RyaW5nPyAgIEBkYi5Mb25nVGV4dAogIENPTlRFTlQgICAgICAgICAgICAgICAgICAgU3RyaW5nPyAgIEBkYi5Mb25nVGV4dAogIFdSSVRFUl9JRCAgICAgICAgICAgICAgICAgU3RyaW5nPyAgIEBkYi5WYXJDaGFyKDE1KQogIFVTRVJfTk0gICAgICAgICAgICAgICAgICAgU3RyaW5nPyAgIEBkYi5WYXJDaGFyKDMwKQogIFJFR19EQVRFICAgICAgICAgICAgICAgICAgRGF0ZVRpbWUgIEBkZWZhdWx0KG5vdygpKSBAZGIuVGltZXN0YW1wKDApCiAgVVBEX0RBVEUgICAgICAgICAgICAgICAgICBEYXRlVGltZT8gQGRiLlRpbWVzdGFtcCgwKQogIFVTRV9ZTiAgICAgICAgICAgICAgICAgICAgU3RyaW5nPyAgIEBkZWZhdWx0KCJZIikgQGRiLkNoYXIoMSkKICBERUxfWU4gICAgICAgICAgICAgICAgICAgIFN0cmluZz8gICBAZGVmYXVsdCgiTiIpIEBkYi5DaGFyKDEpCgogIEBAaW5kZXgoW1dSSVRFUl9JRF0sIG1hcDogIkFQUFJPVkFMX0RPQ19JTkZPX1RCTF9pYmZrXzEiKQp9CgovLy8gVGhpcyBtb2RlbCBvciBhdCBsZWFzdCBvbmUgb2YgaXRzIGZpZWxkcyBoYXMgY29tbWVudHMgaW4gdGhlIGRhdGFiYXNlLCBhbmQgcmVxdWlyZXMgYW4gYWRkaXRpb25hbCBzZXR1cCBmb3IgbWlncmF0aW9uczogUmVhZCBtb3JlOiBodHRwczovL3ByaXMubHkvZC9kYXRhYmFzZS1jb21tZW50cwptb2RlbCBBUFBST1ZBTF9ISVNUT1JZX1RCTCB7CiAgU0VRICAgICAgICAgQmlnSW50ICAgIEBpZCBAZGVmYXVsdChhdXRvaW5jcmVtZW50KCkpCiAgQVBQUk9WQUxfSUQgU3RyaW5nICAgIEBkYi5WYXJDaGFyKDI1NSkKICBXUklURVJfSUQgICBTdHJpbmcgICAgQGRiLlZhckNoYXIoMTUpCiAgV1JJVEVSX05NICAgU3RyaW5nICAgIEBkYi5WYXJDaGFyKDEyOCkKICBET0NfVFlQRSAgICBTdHJpbmcgICAgQGRiLlZhckNoYXIoMykKICBLRUVQX1BSSU9EICBJbnQgICAgICAgQGRlZmF1bHQoMSkKICBLRUVQX0RBVEUgICBEYXRlVGltZSAgQGRlZmF1bHQobm93KCkpIEBkYi5UaW1lc3RhbXAoMCkKICBHUkFERSAgICAgICBTdHJpbmcgICAgQGRlZmF1bHQoIkIiKSBAZGIuQ2hhcigxKQogIFNUQVRVUyAgICAgIFN0cmluZz8gICBAZGIuVmFyQ2hhcigzKQogIENPTlRFTlQgICAgIFN0cmluZz8gICBAZGIuTG9uZ1RleHQKICBSRUdfREFURSAgICBEYXRlVGltZSAgQGRlZmF1bHQobm93KCkpIEBkYi5UaW1lc3RhbXAoMCkKICBVUERfREFURSAgICBEYXRlVGltZT8gQGRiLlRpbWVzdGFtcCgwKQogIERFTF9ZTiAgICAgIFN0cmluZz8gICBAZGVmYXVsdCgiTiIpIEBkYi5DaGFyKDEpCn0KCi8vLyBUaGlzIG1vZGVsIG9yIGF0IGxlYXN0IG9uZSBvZiBpdHMgZmllbGRzIGhhcyBjb21tZW50cyBpbiB0aGUgZGF0YWJhc2UsIGFuZCByZXF1aXJlcyBhbiBhZGRpdGlvbmFsIHNldHVwIGZvciBtaWdyYXRpb25zOiBSZWFkIG1vcmU6IGh0dHBzOi8vcHJpcy5seS9kL2RhdGFiYXNlLWNvbW1lbnRzCm1vZGVsIEFQUFJPVkFMX01BU1RFUl9UQkwgewogIEFQUFJPVkFMX0lEICAgU3RyaW5nICAgIEBpZCBAZGIuVmFyQ2hhcigyNTUpCiAgV1JJVEVSX0lEICAgICBTdHJpbmcgICAgQGRiLlZhckNoYXIoMTUpCiAgV1JJVEVSX05NICAgICBTdHJpbmcgICAgQGRiLlZhckNoYXIoMTI4KQogIERPQ19UWVBFICAgICAgU3RyaW5nICAgIEBkYi5WYXJDaGFyKDMpCiAgS0VFUF9QUklPRCAgICBJbnQgICAgICAgQGRlZmF1bHQoMSkKICBLRUVQX0RBVEUgICAgIERhdGVUaW1lICBAZGVmYXVsdChub3coKSkgQGRiLlRpbWVzdGFtcCgwKQogIEdSQURFICAgICAgICAgU3RyaW5nICAgIEBkZWZhdWx0KCJCIikgQGRiLkNoYXIoMSkKICBTVEFUVVMgICAgICAgIFN0cmluZz8gICBAZGIuVmFyQ2hhcigzKQogIFRJVExFICAgICAgICAgU3RyaW5nPyAgIEBkYi5WYXJDaGFyKDEwMjQpCiAgSEVBREVSICAgICAgICBTdHJpbmc/ICAgQGRiLkxvbmdUZXh0CiAgQ09OVEVOVCAgICAgICBTdHJpbmc/ICAgQGRiLkxvbmdUZXh0CiAgTTEgICAgICAgICAgICBEZWNpbWFsPyAgQGRlZmF1bHQoMC4wKSBAZGIuRGVjaW1hbCgzLCAxKQogIE0yICAgICAgICAgICAgRGVjaW1hbD8gIEBkZWZhdWx0KDAuMCkgQGRiLkRlY2ltYWwoMywgMSkKICBNMyAgICAgICAgICAgIERlY2ltYWw/ICBAZGVmYXVsdCgwLjApIEBkYi5EZWNpbWFsKDMsIDEpCiAgTTQgICAgICAgICAgICBEZWNpbWFsPyAgQGRlZmF1bHQoMC4wKSBAZGIuRGVjaW1hbCgzLCAxKQogIE01ICAgICAgICAgICAgRGVjaW1hbD8gIEBkZWZhdWx0KDAuMCkgQGRiLkRlY2ltYWwoMywgMSkKICBNNiAgICAgICAgICAgIERlY2ltYWw/ICBAZGVmYXVsdCgwLjApIEBkYi5EZWNpbWFsKDMsIDEpCiAgTTcgICAgICAgICAgICBEZWNpbWFsPyAgQGRlZmF1bHQoMC4wKSBAZGIuRGVjaW1hbCgzLCAxKQogIE04ICAgICAgICAgICAgRGVjaW1hbD8gIEBkZWZhdWx0KDAuMCkgQGRiLkRlY2ltYWwoMywgMSkKICBNOSAgICAgICAgICAgIERlY2ltYWw/ICBAZGVmYXVsdCgwLjApIEBkYi5EZWNpbWFsKDMsIDEpCiAgTTEwICAgICAgICAgICBEZWNpbWFsPyAgQGRlZmF1bHQoMC4wKSBAZGIuRGVjaW1hbCgzLCAxKQogIE0xMSAgICAgICAgICAgRGVjaW1hbD8gIEBkZWZhdWx0KDAuMCkgQGRiLkRlY2ltYWwoMywgMSkKICBNMTIgICAgICAgICAgIERlY2ltYWw/ICBAZGVmYXVsdCgwLjApIEBkYi5EZWNpbWFsKDMsIDEpCiAgUkVHX0RBVEUgICAgICBEYXRlVGltZSAgQGRlZmF1bHQobm93KCkpIEBkYi5UaW1lc3RhbXAoMCkKICBDT01QTEVURV9EQVRFIERhdGVUaW1lICBAZGVmYXVsdChkYmdlbmVyYXRlZCgiKCcwMDAwLTAwLTAwIDAwOjAwOjAwJykiKSkgQGRiLlRpbWVzdGFtcCgwKQogIFVQRF9EQVRFICAgICAgRGF0ZVRpbWU/IEBkYi5UaW1lc3RhbXAoMCkKICBERUxfWU4gICAgICAgIFN0cmluZz8gICBAZGVmYXVsdCgiTiIpIEBkYi5DaGFyKDEpCgogIEBAaW5kZXgoW1dSSVRFUl9JRF0sIG1hcDogIkFQUFJPVkFMX01BU1RFUl9UQkxfaWJma18xIikKfQoKLy8vIFRoaXMgbW9kZWwgb3IgYXQgbGVhc3Qgb25lIG9mIGl0cyBmaWVsZHMgaGFzIGNvbW1lbnRzIGluIHRoZSBkYXRhYmFzZSwgYW5kIHJlcXVpcmVzIGFuIGFkZGl0aW9uYWwgc2V0dXAgZm9yIG1pZ3JhdGlvbnM6IFJlYWQgbW9yZTogaHR0cHM6Ly9wcmlzLmx5L2QvZGF0YWJhc2UtY29tbWVudHMKbW9kZWwgQVBQUk9WQUxfTUVNT19UQkwgewogIFNFUSAgICAgICAgIEJpZ0ludCAgICBAaWQgQGRlZmF1bHQoYXV0b2luY3JlbWVudCgpKQogIEFQUFJPVkFMX0lEIFN0cmluZyAgICBAZGIuVmFyQ2hhcigyNTUpCiAgV1JJVEVSX0lEICAgU3RyaW5nICAgIEBkYi5WYXJDaGFyKDE1KQogIFdSSVRFUl9OTSAgIFN0cmluZyAgICBAZGIuVmFyQ2hhcigxMjgpCiAgQ09OVEVOVCAgICAgU3RyaW5nPyAgIEBkYi5UZXh0CiAgUkVHX0RBVEUgICAgRGF0ZVRpbWUgIEBkZWZhdWx0KG5vdygpKSBAZGIuVGltZXN0YW1wKDApCiAgVVBEX0RBVEUgICAgRGF0ZVRpbWU/IEBkYi5UaW1lc3RhbXAoMCkKICBERUxfWU4gICAgICBTdHJpbmc/ICAgQGRlZmF1bHQoIk4iKSBAZGIuQ2hhcigxKQoKICBAQGluZGV4KFtXUklURVJfSURdLCBtYXA6ICJBUFBST1ZBTF9NRU1PX1RCTF9pYmZrXzEiKQp9CgovLy8gVGhpcyBtb2RlbCBvciBhdCBsZWFzdCBvbmUgb2YgaXRzIGZpZWxkcyBoYXMgY29tbWVudHMgaW4gdGhlIGRhdGFiYXNlLCBhbmQgcmVxdWlyZXMgYW4gYWRkaXRpb25hbCBzZXR1cCBmb3IgbWlncmF0aW9uczogUmVhZCBtb3JlOiBodHRwczovL3ByaXMubHkvZC9kYXRhYmFzZS1jb21tZW50cwptb2RlbCBBUFBST1ZBTF9UWVBFX1RCTCB7CiAgVFlQRSAgICAgICAgU3RyaW5nICBAaWQgQGRiLlZhckNoYXIoMykKICBDT05URU5UICAgICBTdHJpbmc/IEBkYi5Mb25nVGV4dAogIENPTlRFTlRfQkFLIFN0cmluZz8gQGRiLkxvbmdUZXh0CiAgVVNFX1lOICAgICAgU3RyaW5nPyBAZGVmYXVsdCgiWSIpIEBkYi5DaGFyKDEpCiAgREVMX1lOICAgICAgU3RyaW5nPyBAZGVmYXVsdCgiTiIpIEBkYi5DaGFyKDEpCn0KCi8vLyBUaGlzIG1vZGVsIG9yIGF0IGxlYXN0IG9uZSBvZiBpdHMgZmllbGRzIGhhcyBjb21tZW50cyBpbiB0aGUgZGF0YWJhc2UsIGFuZCByZXF1aXJlcyBhbiBhZGRpdGlvbmFsIHNldHVwIGZvciBtaWdyYXRpb25zOiBSZWFkIG1vcmU6IGh0dHBzOi8vcHJpcy5seS9kL2RhdGFiYXNlLWNvbW1lbnRzCm1vZGVsIEFQUFJPVkFMX1VTRVJfVEJMIHsKICBBUFBST1ZBTF9JRCAgICAgICAgICAgU3RyaW5nICAgIEBkYi5WYXJDaGFyKDI1NSkKICBBUFBST1ZBTF9VU1JfSUQgICAgICAgU3RyaW5nICAgIEBkYi5WYXJDaGFyKDE1KQogIEFQUFJPVkFMX1VTUl9HUkFERV9DRCBTdHJpbmc/ICAgQGRiLlZhckNoYXIoNCkKICBBUFBST1ZBTF9VU1JfVFlQRSAgICAgU3RyaW5nICAgIEBkZWZhdWx0KCJBIikgQGRiLkNoYXIoMSkKICBBUFBST1ZBTF9VU1JfU09SVCAgICAgSW50CiAgQVBQUk9WQUxfUFJPQ19VU0VSX1lOIFN0cmluZz8gICBAZGVmYXVsdCgiTiIpIEBkYi5DaGFyKDEpCiAgQVBQUk9WQUxfUFJPQ19ZTiAgICAgIFN0cmluZyAgICBAZGVmYXVsdCgiTiIpIEBkYi5DaGFyKDEpCiAgQVBQUk9WQUxfUFJPQ19EQVRFICAgIERhdGVUaW1lICBAZGVmYXVsdChub3coKSkgQGRiLlRpbWVzdGFtcCgwKQogIFJFR19EQVRFICAgICAgICAgICAgICBEYXRlVGltZSAgQGRlZmF1bHQobm93KCkpIEBkYi5UaW1lc3RhbXAoMCkKICBVUERfREFURSAgICAgICAgICAgICAgRGF0ZVRpbWU/IEBkYi5UaW1lc3RhbXAoMCkKICBERUxfWU4gICAgICAgICAgICAgICAgU3RyaW5nPyAgIEBkZWZhdWx0KCJOIikgQGRiLkNoYXIoMSkKCiAgQEBpZChbQVBQUk9WQUxfSUQsIEFQUFJPVkFMX1VTUl9JRCwgQVBQUk9WQUxfVVNSX1RZUEVdKQogIEBAaW5kZXgoW0FQUFJPVkFMX1VTUl9JRF0sIG1hcDogIkFQUFJPVkFMX1VTRVJfVEJMX2liZmtfMiIpCn0KCi8vLyBUaGlzIG1vZGVsIG9yIGF0IGxlYXN0IG9uZSBvZiBpdHMgZmllbGRzIGhhcyBjb21tZW50cyBpbiB0aGUgZGF0YWJhc2UsIGFuZCByZXF1aXJlcyBhbiBhZGRpdGlvbmFsIHNldHVwIGZvciBtaWdyYXRpb25zOiBSZWFkIG1vcmU6IGh0dHBzOi8vcHJpcy5seS9kL2RhdGFiYXNlLWNvbW1lbnRzCm1vZGVsIEJPT0tfQVNTRVRfVEJMIHsKICBTRVEgICAgICAgQmlnSW50ICAgIEBpZCBAZGVmYXVsdChhdXRvaW5jcmVtZW50KCkpCiAgQVNTRVRfTk8gIFN0cmluZyAgICBAZGIuVmFyQ2hhcig1MCkKICBCT09LX05NICAgU3RyaW5nPyAgIEBkYi5WYXJDaGFyKDUwMCkKICBDTlQgICAgICAgSW50PwogIFBVQkxJU0hFUiBTdHJpbmc/ICAgQGRiLlZhckNoYXIoNTApCiAgQU1PVU5UICAgIEludD8KICBCVVlfREFURSAgU3RyaW5nPyAgIEBkYi5WYXJDaGFyKDgpCiAgTU5HX0RFUFQgIFN0cmluZz8gICBAZGIuVmFyQ2hhcig1MCkKICBSRU5UX1lOICAgU3RyaW5nPyAgIEBkYi5DaGFyKDEpCiAgUkVOVF9VU0VSIFN0cmluZz8gICBAZGIuVmFyQ2hhcig1MCkKICBSRU1BUktTICAgU3RyaW5nPyAgIEBkYi5WYXJDaGFyKDQwMDApCiAgVVNFX1lOICAgIFN0cmluZyAgICBAZGVmYXVsdCgiWSIpIEBkYi5DaGFyKDEpCiAgREVMX1lOICAgIFN0cmluZyAgICBAZGVmYXVsdCgiTiIpIEBkYi5DaGFyKDEpCiAgUkVHX0RBVEUgIERhdGVUaW1lICBAZGVmYXVsdChub3coKSkgQGRiLlRpbWVzdGFtcCgwKQogIFVQRF9EQVRFICBEYXRlVGltZT8gQGRiLlRpbWVzdGFtcCgwKQp9CgovLy8gVGhpcyBtb2RlbCBvciBhdCBsZWFzdCBvbmUgb2YgaXRzIGZpZWxkcyBoYXMgY29tbWVudHMgaW4gdGhlIGRhdGFiYXNlLCBhbmQgcmVxdWlyZXMgYW4gYWRkaXRpb25hbCBzZXR1cCBmb3IgbWlncmF0aW9uczogUmVhZCBtb3JlOiBodHRwczovL3ByaXMubHkvZC9kYXRhYmFzZS1jb21tZW50cwptb2RlbCBDQVJfQVNTRVRfSU5TVVJfVEJMIHsKICBTRVEgICAgICAgQmlnSW50IEBpZCBAZGVmYXVsdChhdXRvaW5jcmVtZW50KCkpCiAgTVNFUSAgICAgIEJpZ0ludAogIEdVQVJBTlRFRSBTdHJpbmcgQGRiLlZhckNoYXIoNTAwKQp9CgovLy8gVGhpcyBtb2RlbCBvciBhdCBsZWFzdCBvbmUgb2YgaXRzIGZpZWxkcyBoYXMgY29tbWVudHMgaW4gdGhlIGRhdGFiYXNlLCBhbmQgcmVxdWlyZXMgYW4gYWRkaXRpb25hbCBzZXR1cCBmb3IgbWlncmF0aW9uczogUmVhZCBtb3JlOiBodHRwczovL3ByaXMubHkvZC9kYXRhYmFzZS1jb21tZW50cwptb2RlbCBDQVJfQVNTRVRfVEJMIHsKICBTRVEgICAgICAgIEJpZ0ludCAgICBAaWQgQGRlZmF1bHQoYXV0b2luY3JlbWVudCgpKQogIEFTU0VUX05PICAgU3RyaW5nICAgIEBkYi5WYXJDaGFyKDUwKQogIE1PREVMX05PICAgU3RyaW5nPyAgIEBkYi5WYXJDaGFyKDUwKQogIENBUl9OTyAgICAgU3RyaW5nPyAgIEBkYi5WYXJDaGFyKDUwKQogIE9XTkVSICAgICAgU3RyaW5nPyAgIEBkYi5WYXJDaGFyKDUwKQogIE9XTkVSX1RZUEUgU3RyaW5nPyAgIEBkZWZhdWx0KCIxIikgQGRiLkNoYXIoMSkKICBBTU9VTlQgICAgIEludD8KICBCVVlfREFURSAgIFN0cmluZz8gICBAZGIuVmFyQ2hhcig4KQogIFNFTExFUiAgICAgU3RyaW5nPyAgIEBkYi5WYXJDaGFyKDUwKQogIFJFTUFSS1MgICAgU3RyaW5nPyAgIEBkYi5WYXJDaGFyKDQwMDApCiAgTU5HUl9OTSAgICBTdHJpbmc/ICAgQGRiLlZhckNoYXIoNTApCiAgRlVFTCAgICAgICBTdHJpbmc/ICAgQGRiLlZhckNoYXIoMSkKICBNQU5VX0RUICAgIFN0cmluZz8gICBAZGIuVmFyQ2hhcig0KQogIEVGRklDICAgICAgU3RyaW5nPyAgIEBkYi5WYXJDaGFyKDUpCiAgSU5TVVIgICAgICBTdHJpbmc/ICAgQGRiLlZhckNoYXIoNTApCiAgSU5TVVJfTU5HUiBTdHJpbmc/ICAgQGRiLlZhckNoYXIoNTApCiAgRU1HX1RFTCAgICBTdHJpbmc/ICAgQGRiLlZhckNoYXIoMTUpCiAgU1RPUkVfTk0gICBTdHJpbmc/ICAgQGRiLlZhckNoYXIoNTApCiAgU1RPUkVfVEVMICBTdHJpbmc/ICAgQGRiLlZhckNoYXIoNTApCiAgVVNFX1lOICAgICBTdHJpbmcgICAgQGRlZmF1bHQoIlkiKSBAZGIuQ2hhcigxKQogIERFTF9ZTiAgICAgU3RyaW5nICAgIEBkZWZhdWx0KCJOIikgQGRiLkNoYXIoMSkKICBSRUdfREFURSAgIERhdGVUaW1lICBAZGVmYXVsdChub3coKSkgQGRiLlRpbWVzdGFtcCgwKQogIFVQRF9EQVRFICAgRGF0ZVRpbWU/IEBkYi5UaW1lc3RhbXAoMCkKfQoKLy8vIFRoaXMgbW9kZWwgb3IgYXQgbGVhc3Qgb25lIG9mIGl0cyBmaWVsZHMgaGFzIGNvbW1lbnRzIGluIHRoZSBkYXRhYmFzZSwgYW5kIHJlcXVpcmVzIGFuIGFkZGl0aW9uYWwgc2V0dXAgZm9yIG1pZ3JhdGlvbnM6IFJlYWQgbW9yZTogaHR0cHM6Ly9wcmlzLmx5L2QvZGF0YWJhc2UtY29tbWVudHMKbW9kZWwgQ0FSX0NIQVJHRV9UQkwgewogIFNFUSAgICAgICBCaWdJbnQgQGlkIEBkZWZhdWx0KGF1dG9pbmNyZW1lbnQoKSkKICBJVEVNICAgICAgU3RyaW5nIEBkYi5WYXJDaGFyKDgpCiAgQ0hBUkdFICAgIEJpZ0ludAogIFdSSVRFUl9JRCBTdHJpbmcgQGRiLlZhckNoYXIoOCkKICBNRU1PICAgICAgU3RyaW5nIEBkYi5WYXJDaGFyKDgpCiAgUkVHX0RBVEUgIFN0cmluZyBAZGIuVmFyQ2hhcig4KQp9CgovLy8gVGhpcyBtb2RlbCBvciBhdCBsZWFzdCBvbmUgb2YgaXRzIGZpZWxkcyBoYXMgY29tbWVudHMgaW4gdGhlIGRhdGFiYXNlLCBhbmQgcmVxdWlyZXMgYW4gYWRkaXRpb25hbCBzZXR1cCBmb3IgbWlncmF0aW9uczogUmVhZCBtb3JlOiBodHRwczovL3ByaXMubHkvZC9kYXRhYmFzZS1jb21tZW50cwptb2RlbCBDQVJfSU5GT19UQkwgewogIFNPUlQgICAgICAgICAgQmlnSW50IEBpZCBAZGVmYXVsdChhdXRvaW5jcmVtZW50KCkpCiAgQ0FSX01BTkFHRV9OTyBTdHJpbmcgQGRiLlZhckNoYXIoMTUpCiAgTU9ERUwgICAgICAgICBTdHJpbmcgQGRiLlZhckNoYXIoMjEpCiAgVVNFUl9JRCAgICAgICBTdHJpbmcgQGRiLlZhckNoYXIoMTUpCiAgUkVHX0RBVEUgICAgICBTdHJpbmcgQGRiLlZhckNoYXIoOCkKICBESVNVU0VEX1lOICAgIFN0cmluZyBAZGVmYXVsdCgiTiIpIEBkYi5WYXJDaGFyKDgpCn0KCi8vLyBUaGlzIG1vZGVsIG9yIGF0IGxlYXN0IG9uZSBvZiBpdHMgZmllbGRzIGhhcyBjb21tZW50cyBpbiB0aGUgZGF0YWJhc2UsIGFuZCByZXF1aXJlcyBhbiBhZGRpdGlvbmFsIHNldHVwIGZvciBtaWdyYXRpb25zOiBSZWFkIG1vcmU6IGh0dHBzOi8vcHJpcy5seS9kL2RhdGFiYXNlLWNvbW1lbnRzCm1vZGVsIENBUl9NSUxFQUdFX1RCTCB7CiAgU0VRICAgICAgICAgICBCaWdJbnQgQGlkIEBkZWZhdWx0KGF1dG9pbmNyZW1lbnQoKSkKICBDQVJfTUFOQUdFX05PIFN0cmluZyBAZGIuVmFyQ2hhcigxNSkKICBGT1JfVVNFICAgICAgIFN0cmluZyBAbWFwKCJGT1IgVVNFIikgQGRiLlZhckNoYXIoMjEpCiAgU1RfUE9JTlQgICAgICBTdHJpbmcgQGRiLlZhckNoYXIoMTUpCiAgREVTVElOQVRJT04gICBTdHJpbmcgQGRiLlZhckNoYXIoMTUpCiAgTUlMRUFHRSAgICAgICBCaWdJbnQKICBUT1RBTF9NSUxFQUdFIEJpZ0ludAogIFJFQ09SRF9EQVRFICAgU3RyaW5nIEBkYi5WYXJDaGFyKDgpCiAgV1JJVEVSX0lEICAgICBTdHJpbmcgQGRiLlZhckNoYXIoOCkKICBFRElUT1JfSUQgICAgIFN0cmluZyBAZGIuVmFyQ2hhcig4KQogIFJFR19EQVRFICAgICAgU3RyaW5nIEBkYi5WYXJDaGFyKDgpCiAgQVBQUl9ZTiAgICAgICBTdHJpbmcgQGRiLlZhckNoYXIoOCkKfQoKLy8vIFRoaXMgbW9kZWwgb3IgYXQgbGVhc3Qgb25lIG9mIGl0cyBmaWVsZHMgaGFzIGNvbW1lbnRzIGluIHRoZSBkYXRhYmFzZSwgYW5kIHJlcXVpcmVzIGFuIGFkZGl0aW9uYWwgc2V0dXAgZm9yIG1pZ3JhdGlvbnM6IFJlYWQgbW9yZTogaHR0cHM6Ly9wcmlzLmx5L2QvZGF0YWJhc2UtY29tbWVudHMKbW9kZWwgQ0FSX1BBUlRfUkVQTEFDRV9UQkwgewogIFNFUSAgICAgICAgICAgICAgIEJpZ0ludCBAaWQgQGRlZmF1bHQoYXV0b2luY3JlbWVudCgpKQogIFBBUlRfTk0gICAgICAgICAgIFN0cmluZyBAZGIuVmFyQ2hhcig4KQogIFJFUExBQ0VfUEVSSU9EICAgIEJpZ0ludAogIFJFX1RPVEFMX01JTEVBR0UgIEJpZ0ludAogIE5PV19UT1RBTF9NSUxFQUdFIEJpZ0ludAogIFJFTUFJTl9NSUxFQUdFICAgIEJpZ0ludAogIFJFUExBQ0VfQ09VTlQgICAgIEJpZ0ludAogIFBBUlRfUkVfREFURSAgICAgIFN0cmluZyBAZGIuVmFyQ2hhcig4KQogIFdSSVRFUl9JRCAgICAgICAgIFN0cmluZyBAZGIuVmFyQ2hhcig4KQogIFJFR19EQVRFICAgICAgICAgIFN0cmluZyBAZGIuVmFyQ2hhcig4KQp9CgovLy8gVGhpcyBtb2RlbCBvciBhdCBsZWFzdCBvbmUgb2YgaXRzIGZpZWxkcyBoYXMgY29tbWVudHMgaW4gdGhlIGRhdGFiYXNlLCBhbmQgcmVxdWlyZXMgYW4gYWRkaXRpb25hbCBzZXR1cCBmb3IgbWlncmF0aW9uczogUmVhZCBtb3JlOiBodHRwczovL3ByaXMubHkvZC9kYXRhYmFzZS1jb21tZW50cwptb2RlbCBDQVJfUkVQQUlSX0xPRyB7CiAgU0VRICAgICAgICAgICAgIEJpZ0ludCAgQGlkIEBkZWZhdWx0KGF1dG9pbmNyZW1lbnQoKSkKICBNU0VRICAgICAgICAgICAgQmlnSW50PwogIEFTU0VUX05PICAgICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDUwKQogIFJFUEFJUl9ERSAgICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDgpCiAgUkVQQUlSX0FNT1VOVCAgIFN0cmluZz8gQGRiLlZhckNoYXIoMTApCiAgUkVQQUlSX1NUT1JFICAgIFN0cmluZz8gQGRiLlZhckNoYXIoNTApCiAgUkVQQUlSX0xPRyAgICAgIFN0cmluZz8gQGRiLlZhckNoYXIoMjAwMCkKICBSRVBBSVJfT1dORVIgICAgU3RyaW5nPyBAZGIuVmFyQ2hhcig1MCkKICBGSUxFX1RQICAgICAgICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigxKQogIEZMUFRIICAgICAgICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDIwMCkKICBPUkdJTkFMX0ZJTEVfTk0gU3RyaW5nPyBAZGIuVmFyQ2hhcigyMDApCiAgU1RSRV9GSUxFX05NICAgIFN0cmluZz8gQGRiLlZhckNoYXIoMjAwKQogIFJFR19JRCAgICAgICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDI1KQogIFJFR19EQVRFICAgICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDI1KQogIEVESVRfSUQgICAgICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDI1KQogIEVESVRfREFURSAgICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDI1KQogIERFTF9JRCAgICAgICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDI1KQogIERFTF9EQVRFICAgICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDI1KQp9CgovLy8gVGhpcyBtb2RlbCBvciBhdCBsZWFzdCBvbmUgb2YgaXRzIGZpZWxkcyBoYXMgY29tbWVudHMgaW4gdGhlIGRhdGFiYXNlLCBhbmQgcmVxdWlyZXMgYW4gYWRkaXRpb25hbCBzZXR1cCBmb3IgbWlncmF0aW9uczogUmVhZCBtb3JlOiBodHRwczovL3ByaXMubHkvZC9kYXRhYmFzZS1jb21tZW50cwptb2RlbCBDQVJfVVNFX01BTkFHRV9UQkwgewogIFNFUSAgICAgICAgICAgICAgICAgQmlnSW50ICAgQGlkIEBkZWZhdWx0KGF1dG9pbmNyZW1lbnQoKSkKICBDQVJfTk8gICAgICAgICAgICAgIFN0cmluZyAgIEBkYi5WYXJDaGFyKDI1KQogIENBUl9UWVBFICAgICAgICAgICAgU3RyaW5nICAgQGRiLlZhckNoYXIoNTApCiAgREVTVElOQVRJT04gICAgICAgICBTdHJpbmcgICBAZGIuVmFyQ2hhcigyNTUpCiAgUFVSUE9TRSAgICAgICAgICAgICBTdHJpbmc/ICBAZGIuVmFyQ2hhcig1MTIpCiAgVVNFUlMgICAgICAgICAgICAgICBTdHJpbmcgICBAZGIuVmFyQ2hhcigyNTUpCiAgVVNFX1NUQVJUX0RBVEUgICAgICBEYXRlVGltZSBAZGVmYXVsdChkYmdlbmVyYXRlZCgiKCcwMDAwLTAwLTAwIDAwOjAwOjAwJykiKSkgQGRiLlRpbWVzdGFtcCgwKQogIFVTRV9FTkRfREFURSAgICAgICAgRGF0ZVRpbWUgQGRlZmF1bHQoZGJnZW5lcmF0ZWQoIignMDAwMC0wMC0wMCAwMDowMDowMCcpIikpIEBkYi5UaW1lc3RhbXAoMCkKICBVU0VfQkVGT1JFX0RJU1RBTkNFIERlY2ltYWw/IEBkYi5EZWNpbWFsKDEwLCAwKQogIFVTRV9BRlRFUl9ESVNUQU5DRSAgRGVjaW1hbD8gQGRiLkRlY2ltYWwoMTAsIDApCiAgUkVNQVJLUyAgICAgICAgICAgICBTdHJpbmc/ICBAZGIuVmFyQ2hhcig0MDAwKQogIEFDQ0VQVF9ZTiAgICAgICAgICAgU3RyaW5nPyAgQGRlZmF1bHQoIlMiKSBAZGIuQ2hhcigxKQogIFJFR19VU0VSICAgICAgICAgICAgU3RyaW5nPyAgQGRiLlZhckNoYXIoMTUpCiAgUkVHX0RBVEUgICAgICAgICAgICBEYXRlVGltZSBAZGVmYXVsdChub3coKSkgQGRiLlRpbWVzdGFtcCgwKQogIFVTRV9TVEFSVF9IT1VSICAgICAgU3RyaW5nPyAgQGRlZmF1bHQoIjAiKSBAZGIuVmFyQ2hhcig2KQogIFVTRV9FTkRfSE9VUiAgICAgICAgU3RyaW5nPyAgQGRlZmF1bHQoIjAiKSBAZGIuVmFyQ2hhcig2KQogIENBUkRfQVBQTFkgICAgICAgICAgU3RyaW5nICAgQGRlZmF1bHQoIk4iKSBAZGIuQ2hhcigxKQp9CgovLy8gVGhpcyBtb2RlbCBvciBhdCBsZWFzdCBvbmUgb2YgaXRzIGZpZWxkcyBoYXMgY29tbWVudHMgaW4gdGhlIGRhdGFiYXNlLCBhbmQgcmVxdWlyZXMgYW4gYWRkaXRpb25hbCBzZXR1cCBmb3IgbWlncmF0aW9uczogUmVhZCBtb3JlOiBodHRwczovL3ByaXMubHkvZC9kYXRhYmFzZS1jb21tZW50cwptb2RlbCBIT0xJREFZX1RCTCB7CiAgVVNFUl9JRCAgU3RyaW5nICAgIEBkYi5WYXJDaGFyKDE1KQogIFNURF9ZRUFSIFN0cmluZyAgICBAZGIuVmFyQ2hhcig0KQogIE0xICAgICAgIERlY2ltYWw/ICBAZGVmYXVsdCgwLjApIEBkYi5EZWNpbWFsKDMsIDEpCiAgTTIgICAgICAgRGVjaW1hbD8gIEBkZWZhdWx0KDAuMCkgQGRiLkRlY2ltYWwoMywgMSkKICBNMyAgICAgICBEZWNpbWFsPyAgQGRlZmF1bHQoMC4wKSBAZGIuRGVjaW1hbCgzLCAxKQogIE00ICAgICAgIERlY2ltYWw/ICBAZGVmYXVsdCgwLjApIEBkYi5EZWNpbWFsKDMsIDEpCiAgTTUgICAgICAgRGVjaW1hbD8gIEBkZWZhdWx0KDAuMCkgQGRiLkRlY2ltYWwoMywgMSkKICBNNiAgICAgICBEZWNpbWFsPyAgQGRlZmF1bHQoMC4wKSBAZGIuRGVjaW1hbCgzLCAxKQogIE03ICAgICAgIERlY2ltYWw/ICBAZGVmYXVsdCgwLjApIEBkYi5EZWNpbWFsKDMsIDEpCiAgTTggICAgICAgRGVjaW1hbD8gIEBkZWZhdWx0KDAuMCkgQGRiLkRlY2ltYWwoMywgMSkKICBNOSAgICAgICBEZWNpbWFsPyAgQGRlZmF1bHQoMC4wKSBAZGIuRGVjaW1hbCgzLCAxKQogIE0xMCAgICAgIERlY2ltYWw/ICBAZGVmYXVsdCgwLjApIEBkYi5EZWNpbWFsKDMsIDEpCiAgTTExICAgICAgRGVjaW1hbD8gIEBkZWZhdWx0KDAuMCkgQGRiLkRlY2ltYWwoMywgMSkKICBNMTIgICAgICBEZWNpbWFsPyAgQGRlZmF1bHQoMC4wKSBAZGIuRGVjaW1hbCgzLCAxKQogIFVTRV9ZTiAgIFN0cmluZyAgICBAZGVmYXVsdCgiWSIpIEBkYi5DaGFyKDEpCiAgREVMX1lOICAgU3RyaW5nICAgIEBkZWZhdWx0KCJOIikgQGRiLkNoYXIoMSkKICBSRUdfREFURSBEYXRlVGltZSAgQGRlZmF1bHQobm93KCkpIEBkYi5UaW1lc3RhbXAoMCkKICBVUERfREFURSBEYXRlVGltZT8gQGRiLlRpbWVzdGFtcCgwKQoKICBAQGlkKFtVU0VSX0lELCBTVERfWUVBUl0pCn0KCi8vLyBUaGlzIG1vZGVsIG9yIGF0IGxlYXN0IG9uZSBvZiBpdHMgZmllbGRzIGhhcyBjb21tZW50cyBpbiB0aGUgZGF0YWJhc2UsIGFuZCByZXF1aXJlcyBhbiBhZGRpdGlvbmFsIHNldHVwIGZvciBtaWdyYXRpb25zOiBSZWFkIG1vcmU6IGh0dHBzOi8vcHJpcy5seS9kL2RhdGFiYXNlLWNvbW1lbnRzCm1vZGVsIE1FTUJFUl9UQkwgewogIFVTRVJfSUQgICAgICAgICBTdHJpbmcgICAgIEBpZCBAZGIuVmFyQ2hhcigxNSkKICBQQVNTV0QgICAgICAgICAgU3RyaW5nICAgICBAZGIuVmFyQ2hhcig1MTIpCiAgVVNFUl9OTSAgICAgICAgIFN0cmluZyAgICAgQGRiLlZhckNoYXIoMTI4KQogIERFUFQgICAgICAgICAgICBTdHJpbmc/ICAgIEBkYi5WYXJDaGFyKDEyOCkKICBHUkFERSAgICAgICAgICAgU3RyaW5nPyAgICBAZGIuVmFyQ2hhcig0KQogIEpPSU5fREFURSAgICAgICBEYXRlVGltZSAgIEBkZWZhdWx0KG5vdygpKSBAZGIuVGltZXN0YW1wKDApCiAgUkVUSVJFX0RBVEUgICAgIERhdGVUaW1lICAgQGRlZmF1bHQoZGJnZW5lcmF0ZWQoIignMDAwMC0wMC0wMCAwMDowMDowMCcpIikpIEBkYi5UaW1lc3RhbXAoMCkKICBQV0RfQ0hHX0RBVEUgICAgRGF0ZVRpbWUgICBAZGVmYXVsdChkYmdlbmVyYXRlZCgiKCcwMDAwLTAwLTAwIDAwOjAwOjAwJykiKSkgQGRiLlRpbWVzdGFtcCgwKQogIFBXRF9XUk9OR19DTlQgICBJbnQ/CiAgVVNFX1lOICAgICAgICAgIFN0cmluZz8gICAgQGRlZmF1bHQoIlkiKSBAZGIuQ2hhcigxKQogIERFTF9ZTiAgICAgICAgICBTdHJpbmc/ICAgIEBkZWZhdWx0KCJOIikgQGRiLkNoYXIoMSkKICBSRUdfREFURSAgICAgICAgRGF0ZVRpbWUgICBAZGVmYXVsdChub3coKSkgQGRiLlRpbWVzdGFtcCgwKQogIFVQRF9EQVRFICAgICAgICBEYXRlVGltZT8gIEBkYi5UaW1lc3RhbXAoMCkKICBMQVNUX0xPR0lOX0RBVEUgRGF0ZVRpbWUgICBAZGVmYXVsdChkYmdlbmVyYXRlZCgiKCcwMDAwLTAwLTAwIDAwOjAwOjAwJykiKSkgQGRiLlRpbWVzdGFtcCgwKQogIE1FTU8gICAgICAgICAgICBTdHJpbmc/ICAgIEBkYi5WYXJDaGFyKDQwMDApCiAgTUVOVV9UQkwgICAgICAgIE1FTlVfVEJMW10KfQoKLy8vIFRoaXMgbW9kZWwgb3IgYXQgbGVhc3Qgb25lIG9mIGl0cyBmaWVsZHMgaGFzIGNvbW1lbnRzIGluIHRoZSBkYXRhYmFzZSwgYW5kIHJlcXVpcmVzIGFuIGFkZGl0aW9uYWwgc2V0dXAgZm9yIG1pZ3JhdGlvbnM6IFJlYWQgbW9yZTogaHR0cHM6Ly9wcmlzLmx5L2QvZGF0YWJhc2UtY29tbWVudHMKbW9kZWwgTUVOVV9BVVRIX1RCTCB7CiAgVVNFUl9JRCAgU3RyaW5nICAgIEBkYi5WYXJDaGFyKDE1KQogIE1FTlVfSUQgIFN0cmluZyAgICBAZGIuVmFyQ2hhcig3KQogIFJFQURfWU4gIFN0cmluZz8gICBAZGVmYXVsdCgiWSIpIEBkYi5DaGFyKDEpCiAgV1JJVEVfWU4gU3RyaW5nPyAgIEBkZWZhdWx0KCJZIikgQGRiLkNoYXIoMSkKICBSRUdfSUQgICBTdHJpbmc/ICAgQGRlZmF1bHQoIkFETUlOIikgQGRiLlZhckNoYXIoMTUpCiAgVVBEX0lEICAgU3RyaW5nPyAgIEBkZWZhdWx0KCJBRE1JTiIpIEBkYi5WYXJDaGFyKDE1KQogIFJFR19EQVRFIERhdGVUaW1lICBAZGVmYXVsdChub3coKSkgQGRiLlRpbWVzdGFtcCgwKQogIFVQRF9EQVRFIERhdGVUaW1lPyBAZGIuVGltZXN0YW1wKDApCgogIEBAaWQoW1VTRVJfSUQsIE1FTlVfSURdKQp9CgovLy8gVGhpcyBtb2RlbCBvciBhdCBsZWFzdCBvbmUgb2YgaXRzIGZpZWxkcyBoYXMgY29tbWVudHMgaW4gdGhlIGRhdGFiYXNlLCBhbmQgcmVxdWlyZXMgYW4gYWRkaXRpb25hbCBzZXR1cCBmb3IgbWlncmF0aW9uczogUmVhZCBtb3JlOiBodHRwczovL3ByaXMubHkvZC9kYXRhYmFzZS1jb21tZW50cwptb2RlbCBNRU5VX1RCTCB7CiAgTUVOVV9JRCAgICBTdHJpbmcgICAgICBAaWQgQGRiLlZhckNoYXIoNykKICBNRU5VX05NICAgIFN0cmluZyAgICAgIEBkYi5WYXJDaGFyKDI1NSkKICBERVBUSCAgICAgIEludAogIFNPUlQgICAgICAgSW50CiAgT1dORVJfSUQgICBTdHJpbmc/ICAgICBAZGIuVmFyQ2hhcig3KQogIFVSTCAgICAgICAgU3RyaW5nPyAgICAgQGRiLlRleHQKICBXUklURVJfSUQgIFN0cmluZz8gICAgIEBkYi5WYXJDaGFyKDE1KQogIFJFR19EQVRFICAgRGF0ZVRpbWUgICAgQGRlZmF1bHQobm93KCkpIEBkYi5UaW1lc3RhbXAoMCkKICBVUERfREFURSAgIERhdGVUaW1lPyAgIEBkYi5UaW1lc3RhbXAoMCkKICBVU0VfWU4gICAgIFN0cmluZz8gICAgIEBkZWZhdWx0KCJZIikgQGRiLkNoYXIoMSkKICBERUxfWU4gICAgIFN0cmluZz8gICAgIEBkZWZhdWx0KCJOIikgQGRiLkNoYXIoMSkKICBESVNQX1lOICAgIFN0cmluZz8gICAgIEBkZWZhdWx0KCJZIikgQGRiLkNoYXIoMSkKICBNRU5VX0lDT04gIFN0cmluZz8gICAgIEBkYi5WYXJDaGFyKDEwMCkKICBNRU1CRVJfVEJMIE1FTUJFUl9UQkw/IEByZWxhdGlvbihmaWVsZHM6IFtXUklURVJfSURdLCByZWZlcmVuY2VzOiBbVVNFUl9JRF0sIG9uRGVsZXRlOiBDYXNjYWRlLCBvblVwZGF0ZTogUmVzdHJpY3QsIG1hcDogIk1FTlVfVEJMX01FTUJFUl9UQkxfVVNFUl9JRF9mayIpCgogIEBAaW5kZXgoW1dSSVRFUl9JRF0sIG1hcDogIldSSVRFUl9JRCIpCn0KCi8vLyBUaGlzIG1vZGVsIG9yIGF0IGxlYXN0IG9uZSBvZiBpdHMgZmllbGRzIGhhcyBjb21tZW50cyBpbiB0aGUgZGF0YWJhc2UsIGFuZCByZXF1aXJlcyBhbiBhZGRpdGlvbmFsIHNldHVwIGZvciBtaWdyYXRpb25zOiBSZWFkIG1vcmU6IGh0dHBzOi8vcHJpcy5seS9kL2RhdGFiYXNlLWNvbW1lbnRzCm1vZGVsIE9GRklDRV9BU1NFVF9UQkwgewogIFNFUSAgICAgICAgICAgQmlnSW50ICAgIEBpZCBAZGVmYXVsdChhdXRvaW5jcmVtZW50KCkpCiAgQVNTRVRfTk8gICAgICBTdHJpbmcgICAgQGRiLlZhckNoYXIoNTApCiAgQVNTRVRfVFlQRSAgICBTdHJpbmcgICAgQGRiLlZhckNoYXIoNTApCiAgU0VMTEVSICAgICAgICBTdHJpbmc/ICAgQGRiLlZhckNoYXIoNTApCiAgQlVZX0RBVEUgICAgICBTdHJpbmc/ICAgQGRiLlZhckNoYXIoOCkKICBNT0RFTF9OTyAgICAgIFN0cmluZz8gICBAZGIuVmFyQ2hhcig1MCkKICBTRVJJQUxfTk8gICAgIFN0cmluZz8gICBAZGIuVmFyQ2hhcigxMDApCiAgQU1PVU5UICAgICAgICBJbnQ/CiAgS0VFUF9ZRUFSICAgICBEZWNpbWFsPyAgQGRiLkRlY2ltYWwoMTAsIDApCiAgTU5HX0RFUFQgICAgICBTdHJpbmc/ICAgQGRiLlZhckNoYXIoNTApCiAgQVNTRVRfQUNDT1VOVCBTdHJpbmc/ICAgQGRiLlZhckNoYXIoMjUpCiAgUkVNQVJLUyAgICAgICBTdHJpbmc/ICAgQGRiLlZhckNoYXIoNDAwMCkKICBDQVJSWV9PVVQgICAgIFN0cmluZz8gICBAZGIuVmFyQ2hhcig0MDAwKQogIFVTRV9ZTiAgICAgICAgU3RyaW5nICAgIEBkZWZhdWx0KCJZIikgQGRiLkNoYXIoMSkKICBERUxfWU4gICAgICAgIFN0cmluZyAgICBAZGVmYXVsdCgiTiIpIEBkYi5DaGFyKDEpCiAgUkVHX0RBVEUgICAgICBEYXRlVGltZSAgQGRlZmF1bHQobm93KCkpIEBkYi5UaW1lc3RhbXAoMCkKICBVUERfREFURSAgICAgIERhdGVUaW1lPyBAZGIuVGltZXN0YW1wKDApCn0KCi8vLyBUaGlzIG1vZGVsIG9yIGF0IGxlYXN0IG9uZSBvZiBpdHMgZmllbGRzIGhhcyBjb21tZW50cyBpbiB0aGUgZGF0YWJhc2UsIGFuZCByZXF1aXJlcyBhbiBhZGRpdGlvbmFsIHNldHVwIGZvciBtaWdyYXRpb25zOiBSZWFkIG1vcmU6IGh0dHBzOi8vcHJpcy5seS9kL2RhdGFiYXNlLWNvbW1lbnRzCm1vZGVsIFNFUlZFUl9BU1NFVF9UQkwgewogIFNFUSAgICAgICAgQmlnSW50ICAgIEBpZCBAZGVmYXVsdChhdXRvaW5jcmVtZW50KCkpCiAgQVNTRVRfTk8gICBTdHJpbmcgICAgQGRiLlZhckNoYXIoNTApCiAgQVNTRVRfVFlQRSBTdHJpbmcgICAgQGRiLlZhckNoYXIoNTApCiAgTUFLRVIgICAgICBTdHJpbmc/ICAgQGRiLlZhckNoYXIoNTApCiAgQ05UICAgICAgICBEZWNpbWFsPyAgQGRiLkRlY2ltYWwoNSwgMCkKICBBTU9VTlQgICAgIEludD8KICBCVVlfREFURSAgIFN0cmluZz8gICBAZGIuVmFyQ2hhcig4KQogIFNFTExFUiAgICAgU3RyaW5nPyAgIEBkYi5WYXJDaGFyKDUwKQogIE1PREVMX05PICAgU3RyaW5nPyAgIEBkYi5WYXJDaGFyKDUwKQogIFNFUklBTF9OTyAgU3RyaW5nPyAgIEBkYi5WYXJDaGFyKDEwMCkKICBIT1NUTkFNRSAgIFN0cmluZz8gICBAZGIuVmFyQ2hhcigxMDApCiAgQlVJTFRfTE9DICBTdHJpbmc/ICAgQGRiLkNoYXIoMSkKICBVU0VfREVTQyAgIFN0cmluZz8gICBAZGIuVmFyQ2hhcigxMDAwKQogIE9TX0lORk8gICAgU3RyaW5nPyAgIEBkYi5WYXJDaGFyKDEwMCkKICBDUFVfSU5GTyAgIFN0cmluZz8gICBAZGIuVmFyQ2hhcigxMDApCiAgUkFNX0lORk8gICBTdHJpbmc/ICAgQGRiLlZhckNoYXIoMTAwKQogIEhERF9JTkZPICAgU3RyaW5nPyAgIEBkYi5WYXJDaGFyKDEwMCkKICBTU0RfSU5GTyAgIFN0cmluZz8gICBAZGIuVmFyQ2hhcigxMDApCiAgT0REICAgICAgICBTdHJpbmc/ICAgQGRiLlZhckNoYXIoMTAwKQogIFJFTUFSS1MgICAgU3RyaW5nPyAgIEBkYi5WYXJDaGFyKDQwMDApCiAgQ0FSUllfT1VUICBTdHJpbmc/ICAgQGRiLlZhckNoYXIoNDAwMCkKICBVU0VfWU4gICAgIFN0cmluZyAgICBAZGVmYXVsdCgiWSIpIEBkYi5DaGFyKDEpCiAgREVMX1lOICAgICBTdHJpbmcgICAgQGRlZmF1bHQoIk4iKSBAZGIuQ2hhcigxKQogIFJFR19EQVRFICAgRGF0ZVRpbWUgIEBkZWZhdWx0KG5vdygpKSBAZGIuVGltZXN0YW1wKDApCiAgVVBEX0RBVEUgICBEYXRlVGltZT8gQGRiLlRpbWVzdGFtcCgwKQp9CgovLy8gVGhpcyBtb2RlbCBvciBhdCBsZWFzdCBvbmUgb2YgaXRzIGZpZWxkcyBoYXMgY29tbWVudHMgaW4gdGhlIGRhdGFiYXNlLCBhbmQgcmVxdWlyZXMgYW4gYWRkaXRpb25hbCBzZXR1cCBmb3IgbWlncmF0aW9uczogUmVhZCBtb3JlOiBodHRwczovL3ByaXMubHkvZC9kYXRhYmFzZS1jb21tZW50cwptb2RlbCBTT0ZUV0FSRV9BU1NFVF9UQkwgewogIFNFUSAgICAgICAgIEJpZ0ludCAgICBAaWQgQGRlZmF1bHQoYXV0b2luY3JlbWVudCgpKQogIEFTU0VUX05PICAgIFN0cmluZyAgICBAZGIuVmFyQ2hhcig1MCkKICBTT0ZUV0FSRV9OTSBTdHJpbmcgICAgQGRiLlZhckNoYXIoMTAwKQogIFZFUlNJT05fTk0gIFN0cmluZz8gICBAZGIuVmFyQ2hhcigxMDApCiAgQ05UICAgICAgICAgRGVjaW1hbD8gIEBkYi5EZWNpbWFsKDUsIDApCiAgQU1PVU5UICAgICAgSW50PwogIEJVWV9EQVRFICAgIFN0cmluZz8gICBAZGIuVmFyQ2hhcig4KQogIFNFUklBTF9OTyAgIFN0cmluZz8gICBAZGIuVmFyQ2hhcigxMDApCiAgTElDRU5TRV9OTyAgU3RyaW5nPyAgIEBkYi5WYXJDaGFyKDEwMCkKICBVU0VSX05NICAgICBTdHJpbmc/ICAgQGRiLlZhckNoYXIoMTI4KQogIFJFTUFSS1MgICAgIFN0cmluZz8gICBAZGIuVmFyQ2hhcig0MDAwKQogIFVTRV9ZTiAgICAgIFN0cmluZyAgICBAZGVmYXVsdCgiWSIpIEBkYi5DaGFyKDEpCiAgREVMX1lOICAgICAgU3RyaW5nICAgIEBkZWZhdWx0KCJOIikgQGRiLkNoYXIoMSkKICBSRUdfREFURSAgICBEYXRlVGltZSAgQGRlZmF1bHQobm93KCkpIEBkYi5UaW1lc3RhbXAoMCkKICBVUERfREFURSAgICBEYXRlVGltZT8gQGRiLlRpbWVzdGFtcCgwKQp9CgovLy8gVGhpcyBtb2RlbCBvciBhdCBsZWFzdCBvbmUgb2YgaXRzIGZpZWxkcyBoYXMgY29tbWVudHMgaW4gdGhlIGRhdGFiYXNlLCBhbmQgcmVxdWlyZXMgYW4gYWRkaXRpb25hbCBzZXR1cCBmb3IgbWlncmF0aW9uczogUmVhZCBtb3JlOiBodHRwczovL3ByaXMubHkvZC9kYXRhYmFzZS1jb21tZW50cwptb2RlbCBTVF9BRE1JTl9NRU5VIHsKICBNRU5VX0NEICAgU3RyaW5nICBAaWQgQGRiLlZhckNoYXIoOSkKICBNRU5VX05NICAgU3RyaW5nICBAZGIuVmFyQ2hhcigxMDApCiAgTUVOVV9QQVRIIFN0cmluZz8gQGRiLlZhckNoYXIoMjUwKQogIE1FTlVfU1JUICBJbnQKICBNRU5VX0RFUFMgSW50CiAgTUVOVV9JQ09OIFN0cmluZz8gQGRiLlZhckNoYXIoMTAwKQogIE1FTlVfVFAgICBTdHJpbmcgIEBkZWZhdWx0KCJGIikgQGRiLlZhckNoYXIoMSkKICBSRUdfSUQgICAgU3RyaW5nICBAZGIuVmFyQ2hhcigxMDApCiAgUkVHX0RBVEUgIFN0cmluZz8gQGRiLlZhckNoYXIoMTQpCiAgRURJVF9JRCAgIFN0cmluZz8gQGRiLlZhckNoYXIoMTAwKQogIEVESVRfREFURSBTdHJpbmc/IEBkYi5WYXJDaGFyKDE0KQogIERFTF9JRCAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDEwMCkKICBERUxfREFURSAgU3RyaW5nPyBAZGIuVmFyQ2hhcigxNCkKCiAgQEBpbmRleChbTUVOVV9DRF0sIG1hcDogIklEWF9BRE1JTl9NRU5VIikKfQoKLy8vIFRoaXMgbW9kZWwgb3IgYXQgbGVhc3Qgb25lIG9mIGl0cyBmaWVsZHMgaGFzIGNvbW1lbnRzIGluIHRoZSBkYXRhYmFzZSwgYW5kIHJlcXVpcmVzIGFuIGFkZGl0aW9uYWwgc2V0dXAgZm9yIG1pZ3JhdGlvbnM6IFJlYWQgbW9yZTogaHR0cHM6Ly9wcmlzLmx5L2QvZGF0YWJhc2UtY29tbWVudHMKbW9kZWwgU1RfQUxBUk0gewogIFNFUSAgICAgICAgICBJbnQgICAgIEBpZAogIE1TR19DRCAgICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDkpCiAgTVNHX0NOVFMgICAgIFN0cmluZz8gQGRiLlZhckNoYXIoNDAwMCkKICBTRU5EX0RBVEUgICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigxNCkKICBTRU5EX0RJViAgICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigxKQogIFNFTkRfREVQVF9DRCBTdHJpbmc/IEBkYi5WYXJDaGFyKDEyKQogIFNFTkRfSUQgICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDI1KQogIFJFQ1ZfSUQgICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDI1KQogIFBPUF9ZTiAgICAgICBTdHJpbmc/IEBkZWZhdWx0KCJOIikgQGRiLlZhckNoYXIoMSkKICBFRElUX0lEICAgICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigyNSkKICBFRElUX0RBVEUgICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigxNCkKCiAgQEBpbmRleChbU0VRLCBNU0dfQ0RdLCBtYXA6ICJJTkRFWF9BTEFSTSIpCn0KCi8vLyBUaGlzIG1vZGVsIG9yIGF0IGxlYXN0IG9uZSBvZiBpdHMgZmllbGRzIGhhcyBjb21tZW50cyBpbiB0aGUgZGF0YWJhc2UsIGFuZCByZXF1aXJlcyBhbiBhZGRpdGlvbmFsIHNldHVwIGZvciBtaWdyYXRpb25zOiBSZWFkIG1vcmU6IGh0dHBzOi8vcHJpcy5seS9kL2RhdGFiYXNlLWNvbW1lbnRzCm1vZGVsIFNUX0FVRElUX0xPRyB7CiAgU0VRICAgICAgIEludCAgICAgQGlkCiAgTE9HX0NPREUgIFN0cmluZyAgQGRiLlZhckNoYXIoMTIpCiAgTE9HX0NOVFMgIFN0cmluZyAgQGRiLlRleHQKICBFUlJfQ09ERSAgU3RyaW5nPyBAZGIuVmFyQ2hhcigxMikKICBSRUdfSUQgICAgU3RyaW5nICBAZGIuVmFyQ2hhcigyNSkKICBSRUdfREFURSAgU3RyaW5nICBAZGIuVmFyQ2hhcigxNCkKICBFRElUX0lEICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigyNSkKICBFRElUX0RBVEUgU3RyaW5nPyBAZGIuVmFyQ2hhcigxNCkKICBERUxfSUQgICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigyNSkKICBERUxfREFURSAgU3RyaW5nPyBAZGIuVmFyQ2hhcigxNCkKCiAgQEBpbmRleChbU0VRLCBMT0dfQ09ERSwgRVJSX0NPREVdLCBtYXA6ICJJTkRFWF9BVURJVF9MT0ciKQp9CgovLy8gVGhpcyBtb2RlbCBvciBhdCBsZWFzdCBvbmUgb2YgaXRzIGZpZWxkcyBoYXMgY29tbWVudHMgaW4gdGhlIGRhdGFiYXNlLCBhbmQgcmVxdWlyZXMgYW4gYWRkaXRpb25hbCBzZXR1cCBmb3IgbWlncmF0aW9uczogUmVhZCBtb3JlOiBodHRwczovL3ByaXMubHkvZC9kYXRhYmFzZS1jb21tZW50cwptb2RlbCBTVF9CQU5ORVIgewogIEJBTk5FUl9DRCBTdHJpbmcgIEBpZCBAZGIuVmFyQ2hhcig5KQogIExLX1VSTCAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDI1NSkKICBMS19UQVJHRVQgU3RyaW5nPyBAZGIuVmFyQ2hhcigxKQogIEZMUFRIICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDIwMCkKICBGSUxFX05NICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigyMDApCiAgVVNFX1lOICAgIFN0cmluZz8gQGRlZmF1bHQoIk4iKSBAZGIuVmFyQ2hhcigxKQogIFJFR19JRCAgICBTdHJpbmcgIEBkYi5WYXJDaGFyKDI1KQogIFJFR19EQVRFICBTdHJpbmc/IEBkYi5WYXJDaGFyKDE0KQogIEVESVRfSUQgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDI1KQogIEVESVRfREFURSBTdHJpbmc/IEBkYi5WYXJDaGFyKDE0KQogIERFTF9JRCAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDI1KQogIERFTF9EQVRFICBTdHJpbmc/IEBkYi5WYXJDaGFyKDE0KQp9CgovLy8gVGhpcyBtb2RlbCBvciBhdCBsZWFzdCBvbmUgb2YgaXRzIGZpZWxkcyBoYXMgY29tbWVudHMgaW4gdGhlIGRhdGFiYXNlLCBhbmQgcmVxdWlyZXMgYW4gYWRkaXRpb25hbCBzZXR1cCBmb3IgbWlncmF0aW9uczogUmVhZCBtb3JlOiBodHRwczovL3ByaXMubHkvZC9kYXRhYmFzZS1jb21tZW50cwptb2RlbCBTVF9CT0FSRF9DT0xVTU4gewogIEJPQVJEX0NEIFN0cmluZyBAZGIuVmFyQ2hhcigxMikKICBTT1JUICAgICBJbnQKICBDT0xfQ0QgICBTdHJpbmcgQGRiLlZhckNoYXIoMTAwKQogIENPTF9OTSAgIFN0cmluZyBAZGIuVmFyQ2hhcig1MCkKICBSRUdfSUQgICBTdHJpbmcgQGRiLlZhckNoYXIoMjUpCiAgUkVHX0RBVEUgU3RyaW5nIEBkYi5WYXJDaGFyKDE0KQoKICBAQGlkKFtCT0FSRF9DRCwgQ09MX0NEXSkKfQoKLy8vIFRoaXMgbW9kZWwgb3IgYXQgbGVhc3Qgb25lIG9mIGl0cyBmaWVsZHMgaGFzIGNvbW1lbnRzIGluIHRoZSBkYXRhYmFzZSwgYW5kIHJlcXVpcmVzIGFuIGFkZGl0aW9uYWwgc2V0dXAgZm9yIG1pZ3JhdGlvbnM6IFJlYWQgbW9yZTogaHR0cHM6Ly9wcmlzLmx5L2QvZGF0YWJhc2UtY29tbWVudHMKbW9kZWwgU1RfQk9BUkRfQ09MVU1OX0RGVCB7CiAgQk9BUkRfVFkgIFN0cmluZyAgQGRiLlZhckNoYXIoMTIpCiAgU09SVCAgICAgIEludAogIENPTF9DRCAgICBTdHJpbmcgIEBkYi5WYXJDaGFyKDEwMCkKICBDT0xfTk0gICAgU3RyaW5nICBAZGIuVmFyQ2hhcig1MCkKICBFRElUX0lEICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigyNSkKICBFRElUX0RBVEUgU3RyaW5nPyBAZGIuVmFyQ2hhcigxNCkKICBERUxfWU4gICAgU3RyaW5nICBAZGVmYXVsdCgiTiIpIEBkYi5WYXJDaGFyKDEpCgogIEBAaWQoW0JPQVJEX1RZLCBDT0xfQ0QsIERFTF9ZTl0pCn0KCi8vLyBUaGlzIG1vZGVsIG9yIGF0IGxlYXN0IG9uZSBvZiBpdHMgZmllbGRzIGhhcyBjb21tZW50cyBpbiB0aGUgZGF0YWJhc2UsIGFuZCByZXF1aXJlcyBhbiBhZGRpdGlvbmFsIHNldHVwIGZvciBtaWdyYXRpb25zOiBSZWFkIG1vcmU6IGh0dHBzOi8vcHJpcy5seS9kL2RhdGFiYXNlLWNvbW1lbnRzCm1vZGVsIFNUX0JPQVJEX0NPTU1FTlQgewogIFNFUSAgICAgICAgICBJbnQKICBNU0VRICAgICAgICAgSW50CiAgQk9BUkRfQ0QgICAgIFN0cmluZyAgQGRiLlZhckNoYXIoMTIpCiAgQ05UUyAgICAgICAgIFN0cmluZz8gQGRiLlZhckNoYXIoMTAwMCkKICBVUFBFUl9TRVEgICAgSW50PyAgICBAZGVmYXVsdCgwKQogIFJFUExZX1lOICAgICBTdHJpbmc/IEBkZWZhdWx0KCJOIikgQGRiLlZhckNoYXIoMSkKICBSRUdfQURNSU5fWU4gU3RyaW5nPyBAZGVmYXVsdCgiTiIpIEBkYi5WYXJDaGFyKDEpCiAgUkVHX0lEICAgICAgIFN0cmluZyAgQGRiLlZhckNoYXIoMjUpCiAgUkVHX0RBVEUgICAgIFN0cmluZyAgQGRiLlZhckNoYXIoMTQpCiAgRURJVF9JRCAgICAgIFN0cmluZz8gQGRiLlZhckNoYXIoMjUpCiAgRURJVF9EQVRFICAgIFN0cmluZz8gQGRiLlZhckNoYXIoMTQpCiAgREVMX0lEICAgICAgIFN0cmluZz8gQGRiLlZhckNoYXIoMjUpCiAgREVMX0RBVEUgICAgIFN0cmluZz8gQGRiLlZhckNoYXIoMTQpCgogIEBAaWQoW1NFUSwgTVNFUSwgQk9BUkRfQ0RdKQp9CgovLy8gVGhpcyBtb2RlbCBvciBhdCBsZWFzdCBvbmUgb2YgaXRzIGZpZWxkcyBoYXMgY29tbWVudHMgaW4gdGhlIGRhdGFiYXNlLCBhbmQgcmVxdWlyZXMgYW4gYWRkaXRpb25hbCBzZXR1cCBmb3IgbWlncmF0aW9uczogUmVhZCBtb3JlOiBodHRwczovL3ByaXMubHkvZC9kYXRhYmFzZS1jb21tZW50cwptb2RlbCBTVF9CT0FSRF9GSUxFIHsKICBTRVEgICAgICAgICAgICAgSW50CiAgTVNFUSAgICAgICAgICAgIEludAogIEJPQVJEX0NEICAgICAgICBTdHJpbmcgIEBkYi5WYXJDaGFyKDEyKQogIEZJTEVfVFAgICAgICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDEpCiAgRkxQVEggICAgICAgICAgIFN0cmluZz8gQGRiLlZhckNoYXIoMjAwKQogIE9SR0lOQUxfRklMRV9OTSBTdHJpbmc/IEBkYi5WYXJDaGFyKDIwMCkKICBTVFJFX0ZJTEVfTk0gICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigyMDApCiAgRklMRV9TSVpFICAgICAgIEludD8KICBSRVBSRV9ZTiAgICAgICAgU3RyaW5nPyBAZGVmYXVsdCgiTiIpIEBkYi5WYXJDaGFyKDEpCiAgRFdMRF9DTyAgICAgICAgIEludD8KCiAgQEBpZChbU0VRLCBNU0VRLCBCT0FSRF9DRF0pCn0KCi8vLyBUaGlzIG1vZGVsIG9yIGF0IGxlYXN0IG9uZSBvZiBpdHMgZmllbGRzIGhhcyBjb21tZW50cyBpbiB0aGUgZGF0YWJhc2UsIGFuZCByZXF1aXJlcyBhbiBhZGRpdGlvbmFsIHNldHVwIGZvciBtaWdyYXRpb25zOiBSZWFkIG1vcmU6IGh0dHBzOi8vcHJpcy5seS9kL2RhdGFiYXNlLWNvbW1lbnRzCm1vZGVsIFNUX0JPQVJEX01TVCB7CiAgU0VRICAgICAgICAgIEludAogIEJPQVJEX0NEICAgICBTdHJpbmcgIEBkYi5WYXJDaGFyKDEyKQogIENMU19DRCAgICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDEyKQogIFRUTCAgICAgICAgICBTdHJpbmcgIEBkYi5WYXJDaGFyKDEwMCkKICBDTlRTICAgICAgICAgU3RyaW5nICBAZGIuVGV4dAogIEZJTEVfWU4gICAgICBTdHJpbmc/IEBkZWZhdWx0KCJOIikgQGRiLlZhckNoYXIoMSkKICBJTUFHRV9ZTiAgICAgU3RyaW5nPyBAZGVmYXVsdCgiTiIpIEBkYi5WYXJDaGFyKDEpCiAgTk9USUNFX1lOICAgIFN0cmluZz8gQGRlZmF1bHQoIk4iKSBAZGIuVmFyQ2hhcigxKQogIExLX1VSTCAgICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDI1NSkKICBMS19UQVJHRVQgICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigxKQogIFJFQURfQ05UICAgICBJbnQ/ICAgIEBkZWZhdWx0KDApCiAgUkVHX0FETUlOX1lOIFN0cmluZz8gQGRlZmF1bHQoIk4iKSBAZGIuVmFyQ2hhcigxKQogIFJFUExZX1lOICAgICBTdHJpbmc/IEBkZWZhdWx0KCJOIikgQGRiLlZhckNoYXIoMSkKICBVUFBFUl9TRVEgICAgSW50PyAgICBAZGVmYXVsdCgwKQogIFJFR19JRCAgICAgICBTdHJpbmcgIEBkYi5WYXJDaGFyKDI1KQogIFJFR19EQVRFICAgICBTdHJpbmcgIEBkYi5WYXJDaGFyKDE0KQogIEVESVRfSUQgICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDI1KQogIEVESVRfREFURSAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDE0KQogIERFTF9JRCAgICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDI1KQogIERFTF9EQVRFICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDE0KQoKICBAQGlkKFtTRVEsIEJPQVJEX0NEXSkKICBAQGluZGV4KFtTRVEsIEJPQVJEX0NEXSwgbWFwOiAiSU5ERVhfQk9BUkRfTVNUIikKfQoKLy8vIFRoaXMgbW9kZWwgb3IgYXQgbGVhc3Qgb25lIG9mIGl0cyBmaWVsZHMgaGFzIGNvbW1lbnRzIGluIHRoZSBkYXRhYmFzZSwgYW5kIHJlcXVpcmVzIGFuIGFkZGl0aW9uYWwgc2V0dXAgZm9yIG1pZ3JhdGlvbnM6IFJlYWQgbW9yZTogaHR0cHM6Ly9wcmlzLmx5L2QvZGF0YWJhc2UtY29tbWVudHMKbW9kZWwgU1RfQk9BUkRfU1RORyB7CiAgQk9BUkRfQ0QgICAgU3RyaW5nICBAaWQgQGRiLlZhckNoYXIoMTIpCiAgQk9BUkRfTk0gICAgU3RyaW5nICBAZGIuVmFyQ2hhcigxMDApCiAgQk9BUkRfVFkgICAgU3RyaW5nICBAZGVmYXVsdCgiRCIpIEBkYi5WYXJDaGFyKDEyKQogIEVESVRPUl9ZTiAgIFN0cmluZyAgQGRlZmF1bHQoIlkiKSBAZGIuVmFyQ2hhcigxKQogIFJMU19ZTiAgICAgIFN0cmluZyAgQGRlZmF1bHQoIk4iKSBAZGIuVmFyQ2hhcigxKQogIENDTF9TRVEgICAgIEludD8KICBMSVNUX0NOVCAgICBJbnQ/CiAgV1JJVEVfWU4gICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigxKQogIENPTU1FTlRfWU4gIFN0cmluZz8gQGRiLlZhckNoYXIoMSkKICBSRVBMWV9ZTiAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDEpCiAgQVRUQUNIX1lOICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigxKQogIEFUVEFDSF9TSVpFIFN0cmluZz8gQGRiLlZhckNoYXIoNSkKICBBVFRBQ0hfQ05UICBTdHJpbmc/IEBkYi5WYXJDaGFyKDUpCiAgQVRUQUNIX0VYVCAgU3RyaW5nPyBAZGIuVmFyQ2hhcig1MDApCiAgUkVHX0lEICAgICAgU3RyaW5nICBAZGIuVmFyQ2hhcigyNSkKICBSRUdfREFURSAgICBTdHJpbmcgIEBkYi5WYXJDaGFyKDE0KQogIEVESVRfSUQgICAgIFN0cmluZz8gQGRiLlZhckNoYXIoMjUpCiAgRURJVF9EQVRFICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigxNCkKICBERUxfSUQgICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDI1KQogIERFTF9EQVRFICAgIFN0cmluZz8gQGRiLlZhckNoYXIoMTQpCn0KCi8vLyBUaGlzIG1vZGVsIG9yIGF0IGxlYXN0IG9uZSBvZiBpdHMgZmllbGRzIGhhcyBjb21tZW50cyBpbiB0aGUgZGF0YWJhc2UsIGFuZCByZXF1aXJlcyBhbiBhZGRpdGlvbmFsIHNldHVwIGZvciBtaWdyYXRpb25zOiBSZWFkIG1vcmU6IGh0dHBzOi8vcHJpcy5seS9kL2RhdGFiYXNlLWNvbW1lbnRzCm1vZGVsIFNUX0NDTCB7CiAgU0VRICAgICAgICAgICAgIEludCAgICAgQGlkCiAgQ0NMX1RZUEUgICAgICAgIFN0cmluZyAgQGRiLlZhckNoYXIoNTApCiAgQ0NMX05NICAgICAgICAgIFN0cmluZyAgQGRiLlZhckNoYXIoNTApCiAgRkxQVEggICAgICAgICAgIFN0cmluZz8gQGRiLlZhckNoYXIoMjAwKQogIE9SR0lOQUxfRklMRV9OTSBTdHJpbmc/IEBkYi5WYXJDaGFyKDIwMCkKICBTVFJFX0ZJTEVfTk0gICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigyMDApCiAgRklMRV9FWFRTTiAgICAgIFN0cmluZz8gQGRiLlZhckNoYXIoMTApCiAgRklMRV9TSVpFICAgICAgIEludD8KICBSRUdfSUQgICAgICAgICAgU3RyaW5nICBAZGIuVmFyQ2hhcigyNSkKICBSRUdfREFURSAgICAgICAgU3RyaW5nICBAZGIuVmFyQ2hhcigxNCkKICBFRElUX0lEICAgICAgICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigyNSkKICBFRElUX0RBVEUgICAgICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigxNCkKICBERUxfSUQgICAgICAgICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigyNSkKICBERUxfREFURSAgICAgICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigxNCkKfQoKLy8vIFRoaXMgbW9kZWwgb3IgYXQgbGVhc3Qgb25lIG9mIGl0cyBmaWVsZHMgaGFzIGNvbW1lbnRzIGluIHRoZSBkYXRhYmFzZSwgYW5kIHJlcXVpcmVzIGFuIGFkZGl0aW9uYWwgc2V0dXAgZm9yIG1pZ3JhdGlvbnM6IFJlYWQgbW9yZTogaHR0cHM6Ly9wcmlzLmx5L2QvZGF0YWJhc2UtY29tbWVudHMKbW9kZWwgU1RfQ09ERV9NU1QgewogIENEX0dSUCAgICBTdHJpbmcgIEBkYi5WYXJDaGFyKDEyKQogIENEX0tFWSAgICBTdHJpbmcgIEBkYi5WYXJDaGFyKDEyKQogIENEX1ZBTCAgICBTdHJpbmcgIEBkYi5WYXJDaGFyKDUwKQogIENEX0RFU0MgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDMwMCkKICBDRF9TUlQgICAgSW50CiAgREVQVEggICAgIEludD8KICBSRUdfSUQgICAgU3RyaW5nICBAZGIuVmFyQ2hhcigyMCkKICBSRUdfREFURSAgU3RyaW5nPyBAZGIuVmFyQ2hhcigxNCkKICBFRElUX0lEICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigyMCkKICBFRElUX0RBVEUgU3RyaW5nPyBAZGIuVmFyQ2hhcigxNCkKICBERUxfSUQgICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigyMCkKICBERUxfREFURSAgU3RyaW5nPyBAZGIuVmFyQ2hhcigxNCkKCiAgQEBpZChbQ0RfR1JQLCBDRF9LRVldKQp9CgovLy8gVGhpcyBtb2RlbCBvciBhdCBsZWFzdCBvbmUgb2YgaXRzIGZpZWxkcyBoYXMgY29tbWVudHMgaW4gdGhlIGRhdGFiYXNlLCBhbmQgcmVxdWlyZXMgYW4gYWRkaXRpb25hbCBzZXR1cCBmb3IgbWlncmF0aW9uczogUmVhZCBtb3JlOiBodHRwczovL3ByaXMubHkvZC9kYXRhYmFzZS1jb21tZW50cwptb2RlbCBTVF9DT05ORUNUX0xPRyB7CiAgU0VRICAgICAgICAgIEludCAgICAgQGlkCiAgVVNFUl9JRCAgICAgIFN0cmluZyAgQGRiLlZhckNoYXIoMjUpCiAgQ09OTl9UWVBFICAgIFN0cmluZz8gQGRiLlZhckNoYXIoNTApCiAgT1NfVFlQRSAgICAgIFN0cmluZz8gQGRiLlZhckNoYXIoNTApCiAgQlJPV1NFUl9UWVBFIFN0cmluZz8gQGRiLlZhckNoYXIoMTAwKQogIENPTk5FX0lQICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDIwKQogIFJFR19EQVRFICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDE0KQp9CgovLy8gVGhpcyBtb2RlbCBvciBhdCBsZWFzdCBvbmUgb2YgaXRzIGZpZWxkcyBoYXMgY29tbWVudHMgaW4gdGhlIGRhdGFiYXNlLCBhbmQgcmVxdWlyZXMgYW4gYWRkaXRpb25hbCBzZXR1cCBmb3IgbWlncmF0aW9uczogUmVhZCBtb3JlOiBodHRwczovL3ByaXMubHkvZC9kYXRhYmFzZS1jb21tZW50cwptb2RlbCBTVF9DT05URU5UU19GSUxFIHsKICBTRVEgICAgICAgICAgICAgSW50ICAgICBAaWQgQGRlZmF1bHQoYXV0b2luY3JlbWVudCgpKQogIE1TRVEgICAgICAgICAgICBTdHJpbmcgIEBkYi5WYXJDaGFyKDEyKQogIEZJTEVfVFAgICAgICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDEpCiAgRkxQVEggICAgICAgICAgIFN0cmluZyAgQGRiLlZhckNoYXIoMjAwKQogIE9SR0lOQUxfRklMRV9OTSBTdHJpbmcgIEBkYi5WYXJDaGFyKDIwMCkKICBTVFJFX0ZJTEVfTk0gICAgU3RyaW5nICBAZGIuVmFyQ2hhcigyMDApCiAgRklMRV9TSVpFICAgICAgIEludAp9CgovLy8gVGhpcyBtb2RlbCBvciBhdCBsZWFzdCBvbmUgb2YgaXRzIGZpZWxkcyBoYXMgY29tbWVudHMgaW4gdGhlIGRhdGFiYXNlLCBhbmQgcmVxdWlyZXMgYW4gYWRkaXRpb25hbCBzZXR1cCBmb3IgbWlncmF0aW9uczogUmVhZCBtb3JlOiBodHRwczovL3ByaXMubHkvZC9kYXRhYmFzZS1jb21tZW50cwptb2RlbCBTVF9DT05URU5UU19NU1QgewogIFNFUSAgICAgICBJbnQgICAgIEBpZAogIENOVFNfTk0gICBTdHJpbmcgIEBkYi5WYXJDaGFyKDEwMCkKICBQVUJfREFURSAgU3RyaW5nPyBAZGIuVmFyQ2hhcigxNCkKICBQVUJfU1RBVEUgU3RyaW5nPyBAZGVmYXVsdCgiTiIpIEBkYi5WYXJDaGFyKDEpCiAgQ04gICAgICAgIFN0cmluZz8gQGRiLkxvbmdUZXh0CiAgU1JDSF9ZTiAgIFN0cmluZz8gQGRlZmF1bHQoIlkiKSBAZGIuVmFyQ2hhcigxKQogIEZJTEVfWU4gICBTdHJpbmc/IEBkZWZhdWx0KCJOIikgQGRiLlZhckNoYXIoMSkKICBJTUFHRV9ZTiAgU3RyaW5nPyBAZGVmYXVsdCgiTiIpIEBkYi5WYXJDaGFyKDEpCiAgUkVHX0lEICAgIFN0cmluZyAgQGRiLlZhckNoYXIoMjUpCiAgUkVHX0RBVEUgIFN0cmluZz8gQGRiLlZhckNoYXIoMTQpCiAgRURJVF9JRCAgIFN0cmluZz8gQGRiLlZhckNoYXIoMjUpCiAgRURJVF9EQVRFIFN0cmluZz8gQGRiLlZhckNoYXIoMTQpCiAgREVMX0lEICAgIFN0cmluZz8gQGRiLlZhckNoYXIoMjUpCiAgREVMX0RBVEUgIFN0cmluZz8gQGRiLlZhckNoYXIoMTQpCn0KCi8vLyBUaGlzIG1vZGVsIG9yIGF0IGxlYXN0IG9uZSBvZiBpdHMgZmllbGRzIGhhcyBjb21tZW50cyBpbiB0aGUgZGF0YWJhc2UsIGFuZCByZXF1aXJlcyBhbiBhZGRpdGlvbmFsIHNldHVwIGZvciBtaWdyYXRpb25zOiBSZWFkIG1vcmU6IGh0dHBzOi8vcHJpcy5seS9kL2RhdGFiYXNlLWNvbW1lbnRzCm1vZGVsIFNUX0RFUFQgewogIERFUFRfQ0QgICAgICAgU3RyaW5nICBAaWQgQGRiLlZhckNoYXIoMTIpCiAgREVQVF9OTSAgICAgICBTdHJpbmcgIEBkYi5WYXJDaGFyKDUwKQogIFVQUEVSX0RFUFRfQ0QgU3RyaW5nPyBAZGIuVmFyQ2hhcigxMikKICBVUFBFUl9ERVBUX05NIFN0cmluZz8gQGRiLlZhckNoYXIoNTApCiAgU09SVCAgICAgICAgICBJbnQ/CiAgTUFJTl9ZTiAgICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDUwKQogIERFUFRfREVTQyAgICAgU3RyaW5nPyBAZGIuVmFyQ2hhcig0MDAwKQogIFJFR19JRCAgICAgICAgU3RyaW5nICBAZGIuVmFyQ2hhcigyNSkKICBSRUdfREFURSAgICAgIFN0cmluZyAgQGRiLlZhckNoYXIoMTQpCiAgRURJVF9JRCAgICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDI1KQogIEVESVRfREFURSAgICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigxNCkKICBERUxfSUQgICAgICAgIFN0cmluZz8gQGRiLlZhckNoYXIoMjUpCiAgREVMX0RBVEUgICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDE0KQoKICBAQGluZGV4KFtERVBUX0NELCBVUFBFUl9ERVBUX0NEXSwgbWFwOiAiSURYX0RFUFQiKQp9CgovLy8gVGhpcyBtb2RlbCBvciBhdCBsZWFzdCBvbmUgb2YgaXRzIGZpZWxkcyBoYXMgY29tbWVudHMgaW4gdGhlIGRhdGFiYXNlLCBhbmQgcmVxdWlyZXMgYW4gYWRkaXRpb25hbCBzZXR1cCBmb3IgbWlncmF0aW9uczogUmVhZCBtb3JlOiBodHRwczovL3ByaXMubHkvZC9kYXRhYmFzZS1jb21tZW50cwptb2RlbCBTVF9ERVBUX0VNUCB7CiAgRU1QX05PICAgICBTdHJpbmcgIEBpZCBAZGIuVmFyQ2hhcigxMikKICBFTVBfTk0gICAgIFN0cmluZyAgQGRiLlZhckNoYXIoMTAwKQogIERFUFRfQ0QgICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigxMikKICBERVBUX05NICAgIFN0cmluZz8gQGRiLlZhckNoYXIoNTApCiAgRkNUTl9DRCAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDEyKQogIEZDVE5fTk0gICAgU3RyaW5nPyBAZGIuVmFyQ2hhcig1MCkKICBPRkNQX0NEICAgIFN0cmluZz8gQGRiLlZhckNoYXIoMTIpCiAgT0ZDUF9OTSAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDUwKQogIEVNQUlMX0FERFIgU3RyaW5nPyBAZGIuVmFyQ2hhcigyMDApCiAgT0ZGTV9URUxOTyBTdHJpbmc/IEBkYi5WYXJDaGFyKDEwMCkKICBIVEVMX1RFTE5PIFN0cmluZz8gQGRiLlZhckNoYXIoMjApCiAgREVQVF9ZTiAgICBTdHJpbmc/IEBkZWZhdWx0KCJOIikgQGRiLlZhckNoYXIoMSkKICBSRUdfSUQgICAgIFN0cmluZyAgQGRiLlZhckNoYXIoMjUpCiAgUkVHX0RBVEUgICBTdHJpbmcgIEBkYi5WYXJDaGFyKDE0KQogIEVESVRfSUQgICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigyNSkKICBFRElUX0RBVEUgIFN0cmluZz8gQGRiLlZhckNoYXIoMTQpCiAgREVMX0lEICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDI1KQogIERFTF9EQVRFICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigxNCkKCiAgQEBpbmRleChbRU1QX05PLCBFTVBfTk0sIERFUFRfQ0QsIERFUFRfTk1dLCBtYXA6ICJJRFhfREVQVF9FTVAiKQp9CgovLy8gVGhpcyBtb2RlbCBvciBhdCBsZWFzdCBvbmUgb2YgaXRzIGZpZWxkcyBoYXMgY29tbWVudHMgaW4gdGhlIGRhdGFiYXNlLCBhbmQgcmVxdWlyZXMgYW4gYWRkaXRpb25hbCBzZXR1cCBmb3IgbWlncmF0aW9uczogUmVhZCBtb3JlOiBodHRwczovL3ByaXMubHkvZC9kYXRhYmFzZS1jb21tZW50cwptb2RlbCBTVF9NRU5VIHsKICBNRU5VX0NEICAgICAgIFN0cmluZyAgQGlkIEBkYi5WYXJDaGFyKDkpCiAgTUVOVV9OTSAgICAgICBTdHJpbmcgIEBkYi5WYXJDaGFyKDEwMCkKICBNRU5VX1BBVEggICAgIFN0cmluZz8gQGRiLlZhckNoYXIoMjUwKQogIE1FTlVfTUFQUElORyAgU3RyaW5nPyBAZGIuVmFyQ2hhcigyNTApCiAgTUVOVV9TUlQgICAgICBJbnQKICBNRU5VX0RFUFMgICAgIEludAogIE1FTlVfSUNPTiAgICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigxMDApCiAgTUVOVV9UUCAgICAgICBTdHJpbmcgIEBkZWZhdWx0KCJGIikgQGRiLlZhckNoYXIoMSkKICBNQUlOX0VYUFNSX1lOIFN0cmluZz8gQGRlZmF1bHQoIk4iKSBAZGIuVmFyQ2hhcigxKQogIFNVQl9FWFBTUl9ZTiAgU3RyaW5nPyBAZGVmYXVsdCgiTiIpIEBkYi5WYXJDaGFyKDEpCiAgVVBFTkRfQ0xBUyAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDUwKQogIFVQRU5EX0NOICAgICAgU3RyaW5nPyBAZGIuVmFyQ2hhcig5MDApCiAgQ0NMX1RZUEUgICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDUwKQogIFJFR19JRCAgICAgICAgU3RyaW5nICBAZGIuVmFyQ2hhcigxMDApCiAgUkVHX0RBVEUgICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDE0KQogIEVESVRfSUQgICAgICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigxMDApCiAgRURJVF9EQVRFICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDE0KQogIERFTF9JRCAgICAgICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigxMDApCiAgREVMX0RBVEUgICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDE0KQp9CgovLy8gVGhpcyBtb2RlbCBvciBhdCBsZWFzdCBvbmUgb2YgaXRzIGZpZWxkcyBoYXMgY29tbWVudHMgaW4gdGhlIGRhdGFiYXNlLCBhbmQgcmVxdWlyZXMgYW4gYWRkaXRpb25hbCBzZXR1cCBmb3IgbWlncmF0aW9uczogUmVhZCBtb3JlOiBodHRwczovL3ByaXMubHkvZC9kYXRhYmFzZS1jb21tZW50cwptb2RlbCBTVF9NRVNTQUdFX1RNUExBVCB7CiAgTVNHX0RJVl9DRCBTdHJpbmcgIEBkYi5WYXJDaGFyKDkpCiAgTVNHX0NEICAgICBTdHJpbmcgIEBkYi5WYXJDaGFyKDkpCiAgTVNHX05NICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDEwMCkKICBNU0dfVE1QTEFUIFN0cmluZz8gQGRiLlZhckNoYXIoNDAwMCkKICBVU0VfWU4gICAgIFN0cmluZz8gQGRlZmF1bHQoIk4iKSBAZGIuVmFyQ2hhcigxKQogIEVESVRfSUQgICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigyNSkKICBFRElUX0RBVEUgIFN0cmluZz8gQGRiLlZhckNoYXIoMTQpCgogIEBAaWQoW01TR19ESVZfQ0QsIE1TR19DRF0pCiAgQEBpbmRleChbTVNHX0RJVl9DRCwgTVNHX0NEXSwgbWFwOiAiSU5ERVhfTUVTU0FHRV9UTVBMQVQiKQp9CgovLy8gVGhpcyBtb2RlbCBvciBhdCBsZWFzdCBvbmUgb2YgaXRzIGZpZWxkcyBoYXMgY29tbWVudHMgaW4gdGhlIGRhdGFiYXNlLCBhbmQgcmVxdWlyZXMgYW4gYWRkaXRpb25hbCBzZXR1cCBmb3IgbWlncmF0aW9uczogUmVhZCBtb3JlOiBodHRwczovL3ByaXMubHkvZC9kYXRhYmFzZS1jb21tZW50cwptb2RlbCBTVF9NSU1FX1RZUEUgewogIFNFUSAgICAgSW50ICAgIEBpZCBAZGVmYXVsdChhdXRvaW5jcmVtZW50KCkpCiAgRVhUTl9OTSBTdHJpbmcgQGRiLlZhckNoYXIoNTApCiAgRklMRV9NVCBTdHJpbmcgQGRiLlZhckNoYXIoMTAwKQp9CgovLy8gVGhpcyBtb2RlbCBvciBhdCBsZWFzdCBvbmUgb2YgaXRzIGZpZWxkcyBoYXMgY29tbWVudHMgaW4gdGhlIGRhdGFiYXNlLCBhbmQgcmVxdWlyZXMgYW4gYWRkaXRpb25hbCBzZXR1cCBmb3IgbWlncmF0aW9uczogUmVhZCBtb3JlOiBodHRwczovL3ByaXMubHkvZC9kYXRhYmFzZS1jb21tZW50cwptb2RlbCBTVF9NTkdSX0dSUCB7CiAgR1JQX0NEICAgIFN0cmluZyAgQGlkIEBkYi5WYXJDaGFyKDEyKQogIEdSUF9OTSAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDUwKQogIEdSUF9ERVNDICBTdHJpbmc/IEBkYi5WYXJDaGFyKDEwMCkKICBTT1JUICAgICAgSW50PwogIFJFR19JRCAgICBTdHJpbmcgIEBkYi5WYXJDaGFyKDI1KQogIFJFR19EQVRFICBTdHJpbmcgIEBkYi5WYXJDaGFyKDE0KQogIEVESVRfSUQgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDI1KQogIEVESVRfREFURSBTdHJpbmc/IEBkYi5WYXJDaGFyKDE0KQogIERFTF9JRCAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDI1KQogIERFTF9EQVRFICBTdHJpbmc/IEBkYi5WYXJDaGFyKDE0KQp9CgovLy8gVGhpcyBtb2RlbCBvciBhdCBsZWFzdCBvbmUgb2YgaXRzIGZpZWxkcyBoYXMgY29tbWVudHMgaW4gdGhlIGRhdGFiYXNlLCBhbmQgcmVxdWlyZXMgYW4gYWRkaXRpb25hbCBzZXR1cCBmb3IgbWlncmF0aW9uczogUmVhZCBtb3JlOiBodHRwczovL3ByaXMubHkvZC9kYXRhYmFzZS1jb21tZW50cwptb2RlbCBTVF9NTkdSX01TVCB7CiAgTU5HUl9JRCAgICAgICAgU3RyaW5nICAgQGlkIEBkYi5WYXJDaGFyKDI1KQogIE1OR1JfTk0gICAgICAgIFN0cmluZyAgIEBkYi5WYXJDaGFyKDUwKQogIE1OR1JfUFcgICAgICAgIFN0cmluZz8gIEBkYi5WYXJDaGFyKDY0KQogIEdSUF9DRCAgICAgICAgIFN0cmluZz8gIEBkYi5WYXJDaGFyKDEyKQogIEdSQURFICAgICAgICAgIFN0cmluZz8gIEBkYi5WYXJDaGFyKDQpCiAgUEVSTV9DRCAgICAgICAgU3RyaW5nICAgQGRiLlZhckNoYXIoMTIpCiAgQUNTX1lOICAgICAgICAgU3RyaW5nPyAgQGRiLlZhckNoYXIoMSkKICBDTFBIICAgICAgICAgICBTdHJpbmc/ICBAZGIuVmFyQ2hhcigxNCkKICBFTVBfTk8gICAgICAgICBTdHJpbmc/ICBAZGIuVmFyQ2hhcigxMikKICBKT0lOX0RBVEUgICAgICBTdHJpbmcgICBAZGVmYXVsdCgiMjAyMzA4MDEwMDAwMDAiKSBAZGIuVmFyQ2hhcigxNCkKICBSRVRJUkVfREFURSAgICBEYXRlVGltZSBAZGVmYXVsdChkYmdlbmVyYXRlZCgiKCcwMDAwLTAwLTAwIDAwOjAwOjAwJykiKSkgQGRiLlRpbWVzdGFtcCgwKQogIFBXRF9DSEdfREFURSAgIERhdGVUaW1lIEBkZWZhdWx0KGRiZ2VuZXJhdGVkKCIoJzAwMDAtMDAtMDAgMDA6MDA6MDAnKSIpKSBAZGIuVGltZXN0YW1wKDApCiAgUFdEX1dST05HX0NOVCAgSW50PyAgICAgQGRlZmF1bHQoMCkKICBQV0RfV1JPTkdfREFURSBTdHJpbmc/ICBAZGIuVmFyQ2hhcigxNCkKICBMU1RfTE9HSU5fREFURSBTdHJpbmc/ICBAZGIuVmFyQ2hhcigxNCkKICBGTFBUSCAgICAgICAgICBTdHJpbmc/ICBAZGIuVmFyQ2hhcigyMDApCiAgRklMRV9OTSAgICAgICAgU3RyaW5nPyAgQGRiLlZhckNoYXIoMjAwKQogIFJFR19JRCAgICAgICAgIFN0cmluZyAgIEBkYi5WYXJDaGFyKDI1KQogIFJFR19EQVRFICAgICAgIFN0cmluZyAgIEBkYi5WYXJDaGFyKDE0KQogIEVESVRfSUQgICAgICAgIFN0cmluZz8gIEBkYi5WYXJDaGFyKDI1KQogIEVESVRfREFURSAgICAgIFN0cmluZz8gIEBkYi5WYXJDaGFyKDE0KQogIERFTF9JRCAgICAgICAgIFN0cmluZz8gIEBkYi5WYXJDaGFyKDI1KQogIERFTF9EQVRFICAgICAgIFN0cmluZz8gIEBkYi5WYXJDaGFyKDE0KQp9CgovLy8gVGhpcyBtb2RlbCBvciBhdCBsZWFzdCBvbmUgb2YgaXRzIGZpZWxkcyBoYXMgY29tbWVudHMgaW4gdGhlIGRhdGFiYXNlLCBhbmQgcmVxdWlyZXMgYW4gYWRkaXRpb25hbCBzZXR1cCBmb3IgbWlncmF0aW9uczogUmVhZCBtb3JlOiBodHRwczovL3ByaXMubHkvZC9kYXRhYmFzZS1jb21tZW50cwptb2RlbCBTVF9NWV9TVE5HIHsKICBVU0VSX0lEICAgU3RyaW5nICBAZGIuVmFyQ2hhcigyNSkKICBTVE5HX0NEICAgU3RyaW5nICBAZGIuVmFyQ2hhcigxMikKICBVU0VSX0RJViAgU3RyaW5nICBAZGIuVmFyQ2hhcigxKQogIFNUTkdfREFUQSBTdHJpbmc/IEBkYi5WYXJDaGFyKDUwMCkKCiAgQEBpZChbVVNFUl9JRCwgU1ROR19DRCwgVVNFUl9ESVZdKQogIEBAaW5kZXgoW1VTRVJfSUQsIFNUTkdfQ0QsIFVTRVJfRElWXSwgbWFwOiAiSU5ERVhfTVlfU1RORyIpCn0KCi8vLyBUaGlzIG1vZGVsIG9yIGF0IGxlYXN0IG9uZSBvZiBpdHMgZmllbGRzIGhhcyBjb21tZW50cyBpbiB0aGUgZGF0YWJhc2UsIGFuZCByZXF1aXJlcyBhbiBhZGRpdGlvbmFsIHNldHVwIGZvciBtaWdyYXRpb25zOiBSZWFkIG1vcmU6IGh0dHBzOi8vcHJpcy5seS9kL2RhdGFiYXNlLWNvbW1lbnRzCm1vZGVsIFNUX1BFUk1fRFRMIHsKICBQRVJNX0NEICAgU3RyaW5nICBAZGIuVmFyQ2hhcigxMikKICBNRU5VX0NEICAgU3RyaW5nICBAZGIuVmFyQ2hhcigxMikKICBSRUFEX1lOICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigxKQogIFJFR19ZTiAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDEpCiAgTURGQ05fWU4gIFN0cmluZz8gQGRiLlZhckNoYXIoMSkKICBERUxfWU4gICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigxKQogIE1BTkFHRV9ZTiBTdHJpbmc/IEBkYi5WYXJDaGFyKDEpCiAgUkVHX0lEICAgIFN0cmluZyAgQGRiLlZhckNoYXIoMjUpCiAgUkVHX0RBVEUgIFN0cmluZyAgQGRiLlZhckNoYXIoMTQpCgogIEBAaWQoW1BFUk1fQ0QsIE1FTlVfQ0RdKQp9CgovLy8gVGhpcyBtb2RlbCBvciBhdCBsZWFzdCBvbmUgb2YgaXRzIGZpZWxkcyBoYXMgY29tbWVudHMgaW4gdGhlIGRhdGFiYXNlLCBhbmQgcmVxdWlyZXMgYW4gYWRkaXRpb25hbCBzZXR1cCBmb3IgbWlncmF0aW9uczogUmVhZCBtb3JlOiBodHRwczovL3ByaXMubHkvZC9kYXRhYmFzZS1jb21tZW50cwptb2RlbCBTVF9QRVJNX01TVCB7CiAgUEVSTV9DRCAgIFN0cmluZyAgQGlkIEBkYi5WYXJDaGFyKDEyKQogIFBFUk1fTk0gICBTdHJpbmcgIEBkYi5WYXJDaGFyKDUwKQogIFNPUlQgICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDEpCiAgUkVHX0lEICAgIFN0cmluZyAgQGRiLlZhckNoYXIoMjUpCiAgUkVHX0RBVEUgIFN0cmluZyAgQGRiLlZhckNoYXIoMTQpCiAgRURJVF9JRCAgIFN0cmluZz8gQGRiLlZhckNoYXIoMjUpCiAgRURJVF9EQVRFIFN0cmluZz8gQGRiLlZhckNoYXIoMTQpCiAgREVMX0lEICAgIFN0cmluZz8gQGRiLlZhckNoYXIoMjUpCiAgREVMX0RBVEUgIFN0cmluZz8gQGRiLlZhckNoYXIoMTQpCn0KCi8vLyBUaGlzIG1vZGVsIG9yIGF0IGxlYXN0IG9uZSBvZiBpdHMgZmllbGRzIGhhcyBjb21tZW50cyBpbiB0aGUgZGF0YWJhc2UsIGFuZCByZXF1aXJlcyBhbiBhZGRpdGlvbmFsIHNldHVwIGZvciBtaWdyYXRpb25zOiBSZWFkIG1vcmU6IGh0dHBzOi8vcHJpcy5seS9kL2RhdGFiYXNlLWNvbW1lbnRzCm1vZGVsIFNUX1BPUFVQIHsKICBQT1BfQ0QgICAgU3RyaW5nICBAaWQgQGRiLlZhckNoYXIoOSkKICBQT1BfTk0gICAgU3RyaW5nICBAZGIuVmFyQ2hhcigyMDApCiAgUE9QX1RZICAgIFN0cmluZyAgQGRiLlZhckNoYXIoMSkKICBJTUdfVEVYVCAgU3RyaW5nPyBAZGIuVmFyQ2hhcig5MDApCiAgTEtfVVJMICAgIFN0cmluZz8gQGRiLlZhckNoYXIoMjU1KQogIExLX1RBUkdFVCBTdHJpbmc/IEBkYi5WYXJDaGFyKDEpCiAgQkdOR19EQVRFIFN0cmluZyAgQGRiLlZhckNoYXIoMTQpCiAgRU5EX0RBVEUgIFN0cmluZyAgQGRiLlZhckNoYXIoMTQpCiAgU1BXR19QUkVEIFN0cmluZz8gQGRiLlZhckNoYXIoMikKICBGTFBUSCAgICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigyMDApCiAgRklMRV9OTSAgIFN0cmluZz8gQGRiLlZhckNoYXIoMjAwKQogIFVTRV9ZTiAgICBTdHJpbmc/IEBkZWZhdWx0KCJOIikgQGRiLlZhckNoYXIoMSkKICBCRUZPUkVfQ0QgU3RyaW5nPyBAZGIuVmFyQ2hhcig5KQogIFJFR19JRCAgICBTdHJpbmcgIEBkYi5WYXJDaGFyKDI1KQogIFJFR19EQVRFICBTdHJpbmc/IEBkYi5WYXJDaGFyKDE0KQogIEVESVRfSUQgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDI1KQogIEVESVRfREFURSBTdHJpbmc/IEBkYi5WYXJDaGFyKDE0KQogIERFTF9JRCAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDI1KQogIERFTF9EQVRFICBTdHJpbmc/IEBkYi5WYXJDaGFyKDE0KQp9CgovLy8gVGhpcyBtb2RlbCBvciBhdCBsZWFzdCBvbmUgb2YgaXRzIGZpZWxkcyBoYXMgY29tbWVudHMgaW4gdGhlIGRhdGFiYXNlLCBhbmQgcmVxdWlyZXMgYW4gYWRkaXRpb25hbCBzZXR1cCBmb3IgbWlncmF0aW9uczogUmVhZCBtb3JlOiBodHRwczovL3ByaXMubHkvZC9kYXRhYmFzZS1jb21tZW50cwptb2RlbCBTVF9TVE5HIHsKICBTVE5HX0NEICAgU3RyaW5nICBAaWQgQGRiLlZhckNoYXIoMTIpCiAgU1ROR19EQVRBIFN0cmluZz8gQGRiLlZhckNoYXIoNTAwKQogIFRJVExFICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDIwMCkKICBERVNDX0NOICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigzMDApCiAgU09SVCAgICAgIEludD8KICBFRElUX0lEICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigyNSkKICBFRElUX0RBVEUgU3RyaW5nPyBAZGIuVmFyQ2hhcigxNCkKfQoKLy8vIFRoaXMgbW9kZWwgb3IgYXQgbGVhc3Qgb25lIG9mIGl0cyBmaWVsZHMgaGFzIGNvbW1lbnRzIGluIHRoZSBkYXRhYmFzZSwgYW5kIHJlcXVpcmVzIGFuIGFkZGl0aW9uYWwgc2V0dXAgZm9yIG1pZ3JhdGlvbnM6IFJlYWQgbW9yZTogaHR0cHM6Ly9wcmlzLmx5L2QvZGF0YWJhc2UtY29tbWVudHMKbW9kZWwgU1RfVVNFUl9NU1QgewogIFVTRVJfSUQgICAgICAgIFN0cmluZyAgQGlkIEBkYi5WYXJDaGFyKDI1KQogIFVTRVJfTk0gICAgICAgIFN0cmluZz8gQGRiLlZhckNoYXIoNTApCiAgVVNFUl9QVyAgICAgICAgU3RyaW5nICBAZGIuVmFyQ2hhcig2NCkKICBVU0VSX0RJViAgICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDEwKQogIFNUQVRVUyAgICAgICAgIFN0cmluZz8gQGRiLlZhckNoYXIoMTApCiAgUFJFVl9MT0dJTl9ZTiAgU3RyaW5nPyBAZGIuVmFyQ2hhcigxKQogIFdJVEhEUkFXTl9ZTiAgIFN0cmluZz8gQGRiLlZhckNoYXIoMSkKICBDTFBIICAgICAgICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDE0KQogIEVNQUlMICAgICAgICAgIFN0cmluZz8gQGRiLlZhckNoYXIoMTAwKQogIExTVF9MT0dJTl9EQVRFIFN0cmluZz8gQGRiLlZhckNoYXIoMTQpCiAgUkVHX0lEICAgICAgICAgU3RyaW5nICBAZGIuVmFyQ2hhcigyMCkKICBSRUdfREFURSAgICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDE0KQogIEVESVRfSUQgICAgICAgIFN0cmluZz8gQGRiLlZhckNoYXIoMjApCiAgRURJVF9EQVRFICAgICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigxNCkKICBERUxfSUQgICAgICAgICBTdHJpbmc/IEBkYi5WYXJDaGFyKDIwKQogIERFTF9EQVRFICAgICAgIFN0cmluZz8gQGRiLlZhckNoYXIoMTQpCn0KCi8vLyBUaGlzIG1vZGVsIG9yIGF0IGxlYXN0IG9uZSBvZiBpdHMgZmllbGRzIGhhcyBjb21tZW50cyBpbiB0aGUgZGF0YWJhc2UsIGFuZCByZXF1aXJlcyBhbiBhZGRpdGlvbmFsIHNldHVwIGZvciBtaWdyYXRpb25zOiBSZWFkIG1vcmU6IGh0dHBzOi8vcHJpcy5seS9kL2RhdGFiYXNlLWNvbW1lbnRzCm1vZGVsIFdPUktfUkVQT1JUX0RFVEFJTF9UQkwgewogIFJFUE9SVF9JRCAgICAgIFN0cmluZyAgIEBkYi5WYXJDaGFyKDEwKQogIFNFUSAgICAgICAgICAgIEJpZ0ludCAgIEBkZWZhdWx0KGF1dG9pbmNyZW1lbnQoKSkKICBQUk9KRUNUX05NICAgICBTdHJpbmcgICBAZGIuVmFyQ2hhcigyNTUpCiAgUFJPSkVDVF9TVUJfTk0gU3RyaW5nICAgQGRiLlZhckNoYXIoMjU1KQogIERFVEFJTF9DT05URU5UIFN0cmluZz8gIEBkYi5WYXJDaGFyKDUxMikKICBXT1JLRVIgICAgICAgICBTdHJpbmc/ICBAZGIuVmFyQ2hhcig1MCkKICBHUkFERSAgICAgICAgICBTdHJpbmc/ICBAZGIuVmFyQ2hhcig0KQogIFBST0NFU1NfUkFURSAgIFN0cmluZz8gIEBkYi5WYXJDaGFyKDMpCiAgV09SS19EQVRFICAgICAgU3RyaW5nPyAgQGRiLlZhckNoYXIoMzApCiAgUFJPQ0VTU19UWVBFICAgU3RyaW5nPyAgQGRiLkNoYXIoMSkKICBTVUJKRUNUX1lOICAgICBTdHJpbmcgICBAZGVmYXVsdCgiTiIpIEBkYi5DaGFyKDEpCiAgUkVHX1VTRVIgICAgICAgU3RyaW5nICAgQGRiLlZhckNoYXIoMTUpCiAgUkVHX0RBVEUgICAgICAgRGF0ZVRpbWUgQGRlZmF1bHQobm93KCkpIEBkYi5UaW1lc3RhbXAoMCkKICBDT01QTEVURV9EQVRFICBTdHJpbmc/ICBAZGIuVmFyQ2hhcigxMCkKCiAgQEBpZChbU0VRLCBSRVBPUlRfSURdKQp9CgovLy8gVGhlIHVuZGVybHlpbmcgdGFibGUgZG9lcyBub3QgY29udGFpbiBhIHZhbGlkIHVuaXF1ZSBpZGVudGlmaWVyIGFuZCBjYW4gdGhlcmVmb3JlIGN1cnJlbnRseSBub3QgYmUgaGFuZGxlZCBieSBQcmlzbWEgQ2xpZW50Lgptb2RlbCBXT1JLX1JFUE9SVF9ERVRBSUxfVEJMX0JBQ0sgewogIFJFUE9SVF9JRCAgICAgIFN0cmluZz8gICBAZGIuVmFyQ2hhcigxMCkKICBTRVEgICAgICAgICAgICBCaWdJbnQ/CiAgUFJPSkVDVF9OTSAgICAgU3RyaW5nPyAgIEBkYi5WYXJDaGFyKDI1NSkKICBQUk9KRUNUX1NVQl9OTSBTdHJpbmc/ICAgQGRiLlZhckNoYXIoMjU1KQogIERFVEFJTF9DT05URU5UIFN0cmluZz8gICBAZGIuVmFyQ2hhcig1MTIpCiAgV09SS0VSICAgICAgICAgU3RyaW5nPyAgIEBkYi5WYXJDaGFyKDUwKQogIEdSQURFICAgICAgICAgIFN0cmluZz8gICBAZGIuVmFyQ2hhcig0KQogIFBST0NFU1NfUkFURSAgIFN0cmluZz8gICBAZGIuVmFyQ2hhcigzKQogIFdPUktfREFURSAgICAgIFN0cmluZz8gICBAZGIuVmFyQ2hhcigzMCkKICBQUk9DRVNTX1RZUEUgICBTdHJpbmc/ICAgQGRiLkNoYXIoMSkKICBTVUJKRUNUX1lOICAgICBTdHJpbmc/ICAgQGRiLkNoYXIoMSkKICBSRUdfVVNFUiAgICAgICBTdHJpbmc/ICAgQGRiLlZhckNoYXIoMTUpCiAgUkVHX0RBVEUgICAgICAgRGF0ZVRpbWU/IEBkYi5UaW1lc3RhbXAoMCkKICBDT01QTEVURV9EQVRFICBTdHJpbmc/ICAgQGRiLlZhckNoYXIoMTApCgogIEBAaWdub3JlCn0KCi8vLyBUaGlzIG1vZGVsIG9yIGF0IGxlYXN0IG9uZSBvZiBpdHMgZmllbGRzIGhhcyBjb21tZW50cyBpbiB0aGUgZGF0YWJhc2UsIGFuZCByZXF1aXJlcyBhbiBhZGRpdGlvbmFsIHNldHVwIGZvciBtaWdyYXRpb25zOiBSZWFkIG1vcmU6IGh0dHBzOi8vcHJpcy5seS9kL2RhdGFiYXNlLWNvbW1lbnRzCm1vZGVsIFdPUktfUkVQT1JUX0hUTUxfVEJMIHsKICBSRVBPUlRfSUQgICAgU3RyaW5nICAgQGRiLlZhckNoYXIoMTApCiAgVVNFUl9JRCAgICAgIFN0cmluZyAgIEBkYi5WYXJDaGFyKDE1KQogIFRJVExFICAgICAgICBTdHJpbmcgICBAZGIuVmFyQ2hhcigyNTUpCiAgSFRNTF9DT05URU5UIFN0cmluZz8gIEBkYi5Mb25nVGV4dAogIFJFR19EQVRFICAgICBEYXRlVGltZSBAZGVmYXVsdChub3coKSkgQGRiLlRpbWVzdGFtcCgwKQogIERFTF9ZTiAgICAgICBTdHJpbmc/ICBAZGVmYXVsdCgiTiIpIEBkYi5DaGFyKDEpCgogIEBAaWQoW1JFUE9SVF9JRCwgVVNFUl9JRF0pCn0KCi8vLyBUaGlzIG1vZGVsIG9yIGF0IGxlYXN0IG9uZSBvZiBpdHMgZmllbGRzIGhhcyBjb21tZW50cyBpbiB0aGUgZGF0YWJhc2UsIGFuZCByZXF1aXJlcyBhbiBhZGRpdGlvbmFsIHNldHVwIGZvciBtaWdyYXRpb25zOiBSZWFkIG1vcmU6IGh0dHBzOi8vcHJpcy5seS9kL2RhdGFiYXNlLWNvbW1lbnRzCm1vZGVsIFdPUktfUkVQT1JUX0hUTUxfVEJMX0JBQ0sgewogIFJFUE9SVF9JRCAgICBTdHJpbmcgICBAZGIuVmFyQ2hhcigxMCkKICBVU0VSX0lEICAgICAgU3RyaW5nICAgQGRiLlZhckNoYXIoMTUpCiAgVElUTEUgICAgICAgIFN0cmluZyAgIEBkYi5WYXJDaGFyKDI1NSkKICBIVE1MX0NPTlRFTlQgU3RyaW5nPyAgQGRiLkxvbmdUZXh0CiAgUkVHX0RBVEUgICAgIERhdGVUaW1lIEBkZWZhdWx0KG5vdygpKSBAZGIuVGltZXN0YW1wKDApCiAgREVMX1lOICAgICAgIFN0cmluZz8gIEBkZWZhdWx0KCJOIikgQGRiLkNoYXIoMSkKCiAgQEBpZChbUkVQT1JUX0lELCBVU0VSX0lEXSkKfQoKLy8vIFRoaXMgbW9kZWwgb3IgYXQgbGVhc3Qgb25lIG9mIGl0cyBmaWVsZHMgaGFzIGNvbW1lbnRzIGluIHRoZSBkYXRhYmFzZSwgYW5kIHJlcXVpcmVzIGFuIGFkZGl0aW9uYWwgc2V0dXAgZm9yIG1pZ3JhdGlvbnM6IFJlYWQgbW9yZTogaHR0cHM6Ly9wcmlzLmx5L2QvZGF0YWJhc2UtY29tbWVudHMKbW9kZWwgV09SS19SRVBPUlRfTUFTVEVSX1RCTCB7CiAgUkVQT1JUX0lEIFN0cmluZyAgICBAaWQgQGRiLlZhckNoYXIoMTApCiAgVElUTEUgICAgIFN0cmluZyAgICBAZGIuVmFyQ2hhcigyNTUpCiAgREVQVCAgICAgIFN0cmluZyAgICBAZGIuVmFyQ2hhcigxMjgpCiAgUkVHX0RBVEUgIERhdGVUaW1lICBAZGVmYXVsdChub3coKSkgQGRiLlRpbWVzdGFtcCgwKQogIFVQRF9EQVRFICBEYXRlVGltZT8gQGRiLlRpbWVzdGFtcCgwKQogIERFTF9ZTiAgICBTdHJpbmc/ICAgQGRlZmF1bHQoIk4iKSBAZGIuQ2hhcigxKQoKICBAQGluZGV4KFtUSVRMRSwgUkVHX0RBVEUsIFVQRF9EQVRFXSwgbWFwOiAiSURYX1dPUktfUkVQT1JUX01BU1RFUl9UQkwiKQp9CgovLy8gVGhlIHVuZGVybHlpbmcgdGFibGUgZG9lcyBub3QgY29udGFpbiBhIHZhbGlkIHVuaXF1ZSBpZGVudGlmaWVyIGFuZCBjYW4gdGhlcmVmb3JlIGN1cnJlbnRseSBub3QgYmUgaGFuZGxlZCBieSBQcmlzbWEgQ2xpZW50Lgptb2RlbCBXT1JLX1JFUE9SVF9NQVNURVJfVEJMX0JBQ0sgewogIFJFUE9SVF9JRCBTdHJpbmc/ICAgQGRiLlZhckNoYXIoMTApCiAgVElUTEUgICAgIFN0cmluZz8gICBAZGIuVmFyQ2hhcigyNTUpCiAgREVQVCAgICAgIFN0cmluZz8gICBAZGIuVmFyQ2hhcigxMjgpCiAgUkVHX0RBVEUgIERhdGVUaW1lPyBAZGIuVGltZXN0YW1wKDApCiAgVVBEX0RBVEUgIERhdGVUaW1lPyBAZGIuVGltZXN0YW1wKDApCiAgREVMX1lOICAgIFN0cmluZz8gICBAZGIuQ2hhcigxKQoKICBAQGlnbm9yZQp9CgovLy8gVGhpcyBtb2RlbCBvciBhdCBsZWFzdCBvbmUgb2YgaXRzIGZpZWxkcyBoYXMgY29tbWVudHMgaW4gdGhlIGRhdGFiYXNlLCBhbmQgcmVxdWlyZXMgYW4gYWRkaXRpb25hbCBzZXR1cCBmb3IgbWlncmF0aW9uczogUmVhZCBtb3JlOiBodHRwczovL3ByaXMubHkvZC9kYXRhYmFzZS1jb21tZW50cwptb2RlbCBXT1JLX1JFUVVFU1RfTVNUIHsKICBTRVEgICAgICAgIEludCAgICAgQGlkCiAgUlFTVFJfRFBOTSBTdHJpbmcgIEBkYi5WYXJDaGFyKDMwKQogIFJRU1RSX05NICAgU3RyaW5nICBAZGIuVmFyQ2hhcigyNSkKICBSUVNUUl9JRCAgIFN0cmluZyAgQGRiLlZhckNoYXIoMjUpCiAgUlFTVFJfREFURSBTdHJpbmcgIEBkYi5WYXJDaGFyKDE0KQogIEhPUEVfREFURSAgU3RyaW5nICBAZGIuVmFyQ2hhcigxNCkKICBDSFJfRFBSX05NIFN0cmluZyAgQGRiLlZhckNoYXIoMzApCiAgQ0hSX05NICAgICBTdHJpbmcgIEBkYi5WYXJDaGFyKDI1KQogIENIUl9JRCAgICAgU3RyaW5nICBAZGIuVmFyQ2hhcigyNSkKICBDSFJfQ0hLICAgIFN0cmluZz8gQGRlZmF1bHQoIk4iKSBAZGIuVmFyQ2hhcigxKQogIFRJVExFICAgICAgU3RyaW5nICBAZGIuVmFyQ2hhcigxMDApCiAgQ04gICAgICAgICBTdHJpbmcgIEBkYi5UZXh0CiAgRVRDICAgICAgICBTdHJpbmc/IEBkYi5UZXh0CiAgRE9DICAgICAgICBTdHJpbmc/IEBkYi5UZXh0CiAgUkVHX0lEICAgICBTdHJpbmcgIEBkYi5WYXJDaGFyKDI1KQogIFJFR19EQVRFICAgU3RyaW5nICBAZGIuVmFyQ2hhcigxNCkKICBFRElUX0lEICAgIFN0cmluZz8gQGRiLlZhckNoYXIoMjUpCiAgRURJVF9EQVRFICBTdHJpbmc/IEBkYi5WYXJDaGFyKDE0KQogIERFTF9JRCAgICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigyNSkKICBERUxfREFURSAgIFN0cmluZz8gQGRiLlZhckNoYXIoMTQpCn0KCi8vLyBUaGlzIG1vZGVsIG9yIGF0IGxlYXN0IG9uZSBvZiBpdHMgZmllbGRzIGhhcyBjb21tZW50cyBpbiB0aGUgZGF0YWJhc2UsIGFuZCByZXF1aXJlcyBhbiBhZGRpdGlvbmFsIHNldHVwIGZvciBtaWdyYXRpb25zOiBSZWFkIG1vcmU6IGh0dHBzOi8vcHJpcy5seS9kL2RhdGFiYXNlLWNvbW1lbnRzCm1vZGVsIFdPUktfUkVRVUVTVF9SRUYgewogIFNFUSAgICAgICBJbnQgICAgIEBpZAogIE1TRVEgICAgICBJbnQKICBSRUZfSUQgICAgU3RyaW5nICBAZGIuVmFyQ2hhcigyNSkKICBSRUZfTk0gICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigyNSkKICBSRUZfREVQICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigyNSkKICBSRUZfR1JBREUgU3RyaW5nPyBAZGIuVmFyQ2hhcigyNSkKICBSRUdfSUQgICAgU3RyaW5nICBAZGIuVmFyQ2hhcigyNSkKICBSRUdfREFURSAgU3RyaW5nICBAZGIuVmFyQ2hhcigxNCkKICBFRElUX0lEICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigyNSkKICBFRElUX0RBVEUgU3RyaW5nPyBAZGIuVmFyQ2hhcigxNCkKICBERUxfSUQgICAgU3RyaW5nPyBAZGIuVmFyQ2hhcigyNSkKICBERUxfREFURSAgU3RyaW5nPyBAZGIuVmFyQ2hhcigxNCkKfQo=',
      datasources: datasources?.toJson().cast() ?? const {},
      executable:
          r'/Users/htlee/Project/2023-my/book_manage/book_server/node_modules/prisma/query-engine-darwin',
    );
    return PrismaClient._internal(engine);
  }

  final _i3.Engine _engine;

  final _i3.QueryEngineRequestHeaders? _headers;

  final _i3.TransactionInfo? _transaction;

  @override
  PrismaClient copyWith({
    _i3.QueryEngineRequestHeaders? headers,
    _i3.TransactionInfo? transaction,
  }) =>
      PrismaClient._internal(
        _engine,
        headers: headers ?? _headers,
        transaction: transaction ?? _transaction,
      );

  _i1.ModelDelegate<AllCodeTbl> get allCodeTbl => _i1.ModelDelegate<AllCodeTbl>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<ApprovalAttachfileTbl> get approvalAttachfileTbl =>
      _i1.ModelDelegate<ApprovalAttachfileTbl>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<ApprovalDocInfoTbl> get approvalDocInfoTbl =>
      _i1.ModelDelegate<ApprovalDocInfoTbl>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<ApprovalHistoryTbl> get approvalHistoryTbl =>
      _i1.ModelDelegate<ApprovalHistoryTbl>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<ApprovalMasterTbl> get approvalMasterTbl =>
      _i1.ModelDelegate<ApprovalMasterTbl>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<ApprovalMemoTbl> get approvalMemoTbl =>
      _i1.ModelDelegate<ApprovalMemoTbl>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<ApprovalTypeTbl> get approvalTypeTbl =>
      _i1.ModelDelegate<ApprovalTypeTbl>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<ApprovalUserTbl> get approvalUserTbl =>
      _i1.ModelDelegate<ApprovalUserTbl>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<BookAssetTbl> get bookAssetTbl =>
      _i1.ModelDelegate<BookAssetTbl>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<CarAssetInsurTbl> get carAssetInsurTbl =>
      _i1.ModelDelegate<CarAssetInsurTbl>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<CarAssetTbl> get carAssetTbl =>
      _i1.ModelDelegate<CarAssetTbl>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<CarChargeTbl> get carChargeTbl =>
      _i1.ModelDelegate<CarChargeTbl>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<CarInfoTbl> get carInfoTbl => _i1.ModelDelegate<CarInfoTbl>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<CarMileageTbl> get carMileageTbl =>
      _i1.ModelDelegate<CarMileageTbl>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<CarPartReplaceTbl> get carPartReplaceTbl =>
      _i1.ModelDelegate<CarPartReplaceTbl>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<CarRepairLog> get carRepairLog =>
      _i1.ModelDelegate<CarRepairLog>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<CarUseManageTbl> get carUseManageTbl =>
      _i1.ModelDelegate<CarUseManageTbl>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<HolidayTbl> get holidayTbl => _i1.ModelDelegate<HolidayTbl>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<MemberTbl> get memberTbl => _i1.ModelDelegate<MemberTbl>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<MenuAuthTbl> get menuAuthTbl =>
      _i1.ModelDelegate<MenuAuthTbl>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<MenuTbl> get menuTbl => _i1.ModelDelegate<MenuTbl>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<OfficeAssetTbl> get officeAssetTbl =>
      _i1.ModelDelegate<OfficeAssetTbl>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<ServerAssetTbl> get serverAssetTbl =>
      _i1.ModelDelegate<ServerAssetTbl>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<SoftwareAssetTbl> get softwareAssetTbl =>
      _i1.ModelDelegate<SoftwareAssetTbl>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<StAdminMenu> get stAdminMenu =>
      _i1.ModelDelegate<StAdminMenu>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<StAlarm> get stAlarm => _i1.ModelDelegate<StAlarm>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<StAuditLog> get stAuditLog => _i1.ModelDelegate<StAuditLog>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<StBanner> get stBanner => _i1.ModelDelegate<StBanner>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<StBoardColumn> get stBoardColumn =>
      _i1.ModelDelegate<StBoardColumn>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<StBoardColumnDft> get stBoardColumnDft =>
      _i1.ModelDelegate<StBoardColumnDft>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<StBoardComment> get stBoardComment =>
      _i1.ModelDelegate<StBoardComment>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<StBoardFile> get stBoardFile =>
      _i1.ModelDelegate<StBoardFile>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<StBoardMst> get stBoardMst => _i1.ModelDelegate<StBoardMst>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<StBoardStng> get stBoardStng =>
      _i1.ModelDelegate<StBoardStng>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<StCcl> get stCcl => _i1.ModelDelegate<StCcl>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<StCodeMst> get stCodeMst => _i1.ModelDelegate<StCodeMst>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<StConnectLog> get stConnectLog =>
      _i1.ModelDelegate<StConnectLog>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<StContentsFile> get stContentsFile =>
      _i1.ModelDelegate<StContentsFile>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<StContentsMst> get stContentsMst =>
      _i1.ModelDelegate<StContentsMst>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<StDept> get stDept => _i1.ModelDelegate<StDept>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<StDeptEmp> get stDeptEmp => _i1.ModelDelegate<StDeptEmp>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<StMenu> get stMenu => _i1.ModelDelegate<StMenu>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<StMessageTmplat> get stMessageTmplat =>
      _i1.ModelDelegate<StMessageTmplat>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<StMimeType> get stMimeType => _i1.ModelDelegate<StMimeType>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<StMngrGrp> get stMngrGrp => _i1.ModelDelegate<StMngrGrp>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<StMngrMst> get stMngrMst => _i1.ModelDelegate<StMngrMst>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<StMyStng> get stMyStng => _i1.ModelDelegate<StMyStng>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<StPermDtl> get stPermDtl => _i1.ModelDelegate<StPermDtl>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<StPermMst> get stPermMst => _i1.ModelDelegate<StPermMst>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<StPopup> get stPopup => _i1.ModelDelegate<StPopup>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<StStng> get stStng => _i1.ModelDelegate<StStng>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<StUserMst> get stUserMst => _i1.ModelDelegate<StUserMst>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<WorkReportDetailTbl> get workReportDetailTbl =>
      _i1.ModelDelegate<WorkReportDetailTbl>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<WorkReportHtmlTbl> get workReportHtmlTbl =>
      _i1.ModelDelegate<WorkReportHtmlTbl>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<WorkReportHtmlTblBack> get workReportHtmlTblBack =>
      _i1.ModelDelegate<WorkReportHtmlTblBack>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<WorkReportMasterTbl> get workReportMasterTbl =>
      _i1.ModelDelegate<WorkReportMasterTbl>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<WorkRequestMst> get workRequestMst =>
      _i1.ModelDelegate<WorkRequestMst>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );

  _i1.ModelDelegate<WorkRequestRef> get workRequestRef =>
      _i1.ModelDelegate<WorkRequestRef>(
        _engine,
        headers: _headers,
        transaction: _transaction,
      );
}
